use std::path::Path;
use std::process::Stdio;
use std::sync::{Arc, OnceLock};
use immt_api::building::targets::{BuildDataFormat, BuildTarget, SourceFormat};
use immt_api::controller::{Controller, ControllerAsync};
use immt_api::core::building::formats::ShortId;
use immt_api::extensions::{FormatExtension, MMTExtension};
use immt_api::utils::asyncs::{background, in_span};
use immt_api::utils::run_command;
use immt_shtml::{SHTML_FORMAT, SHTML_OMDOC};
use crate::rustex::RusTeX;

mod rustex;
mod quickparse;
mod dependencies;

/*
immt_api::export_plugin!(register);
unsafe extern "C" fn register() -> Box<dyn MMTExtension> {
    Box::new(STeXExtension {})//engine:None})
}

 */

#[derive(Debug)]
pub struct STeXExtension {}

const ID: ShortId = ShortId::new("stex");

pub const TEX_FORMAT: BuildDataFormat = BuildDataFormat{id:ShortId::new("tex"),file_extensions:&["tex","ltx"],
    description:"LaTeX source file"
};

pub const AUX_FORMAT: BuildDataFormat = BuildDataFormat{id:ShortId::new("texaux"),file_extensions:&["aux"],
    description:"LaTeX aux/bbl/toc files, as generated by pdflatex+bibtex/biber/mkindex"
};

pub const PDFLATEX_FIRST: BuildTarget = BuildTarget {id:ShortId::new("texfirst"),requires:&[TEX_FORMAT],produces:&[AUX_FORMAT],
    description:"Run pdflatex and bibtex/biber/index once",
    extension:Some(ID)
};

pub const PDFLATEX_ONLY: BuildTarget = BuildTarget {id:ShortId::new("pdflatex"),requires:&[TEX_FORMAT],produces:&[],
    description:"Run pdflatex only",
    extension:Some(ID)
};
pub const RUSTEX: BuildTarget = BuildTarget{id:ShortId::new("rustex"), requires:&[AUX_FORMAT],produces:&[SHTML_FORMAT],
    description:"Run RusTeX tex->html only",
    extension:Some(ID)
};

pub const STEX: SourceFormat = SourceFormat {
    id:ID,
    file_extensions: &["tex", "ltx"],
    targets:&[PDFLATEX_FIRST,RUSTEX,SHTML_OMDOC,BuildTarget::CHECK],
    description: "The full sTeX pipeline: pdflatex, bibtex/biber/index, rustex and check",
    extension:Some(ID)
};


impl MMTExtension for STeXExtension {
    fn on_plugin_load(&self, _controller: &dyn Controller) {
        background(|| RusTeX::initialize());
    }
    fn on_plugin_load_async(&self,_controller:&dyn ControllerAsync) {
        let f = in_span(|| RusTeX::initialize());
        tokio::task::spawn_blocking(f);
    }
    fn name(&self) -> ShortId { ID }
    fn test(&self, _controller: &mut dyn Controller) -> bool { true }
    fn test2(&self, _controller: &mut dyn Controller) -> bool { true }
    fn as_formats(&self) -> Option<&dyn FormatExtension> { Some(self) }
}
impl FormatExtension for STeXExtension {
    fn formats(&self) -> Vec<SourceFormat> { vec![STEX] }
    fn sandbox(&self, _controller: &mut dyn Controller) -> Box<dyn MMTExtension> {
        todo!()
    }
}

pub(crate) fn pdflatex<I:Iterator<Item=(String,String)>>(path:&Path,mut envs:I) -> Result<(),()> {
    let parent = if let Some(p) = path.parent() {p} else {return Err(())};
    let stem = if let Some(s) = path.file_stem() {s} else {return Err(())};
    let out = run_command(
        "pdflatex",
        ["-interaction", "nonstopmode", "-halt-on-error", stem.to_str().unwrap()].into_iter(),
        parent,
        envs
    )?;
    if !out.status.success() {
        let out = std::str::from_utf8(out.stdout.as_slice()).unwrap();
        let err = out
            .find("Fatal error")
            .map(|i| &out[i..])
            .unwrap_or("unknown error");
        return Err(())
    } else {
        let bib = path.with_extension("bcf");
        if bib.exists() {
            let _ = run_command("biber", [stem.to_str().unwrap()].into_iter(), parent, std::iter::empty::<(String,String)>());
        } else {
            let _ = run_command("bibtex", [stem.to_str().unwrap()].into_iter(), parent, std::iter::empty::<(String,String)>());
        }
    }
    Ok(())
}