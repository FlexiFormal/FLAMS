use std::path::{Path, PathBuf};
use std::process::Stdio;
use std::sync::{Arc, OnceLock};
use immt_api::async_trait::async_trait;
use immt_api::backend::archives::{Archive, Storage};
use immt_api::backend::manager::ArchiveTree;
use immt_api::building::queue::{BuildTask, Dependency, TaskRef};
use immt_api::building::targets::{BuildDataFormat, BuildFormatId, BuildTarget, SourceFormat};
use immt_api::controller::Controller;
use immt_api::core::building::formats::{BuildTargetId, ShortId, SourceFormatId};
use immt_api::core::uris::archives::ArchiveId;
use immt_api::extensions::{ExtensionId, FormatExtension, MMTExtension};
use immt_api::utils::asyncs::{background, in_span};
use immt_api::utils::run_command;
use immt_shtml::{SHTML_FORMAT, SHTML_OMDOC};
use crate::dependencies::STeXDependency;
use crate::rustex::RusTeX;

mod rustex;
mod quickparse;
mod dependencies;

/*
immt_api::export_plugin!(register);
unsafe extern "C" fn register() -> Box<dyn MMTExtension> {
    Box::new(STeXExtension {})//engine:None})
}

 */

#[derive(Debug)]
pub struct STeXExtension {}

const ID: ShortId = ShortId::new_unchecked("stex");

pub const TEX_FORMAT: BuildDataFormat = BuildDataFormat{id:BuildFormatId::new(ShortId::new_unchecked("tex")),file_extensions:&["tex","ltx"],
    description:"LaTeX source file"
};

pub const AUX_FORMAT: BuildDataFormat = BuildDataFormat{id:BuildFormatId::new(ShortId::new_unchecked("texaux")),file_extensions:&["aux"],
    description:"LaTeX aux/bbl/toc files, as generated by pdflatex+bibtex/biber/mkindex"
};

pub const PDFLATEX_FIRST: BuildTarget = BuildTarget {id:BuildTargetId::new(ShortId::new_unchecked("texfirst")),requires:&[TEX_FORMAT],produces:&[AUX_FORMAT],
    description:"Run pdflatex and bibtex/biber/index once",
    extension:Some(ExtensionId::new(ID))
};

pub const PDFLATEX_ONLY: BuildTarget = BuildTarget {id:BuildTargetId::new(ShortId::new_unchecked("pdflatex")),requires:&[TEX_FORMAT],produces:&[],
    description:"Run pdflatex only",
    extension:Some(ExtensionId::new(ID))
};
pub const RUSTEX: BuildTarget = BuildTarget{id:BuildTargetId::new(ShortId::new_unchecked("rustex")), requires:&[AUX_FORMAT],produces:&[SHTML_FORMAT],
    description:"Run RusTeX tex->html only",
    extension:Some(ExtensionId::new(ID))
};

pub const STEX: SourceFormat = SourceFormat {
    id:SourceFormatId::new(ID),
    file_extensions: &["tex", "ltx"],
    targets:&[PDFLATEX_FIRST,RUSTEX,SHTML_OMDOC,BuildTarget::CHECK],
    description: "The full sTeX pipeline: pdflatex, bibtex/biber/index, rustex and check",
    extension:Some(ExtensionId::new(ID))
};


impl MMTExtension for STeXExtension {
    fn on_plugin_load(&self, _controller: &dyn Controller) {
        background(|| RusTeX::initialize());
    }
    /*fn on_plugin_load_async(&self,_controller:&dyn ControllerAsync) {
        let f = in_span(|| RusTeX::initialize());
        tokio::task::spawn_blocking(f);
    }*/
    fn name(&self) -> ExtensionId { ExtensionId::new(ID) }
    fn test(&self, _controller: &mut dyn Controller) -> bool { true }
    fn test2(&self, _controller: &mut dyn Controller) -> bool { true }
    fn as_formats(&self) -> Option<&dyn FormatExtension> { Some(self) }
}
#[async_trait]
impl FormatExtension for STeXExtension {
    fn formats(&self) -> Vec<SourceFormat> { vec![STEX] }
    fn sandbox(&self, _controller: &mut dyn Controller) -> Box<dyn MMTExtension> {
        todo!()
    }
    fn get_deps(&self, ctrl:&dyn Controller,task: &BuildTask) {
        let source = std::fs::read_to_string(task.path());
        if let Ok(source) = source {
            for d in dependencies::get_deps(&source,task.path()) {
                match d {
                    STeXDependency::ImportModule { archive, module} | STeXDependency::UseModule { archive, module} => {
                        let archive = archive.map(|s| ArchiveId::new(s)).unwrap_or(task.archive().id().clone());
                        if let Some(rel_path) = ctrl.archives().with_tree(|tree|
                            to_file_path(task.path(),&archive,module,tree)
                        ) {
                            let mut rf = TaskRef {
                                archive,rel_path,
                                target: PDFLATEX_FIRST.id
                            };
                            //tracing::debug!("Adding dependency: {:?}", rf);
                            if let Some(step) = task.find_step(PDFLATEX_FIRST.id) {
                                step.push_dependency(Dependency::Physical {
                                    strict:false,
                                    task:rf.clone()
                                })
                            }
                            if let Some(step) = task.find_step(BuildTarget::CHECK.id) {
                                rf.target = BuildTarget::CHECK.id;
                                step.push_dependency(Dependency::Physical {
                                    strict:true,
                                    task:rf
                                })
                            }
                        }
                    }
                    STeXDependency::Inputref { archive, filepath } => {
                        let archive = archive.map(|s| ArchiveId::new(s)).unwrap_or(task.archive().id().clone());
                        let rel_path = to_file_path_ref(filepath);
                        let rf = TaskRef {
                            archive,rel_path,
                            target: PDFLATEX_FIRST.id
                        };
                        //tracing::debug!("Adding dependency: {:?}", rf);
                        if let Some(step) = task.find_step(PDFLATEX_FIRST.id) {
                            step.push_dependency(Dependency::Physical {
                                strict:false, task:rf
                            })
                        }
                    },
                    STeXDependency::Signature(lang) => {
                        let archive = task.archive().id().clone();
                        let rel_path = task.rel_path()
                            .rsplit_once('.')
                            .and_then(|(a, _)| {
                                a.rsplit_once('.').map(|(a, _)| format!("{a}.{lang}.tex"))
                            })
                            .unwrap().into();
                        let mut rf = TaskRef {
                            archive,rel_path,
                            target: PDFLATEX_FIRST.id
                        };
                        //tracing::debug!("Adding dependency: {:?}", rf);
                        if let Some(step) = task.find_step(PDFLATEX_FIRST.id) {
                            step.push_dependency(Dependency::Physical {
                                strict:false,
                                task:rf.clone()
                            })
                        }
                        if let Some(step) = task.find_step(BuildTarget::CHECK.id) {
                            rf.target = BuildTarget::CHECK.id;
                            step.push_dependency(Dependency::Physical {
                                strict:true,
                                task:rf
                            })
                        }
                    }
                }
            }

        }
    }
    /*
    fn get_deps(&self, ctrl: &dyn Controller, task: &BuildTask) {
        let source = std::fs::read_to_string(task.path());
        if let Ok(source) = source {
            for d in dependencies::get_deps(&source,task.path()) {
                match d {
                    STeXDependency::ImportModule { archive, module} | STeXDependency::UseModule { archive, module} => {
                        let archive = archive.map(|s| ArchiveId::new(s)).unwrap_or(task.archive().id().clone());
                        if let Some(rel_path) = ctrl.archives().with_tree(|tree|
                            to_file_path(task.path(),&archive,module,tree)
                        ) {
                            let mut rf = TaskRef {
                                archive,rel_path,
                                target: PDFLATEX_FIRST.id
                            };
                            //tracing::debug!("Adding dependency: {:?}", rf);
                            if let Some(step) = task.find_step(PDFLATEX_FIRST.id) {
                                step.push_dependency(Dependency::Physical {
                                    strict:false,
                                    task:rf.clone()
                                })
                            }
                            if let Some(step) = task.find_step(BuildTarget::CHECK.id) {
                                rf.target = BuildTarget::CHECK.id;
                                step.push_dependency(Dependency::Physical {
                                    strict:true,
                                    task:rf
                                })
                            }
                        }
                    }
                    STeXDependency::Inputref { archive, filepath } => {
                        let archive = archive.map(|s| ArchiveId::new(s)).unwrap_or(task.archive().id().clone());
                        let rel_path = to_file_path_ref(filepath);
                        let rf = TaskRef {
                            archive,rel_path,
                            target: PDFLATEX_FIRST.id
                        };
                        //tracing::debug!("Adding dependency: {:?}", rf);
                        if let Some(step) = task.find_step(PDFLATEX_FIRST.id) {
                            step.push_dependency(Dependency::Physical {
                                strict:false, task:rf
                            })
                        }
                    },
                    STeXDependency::Signature(lang) => {
                        let archive = task.archive().id().clone();
                        let rel_path = task.rel_path()
                            .rsplit_once('.')
                            .and_then(|(a, _)| {
                                a.rsplit_once('.').map(|(a, _)| format!("{a}.{lang}.tex"))
                            })
                            .unwrap().into();
                        let mut rf = TaskRef {
                            archive,rel_path,
                            target: PDFLATEX_FIRST.id
                        };
                        //tracing::debug!("Adding dependency: {:?}", rf);
                        if let Some(step) = task.find_step(PDFLATEX_FIRST.id) {
                            step.push_dependency(Dependency::Physical {
                                strict:false,
                                task:rf.clone()
                            })
                        }
                        if let Some(step) = task.find_step(BuildTarget::CHECK.id) {
                            rf.target = BuildTarget::CHECK.id;
                            step.push_dependency(Dependency::Physical {
                                strict:true,
                                task:rf
                            })
                        }
                    }
                }
            }
        }
    }

     */
}

pub(crate) fn pdflatex<I:Iterator<Item=(String,String)>>(path:&Path,mut envs:I) -> Result<(),()> {
    let parent = if let Some(p) = path.parent() {p} else {return Err(())};
    let stem = if let Some(s) = path.file_stem() {s} else {return Err(())};
    let out = run_command(
        "pdflatex",
        ["-interaction", "nonstopmode", "-halt-on-error", stem.to_str().unwrap()].into_iter(),
        parent,
        envs
    )?;
    if !out.status.success() {
        let out = std::str::from_utf8(out.stdout.as_slice()).unwrap();
        let err = out
            .find("Fatal error")
            .map(|i| &out[i..])
            .unwrap_or("unknown error");
        return Err(())
    } else {
        let bib = path.with_extension("bcf");
        if bib.exists() {
            let _ = run_command("biber", [stem.to_str().unwrap()].into_iter(), parent, std::iter::empty::<(String,String)>());
        } else {
            let _ = run_command("bibtex", [stem.to_str().unwrap()].into_iter(), parent, std::iter::empty::<(String,String)>());
        }
    }
    Ok(())
}

fn to_file_path(
    current: &Path,
    id: &ArchiveId,
    module: &str,
    tree:&ArchiveTree,
) -> Option<Box<str>> {
    let lang = if current.extension().and_then(|s| s.to_str()) == Some("tex") {
        match current.file_stem().and_then(|s| s.to_str()) {
            Some(s) if s.ends_with(".ru") => "ru",
            Some(s) if s.ends_with(".de") => "de",
            Some(s) if s.ends_with(".fr") => "fr",
            // TODO etc
            _ => "en",
        }
    } else {
        "en"
    };
    if let Some(Archive::Physical(a)) = tree.find_archive(id) {
        let archive_path = a.path();
        let (path, module) = module.split_once('?')?;
        let p = PathBuf::from(format!(
            "{}/source/{path}/{module}.{lang}.tex",
            archive_path.display()
        ));
        if p.exists() {
            return Some(format!("{path}/{module}.{lang}.tex").into())
        }
        let p = PathBuf::from(format!(
            "{}/source/{path}/{module}.en.tex",
            archive_path.display()
        ));
        if p.exists() {
            return Some(format!("{path}/{module}.en.tex").into());
        }
        let p = PathBuf::from(format!(
            "{}/source/{path}/{module}.tex",
            archive_path.display()
        ));
        if p.exists() {
            return Some(format!("{path}/{module}.tex").into())
        }
        let p = PathBuf::from(format!(
            "{}/source/{path}.{lang}.tex",
            archive_path.display()
        ));
        if p.exists() {
            return Some(format!("{path}.{lang}.tex").into())
        }
        let p = PathBuf::from(format!("{}/source/{path}.en.tex", archive_path.display()));
        if p.exists() {
            return Some(format!("{path}.en.tex").into())
        }
        let p = PathBuf::from(format!("{}/source/{path}.tex", archive_path.display()));
        if p.exists() {
            return Some(format!("{path}.tex").into())
        }
    }
    None
}

fn to_file_path_ref(
    path: &str,
) -> Box<str> {
    if path.ends_with(".tex") {
        path.into()
    } else {
        format!("{path}.tex").into()
    }
}
