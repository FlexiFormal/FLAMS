use std::path::{Path, PathBuf};
use std::process::Stdio;
use std::sync::{Arc, OnceLock};
use immt_api::async_trait::async_trait;
use immt_api::backend::archives::{Archive, Storage};
use immt_api::backend::manager::ArchiveTree;
use immt_api::building::targets::{BuildDataFormat, BuildFormatId, BuildTarget, SourceFormat};
use immt_api::building::tasks::BuildTask;
use immt_api::controller::Controller;
use immt_api::core::building::formats::{BuildTargetId, ShortId, SourceFormatId};
use immt_api::core::uris::archives::ArchiveId;
use immt_api::extensions::{ExtensionId, FormatExtension, MMTExtension};
use immt_api::utils::asyncs::{background, in_span};
use immt_api::utils::run_command;
use immt_shtml::{SHTML_FORMAT, SHTML_OMDOC};
use crate::dependencies::STeXDependency;
use crate::rustex::RusTeX;

mod rustex;
mod quickparse;
mod dependencies;
mod utils;

/*
immt_api::export_plugin!(register);
unsafe extern "C" fn register() -> Box<dyn MMTExtension> {
    Box::new(STeXExtension {})//engine:None})
}

 */

#[derive(Debug)]
pub struct STeXExtension {}

const ID: ShortId = ShortId::new_unchecked("stex");

pub const TEX_FORMAT: BuildDataFormat = BuildDataFormat{id:BuildFormatId::new(ShortId::new_unchecked("tex")),file_extensions:&["tex","ltx"],
    description:"LaTeX source file"
};

pub const AUX_FORMAT: BuildDataFormat = BuildDataFormat{id:BuildFormatId::new(ShortId::new_unchecked("texaux")),file_extensions:&["aux"],
    description:"LaTeX aux/bbl/toc files, as generated by pdflatex+bibtex/biber/mkindex"
};

pub const PDFLATEX_FIRST: BuildTarget = BuildTarget {id:BuildTargetId::new(ShortId::new_unchecked("texfirst")),requires:&[TEX_FORMAT],produces:&[AUX_FORMAT],
    description:"Run pdflatex and bibtex/biber/index once",
    extension:Some(ExtensionId::new(ID))
};

pub const PDFLATEX_ONLY: BuildTarget = BuildTarget {id:BuildTargetId::new(ShortId::new_unchecked("pdflatex")),requires:&[TEX_FORMAT],produces:&[],
    description:"Run pdflatex only",
    extension:Some(ExtensionId::new(ID))
};
pub const RUSTEX: BuildTarget = BuildTarget{id:BuildTargetId::new(ShortId::new_unchecked("rustex")), requires:&[AUX_FORMAT],produces:&[SHTML_FORMAT],
    description:"Run RusTeX tex->html only",
    extension:Some(ExtensionId::new(ID))
};

pub const STEX: SourceFormat = SourceFormat {
    id:SourceFormatId::new(ID),
    file_extensions: &["tex", "ltx"],
    targets:&[PDFLATEX_FIRST,RUSTEX,SHTML_OMDOC,BuildTarget::CHECK],
    description: "The full sTeX pipeline: pdflatex, bibtex/biber/index, rustex and check",
    extension:Some(ExtensionId::new(ID))
};


impl MMTExtension for STeXExtension {
    fn on_plugin_load(&self, _controller: &dyn Controller) {
        background(|| RusTeX::initialize());
    }
    /*fn on_plugin_load_async(&self,_controller:&dyn ControllerAsync) {
        let f = in_span(|| RusTeX::initialize());
        tokio::task::spawn_blocking(f);
    }*/
    fn name(&self) -> ExtensionId { ExtensionId::new(ID) }
    fn as_formats(&self) -> Option<&dyn FormatExtension> { Some(self) }
}
#[async_trait]
impl FormatExtension for STeXExtension {
    fn formats(&self) -> Vec<SourceFormat> { vec![STEX] }
    fn sandbox(&self, _controller: &mut dyn Controller) -> Box<dyn MMTExtension> {
        todo!()
    }
    fn get_deps(&self, ctrl:&dyn Controller,task: &BuildTask) {
        dependencies::get_deps(ctrl,task)
    }
    fn build(&self, ctrl:&dyn Controller,task: &BuildTask, target: BuildTargetId, index: u8) -> bool {
        match target {
            s if s == PDFLATEX_FIRST.id => {
                let ret = pdflatex_and_bib(task.path(),[("STEX_WRITESMS","true")].into_iter()).is_ok();
                if let Some(step) = task.find_step(target) {
                    step.set_log_path(ret, ctrl, task, &task.path().with_extension("log"));
                    step.set_artifact_path(ctrl, task, BuildDataFormat::PDF ,&task.path().with_extension("pdf"));
                }
                return ret
            }
            s if s == PDFLATEX_ONLY.id => {
                let ret = pdflatex(task.path(),[("STEX_USESMS","true")].into_iter()).is_ok();
                if let Some(step) = task.find_step(target) {
                    step.set_log_path(ret, ctrl, task, &task.path().with_extension("log"));
                    step.set_artifact_path(ctrl, task, BuildDataFormat::PDF ,&task.path().with_extension("pdf"));
                }
                return ret
            }
            s if s == RUSTEX.id => {
                return match RusTeX::get().run_with_envs(task.path(), false, [("STEX_USESMS".to_string(), "true".to_string())].into_iter()) {
                    Ok(s) => {
                        if let Some(step) = task.find_step(target) {
                            step.set_artifact_str(ctrl, task, SHTML_FORMAT ,&s);
                        }
                        true
                    },
                    Err(s) => {
                        tracing::error!("RusTeX failed: {} ({})", s,task.path().display());
                        false
                    }
                }
            },
            _ => unreachable!()
        }
    }
}

fn pdflatex_and_bib<S:AsRef<std::ffi::OsStr>,I:Iterator<Item=(S,S)>>(path:&Path,mut envs:I) -> Result<(),()> {
    pdflatex(path,envs)?;
    let stem = if let Some(s) = path.file_stem() {s} else {
        return Err(())
    };
    let parent = if let Some(p) = path.parent() {p} else {
        return Err(())
    };
    let bib = path.with_extension("bcf");
    if bib.exists() {
        let _ = run_command("biber", [stem.to_str().unwrap()].into_iter(), parent, std::iter::empty::<(String,String)>());
    } else {
        let _ = run_command("bibtex", [stem.to_str().unwrap()].into_iter(), parent, std::iter::empty::<(String,String)>());
    }
    Ok(())
}

fn pdflatex<S:AsRef<std::ffi::OsStr>,I:Iterator<Item=(S,S)>>(path:&Path,mut envs:I) -> Result<(),()> {
    let parent = if let Some(p) = path.parent() {p} else {
        return Err(())
    };
    let stem = if let Some(s) = path.file_stem() {s} else {
        return Err(())
    };
    tracing::info!("Running: pdflatex {} in {}", stem.to_str().unwrap(), parent.display());
    let out = run_command(
        "pdflatex",
        ["-interaction", "nonstopmode", "-halt-on-error", stem.to_str().unwrap()].into_iter(),
        parent,
        envs
    )?;
    if !out.status.success() {
        let out = std::str::from_utf8(out.stdout.as_slice()).unwrap();
        let err = out
            .find("Fatal error")
            .map(|i| &out[i..])
            .unwrap_or("unknown error");
        tracing::error!("pdflatex failed: {} ({})", err,path.display());
        return Err(())
    }
    Ok(())
}


fn to_file_path_ref(
    path: &str,
) -> Box<str> {
    if path.ends_with(".tex") {
        path.into()
    } else {
        format!("{path}.tex").into()
    }
}
