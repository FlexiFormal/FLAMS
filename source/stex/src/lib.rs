#![feature(lazy_type_alias)]
#![cfg_attr(docsrs, feature(doc_auto_cfg))]

mod dependencies;
mod latex;
mod quickparse;
mod rustex;
use either::Either;
use immt_shtml::{HTMLString, SHTML_DOC, SHTML_OMDOC};
use immt_system::{
    backend::AnyBackend, build_result, build_target, building::{BuildResult, BuildResultArtifact, BuildTask}, formats::{CHECK, PDF}, immt_extension, source_format
};
pub use rustex::RusTeX;

source_format!(stex ["tex","ltx"] [
  PDFLATEX_FIRST => PDFLATEX => RUSTEX => SHTML_OMDOC => CHECK]
   @ "(Semantically annotated) LaTeX"
   = dependencies::get_deps
);

build_target!(
  pdflatex_first [] => [AUX]
  @ "Run pdflatex and bibtex/biber/index once"
  = pdflatex_first
);

fn pdflatex_first(_:&AnyBackend,task:&BuildTask) -> BuildResult {
  let Either::Left(path) = task.source() else {
    return BuildResult {
      log:Either::Left("Needs a physical file".to_string()),
      result:Err(Vec::new())
    }
  };
  latex::clean(path);
  let log = path.with_extension("log");
  let ret = latex::pdflatex_and_bib(
    path,
    std::iter::once(("STEX_WRITESMS","true"))
  );
  if ret.is_ok() {
    BuildResult {
      log:Either::Right(log),
      result: Ok(BuildResultArtifact::File(PDF,path.with_extension("pdf")))
    }
  } else {
    BuildResult {
      log:Either::Right(log),
      result:Err(Vec::new())
    }
  }
}

build_target!(
  pdflatex [AUX] => [PDF]
  @ "Run pdflatex a second time"
  = pdflatex_second
);

fn pdflatex_second(_:&AnyBackend,task:&BuildTask) -> BuildResult {
  let Either::Left(path) = task.source() else {
    return BuildResult {
      log:Either::Left("Needs a physical file".to_string()),
      result:Err(Vec::new())
    }
  };
  let log = path.with_extension("log");
  let ret = latex::pdflatex(
    path,
    std::iter::once(("STEX_USESMS","true"))
  );
  if ret.is_ok() {
    BuildResult {
      log:Either::Right(log),
      result: Ok(BuildResultArtifact::File(PDF,path.with_extension("pdf")))
    }
  } else {
    BuildResult {
      log:Either::Right(log),
      result:Err(Vec::new())
    }
  }
}

build_target!(
  rustex [AUX] => [SHTML_DOC]
  @ "Run RusTeX tex->html only"
  = rustex
);

fn rustex(_:&AnyBackend,task:&BuildTask) -> BuildResult {
  // TODO make work with string as well
  let Either::Left(path) = task.source() else {
    return BuildResult {
      log:Either::Left("Needs a physical file".to_string()),
      result:Err(Vec::new())
    }
  };
  let out = path.with_extension("rlog");
  let ocl = out.clone();
  let run = move || RusTeX::get().run_with_envs(
    path, false, 
    std::iter::once(("STEX_USESMS".to_string(),"true".to_string())),
    Some(&ocl)
  );
  #[cfg(debug_assertions)]
  let ret = { std::thread::scope(move |s| std::thread::Builder::new().stack_size(16 * 1024 * 1024).spawn_scoped(s,run).expect("foo").join().expect("foo")) };
  #[cfg(not(debug_assertions))]
  let ret = { run() };
  match ret {
    Err(_) => BuildResult {
      log:Either::Right(out),
      result:Err(Vec::new())
    },
    Ok(s) => {
      latex::clean(path);
      BuildResult {
        log:Either::Right(out),
        result:Ok(HTMLString::create(s))
      }
    }
  }
}

build_result!(aux @ "LaTeX aux/bbl/toc files, as generated by pdflatex+bibtex/biber/mkindex");

immt_extension!(stex_ext = RusTeX::initialize);