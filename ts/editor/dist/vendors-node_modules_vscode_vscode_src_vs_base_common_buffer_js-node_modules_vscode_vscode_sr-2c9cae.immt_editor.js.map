{"version":3,"file":"vendors-node_modules_vscode_vscode_src_vs_base_common_buffer_js-node_modules_vscode_vscode_sr-2c9cae.immt_editor.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAiC;AACwG;AACzI;AACA,2BAA2B,0CAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2DAAe;AAC1B;AACA;AACA,WAAW,sDAAU;AACrB;AACA;AACA,WAAW,yDAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oDAAQ;AACnB;AACA;AACA,WAAW,8DAAkB;AAC7B;AACA;AACA,WAAW,4DAAgB;AAC3B;AACA;AACA,WAAW,0DAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,WAAW;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA,WAAW,mCAAmC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiV;;;;;;;;;;;;;;;;;;;;;ACjU5S;AACrC;AACA;AACA,qBAAqB,kDAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsG;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7FvD;AACP;AAClB;AAC8B;AAC/B;AAC4E;AACxD;AACzC;AACA,uCAAuC,wDAAa;AACpD;AACA;AACA,uCAAuC,wDAAa;AACpD;AACA;AACA,uCAAuC,wDAAa;AACpD;AACA;AACA,wBAAwB,0DAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,WAAW,2DAAY;AACvB;AACA;AACA,KAAK;AACL;AACA;AACA,wBAAwB,0DAAe;AACvC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,WAAW,2DAAY;AACvB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8DAAe;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6DAAc;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sDAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gEAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,eAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,QAAQ,oDAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,gBAAgB,gEAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC6F;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1KxD;AACpB;AACvB;AACI;AACgB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8DAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,eAAe,GAAG,SAAS;AACzD;AACA;AACA,8BAA8B,gBAAgB;AAC9C;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gCAAgC,gBAAgB;AAChD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAAe;AAC9B;AACA;AACA,sCAAsC,sBAAsB;AAC5D;AACA;AACA;AACA;AACA,wBAAwB,8BAA8B;AACtD,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wDAAa;AAC3C;AACA;AACA,8BAA8B,wDAAa;AAC3C;AACA,8DAA8D,oDAAY;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,mBAAmB,eAAe;AACxF;AACA;AACA;AACA;AACA,YAAY,sDAAS,oCAAoC,oEAAoE;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAe,IAAI,YAAY;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wDAAa;AAC3C;AACA;AACA,8BAA8B,wDAAa;AAC3C;AACA,wEAAwE,oDAAY;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiS;;;;;;;;;;;;;;;;;AC7OjS;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,QAAQ,GAAG,MAAM;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,UAAU,GAAG,MAAM;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnGI;AACb;AACP;AACI;AACQ;AAC/B;AAC6B;AACT;AACzC;AACA;AACA,mCAAmC,wDAAa,uFAAuF,oDAAY;AACnJ;AACA,+BAA+B,wDAAa,8FAA8F,oDAAY;AACtJ;AACA;AACA,yCAAyC,wDAAa,4EAA4E,oDAAY;AAC9I;AACA;AACA,+BAA+B,wDAAa,mJAAmJ,oDAAY;AAC3M;AACA,yDAAe;AACf;AACA,+BAA+B,wDAAa,0JAA0J,oDAAY;AAClN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0DAAe;AACvC,+BAA+B,wDAAa;AAC5C;AACA;AACA,KAAK,+CAA+C,oDAAY;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wDAAa;AAC5C;AACA,0BAA0B,0DAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK,EAAE,oDAAY;AACnB;AACA,sBAAsB,oDAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sDAAS;AACrB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,YAAY,gEAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,eAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oDAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,gBAAgB,gEAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0I;;;;;;;;;;;;;;;AChQ1I;AACA;AACA;AACA;AACqB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACJqD;AAC0F;AACvG;AACX;AACN;AACR;AAC4B;AACZ;AACpD;AACA;AACA;AACA,8BAA8B,0DAAoB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,WAAW;AACpC;AACA;AACA;AACA,uBAAuB,yDAAe,mBAAmB;AACzD;AACA,yBAAyB,OAAO;AAChC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,wDAAa,6FAA6F,oDAAY;AACjK;AACA;AACA,2CAA2C,wDAAa,6JAA6J,oDAAY;AACjO;AACA,kCAAkC,oDAAc;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wDAAc;AAClC;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,4DAA4D,KAAK;AACjE,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,KAAK;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kDAAkD;AACnD;AACA;AACA;AACA,wCAAwC,oDAAc;AACtD;AACA;AACA;AACA;AACA;AACA,YAAY,qDAAW;AACvB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oDAAc;AAC7C;AACA,qBAAqB,wDAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qDAAW;AACvB;AACA,aAAa,0BAA0B,eAAe;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yDAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,WAAW,2DAAY;AACvB;AACA,KAAK;AACL;AACA,0DAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2DAAY;AACvB;AACA,KAAK;AACL;AACA,2EAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wDAAW,GAAG,oCAAoC;AACzE;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAO;AAC9B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,iBAAiB,wDAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,0DAAe;AACnD;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4CAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0DAAkB;AACtC;AACA;AACA;AACA;AACA,4BAA4B,0DAAe;AAC3C;AACA,sBAAsB,wDAAW,GAAG,iBAAiB,2DAAY,eAAe,wDAAa,6DAA6D;AAC1J;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0EAA6B;AACxC,2CAA2C,8BAA8B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,wBAAwB,0DAAe;AACvC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AAC+e;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACta/b;AACe;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6DAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,sCAAsC,0DAAe;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8BAA8B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6BAA6B;AAC1D;AACA,4BAA4B,2DAAY;AACxC;AACA,4BAA4B,2DAAY;AACxC;AACA,4BAA4B,2DAAY;AACxC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,sCAAsC;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACkO;;;;;;;;;;;;;;;AC/WlO;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoB","sources":["webpack://immt-editor/./node_modules/vscode/vscode/src/vs/base/common/buffer.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/base/common/equals.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/base/common/observableInternal/autorun.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/base/common/observableInternal/base.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/base/common/observableInternal/debugName.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/base/common/observableInternal/derived.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/base/common/observableInternal/logging.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/base/common/observableInternal/utils.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/base/common/stream.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/editor/common/core/eolCounter.js"],"sourcesContent":["import { Lazy } from './lazy.js';\nimport { consumeReadable, toReadable, consumeStream, toStream, prefixedStream, newWriteableStream, prefixedReadable } from './stream.js';\nconst hasBuffer = (typeof Buffer !== 'undefined');\nconst indexOfTable = ( new Lazy(() => ( new Uint8Array(256))));\nlet textEncoder;\nlet textDecoder;\nclass VSBuffer {\n    static alloc(byteLength) {\n        if (hasBuffer) {\n            return ( new VSBuffer(Buffer.allocUnsafe(byteLength)));\n        }\n        else {\n            return ( new VSBuffer(( new Uint8Array(byteLength))));\n        }\n    }\n    static wrap(actual) {\n        if (hasBuffer && !(Buffer.isBuffer(actual))) {\n            actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);\n        }\n        return ( new VSBuffer(actual));\n    }\n    static fromString(source, options) {\n        const dontUseNodeBuffer = options?.dontUseNodeBuffer || false;\n        if (!dontUseNodeBuffer && hasBuffer) {\n            return ( new VSBuffer(Buffer.from(source)));\n        }\n        else {\n            if (!textEncoder) {\n                textEncoder = ( new TextEncoder());\n            }\n            return ( new VSBuffer(textEncoder.encode(source)));\n        }\n    }\n    static fromByteArray(source) {\n        const result = VSBuffer.alloc(source.length);\n        for (let i = 0, len = source.length; i < len; i++) {\n            result.buffer[i] = source[i];\n        }\n        return result;\n    }\n    static concat(buffers, totalLength) {\n        if (typeof totalLength === 'undefined') {\n            totalLength = 0;\n            for (let i = 0, len = buffers.length; i < len; i++) {\n                totalLength += buffers[i].byteLength;\n            }\n        }\n        const ret = VSBuffer.alloc(totalLength);\n        let offset = 0;\n        for (let i = 0, len = buffers.length; i < len; i++) {\n            const element = buffers[i];\n            ret.set(element, offset);\n            offset += element.byteLength;\n        }\n        return ret;\n    }\n    constructor(buffer) {\n        this.buffer = buffer;\n        this.byteLength = this.buffer.byteLength;\n    }\n    clone() {\n        const result = VSBuffer.alloc(this.byteLength);\n        result.set(this);\n        return result;\n    }\n    toString() {\n        if (hasBuffer) {\n            return ( this.buffer.toString());\n        }\n        else {\n            if (!textDecoder) {\n                textDecoder = ( new TextDecoder());\n            }\n            return textDecoder.decode(this.buffer);\n        }\n    }\n    slice(start, end) {\n        return ( new VSBuffer(this.buffer.subarray(start, end)));\n    }\n    set(array, offset) {\n        if (array instanceof VSBuffer) {\n            this.buffer.set(array.buffer, offset);\n        }\n        else if (array instanceof Uint8Array) {\n            this.buffer.set(array, offset);\n        }\n        else if (array instanceof ArrayBuffer) {\n            this.buffer.set(( new Uint8Array(array)), offset);\n        }\n        else if (ArrayBuffer.isView(array)) {\n            this.buffer.set(( new Uint8Array(array.buffer, array.byteOffset, array.byteLength)), offset);\n        }\n        else {\n            throw ( new Error(`Unknown argument 'array'`));\n        }\n    }\n    readUInt32BE(offset) {\n        return readUInt32BE(this.buffer, offset);\n    }\n    writeUInt32BE(value, offset) {\n        writeUInt32BE(this.buffer, value, offset);\n    }\n    readUInt32LE(offset) {\n        return readUInt32LE(this.buffer, offset);\n    }\n    writeUInt32LE(value, offset) {\n        writeUInt32LE(this.buffer, value, offset);\n    }\n    readUInt8(offset) {\n        return readUInt8(this.buffer, offset);\n    }\n    writeUInt8(value, offset) {\n        writeUInt8(this.buffer, value, offset);\n    }\n    indexOf(subarray, offset = 0) {\n        return binaryIndexOf(this.buffer, subarray instanceof VSBuffer ? subarray.buffer : subarray, offset);\n    }\n}\nfunction binaryIndexOf(haystack, needle, offset = 0) {\n    const needleLen = needle.byteLength;\n    const haystackLen = haystack.byteLength;\n    if (needleLen === 0) {\n        return 0;\n    }\n    if (needleLen === 1) {\n        return haystack.indexOf(needle[0]);\n    }\n    if (needleLen > haystackLen - offset) {\n        return -1;\n    }\n    const table = indexOfTable.value;\n    table.fill(needle.length);\n    for (let i = 0; i < needle.length; i++) {\n        table[needle[i]] = needle.length - i - 1;\n    }\n    let i = offset + needle.length - 1;\n    let j = i;\n    let result = -1;\n    while (i < haystackLen) {\n        if (haystack[i] === needle[j]) {\n            if (j === 0) {\n                result = i;\n                break;\n            }\n            i--;\n            j--;\n        }\n        else {\n            i += Math.max(needle.length - j, table[haystack[i]]);\n            j = needle.length - 1;\n        }\n    }\n    return result;\n}\nfunction readUInt16LE(source, offset) {\n    return (((source[offset + 0] << 0) >>> 0) |\n        ((source[offset + 1] << 8) >>> 0));\n}\nfunction writeUInt16LE(destination, value, offset) {\n    destination[offset + 0] = (value & 0b11111111);\n    value = value >>> 8;\n    destination[offset + 1] = (value & 0b11111111);\n}\nfunction readUInt32BE(source, offset) {\n    return (source[offset] * 2 ** 24\n        + source[offset + 1] * 2 ** 16\n        + source[offset + 2] * 2 ** 8\n        + source[offset + 3]);\n}\nfunction writeUInt32BE(destination, value, offset) {\n    destination[offset + 3] = value;\n    value = value >>> 8;\n    destination[offset + 2] = value;\n    value = value >>> 8;\n    destination[offset + 1] = value;\n    value = value >>> 8;\n    destination[offset] = value;\n}\nfunction readUInt32LE(source, offset) {\n    return (((source[offset + 0] << 0) >>> 0) |\n        ((source[offset + 1] << 8) >>> 0) |\n        ((source[offset + 2] << 16) >>> 0) |\n        ((source[offset + 3] << 24) >>> 0));\n}\nfunction writeUInt32LE(destination, value, offset) {\n    destination[offset + 0] = (value & 0b11111111);\n    value = value >>> 8;\n    destination[offset + 1] = (value & 0b11111111);\n    value = value >>> 8;\n    destination[offset + 2] = (value & 0b11111111);\n    value = value >>> 8;\n    destination[offset + 3] = (value & 0b11111111);\n}\nfunction readUInt8(source, offset) {\n    return source[offset];\n}\nfunction writeUInt8(destination, value, offset) {\n    destination[offset] = value;\n}\nfunction readableToBuffer(readable) {\n    return consumeReadable(readable, chunks => VSBuffer.concat(chunks));\n}\nfunction bufferToReadable(buffer) {\n    return toReadable(buffer);\n}\nfunction streamToBuffer(stream) {\n    return consumeStream(stream, chunks => VSBuffer.concat(chunks));\n}\nasync function bufferedStreamToBuffer(bufferedStream) {\n    if (bufferedStream.ended) {\n        return VSBuffer.concat(bufferedStream.buffer);\n    }\n    return VSBuffer.concat([\n        ...bufferedStream.buffer,\n        await streamToBuffer(bufferedStream.stream)\n    ]);\n}\nfunction bufferToStream(buffer) {\n    return toStream(buffer, chunks => VSBuffer.concat(chunks));\n}\nfunction newWriteableBufferStream(options) {\n    return newWriteableStream(chunks => VSBuffer.concat(chunks), options);\n}\nfunction prefixedBufferReadable(prefix, readable) {\n    return prefixedReadable(prefix, readable, chunks => VSBuffer.concat(chunks));\n}\nfunction prefixedBufferStream(prefix, stream) {\n    return prefixedStream(prefix, stream, chunks => VSBuffer.concat(chunks));\n}\nfunction decodeBase64(encoded) {\n    let building = 0;\n    let remainder = 0;\n    let bufi = 0;\n    const buffer = ( new Uint8Array(Math.floor(encoded.length / 4 * 3)));\n    const append = (value) => {\n        switch (remainder) {\n            case 3:\n                buffer[bufi++] = building | value;\n                remainder = 0;\n                break;\n            case 2:\n                buffer[bufi++] = building | (value >>> 2);\n                building = value << 6;\n                remainder = 3;\n                break;\n            case 1:\n                buffer[bufi++] = building | (value >>> 4);\n                building = value << 4;\n                remainder = 2;\n                break;\n            default:\n                building = value << 2;\n                remainder = 1;\n        }\n    };\n    for (let i = 0; i < encoded.length; i++) {\n        const code = encoded.charCodeAt(i);\n        if (code >= 65 && code <= 90) {\n            append(code - 65);\n        }\n        else if (code >= 97 && code <= 122) {\n            append(code - 97 + 26);\n        }\n        else if (code >= 48 && code <= 57) {\n            append(code - 48 + 52);\n        }\n        else if (code === 43 || code === 45) {\n            append(62);\n        }\n        else if (code === 47 || code === 95) {\n            append(63);\n        }\n        else if (code === 61) {\n            break;\n        }\n        else {\n            throw ( new SyntaxError(`Unexpected base64 character ${encoded[i]}`));\n        }\n    }\n    const unpadded = bufi;\n    while (remainder > 0) {\n        append(0);\n    }\n    return VSBuffer.wrap(buffer).slice(0, unpadded);\n}\nconst base64Alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst base64UrlSafeAlphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';\nfunction encodeBase64({ buffer }, padded = true, urlSafe = false) {\n    const dictionary = urlSafe ? base64UrlSafeAlphabet : base64Alphabet;\n    let output = '';\n    const remainder = buffer.byteLength % 3;\n    let i = 0;\n    for (; i < buffer.byteLength - remainder; i += 3) {\n        const a = buffer[i + 0];\n        const b = buffer[i + 1];\n        const c = buffer[i + 2];\n        output += dictionary[a >>> 2];\n        output += dictionary[(a << 4 | b >>> 4) & 0b111111];\n        output += dictionary[(b << 2 | c >>> 6) & 0b111111];\n        output += dictionary[c & 0b111111];\n    }\n    if (remainder === 1) {\n        const a = buffer[i + 0];\n        output += dictionary[a >>> 2];\n        output += dictionary[(a << 4) & 0b111111];\n        if (padded) {\n            output += '==';\n        }\n    }\n    else if (remainder === 2) {\n        const a = buffer[i + 0];\n        const b = buffer[i + 1];\n        output += dictionary[a >>> 2];\n        output += dictionary[(a << 4 | b >>> 4) & 0b111111];\n        output += dictionary[(b << 2) & 0b111111];\n        if (padded) {\n            output += '=';\n        }\n    }\n    return output;\n}\nexport { VSBuffer, binaryIndexOf, bufferToReadable, bufferToStream, bufferedStreamToBuffer, decodeBase64, encodeBase64, newWriteableBufferStream, prefixedBufferReadable, prefixedBufferStream, readUInt16LE, readUInt32BE, readUInt32LE, readUInt8, readableToBuffer, streamToBuffer, writeUInt16LE, writeUInt32BE, writeUInt32LE, writeUInt8 };\n","import { equals } from './arrays.js';\nconst strictEquals = (a, b) => a === b;\nfunction itemsEquals(itemEquals = strictEquals) {\n    return (a, b) => equals(a, b, itemEquals);\n}\nfunction itemEquals() {\n    return (a, b) => a.equals(b);\n}\nfunction equalsIfDefined(equalsOrV1, v2, equals) {\n    if (equals !== undefined) {\n        const v1 = equalsOrV1;\n        if (v1 === undefined || v1 === null || v2 === undefined || v2 === null) {\n            return v2 === v1;\n        }\n        return equals(v1, v2);\n    }\n    else {\n        const equals = equalsOrV1;\n        return (v1, v2) => {\n            if (v1 === undefined || v1 === null || v2 === undefined || v2 === null) {\n                return v2 === v1;\n            }\n            return equals(v1, v2);\n        };\n    }\n}\nfunction structuralEquals(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (Array.isArray(a) && Array.isArray(b)) {\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0; i < a.length; i++) {\n            if (!structuralEquals(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    if (a && typeof a === 'object' && b && typeof b === 'object') {\n        if (Object.getPrototypeOf(a) === Object.prototype && Object.getPrototypeOf(b) === Object.prototype) {\n            const aObj = a;\n            const bObj = b;\n            const keysA = ( Object.keys(aObj));\n            const keysB = ( Object.keys(bObj));\n            const keysBSet = ( new Set(keysB));\n            if (keysA.length !== keysB.length) {\n                return false;\n            }\n            for (const key of keysA) {\n                if (!( keysBSet.has(key))) {\n                    return false;\n                }\n                if (!structuralEquals(aObj[key], bObj[key])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    return false;\n}\nfunction getStructuralKey(t) {\n    return JSON.stringify(toNormalizedJsonStructure(t));\n}\nlet objectId = 0;\nconst objIds = ( new WeakMap());\nfunction toNormalizedJsonStructure(t) {\n    if (Array.isArray(t)) {\n        return ( t.map(toNormalizedJsonStructure));\n    }\n    if (t && typeof t === 'object') {\n        if (Object.getPrototypeOf(t) === Object.prototype) {\n            const tObj = t;\n            const res = Object.create(null);\n            for (const key of ( Object.keys(tObj)).sort()) {\n                res[key] = toNormalizedJsonStructure(tObj[key]);\n            }\n            return res;\n        }\n        else {\n            let objId = objIds.get(t);\n            if (objId === undefined) {\n                objId = objectId++;\n                objIds.set(t, objId);\n            }\n            return objId + '----2b76a038c20c4bcc';\n        }\n    }\n    return t;\n}\nexport { equalsIfDefined, getStructuralKey, itemEquals, itemsEquals, strictEquals, structuralEquals };\n","import { DebugNameData } from './debugName.js';\nimport { assertFn } from '../assert.js';\nimport '../arrays.js';\nimport { onBugIndicatingError } from '../errors.js';\nimport '../event.js';\nimport { toDisposable, DisposableStore, trackDisposable, markAsDisposed } from '../lifecycle.js';\nimport { getLogger } from './logging.js';\nfunction autorun(fn) {\n    return ( new AutorunObserver(( new DebugNameData(undefined, undefined, fn)), fn, undefined, undefined));\n}\nfunction autorunOpts(options, fn) {\n    return ( new AutorunObserver(( new DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? fn)), fn, undefined, undefined));\n}\nfunction autorunHandleChanges(options, fn) {\n    return ( new AutorunObserver(( new DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? fn)), fn, options.createEmptyChangeSummary, options.handleChange));\n}\nfunction autorunWithStoreHandleChanges(options, fn) {\n    const store = ( new DisposableStore());\n    const disposable = autorunHandleChanges({\n        owner: options.owner,\n        debugName: options.debugName,\n        debugReferenceFn: options.debugReferenceFn ?? fn,\n        createEmptyChangeSummary: options.createEmptyChangeSummary,\n        handleChange: options.handleChange,\n    }, (reader, changeSummary) => {\n        store.clear();\n        fn(reader, changeSummary, store);\n    });\n    return toDisposable(() => {\n        disposable.dispose();\n        store.dispose();\n    });\n}\nfunction autorunWithStore(fn) {\n    const store = ( new DisposableStore());\n    const disposable = autorunOpts({\n        owner: undefined,\n        debugName: undefined,\n        debugReferenceFn: fn,\n    }, reader => {\n        store.clear();\n        fn(reader, store);\n    });\n    return toDisposable(() => {\n        disposable.dispose();\n        store.dispose();\n    });\n}\nclass AutorunObserver {\n    get debugName() {\n        return this._debugNameData.getDebugName(this) ?? '(anonymous)';\n    }\n    constructor(_debugNameData, _runFn, createChangeSummary, _handleChange) {\n        this._debugNameData = _debugNameData;\n        this._runFn = _runFn;\n        this.createChangeSummary = createChangeSummary;\n        this._handleChange = _handleChange;\n        this.state = 2 ;\n        this.updateCount = 0;\n        this.disposed = false;\n        this.dependencies = ( new Set());\n        this.dependenciesToBeRemoved = ( new Set());\n        this.changeSummary = this.createChangeSummary?.();\n        this._runIfNeeded();\n        trackDisposable(this);\n    }\n    dispose() {\n        this.disposed = true;\n        for (const o of this.dependencies) {\n            o.removeObserver(this);\n        }\n        this.dependencies.clear();\n        markAsDisposed(this);\n    }\n    _runIfNeeded() {\n        if (this.state === 3 ) {\n            return;\n        }\n        const emptySet = this.dependenciesToBeRemoved;\n        this.dependenciesToBeRemoved = this.dependencies;\n        this.dependencies = emptySet;\n        this.state = 3 ;\n        const isDisposed = this.disposed;\n        try {\n            if (!isDisposed) {\n                getLogger()?.handleAutorunTriggered(this);\n                const changeSummary = this.changeSummary;\n                try {\n                    this.changeSummary = this.createChangeSummary?.();\n                    this._runFn(this, changeSummary);\n                }\n                catch (e) {\n                    onBugIndicatingError(e);\n                }\n            }\n        }\n        finally {\n            for (const o of this.dependenciesToBeRemoved) {\n                o.removeObserver(this);\n            }\n            this.dependenciesToBeRemoved.clear();\n        }\n    }\n    toString() {\n        return `Autorun<${this.debugName}>`;\n    }\n    beginUpdate() {\n        if (this.state === 3 ) {\n            this.state = 1 ;\n        }\n        this.updateCount++;\n    }\n    endUpdate() {\n        try {\n            if (this.updateCount === 1) {\n                do {\n                    if (this.state === 1 ) {\n                        this.state = 3 ;\n                        for (const d of this.dependencies) {\n                            d.reportChanges();\n                            if (this.state === 2 ) {\n                                break;\n                            }\n                        }\n                    }\n                    this._runIfNeeded();\n                } while (this.state !== 3 );\n            }\n        }\n        finally {\n            this.updateCount--;\n        }\n        assertFn(() => this.updateCount >= 0);\n    }\n    handlePossibleChange(observable) {\n        if (this.state === 3  && ( this.dependencies.has(observable)) && !( this.dependenciesToBeRemoved.has(observable))) {\n            this.state = 1 ;\n        }\n    }\n    handleChange(observable, change) {\n        if (( this.dependencies.has(observable)) && !( this.dependenciesToBeRemoved.has(observable))) {\n            try {\n                const shouldReact = this._handleChange ? this._handleChange({\n                    changedObservable: observable,\n                    change,\n                    didChange: (o) => o === observable,\n                }, this.changeSummary) : true;\n                if (shouldReact) {\n                    this.state = 2 ;\n                }\n            }\n            catch (e) {\n                onBugIndicatingError(e);\n            }\n        }\n    }\n    readObservable(observable) {\n        if (this.disposed) {\n            return observable.get();\n        }\n        observable.addObserver(this);\n        const value = observable.get();\n        this.dependencies.add(observable);\n        this.dependenciesToBeRemoved.delete(observable);\n        return value;\n    }\n}\n( (function(autorun) {\n    autorun.Observer = AutorunObserver;\n})(autorun || (autorun = {})));\nexport { AutorunObserver, autorun, autorunHandleChanges, autorunOpts, autorunWithStore, autorunWithStoreHandleChanges };\n","import { getFunctionName, DebugNameData } from './debugName.js';\nimport { strictEquals } from '../equals.js';\nimport '../event.js';\nimport '../lifecycle.js';\nimport { getLogger } from './logging.js';\nlet _recomputeInitiallyAndOnChange;\nfunction _setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange) {\n    _recomputeInitiallyAndOnChange = recomputeInitiallyAndOnChange;\n}\nlet _keepObserved;\nfunction _setKeepObserved(keepObserved) {\n    _keepObserved = keepObserved;\n}\nlet _derived;\nfunction _setDerivedOpts(derived) {\n    _derived = derived;\n}\nclass ConvenientObservable {\n    get TChange() { return null; }\n    reportChanges() {\n        this.get();\n    }\n    read(reader) {\n        if (reader) {\n            return reader.readObservable(this);\n        }\n        else {\n            return this.get();\n        }\n    }\n    map(fnOrOwner, fnOrUndefined) {\n        const owner = fnOrUndefined === undefined ? undefined : fnOrOwner;\n        const fn = fnOrUndefined === undefined ? fnOrOwner : fnOrUndefined;\n        return _derived({\n            owner,\n            debugName: () => {\n                const name = getFunctionName(fn);\n                if (name !== undefined) {\n                    return name;\n                }\n                const regexp = /^\\s*\\(?\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*\\)?\\s*=>\\s*\\1(?:\\??)\\.([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*$/;\n                const match = regexp.exec(( fn.toString()));\n                if (match) {\n                    return `${this.debugName}.${match[2]}`;\n                }\n                if (!owner) {\n                    return `${this.debugName} (mapped)`;\n                }\n                return undefined;\n            },\n            debugReferenceFn: fn,\n        }, (reader) => fn(this.read(reader), reader));\n    }\n    flatten() {\n        return _derived({\n            owner: undefined,\n            debugName: () => `${this.debugName} (flattened)`,\n        }, (reader) => this.read(reader).read(reader));\n    }\n    recomputeInitiallyAndOnChange(store, handleValue) {\n        store.add(_recomputeInitiallyAndOnChange(this, handleValue));\n        return this;\n    }\n    keepObserved(store) {\n        store.add(_keepObserved(this));\n        return this;\n    }\n    get debugValue() {\n        return this.get();\n    }\n}\nclass BaseObservable extends ConvenientObservable {\n    constructor() {\n        super(...arguments);\n        this.observers = ( new Set());\n    }\n    addObserver(observer) {\n        const len = this.observers.size;\n        this.observers.add(observer);\n        if (len === 0) {\n            this.onFirstObserverAdded();\n        }\n    }\n    removeObserver(observer) {\n        const deleted = this.observers.delete(observer);\n        if (deleted && this.observers.size === 0) {\n            this.onLastObserverRemoved();\n        }\n    }\n    onFirstObserverAdded() { }\n    onLastObserverRemoved() { }\n}\nfunction transaction(fn, getDebugName) {\n    const tx = ( new TransactionImpl(fn, getDebugName));\n    try {\n        fn(tx);\n    }\n    finally {\n        tx.finish();\n    }\n}\nlet _globalTransaction = undefined;\nfunction globalTransaction(fn) {\n    if (_globalTransaction) {\n        fn(_globalTransaction);\n    }\n    else {\n        const tx = ( new TransactionImpl(fn, undefined));\n        _globalTransaction = tx;\n        try {\n            fn(tx);\n        }\n        finally {\n            tx.finish();\n            _globalTransaction = undefined;\n        }\n    }\n}\nasync function asyncTransaction(fn, getDebugName) {\n    const tx = ( new TransactionImpl(fn, getDebugName));\n    try {\n        await fn(tx);\n    }\n    finally {\n        tx.finish();\n    }\n}\nfunction subtransaction(tx, fn, getDebugName) {\n    if (!tx) {\n        transaction(fn, getDebugName);\n    }\n    else {\n        fn(tx);\n    }\n}\nclass TransactionImpl {\n    constructor(_fn, _getDebugName) {\n        this._fn = _fn;\n        this._getDebugName = _getDebugName;\n        this.updatingObservers = [];\n    }\n    getDebugName() {\n        if (this._getDebugName) {\n            return this._getDebugName();\n        }\n        return getFunctionName(this._fn);\n    }\n    updateObserver(observer, observable) {\n        this.updatingObservers.push({ observer, observable });\n        observer.beginUpdate(observable);\n    }\n    finish() {\n        const updatingObservers = this.updatingObservers;\n        for (let i = 0; i < updatingObservers.length; i++) {\n            const { observer, observable } = updatingObservers[i];\n            observer.endUpdate(observable);\n        }\n        this.updatingObservers = null;\n    }\n}\nfunction observableValue(nameOrOwner, initialValue) {\n    let debugNameData;\n    if (typeof nameOrOwner === 'string') {\n        debugNameData = ( new DebugNameData(undefined, nameOrOwner, undefined));\n    }\n    else {\n        debugNameData = ( new DebugNameData(nameOrOwner, undefined, undefined));\n    }\n    return ( new ObservableValue(debugNameData, initialValue, strictEquals));\n}\nclass ObservableValue extends BaseObservable {\n    get debugName() {\n        return this._debugNameData.getDebugName(this) ?? 'ObservableValue';\n    }\n    constructor(_debugNameData, initialValue, _equalityComparator) {\n        super();\n        this._debugNameData = _debugNameData;\n        this._equalityComparator = _equalityComparator;\n        this._value = initialValue;\n    }\n    get() {\n        return this._value;\n    }\n    set(value, tx, change) {\n        if (change === undefined && this._equalityComparator(this._value, value)) {\n            return;\n        }\n        let _tx;\n        if (!tx) {\n            tx = _tx = ( new TransactionImpl(() => { }, () => `Setting ${this.debugName}`));\n        }\n        try {\n            const oldValue = this._value;\n            this._setValue(value);\n            getLogger()?.handleObservableChanged(this, { oldValue, newValue: value, change, didChange: true, hadValue: true });\n            for (const observer of this.observers) {\n                tx.updateObserver(observer, this);\n                observer.handleChange(this, change);\n            }\n        }\n        finally {\n            if (_tx) {\n                _tx.finish();\n            }\n        }\n    }\n    toString() {\n        return `${this.debugName}: ${this._value}`;\n    }\n    _setValue(newValue) {\n        this._value = newValue;\n    }\n}\nfunction disposableObservableValue(nameOrOwner, initialValue) {\n    let debugNameData;\n    if (typeof nameOrOwner === 'string') {\n        debugNameData = ( new DebugNameData(undefined, nameOrOwner, undefined));\n    }\n    else {\n        debugNameData = ( new DebugNameData(nameOrOwner, undefined, undefined));\n    }\n    return ( new DisposableObservableValue(debugNameData, initialValue, strictEquals));\n}\nclass DisposableObservableValue extends ObservableValue {\n    _setValue(newValue) {\n        if (this._value === newValue) {\n            return;\n        }\n        if (this._value) {\n            this._value.dispose();\n        }\n        this._value = newValue;\n    }\n    dispose() {\n        this._value?.dispose();\n    }\n}\nexport { BaseObservable, ConvenientObservable, DisposableObservableValue, ObservableValue, TransactionImpl, _setDerivedOpts, _setKeepObserved, _setRecomputeInitiallyAndOnChange, asyncTransaction, disposableObservableValue, globalTransaction, observableValue, subtransaction, transaction };\n","class DebugNameData {\n    constructor(owner, debugNameSource, referenceFn) {\n        this.owner = owner;\n        this.debugNameSource = debugNameSource;\n        this.referenceFn = referenceFn;\n    }\n    getDebugName(target) {\n        return getDebugName(target, this);\n    }\n}\nconst countPerName = ( new Map());\nconst cachedDebugName = ( new WeakMap());\nfunction getDebugName(target, data) {\n    const cached = cachedDebugName.get(target);\n    if (cached) {\n        return cached;\n    }\n    const dbgName = computeDebugName(target, data);\n    if (dbgName) {\n        let count = countPerName.get(dbgName) ?? 0;\n        count++;\n        countPerName.set(dbgName, count);\n        const result = count === 1 ? dbgName : `${dbgName}#${count}`;\n        cachedDebugName.set(target, result);\n        return result;\n    }\n    return undefined;\n}\nfunction computeDebugName(self, data) {\n    const cached = cachedDebugName.get(self);\n    if (cached) {\n        return cached;\n    }\n    const ownerStr = data.owner ? formatOwner(data.owner) + `.` : '';\n    let result;\n    const debugNameSource = data.debugNameSource;\n    if (debugNameSource !== undefined) {\n        if (typeof debugNameSource === 'function') {\n            result = debugNameSource();\n            if (result !== undefined) {\n                return ownerStr + result;\n            }\n        }\n        else {\n            return ownerStr + debugNameSource;\n        }\n    }\n    const referenceFn = data.referenceFn;\n    if (referenceFn !== undefined) {\n        result = getFunctionName(referenceFn);\n        if (result !== undefined) {\n            return ownerStr + result;\n        }\n    }\n    if (data.owner !== undefined) {\n        const key = findKey(data.owner, self);\n        if (key !== undefined) {\n            return ownerStr + key;\n        }\n    }\n    return undefined;\n}\nfunction findKey(obj, value) {\n    for (const key in obj) {\n        if (obj[key] === value) {\n            return key;\n        }\n    }\n    return undefined;\n}\nconst countPerClassName = ( new Map());\nconst ownerId = ( new WeakMap());\nfunction formatOwner(owner) {\n    const id = ownerId.get(owner);\n    if (id) {\n        return id;\n    }\n    const className = getClassName(owner);\n    let count = countPerClassName.get(className) ?? 0;\n    count++;\n    countPerClassName.set(className, count);\n    const result = count === 1 ? className : `${className}#${count}`;\n    ownerId.set(owner, result);\n    return result;\n}\nfunction getClassName(obj) {\n    const ctor = obj.constructor;\n    if (ctor) {\n        return ctor.name;\n    }\n    return 'Object';\n}\nfunction getFunctionName(fn) {\n    const fnSrc = ( fn.toString());\n    const regexp = /\\/\\*\\*\\s*@description\\s*([^*]*)\\*\\//;\n    const match = regexp.exec(fnSrc);\n    const result = match ? match[1] : undefined;\n    return result?.trim();\n}\nexport { DebugNameData, getDebugName, getFunctionName };\n","import { BaseObservable, _setDerivedOpts } from './base.js';\nimport { DebugNameData } from './debugName.js';\nimport { assertFn } from '../assert.js';\nimport { strictEquals } from '../equals.js';\nimport { onBugIndicatingError } from '../errors.js';\nimport '../event.js';\nimport { DisposableStore } from '../lifecycle.js';\nimport { getLogger } from './logging.js';\nfunction derived(computeFnOrOwner, computeFn) {\n    if (computeFn !== undefined) {\n        return ( new Derived(( new DebugNameData(computeFnOrOwner, undefined, computeFn)), computeFn, undefined, undefined, undefined, strictEquals));\n    }\n    return ( new Derived(( new DebugNameData(undefined, undefined, computeFnOrOwner)), computeFnOrOwner, undefined, undefined, undefined, strictEquals));\n}\nfunction derivedWithSetter(owner, computeFn, setter) {\n    return ( new DerivedWithSetter(( new DebugNameData(owner, undefined, computeFn)), computeFn, undefined, undefined, undefined, strictEquals, setter));\n}\nfunction derivedOpts(options, computeFn) {\n    return ( new Derived(( new DebugNameData(options.owner, options.debugName, options.debugReferenceFn)), computeFn, undefined, undefined, options.onLastObserverRemoved, options.equalsFn ?? strictEquals));\n}\n_setDerivedOpts(derivedOpts);\nfunction derivedHandleChanges(options, computeFn) {\n    return ( new Derived(( new DebugNameData(options.owner, options.debugName, undefined)), computeFn, options.createEmptyChangeSummary, options.handleChange, undefined, options.equalityComparer ?? strictEquals));\n}\nfunction derivedWithStore(computeFnOrOwner, computeFnOrUndefined) {\n    let computeFn;\n    let owner;\n    if (computeFnOrUndefined === undefined) {\n        computeFn = computeFnOrOwner;\n        owner = undefined;\n    }\n    else {\n        owner = computeFnOrOwner;\n        computeFn = computeFnOrUndefined;\n    }\n    const store = ( new DisposableStore());\n    return ( new Derived(( new DebugNameData(owner, undefined, computeFn)), r => {\n        store.clear();\n        return computeFn(r, store);\n    }, undefined, undefined, () => store.dispose(), strictEquals));\n}\nfunction derivedDisposable(computeFnOrOwner, computeFnOrUndefined) {\n    let computeFn;\n    let owner;\n    if (computeFnOrUndefined === undefined) {\n        computeFn = computeFnOrOwner;\n        owner = undefined;\n    }\n    else {\n        owner = computeFnOrOwner;\n        computeFn = computeFnOrUndefined;\n    }\n    let store = undefined;\n    return ( new Derived(( new DebugNameData(owner, undefined, computeFn)), r => {\n        if (!store) {\n            store = ( new DisposableStore());\n        }\n        else {\n            store.clear();\n        }\n        const result = computeFn(r);\n        if (result) {\n            store.add(result);\n        }\n        return result;\n    }, undefined, undefined, () => {\n        if (store) {\n            store.dispose();\n            store = undefined;\n        }\n    }, strictEquals));\n}\nclass Derived extends BaseObservable {\n    get debugName() {\n        return this._debugNameData.getDebugName(this) ?? '(anonymous)';\n    }\n    constructor(_debugNameData, _computeFn, createChangeSummary, _handleChange, _handleLastObserverRemoved = undefined, _equalityComparator) {\n        super();\n        this._debugNameData = _debugNameData;\n        this._computeFn = _computeFn;\n        this.createChangeSummary = createChangeSummary;\n        this._handleChange = _handleChange;\n        this._handleLastObserverRemoved = _handleLastObserverRemoved;\n        this._equalityComparator = _equalityComparator;\n        this.state = 0 ;\n        this.value = undefined;\n        this.updateCount = 0;\n        this.dependencies = ( new Set());\n        this.dependenciesToBeRemoved = ( new Set());\n        this.changeSummary = undefined;\n        this.changeSummary = this.createChangeSummary?.();\n    }\n    onLastObserverRemoved() {\n        this.state = 0 ;\n        this.value = undefined;\n        for (const d of this.dependencies) {\n            d.removeObserver(this);\n        }\n        this.dependencies.clear();\n        this._handleLastObserverRemoved?.();\n    }\n    get() {\n        if (this.observers.size === 0) {\n            const result = this._computeFn(this, this.createChangeSummary?.());\n            this.onLastObserverRemoved();\n            return result;\n        }\n        else {\n            do {\n                if (this.state === 1 ) {\n                    for (const d of this.dependencies) {\n                        d.reportChanges();\n                        if (this.state === 2 ) {\n                            break;\n                        }\n                    }\n                }\n                if (this.state === 1 ) {\n                    this.state = 3 ;\n                }\n                this._recomputeIfNeeded();\n            } while (this.state !== 3 );\n            return this.value;\n        }\n    }\n    _recomputeIfNeeded() {\n        if (this.state === 3 ) {\n            return;\n        }\n        const emptySet = this.dependenciesToBeRemoved;\n        this.dependenciesToBeRemoved = this.dependencies;\n        this.dependencies = emptySet;\n        const hadValue = this.state !== 0 ;\n        const oldValue = this.value;\n        this.state = 3 ;\n        let didChange = false;\n        try {\n            const changeSummary = this.changeSummary;\n            this.changeSummary = this.createChangeSummary?.();\n            try {\n                this.value = this._computeFn(this, changeSummary);\n            }\n            finally {\n                for (const o of this.dependenciesToBeRemoved) {\n                    o.removeObserver(this);\n                }\n                this.dependenciesToBeRemoved.clear();\n            }\n            didChange = hadValue && !(this._equalityComparator(oldValue, this.value));\n            getLogger()?.handleDerivedRecomputed(this, {\n                oldValue,\n                newValue: this.value,\n                change: undefined,\n                didChange,\n                hadValue,\n            });\n        }\n        catch (e) {\n            onBugIndicatingError(e);\n        }\n        if (didChange) {\n            for (const r of this.observers) {\n                r.handleChange(this, undefined);\n            }\n        }\n    }\n    toString() {\n        return `LazyDerived<${this.debugName}>`;\n    }\n    beginUpdate(_observable) {\n        this.updateCount++;\n        const propagateBeginUpdate = this.updateCount === 1;\n        if (this.state === 3 ) {\n            this.state = 1 ;\n            if (!propagateBeginUpdate) {\n                for (const r of this.observers) {\n                    r.handlePossibleChange(this);\n                }\n            }\n        }\n        if (propagateBeginUpdate) {\n            for (const r of this.observers) {\n                r.beginUpdate(this);\n            }\n        }\n    }\n    endUpdate(_observable) {\n        this.updateCount--;\n        if (this.updateCount === 0) {\n            const observers = [...this.observers];\n            for (const r of observers) {\n                r.endUpdate(this);\n            }\n        }\n        assertFn(() => this.updateCount >= 0);\n    }\n    handlePossibleChange(observable) {\n        if (this.state === 3  && ( this.dependencies.has(observable)) && !( this.dependenciesToBeRemoved.has(observable))) {\n            this.state = 1 ;\n            for (const r of this.observers) {\n                r.handlePossibleChange(this);\n            }\n        }\n    }\n    handleChange(observable, change) {\n        if (( this.dependencies.has(observable)) && !( this.dependenciesToBeRemoved.has(observable))) {\n            let shouldReact = false;\n            try {\n                shouldReact = this._handleChange ? this._handleChange({\n                    changedObservable: observable,\n                    change,\n                    didChange: (o) => o === observable,\n                }, this.changeSummary) : true;\n            }\n            catch (e) {\n                onBugIndicatingError(e);\n            }\n            const wasUpToDate = this.state === 3 ;\n            if (shouldReact && (this.state === 1  || wasUpToDate)) {\n                this.state = 2 ;\n                if (wasUpToDate) {\n                    for (const r of this.observers) {\n                        r.handlePossibleChange(this);\n                    }\n                }\n            }\n        }\n    }\n    readObservable(observable) {\n        observable.addObserver(this);\n        const value = observable.get();\n        this.dependencies.add(observable);\n        this.dependenciesToBeRemoved.delete(observable);\n        return value;\n    }\n    addObserver(observer) {\n        const shouldCallBeginUpdate = !( this.observers.has(observer)) && this.updateCount > 0;\n        super.addObserver(observer);\n        if (shouldCallBeginUpdate) {\n            observer.beginUpdate(this);\n        }\n    }\n    removeObserver(observer) {\n        const shouldCallEndUpdate = ( this.observers.has(observer)) && this.updateCount > 0;\n        super.removeObserver(observer);\n        if (shouldCallEndUpdate) {\n            observer.endUpdate(this);\n        }\n    }\n}\nclass DerivedWithSetter extends Derived {\n    constructor(debugNameData, computeFn, createChangeSummary, handleChange, handleLastObserverRemoved = undefined, equalityComparator, set) {\n        super(debugNameData, computeFn, createChangeSummary, handleChange, handleLastObserverRemoved, equalityComparator);\n        this.set = set;\n    }\n}\nexport { Derived, DerivedWithSetter, derived, derivedDisposable, derivedHandleChanges, derivedOpts, derivedWithSetter, derivedWithStore };\n","let globalObservableLogger;\nfunction getLogger() {\n    return globalObservableLogger;\n}\nexport { getLogger };\n","import { autorunWithStoreHandleChanges, autorunOpts } from './autorun.js';\nimport { ConvenientObservable, BaseObservable, subtransaction, transaction, _setKeepObserved, _setRecomputeInitiallyAndOnChange, observableValue } from './base.js';\nimport { DebugNameData, getDebugName } from './debugName.js';\nimport { BugIndicatingError } from '../errors.js';\nimport { strictEquals } from '../equals.js';\nimport { Event } from '../event.js';\nimport { toDisposable, DisposableStore } from '../lifecycle.js';\nimport { derivedOpts, derived } from './derived.js';\nfunction constObservable(value) {\n    return ( new ConstObservable(value));\n}\nclass ConstObservable extends ConvenientObservable {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    get debugName() {\n        return ( this.toString());\n    }\n    get() {\n        return this.value;\n    }\n    addObserver(observer) {\n    }\n    removeObserver(observer) {\n    }\n    toString() {\n        return `Const: ${this.value}`;\n    }\n}\nfunction observableFromPromise(promise) {\n    const observable = observableValue('promiseValue', {});\n    promise.then((value) => {\n        observable.set({ value }, undefined);\n    });\n    return observable;\n}\nfunction observableFromEvent(...args) {\n    let owner;\n    let event;\n    let getValue;\n    if (args.length === 3) {\n        [owner, event, getValue] = args;\n    }\n    else {\n        [event, getValue] = args;\n    }\n    return ( new FromEventObservable(( new DebugNameData(owner, undefined, getValue)), event, getValue, () => FromEventObservable.globalTransaction, strictEquals));\n}\nfunction observableFromEventOpts(options, event, getValue) {\n    return ( new FromEventObservable(( new DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? getValue)), event, getValue, () => FromEventObservable.globalTransaction, options.equalsFn ?? strictEquals));\n}\nclass FromEventObservable extends BaseObservable {\n    constructor(_debugNameData, event, _getValue, _getTransaction, _equalityComparator) {\n        super();\n        this._debugNameData = _debugNameData;\n        this.event = event;\n        this._getValue = _getValue;\n        this._getTransaction = _getTransaction;\n        this._equalityComparator = _equalityComparator;\n        this.hasValue = false;\n        this.handleEvent = (args) => {\n            const newValue = this._getValue(args);\n            const oldValue = this.value;\n            const didChange = !this.hasValue || !(this._equalityComparator(oldValue, newValue));\n            if (didChange) {\n                this.value = newValue;\n                if (this.hasValue) {\n                    subtransaction(this._getTransaction(), (tx) => {\n                        for (const o of this.observers) {\n                            tx.updateObserver(o, this);\n                            o.handleChange(this, undefined);\n                        }\n                    }, () => {\n                        const name = this.getDebugName();\n                        return 'Event fired' + (name ? `: ${name}` : '');\n                    });\n                }\n                this.hasValue = true;\n            }\n        };\n    }\n    getDebugName() {\n        return this._debugNameData.getDebugName(this);\n    }\n    get debugName() {\n        const name = this.getDebugName();\n        return 'From Event' + (name ? `: ${name}` : '');\n    }\n    onFirstObserverAdded() {\n        this.subscription = this.event(this.handleEvent);\n    }\n    onLastObserverRemoved() {\n        this.subscription.dispose();\n        this.subscription = undefined;\n        this.hasValue = false;\n        this.value = undefined;\n    }\n    get() {\n        if (this.subscription) {\n            if (!this.hasValue) {\n                this.handleEvent(undefined);\n            }\n            return this.value;\n        }\n        else {\n            const value = this._getValue(undefined);\n            return value;\n        }\n    }\n}\n( (function(observableFromEvent) {\n    observableFromEvent.Observer = FromEventObservable;\n    function batchEventsGlobally(tx, fn) {\n        let didSet = false;\n        if (FromEventObservable.globalTransaction === undefined) {\n            FromEventObservable.globalTransaction = tx;\n            didSet = true;\n        }\n        try {\n            fn();\n        }\n        finally {\n            if (didSet) {\n                FromEventObservable.globalTransaction = undefined;\n            }\n        }\n    }\n    observableFromEvent.batchEventsGlobally = batchEventsGlobally;\n})(observableFromEvent || (observableFromEvent = {})));\nfunction observableSignalFromEvent(debugName, event) {\n    return ( new FromEventObservableSignal(debugName, event));\n}\nclass FromEventObservableSignal extends BaseObservable {\n    constructor(debugName, event) {\n        super();\n        this.debugName = debugName;\n        this.event = event;\n        this.handleEvent = () => {\n            transaction((tx) => {\n                for (const o of this.observers) {\n                    tx.updateObserver(o, this);\n                    o.handleChange(this, undefined);\n                }\n            }, () => this.debugName);\n        };\n    }\n    onFirstObserverAdded() {\n        this.subscription = this.event(this.handleEvent);\n    }\n    onLastObserverRemoved() {\n        this.subscription.dispose();\n        this.subscription = undefined;\n    }\n    get() {\n    }\n}\nfunction observableSignal(debugNameOrOwner) {\n    if (typeof debugNameOrOwner === 'string') {\n        return ( new ObservableSignal(debugNameOrOwner));\n    }\n    else {\n        return ( new ObservableSignal(undefined, debugNameOrOwner));\n    }\n}\nclass ObservableSignal extends BaseObservable {\n    get debugName() {\n        return ( new DebugNameData(this._owner, this._debugName, undefined)).getDebugName(this) ?? 'Observable Signal';\n    }\n    toString() {\n        return this.debugName;\n    }\n    constructor(_debugName, _owner) {\n        super();\n        this._debugName = _debugName;\n        this._owner = _owner;\n    }\n    trigger(tx, change) {\n        if (!tx) {\n            transaction(tx => {\n                this.trigger(tx, change);\n            }, () => `Trigger signal ${this.debugName}`);\n            return;\n        }\n        for (const o of this.observers) {\n            tx.updateObserver(o, this);\n            o.handleChange(this, change);\n        }\n    }\n    get() {\n    }\n}\nfunction wasEventTriggeredRecently(event, timeoutMs, disposableStore) {\n    const observable = observableValue('triggeredRecently', false);\n    let timeout = undefined;\n    disposableStore.add(event(() => {\n        observable.set(true, undefined);\n        if (timeout) {\n            clearTimeout(timeout);\n        }\n        timeout = setTimeout(() => {\n            observable.set(false, undefined);\n        }, timeoutMs);\n    }));\n    return observable;\n}\nfunction keepObserved(observable) {\n    const o = ( new KeepAliveObserver(false, undefined));\n    observable.addObserver(o);\n    return toDisposable(() => {\n        observable.removeObserver(o);\n    });\n}\n_setKeepObserved(keepObserved);\nfunction recomputeInitiallyAndOnChange(observable, handleValue) {\n    const o = ( new KeepAliveObserver(true, handleValue));\n    observable.addObserver(o);\n    if (handleValue) {\n        handleValue(observable.get());\n    }\n    else {\n        observable.reportChanges();\n    }\n    return toDisposable(() => {\n        observable.removeObserver(o);\n    });\n}\n_setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange);\nclass KeepAliveObserver {\n    constructor(_forceRecompute, _handleValue) {\n        this._forceRecompute = _forceRecompute;\n        this._handleValue = _handleValue;\n        this._counter = 0;\n    }\n    beginUpdate(observable) {\n        this._counter++;\n    }\n    endUpdate(observable) {\n        this._counter--;\n        if (this._counter === 0 && this._forceRecompute) {\n            if (this._handleValue) {\n                this._handleValue(observable.get());\n            }\n            else {\n                observable.reportChanges();\n            }\n        }\n    }\n    handlePossibleChange(observable) {\n    }\n    handleChange(observable, change) {\n    }\n}\nfunction derivedObservableWithCache(owner, computeFn) {\n    let lastValue = undefined;\n    const observable = derivedOpts({ owner, debugReferenceFn: computeFn }, reader => {\n        lastValue = computeFn(reader, lastValue);\n        return lastValue;\n    });\n    return observable;\n}\nfunction derivedObservableWithWritableCache(owner, computeFn) {\n    let lastValue = undefined;\n    const onChange = observableSignal('derivedObservableWithWritableCache');\n    const observable = derived(owner, reader => {\n        onChange.read(reader);\n        lastValue = computeFn(reader, lastValue);\n        return lastValue;\n    });\n    return Object.assign(observable, {\n        clearCache: (tx) => {\n            lastValue = undefined;\n            onChange.trigger(tx);\n        },\n        setCache: (newValue, tx) => {\n            lastValue = newValue;\n            onChange.trigger(tx);\n        }\n    });\n}\nfunction mapObservableArrayCached(owner, items, map, keySelector) {\n    let m = ( new ArrayMap(map, keySelector));\n    const self = derivedOpts({\n        debugReferenceFn: map,\n        owner,\n        onLastObserverRemoved: () => {\n            m.dispose();\n            m = ( new ArrayMap(map));\n        }\n    }, (reader) => {\n        m.setItems(items.read(reader));\n        return m.getItems();\n    });\n    return self;\n}\nclass ArrayMap {\n    constructor(_map, _keySelector) {\n        this._map = _map;\n        this._keySelector = _keySelector;\n        this._cache = ( new Map());\n        this._items = [];\n    }\n    dispose() {\n        this._cache.forEach(entry => entry.store.dispose());\n        this._cache.clear();\n    }\n    setItems(items) {\n        const newItems = [];\n        const itemsToRemove = ( new Set(( this._cache.keys())));\n        for (const item of items) {\n            const key = this._keySelector ? this._keySelector(item) : item;\n            let entry = this._cache.get(key);\n            if (!entry) {\n                const store = ( new DisposableStore());\n                const out = this._map(item, store);\n                entry = { out, store };\n                this._cache.set(key, entry);\n            }\n            else {\n                itemsToRemove.delete(key);\n            }\n            newItems.push(entry.out);\n        }\n        for (const item of itemsToRemove) {\n            const entry = this._cache.get(item);\n            entry.store.dispose();\n            this._cache.delete(item);\n        }\n        this._items = newItems;\n    }\n    getItems() {\n        return this._items;\n    }\n}\nclass ValueWithChangeEventFromObservable {\n    constructor(observable) {\n        this.observable = observable;\n    }\n    get onDidChange() {\n        return Event.fromObservableLight(this.observable);\n    }\n    get value() {\n        return this.observable.get();\n    }\n}\nfunction observableFromValueWithChangeEvent(owner, value) {\n    if (value instanceof ValueWithChangeEventFromObservable) {\n        return value.observable;\n    }\n    return observableFromEvent(owner, value.onDidChange, () => value.value);\n}\nfunction latestChangedValue(owner, observables) {\n    if (observables.length === 0) {\n        throw ( new BugIndicatingError());\n    }\n    let hasLastChangedValue = false;\n    let lastChangedValue = undefined;\n    const result = observableFromEvent(owner, cb => {\n        const store = ( new DisposableStore());\n        for (const o of observables) {\n            store.add(autorunOpts({ debugName: () => getDebugName(result, ( new DebugNameData(owner, undefined, undefined))) + '.updateLastChangedValue' }, reader => {\n                hasLastChangedValue = true;\n                lastChangedValue = o.read(reader);\n                cb();\n            }));\n        }\n        store.add({\n            dispose() {\n                hasLastChangedValue = false;\n                lastChangedValue = undefined;\n            },\n        });\n        return store;\n    }, () => {\n        if (hasLastChangedValue) {\n            return lastChangedValue;\n        }\n        else {\n            return observables[observables.length - 1].get();\n        }\n    });\n    return result;\n}\nfunction derivedConstOnceDefined(owner, fn) {\n    return derivedObservableWithCache(owner, (reader, lastValue) => lastValue ?? fn(reader));\n}\nfunction runOnChange(observable, cb) {\n    let _previousValue;\n    return autorunWithStoreHandleChanges({\n        createEmptyChangeSummary: () => ({ deltas: [], didChange: false }),\n        handleChange: (context, changeSummary) => {\n            if (context.didChange(observable)) {\n                const e = context.change;\n                if (e !== undefined) {\n                    changeSummary.deltas.push(e);\n                }\n                changeSummary.didChange = true;\n            }\n            return true;\n        },\n    }, (reader, changeSummary) => {\n        const value = observable.read(reader);\n        const previousValue = _previousValue;\n        if (changeSummary.didChange) {\n            _previousValue = value;\n            cb(value, previousValue, changeSummary.deltas);\n        }\n    });\n}\nfunction runOnChangeWithStore(observable, cb) {\n    const store = ( new DisposableStore());\n    const disposable = runOnChange(observable, (value, previousValue, deltas) => {\n        store.clear();\n        cb(value, previousValue, deltas, store);\n    });\n    return {\n        dispose() {\n            disposable.dispose();\n            store.dispose();\n        }\n    };\n}\nexport { FromEventObservable, KeepAliveObserver, ValueWithChangeEventFromObservable, constObservable, derivedConstOnceDefined, derivedObservableWithCache, derivedObservableWithWritableCache, keepObserved, latestChangedValue, mapObservableArrayCached, observableFromEvent, observableFromEventOpts, observableFromPromise, observableFromValueWithChangeEvent, observableSignal, observableSignalFromEvent, recomputeInitiallyAndOnChange, runOnChange, runOnChangeWithStore, wasEventTriggeredRecently };\n","import { onUnexpectedError } from './errors.js';\nimport { toDisposable, DisposableStore } from './lifecycle.js';\nfunction isReadableStream(obj) {\n    const candidate = obj;\n    if (!candidate) {\n        return false;\n    }\n    return [candidate.on, candidate.pause, candidate.resume, candidate.destroy].every(fn => typeof fn === 'function');\n}\nfunction isReadableBufferedStream(obj) {\n    const candidate = obj;\n    if (!candidate) {\n        return false;\n    }\n    return isReadableStream(candidate.stream) && Array.isArray(candidate.buffer) && typeof candidate.ended === 'boolean';\n}\nfunction newWriteableStream(reducer, options) {\n    return ( new WriteableStreamImpl(reducer, options));\n}\nclass WriteableStreamImpl {\n    constructor(reducer, options) {\n        this.reducer = reducer;\n        this.options = options;\n        this.state = {\n            flowing: false,\n            ended: false,\n            destroyed: false\n        };\n        this.buffer = {\n            data: [],\n            error: []\n        };\n        this.listeners = {\n            data: [],\n            error: [],\n            end: []\n        };\n        this.pendingWritePromises = [];\n    }\n    pause() {\n        if (this.state.destroyed) {\n            return;\n        }\n        this.state.flowing = false;\n    }\n    resume() {\n        if (this.state.destroyed) {\n            return;\n        }\n        if (!this.state.flowing) {\n            this.state.flowing = true;\n            this.flowData();\n            this.flowErrors();\n            this.flowEnd();\n        }\n    }\n    write(data) {\n        if (this.state.destroyed) {\n            return;\n        }\n        if (this.state.flowing) {\n            this.emitData(data);\n        }\n        else {\n            this.buffer.data.push(data);\n            if (typeof this.options?.highWaterMark === 'number' && this.buffer.data.length > this.options.highWaterMark) {\n                return ( new Promise(resolve => this.pendingWritePromises.push(resolve)));\n            }\n        }\n    }\n    error(error) {\n        if (this.state.destroyed) {\n            return;\n        }\n        if (this.state.flowing) {\n            this.emitError(error);\n        }\n        else {\n            this.buffer.error.push(error);\n        }\n    }\n    end(result) {\n        if (this.state.destroyed) {\n            return;\n        }\n        if (typeof result !== 'undefined') {\n            this.write(result);\n        }\n        if (this.state.flowing) {\n            this.emitEnd();\n            this.destroy();\n        }\n        else {\n            this.state.ended = true;\n        }\n    }\n    emitData(data) {\n        this.listeners.data.slice(0).forEach(listener => listener(data));\n    }\n    emitError(error) {\n        if (this.listeners.error.length === 0) {\n            onUnexpectedError(error);\n        }\n        else {\n            this.listeners.error.slice(0).forEach(listener => listener(error));\n        }\n    }\n    emitEnd() {\n        this.listeners.end.slice(0).forEach(listener => listener());\n    }\n    on(event, callback) {\n        if (this.state.destroyed) {\n            return;\n        }\n        switch (event) {\n            case 'data':\n                this.listeners.data.push(callback);\n                this.resume();\n                break;\n            case 'end':\n                this.listeners.end.push(callback);\n                if (this.state.flowing && this.flowEnd()) {\n                    this.destroy();\n                }\n                break;\n            case 'error':\n                this.listeners.error.push(callback);\n                if (this.state.flowing) {\n                    this.flowErrors();\n                }\n                break;\n        }\n    }\n    removeListener(event, callback) {\n        if (this.state.destroyed) {\n            return;\n        }\n        let listeners = undefined;\n        switch (event) {\n            case 'data':\n                listeners = this.listeners.data;\n                break;\n            case 'end':\n                listeners = this.listeners.end;\n                break;\n            case 'error':\n                listeners = this.listeners.error;\n                break;\n        }\n        if (listeners) {\n            const index = listeners.indexOf(callback);\n            if (index >= 0) {\n                listeners.splice(index, 1);\n            }\n        }\n    }\n    flowData() {\n        if (this.buffer.data.length > 0) {\n            const fullDataBuffer = this.reducer(this.buffer.data);\n            this.emitData(fullDataBuffer);\n            this.buffer.data.length = 0;\n            const pendingWritePromises = [...this.pendingWritePromises];\n            this.pendingWritePromises.length = 0;\n            pendingWritePromises.forEach(pendingWritePromise => pendingWritePromise());\n        }\n    }\n    flowErrors() {\n        if (this.listeners.error.length > 0) {\n            for (const error of this.buffer.error) {\n                this.emitError(error);\n            }\n            this.buffer.error.length = 0;\n        }\n    }\n    flowEnd() {\n        if (this.state.ended) {\n            this.emitEnd();\n            return this.listeners.end.length > 0;\n        }\n        return false;\n    }\n    destroy() {\n        if (!this.state.destroyed) {\n            this.state.destroyed = true;\n            this.state.ended = true;\n            this.buffer.data.length = 0;\n            this.buffer.error.length = 0;\n            this.listeners.data.length = 0;\n            this.listeners.error.length = 0;\n            this.listeners.end.length = 0;\n            this.pendingWritePromises.length = 0;\n        }\n    }\n}\nfunction consumeReadable(readable, reducer) {\n    const chunks = [];\n    let chunk;\n    while ((chunk = readable.read()) !== null) {\n        chunks.push(chunk);\n    }\n    return reducer(chunks);\n}\nfunction peekReadable(readable, reducer, maxChunks) {\n    const chunks = [];\n    let chunk = undefined;\n    while ((chunk = readable.read()) !== null && chunks.length < maxChunks) {\n        chunks.push(chunk);\n    }\n    if (chunk === null && chunks.length > 0) {\n        return reducer(chunks);\n    }\n    return {\n        read: () => {\n            if (chunks.length > 0) {\n                return chunks.shift();\n            }\n            if (typeof chunk !== 'undefined') {\n                const lastReadChunk = chunk;\n                chunk = undefined;\n                return lastReadChunk;\n            }\n            return readable.read();\n        }\n    };\n}\nfunction consumeStream(stream, reducer) {\n    return ( new Promise((resolve, reject) => {\n        const chunks = [];\n        listenStream(stream, {\n            onData: chunk => {\n                if (reducer) {\n                    chunks.push(chunk);\n                }\n            },\n            onError: error => {\n                if (reducer) {\n                    reject(error);\n                }\n                else {\n                    resolve(undefined);\n                }\n            },\n            onEnd: () => {\n                if (reducer) {\n                    resolve(reducer(chunks));\n                }\n                else {\n                    resolve(undefined);\n                }\n            }\n        });\n    }));\n}\nfunction listenStream(stream, listener, token) {\n    stream.on('error', error => {\n        if (!token?.isCancellationRequested) {\n            listener.onError(error);\n        }\n    });\n    stream.on('end', () => {\n        if (!token?.isCancellationRequested) {\n            listener.onEnd();\n        }\n    });\n    stream.on('data', data => {\n        if (!token?.isCancellationRequested) {\n            listener.onData(data);\n        }\n    });\n}\nfunction peekStream(stream, maxChunks) {\n    return ( new Promise((resolve, reject) => {\n        const streamListeners = ( new DisposableStore());\n        const buffer = [];\n        const dataListener = (chunk) => {\n            buffer.push(chunk);\n            if (buffer.length > maxChunks) {\n                streamListeners.dispose();\n                stream.pause();\n                return resolve({ stream, buffer, ended: false });\n            }\n        };\n        const errorListener = (error) => {\n            streamListeners.dispose();\n            return reject(error);\n        };\n        const endListener = () => {\n            streamListeners.dispose();\n            return resolve({ stream, buffer, ended: true });\n        };\n        streamListeners.add(toDisposable(() => stream.removeListener('error', errorListener)));\n        stream.on('error', errorListener);\n        streamListeners.add(toDisposable(() => stream.removeListener('end', endListener)));\n        stream.on('end', endListener);\n        streamListeners.add(toDisposable(() => stream.removeListener('data', dataListener)));\n        stream.on('data', dataListener);\n    }));\n}\nfunction toStream(t, reducer) {\n    const stream = newWriteableStream(reducer);\n    stream.end(t);\n    return stream;\n}\nfunction emptyStream() {\n    const stream = newWriteableStream(() => { throw ( new Error('not supported')); });\n    stream.end();\n    return stream;\n}\nfunction toReadable(t) {\n    let consumed = false;\n    return {\n        read: () => {\n            if (consumed) {\n                return null;\n            }\n            consumed = true;\n            return t;\n        }\n    };\n}\nfunction transform(stream, transformer, reducer) {\n    const target = newWriteableStream(reducer);\n    listenStream(stream, {\n        onData: data => target.write(transformer.data(data)),\n        onError: error => target.error(transformer.error ? transformer.error(error) : error),\n        onEnd: () => target.end()\n    });\n    return target;\n}\nfunction prefixedReadable(prefix, readable, reducer) {\n    let prefixHandled = false;\n    return {\n        read: () => {\n            const chunk = readable.read();\n            if (!prefixHandled) {\n                prefixHandled = true;\n                if (chunk !== null) {\n                    return reducer([prefix, chunk]);\n                }\n                return prefix;\n            }\n            return chunk;\n        }\n    };\n}\nfunction prefixedStream(prefix, stream, reducer) {\n    let prefixHandled = false;\n    const target = newWriteableStream(reducer);\n    listenStream(stream, {\n        onData: data => {\n            if (!prefixHandled) {\n                prefixHandled = true;\n                return target.write(reducer([prefix, data]));\n            }\n            return target.write(data);\n        },\n        onError: error => target.error(error),\n        onEnd: () => {\n            if (!prefixHandled) {\n                prefixHandled = true;\n                target.write(prefix);\n            }\n            target.end();\n        }\n    });\n    return target;\n}\nexport { consumeReadable, consumeStream, emptyStream, isReadableBufferedStream, isReadableStream, listenStream, newWriteableStream, peekReadable, peekStream, prefixedReadable, prefixedStream, toReadable, toStream, transform };\n","function countEOL(text) {\n    let eolCount = 0;\n    let firstLineLength = 0;\n    let lastLineStart = 0;\n    let eol = 0 ;\n    for (let i = 0, len = text.length; i < len; i++) {\n        const chr = text.charCodeAt(i);\n        if (chr === 13 ) {\n            if (eolCount === 0) {\n                firstLineLength = i;\n            }\n            eolCount++;\n            if (i + 1 < len && text.charCodeAt(i + 1) === 10 ) {\n                eol |= 2 ;\n                i++;\n            }\n            else {\n                eol |= 3 ;\n            }\n            lastLineStart = i + 1;\n        }\n        else if (chr === 10 ) {\n            eol |= 1 ;\n            if (eolCount === 0) {\n                firstLineLength = i;\n            }\n            eolCount++;\n            lastLineStart = i + 1;\n        }\n    }\n    if (eolCount === 0) {\n        firstLineLength = text.length;\n    }\n    return [eolCount, firstLineLength, text.length - lastLineStart, eol];\n}\nexport { countEOL };\n"],"names":[],"sourceRoot":""}