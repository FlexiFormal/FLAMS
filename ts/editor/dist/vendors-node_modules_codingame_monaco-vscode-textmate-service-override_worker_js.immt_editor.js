/******/ var __webpack_modules__ = ({

/***/ "./node_modules/@codingame/monaco-vscode-textmate-service-override/vscode/src/vs/workbench/services/textMate/browser/backgroundTokenization/worker/textMateTokenizationWorker.worker.esm.js":
/*!**************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/@codingame/monaco-vscode-textmate-service-override/vscode/src/vs/workbench/services/textMate/browser/backgroundTokenization/worker/textMateTokenizationWorker.worker.esm.js ***!
  \**************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _textMateTokenizationWorker_worker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./textMateTokenizationWorker.worker.js */ "./node_modules/@codingame/monaco-vscode-textmate-service-override/vscode/src/vs/workbench/services/textMate/browser/backgroundTokenization/worker/textMateTokenizationWorker.worker.js");
/* harmony import */ var vscode_vscode_vs_base_common_worker_simpleWorkerBootstrap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vscode/vscode/vs/base/common/worker/simpleWorkerBootstrap */ "./node_modules/vscode/vscode/src/vs/base/common/worker/simpleWorkerBootstrap.js");



(0,vscode_vscode_vs_base_common_worker_simpleWorkerBootstrap__WEBPACK_IMPORTED_MODULE_1__.bootstrapSimpleWorker)(_textMateTokenizationWorker_worker_js__WEBPACK_IMPORTED_MODULE_0__.create);


/***/ }),

/***/ "./node_modules/@codingame/monaco-vscode-textmate-service-override/vscode/src/vs/workbench/services/textMate/browser/backgroundTokenization/worker/textMateTokenizationWorker.worker.js":
/*!**********************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/@codingame/monaco-vscode-textmate-service-override/vscode/src/vs/workbench/services/textMate/browser/backgroundTokenization/worker/textMateTokenizationWorker.worker.js ***!
  \**********************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextMateTokenizationWorker: () => (/* binding */ TextMateTokenizationWorker),
/* harmony export */   create: () => (/* binding */ create)
/* harmony export */ });
/* harmony import */ var vscode_vscode_vs_base_common_uri__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode/vscode/vs/base/common/uri */ "./node_modules/vscode/vscode/src/vs/base/common/uri.js");
/* harmony import */ var _common_TMGrammarFactory_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../common/TMGrammarFactory.js */ "./node_modules/@codingame/monaco-vscode-textmate-service-override/vscode/src/vs/workbench/services/textMate/common/TMGrammarFactory.js");
/* harmony import */ var _textMateWorkerTokenizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./textMateWorkerTokenizer.js */ "./node_modules/@codingame/monaco-vscode-textmate-service-override/vscode/src/vs/workbench/services/textMate/browser/backgroundTokenization/worker/textMateWorkerTokenizer.js");
/* harmony import */ var _textMateWorkerHost_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./textMateWorkerHost.js */ "./node_modules/@codingame/monaco-vscode-textmate-service-override/vscode/src/vs/workbench/services/textMate/browser/backgroundTokenization/worker/textMateWorkerHost.js");





function create(workerServer) {
    return ( new TextMateTokenizationWorker(workerServer));
}
class TextMateTokenizationWorker {
    constructor(workerServer) {
        this._models = ( new Map());
        this._grammarCache = [];
        this._grammarFactory = Promise.resolve(null);
        this._host = _textMateWorkerHost_js__WEBPACK_IMPORTED_MODULE_3__.TextMateWorkerHost.getChannel(workerServer);
    }
    async $init(_createData) {
        const grammarDefinitions = ( _createData.grammarDefinitions.map((def) => {
            return {
                location: vscode_vscode_vs_base_common_uri__WEBPACK_IMPORTED_MODULE_0__.URI.revive(def.location),
                language: def.language,
                scopeName: def.scopeName,
                embeddedLanguages: def.embeddedLanguages,
                tokenTypes: def.tokenTypes,
                injectTo: def.injectTo,
                balancedBracketSelectors: def.balancedBracketSelectors,
                unbalancedBracketSelectors: def.unbalancedBracketSelectors,
                sourceExtensionId: def.sourceExtensionId,
            };
        }));
        this._grammarFactory = this._loadTMGrammarFactory(grammarDefinitions, _createData.onigurumaWASMUri);
    }
    async _loadTMGrammarFactory(grammarDefinitions, onigurumaWASMUri) {
        const vscodeTextmate = await __webpack_require__.e(/*! import() */ "vendors-node_modules_vscode-textmate_release_main_js").then(__webpack_require__.t.bind(__webpack_require__, /*! vscode-textmate */ "./node_modules/vscode-textmate/release/main.js", 19)).then(module => module.default ?? module);
        const vscodeOniguruma = await __webpack_require__.e(/*! import() */ "vendors-node_modules_vscode-oniguruma_release_main_js").then(__webpack_require__.t.bind(__webpack_require__, /*! vscode-oniguruma */ "./node_modules/vscode-oniguruma/release/main.js", 19)).then(module => module.default ?? module);
        const response = await fetch(onigurumaWASMUri);
        const bytes = await response.arrayBuffer();
        await vscodeOniguruma.loadWASM(bytes);
        const onigLib = Promise.resolve({
            createOnigScanner: (sources) => vscodeOniguruma.createOnigScanner(sources),
            createOnigString: (str) => vscodeOniguruma.createOnigString(str)
        });
        return ( new _common_TMGrammarFactory_js__WEBPACK_IMPORTED_MODULE_1__.TMGrammarFactory({
            logTrace: (msg) => { },
            logError: (msg, err) => console.error(msg, err),
            readFile: (resource) => this._host.$readFile(resource)
        }, grammarDefinitions, vscodeTextmate, onigLib));
    }
    $acceptNewModel(data) {
        const uri = vscode_vscode_vs_base_common_uri__WEBPACK_IMPORTED_MODULE_0__.URI.revive(data.uri);
        const that = this;
        this._models.set(data.controllerId, ( new _textMateWorkerTokenizer_js__WEBPACK_IMPORTED_MODULE_2__.TextMateWorkerTokenizer(uri, data.lines, data.EOL, data.versionId, {
            async getOrCreateGrammar(languageId, encodedLanguageId) {
                const grammarFactory = await that._grammarFactory;
                if (!grammarFactory) {
                    return Promise.resolve(null);
                }
                if (!that._grammarCache[encodedLanguageId]) {
                    that._grammarCache[encodedLanguageId] = grammarFactory.createGrammar(languageId, encodedLanguageId);
                }
                return that._grammarCache[encodedLanguageId];
            },
            setTokensAndStates(versionId, tokens, stateDeltas) {
                that._host.$setTokensAndStates(data.controllerId, versionId, tokens, stateDeltas);
            },
            reportTokenizationTime(timeMs, languageId, sourceExtensionId, lineLength, isRandomSample) {
                that._host.$reportTokenizationTime(timeMs, languageId, sourceExtensionId, lineLength, isRandomSample);
            },
        }, data.languageId, data.encodedLanguageId, data.maxTokenizationLineLength)));
    }
    $acceptModelChanged(controllerId, e) {
        this._models.get(controllerId).onEvents(e);
    }
    $retokenize(controllerId, startLineNumber, endLineNumberExclusive) {
        this._models.get(controllerId).retokenize(startLineNumber, endLineNumberExclusive);
    }
    $acceptModelLanguageChanged(controllerId, newLanguageId, newEncodedLanguageId) {
        this._models.get(controllerId).onLanguageId(newLanguageId, newEncodedLanguageId);
    }
    $acceptRemovedModel(controllerId) {
        const model = this._models.get(controllerId);
        if (model) {
            model.dispose();
            this._models.delete(controllerId);
        }
    }
    async $acceptTheme(theme, colorMap) {
        const grammarFactory = await this._grammarFactory;
        grammarFactory?.setTheme(theme, colorMap);
    }
    $acceptMaxTokenizationLineLength(controllerId, value) {
        this._models.get(controllerId).acceptMaxTokenizationLineLength(value);
    }
}




/***/ }),

/***/ "./node_modules/@codingame/monaco-vscode-textmate-service-override/vscode/src/vs/workbench/services/textMate/browser/backgroundTokenization/worker/textMateWorkerTokenizer.js":
/*!************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/@codingame/monaco-vscode-textmate-service-override/vscode/src/vs/workbench/services/textMate/browser/backgroundTokenization/worker/textMateWorkerTokenizer.js ***!
  \************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextMateWorkerTokenizer: () => (/* binding */ TextMateWorkerTokenizer)
/* harmony export */ });
/* harmony import */ var vscode_vscode_vs_base_common_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode/vscode/vs/base/common/async */ "./node_modules/vscode/vscode/src/vs/base/common/async.js");
/* harmony import */ var vscode_vscode_vs_base_common_observableInternal_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vscode/vscode/vs/base/common/observableInternal/base */ "./node_modules/vscode/vscode/src/vs/base/common/observableInternal/base.js");
/* harmony import */ var vscode_vscode_vs_base_common_arrays__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vscode/vscode/vs/base/common/arrays */ "./node_modules/vscode/vscode/src/vs/base/common/arrays.js");
/* harmony import */ var vscode_vscode_vs_base_common_event__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vscode/vscode/vs/base/common/event */ "./node_modules/vscode/vscode/src/vs/base/common/event.js");
/* harmony import */ var vscode_vscode_vs_base_common_lifecycle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vscode/vscode/vs/base/common/lifecycle */ "./node_modules/vscode/vscode/src/vs/base/common/lifecycle.js");
/* harmony import */ var vscode_vscode_vs_base_common_observableInternal_autorun__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vscode/vscode/vs/base/common/observableInternal/autorun */ "./node_modules/vscode/vscode/src/vs/base/common/observableInternal/autorun.js");
/* harmony import */ var vscode_vscode_vs_base_common_observableInternal_derived__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! vscode/vscode/vs/base/common/observableInternal/derived */ "./node_modules/vscode/vscode/src/vs/base/common/observableInternal/derived.js");
/* harmony import */ var vscode_vscode_vs_base_common_cancellation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! vscode/vscode/vs/base/common/cancellation */ "./node_modules/vscode/vscode/src/vs/base/common/cancellation.js");
/* harmony import */ var vscode_vscode_vs_base_common_observableInternal_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! vscode/vscode/vs/base/common/observableInternal/utils */ "./node_modules/vscode/vscode/src/vs/base/common/observableInternal/utils.js");
/* harmony import */ var vscode_vscode_vs_base_common_platform__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! vscode/vscode/vs/base/common/platform */ "./node_modules/vscode/vscode/src/vs/base/common/platform.js");
/* harmony import */ var vscode_vscode_vs_editor_common_core_lineRange__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! vscode/vscode/vs/editor/common/core/lineRange */ "./node_modules/vscode/vscode/src/vs/editor/common/core/lineRange.js");
/* harmony import */ var vscode_vscode_vs_editor_common_model_mirrorTextModel__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! vscode/vscode/vs/editor/common/model/mirrorTextModel */ "./node_modules/vscode/vscode/src/vs/editor/common/model/mirrorTextModel.js");
/* harmony import */ var vscode_vscode_vs_editor_common_model_textModelTokens__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! vscode/vscode/vs/editor/common/model/textModelTokens */ "./node_modules/vscode/vscode/src/vs/editor/common/model/textModelTokens.js");
/* harmony import */ var vscode_vscode_vs_editor_common_tokens_contiguousMultilineTokensBuilder__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! vscode/vscode/vs/editor/common/tokens/contiguousMultilineTokensBuilder */ "./node_modules/vscode/vscode/src/vs/editor/common/tokens/contiguousMultilineTokensBuilder.js");
/* harmony import */ var vscode_vscode_vs_editor_common_tokens_lineTokens__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! vscode/vscode/vs/editor/common/tokens/lineTokens */ "./node_modules/vscode/vscode/src/vs/editor/common/tokens/lineTokens.js");
/* harmony import */ var _tokenizationSupport_textMateTokenizationSupport_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../tokenizationSupport/textMateTokenizationSupport.js */ "./node_modules/@codingame/monaco-vscode-textmate-service-override/vscode/src/vs/workbench/services/textMate/browser/tokenizationSupport/textMateTokenizationSupport.js");
/* harmony import */ var _tokenizationSupport_tokenizationSupportWithLineLimit_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../tokenizationSupport/tokenizationSupportWithLineLimit.js */ "./node_modules/@codingame/monaco-vscode-textmate-service-override/vscode/src/vs/workbench/services/textMate/browser/tokenizationSupport/tokenizationSupportWithLineLimit.js");


















class TextMateWorkerTokenizer extends vscode_vscode_vs_editor_common_model_mirrorTextModel__WEBPACK_IMPORTED_MODULE_11__.MirrorTextModel {
    constructor(uri, lines, eol, versionId, _host, _languageId, _encodedLanguageId, maxTokenizationLineLength) {
        super(uri, lines, eol, versionId);
        this._host = _host;
        this._languageId = _languageId;
        this._encodedLanguageId = _encodedLanguageId;
        this._tokenizerWithStateStore = null;
        this._isDisposed = false;
        this._maxTokenizationLineLength = (0,vscode_vscode_vs_base_common_observableInternal_base__WEBPACK_IMPORTED_MODULE_1__.observableValue)(this, -1);
        this._tokenizeDebouncer = ( new vscode_vscode_vs_base_common_async__WEBPACK_IMPORTED_MODULE_0__.RunOnceScheduler(() => this._tokenize(), 10));
        this._maxTokenizationLineLength.set(maxTokenizationLineLength, undefined);
        this._resetTokenization();
    }
    dispose() {
        this._isDisposed = true;
        super.dispose();
    }
    onLanguageId(languageId, encodedLanguageId) {
        this._languageId = languageId;
        this._encodedLanguageId = encodedLanguageId;
        this._resetTokenization();
    }
    onEvents(e) {
        super.onEvents(e);
        this._tokenizerWithStateStore?.store.acceptChanges(e.changes);
        this._tokenizeDebouncer.schedule();
    }
    acceptMaxTokenizationLineLength(maxTokenizationLineLength) {
        this._maxTokenizationLineLength.set(maxTokenizationLineLength, undefined);
    }
    retokenize(startLineNumber, endLineNumberExclusive) {
        if (this._tokenizerWithStateStore) {
            this._tokenizerWithStateStore.store.invalidateEndStateRange(( new vscode_vscode_vs_editor_common_core_lineRange__WEBPACK_IMPORTED_MODULE_10__.LineRange(startLineNumber, endLineNumberExclusive)));
            this._tokenizeDebouncer.schedule();
        }
    }
    async _resetTokenization() {
        this._tokenizerWithStateStore = null;
        const languageId = this._languageId;
        const encodedLanguageId = this._encodedLanguageId;
        const r = await this._host.getOrCreateGrammar(languageId, encodedLanguageId);
        if (this._isDisposed || languageId !== this._languageId || encodedLanguageId !== this._encodedLanguageId || !r) {
            return;
        }
        if (r.grammar) {
            const tokenizationSupport = ( new _tokenizationSupport_tokenizationSupportWithLineLimit_js__WEBPACK_IMPORTED_MODULE_16__.TokenizationSupportWithLineLimit(this._encodedLanguageId, ( new _tokenizationSupport_textMateTokenizationSupport_js__WEBPACK_IMPORTED_MODULE_15__.TextMateTokenizationSupport(
                r.grammar,
                r.initialState,
                false,
                undefined,
                () => false,
                (timeMs, lineLength, isRandomSample) => {
                    this._host.reportTokenizationTime(timeMs, languageId, r.sourceExtensionId, lineLength, isRandomSample);
                },
                false
            )), vscode_vscode_vs_base_common_lifecycle__WEBPACK_IMPORTED_MODULE_4__.Disposable.None, this._maxTokenizationLineLength));
            this._tokenizerWithStateStore = ( new vscode_vscode_vs_editor_common_model_textModelTokens__WEBPACK_IMPORTED_MODULE_12__.TokenizerWithStateStore(this._lines.length, tokenizationSupport));
        }
        else {
            this._tokenizerWithStateStore = null;
        }
        this._tokenize();
    }
    async _tokenize() {
        if (this._isDisposed || !this._tokenizerWithStateStore) {
            return;
        }
        if (!this._diffStateStacksRefEqFn) {
            const { diffStateStacksRefEq } = await __webpack_require__.e(/*! import() */ "vendors-node_modules_vscode-textmate_release_main_js").then(__webpack_require__.t.bind(__webpack_require__, /*! vscode-textmate */ "./node_modules/vscode-textmate/release/main.js", 19)).then(module => module.default ?? module);
            this._diffStateStacksRefEqFn = diffStateStacksRefEq;
        }
        const startTime = ( new Date()).getTime();
        while (true) {
            let tokenizedLines = 0;
            const tokenBuilder = ( new vscode_vscode_vs_editor_common_tokens_contiguousMultilineTokensBuilder__WEBPACK_IMPORTED_MODULE_13__.ContiguousMultilineTokensBuilder());
            const stateDeltaBuilder = ( new StateDeltaBuilder());
            while (true) {
                const lineToTokenize = this._tokenizerWithStateStore.getFirstInvalidLine();
                if (lineToTokenize === null || tokenizedLines > 200) {
                    break;
                }
                tokenizedLines++;
                const text = this._lines[lineToTokenize.lineNumber - 1];
                const r = this._tokenizerWithStateStore.tokenizationSupport.tokenizeEncoded(text, true, lineToTokenize.startState);
                if (this._tokenizerWithStateStore.store.setEndState(lineToTokenize.lineNumber, r.endState)) {
                    const delta = this._diffStateStacksRefEqFn(lineToTokenize.startState, r.endState);
                    stateDeltaBuilder.setState(lineToTokenize.lineNumber, delta);
                }
                else {
                    stateDeltaBuilder.setState(lineToTokenize.lineNumber, null);
                }
                vscode_vscode_vs_editor_common_tokens_lineTokens__WEBPACK_IMPORTED_MODULE_14__.LineTokens.convertToEndOffset(r.tokens, text.length);
                tokenBuilder.add(lineToTokenize.lineNumber, r.tokens);
                const deltaMs = ( new Date()).getTime() - startTime;
                if (deltaMs > 20) {
                    break;
                }
            }
            if (tokenizedLines === 0) {
                break;
            }
            const stateDeltas = stateDeltaBuilder.getStateDeltas();
            this._host.setTokensAndStates(this._versionId, tokenBuilder.serialize(), stateDeltas);
            const deltaMs = ( new Date()).getTime() - startTime;
            if (deltaMs > 20) {
                (0,vscode_vscode_vs_base_common_platform__WEBPACK_IMPORTED_MODULE_9__.setTimeout0)(() => this._tokenize());
                return;
            }
        }
    }
}
class StateDeltaBuilder {
    constructor() {
        this._lastStartLineNumber = -1;
        this._stateDeltas = [];
    }
    setState(lineNumber, stackDiff) {
        if (lineNumber === this._lastStartLineNumber + 1) {
            this._stateDeltas[this._stateDeltas.length - 1].stateDeltas.push(stackDiff);
        }
        else {
            this._stateDeltas.push({ startLineNumber: lineNumber, stateDeltas: [stackDiff] });
        }
        this._lastStartLineNumber = lineNumber;
    }
    getStateDeltas() {
        return this._stateDeltas;
    }
}




/***/ }),

/***/ "./node_modules/@codingame/monaco-vscode-textmate-service-override/worker.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@codingame/monaco-vscode-textmate-service-override/worker.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _workers_textmate_worker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./workers/textmate.worker.js */ "./node_modules/@codingame/monaco-vscode-textmate-service-override/workers/textmate.worker.js");



/***/ }),

/***/ "./node_modules/@codingame/monaco-vscode-textmate-service-override/workers/textmate.worker.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@codingame/monaco-vscode-textmate-service-override/workers/textmate.worker.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _vscode_src_vs_workbench_services_textMate_browser_backgroundTokenization_worker_textMateTokenizationWorker_worker_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../vscode/src/vs/workbench/services/textMate/browser/backgroundTokenization/worker/textMateTokenizationWorker.worker.esm.js */ "./node_modules/@codingame/monaco-vscode-textmate-service-override/vscode/src/vs/workbench/services/textMate/browser/backgroundTokenization/worker/textMateTokenizationWorker.worker.esm.js");



/***/ }),

/***/ "./node_modules/vscode/vscode/src/vs/base/common/worker/simpleWorkerBootstrap.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/vscode/vscode/src/vs/base/common/worker/simpleWorkerBootstrap.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bootstrapSimpleWorker: () => (/* binding */ bootstrapSimpleWorker)
/* harmony export */ });
/* harmony import */ var _simpleWorker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./simpleWorker.js */ "./node_modules/vscode/vscode/src/vs/base/common/worker/simpleWorker.js");

let initialized = false;
function initialize(factory) {
    if (initialized) {
        return;
    }
    initialized = true;
    const simpleWorker = ( new _simpleWorker_js__WEBPACK_IMPORTED_MODULE_0__.SimpleWorkerServer(
        msg => globalThis.postMessage(msg),
        (workerServer) => factory(workerServer)
    ));
    globalThis.onmessage = (e) => {
        simpleWorker.onmessage(e.data);
    };
}
function bootstrapSimpleWorker(factory) {
    globalThis.onmessage = (_e) => {
        if (!initialized) {
            initialize(factory);
        }
    };
}



/***/ }),

/***/ "./node_modules/vscode/vscode/src/vs/editor/common/encodedTokenAttributes.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/vscode/vscode/src/vs/editor/common/encodedTokenAttributes.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TokenMetadata: () => (/* binding */ TokenMetadata)
/* harmony export */ });
class TokenMetadata {
    static getLanguageId(metadata) {
        return ((metadata & 255) ) >>> 0 ;
    }
    static getTokenType(metadata) {
        return ((metadata & 768) ) >>> 8 ;
    }
    static containsBalancedBrackets(metadata) {
        return ((metadata & 1024) ) !== 0;
    }
    static getFontStyle(metadata) {
        return ((metadata & 30720) ) >>> 11 ;
    }
    static getForeground(metadata) {
        return ((metadata & 16744448) ) >>> 15 ;
    }
    static getBackground(metadata) {
        return ((metadata & 4278190080) ) >>> 24 ;
    }
    static getClassNameFromMetadata(metadata) {
        const foreground = this.getForeground(metadata);
        let className = 'mtk' + foreground;
        const fontStyle = this.getFontStyle(metadata);
        if (fontStyle & 1 ) {
            className += ' mtki';
        }
        if (fontStyle & 2 ) {
            className += ' mtkb';
        }
        if (fontStyle & 4 ) {
            className += ' mtku';
        }
        if (fontStyle & 8 ) {
            className += ' mtks';
        }
        return className;
    }
    static getInlineStyleFromMetadata(metadata, colorMap) {
        const foreground = this.getForeground(metadata);
        const fontStyle = this.getFontStyle(metadata);
        let result = `color: ${colorMap[foreground]};`;
        if (fontStyle & 1 ) {
            result += 'font-style: italic;';
        }
        if (fontStyle & 2 ) {
            result += 'font-weight: bold;';
        }
        let textDecoration = '';
        if (fontStyle & 4 ) {
            textDecoration += ' underline';
        }
        if (fontStyle & 8 ) {
            textDecoration += ' line-through';
        }
        if (textDecoration) {
            result += `text-decoration:${textDecoration};`;
        }
        return result;
    }
    static getPresentationFromMetadata(metadata) {
        const foreground = this.getForeground(metadata);
        const fontStyle = this.getFontStyle(metadata);
        return {
            foreground: foreground,
            italic: Boolean(fontStyle & 1 ),
            bold: Boolean(fontStyle & 2 ),
            underline: Boolean(fontStyle & 4 ),
            strikethrough: Boolean(fontStyle & 8 ),
        };
    }
}



/***/ }),

/***/ "./node_modules/vscode/vscode/src/vs/editor/common/languages/nullTokenize.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/vscode/vscode/src/vs/editor/common/languages/nullTokenize.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NullState: () => (/* binding */ NullState),
/* harmony export */   nullTokenize: () => (/* binding */ nullTokenize),
/* harmony export */   nullTokenizeEncoded: () => (/* binding */ nullTokenizeEncoded)
/* harmony export */ });
/* harmony import */ var _languages_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../languages.js */ "./node_modules/vscode/vscode/src/vs/editor/common/languages.js");

const NullState = new class {
    clone() {
        return this;
    }
    equals(other) {
        return (this === other);
    }
};
function nullTokenize(languageId, state) {
    return ( new _languages_js__WEBPACK_IMPORTED_MODULE_0__.TokenizationResult([( new _languages_js__WEBPACK_IMPORTED_MODULE_0__.Token(0, '', languageId))], state));
}
function nullTokenizeEncoded(languageId, state) {
    const tokens = ( new Uint32Array(2));
    tokens[0] = 0;
    tokens[1] = (((languageId << 0) )
        | ((0  << 8) )
        | ((0  << 11) )
        | ((1  << 15) )
        | ((2  << 24) )) >>> 0;
    return ( new _languages_js__WEBPACK_IMPORTED_MODULE_0__.EncodedTokenizationResult(tokens, state === null ? NullState : state));
}



/***/ }),

/***/ "./node_modules/vscode/vscode/src/vs/editor/common/model/fixedArray.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/vscode/vscode/src/vs/editor/common/model/fixedArray.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FixedArray: () => (/* binding */ FixedArray)
/* harmony export */ });
/* harmony import */ var _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/arrays.js */ "./node_modules/vscode/vscode/src/vs/base/common/arrays.js");

class FixedArray {
    constructor(_default) {
        this._default = _default;
        this._store = [];
    }
    get(index) {
        if (index < this._store.length) {
            return this._store[index];
        }
        return this._default;
    }
    set(index, value) {
        while (index >= this._store.length) {
            this._store[this._store.length] = this._default;
        }
        this._store[index] = value;
    }
    replace(index, oldLength, newLength) {
        if (index >= this._store.length) {
            return;
        }
        if (oldLength === 0) {
            this.insert(index, newLength);
            return;
        }
        else if (newLength === 0) {
            this.delete(index, oldLength);
            return;
        }
        const before = this._store.slice(0, index);
        const after = this._store.slice(index + oldLength);
        const insertArr = arrayFill(newLength, this._default);
        this._store = before.concat(insertArr, after);
    }
    delete(deleteIndex, deleteCount) {
        if (deleteCount === 0 || deleteIndex >= this._store.length) {
            return;
        }
        this._store.splice(deleteIndex, deleteCount);
    }
    insert(insertIndex, insertCount) {
        if (insertCount === 0 || insertIndex >= this._store.length) {
            return;
        }
        const arr = [];
        for (let i = 0; i < insertCount; i++) {
            arr[i] = this._default;
        }
        this._store = (0,_base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__.arrayInsert)(this._store, insertIndex, arr);
    }
}
function arrayFill(length, value) {
    const arr = [];
    for (let i = 0; i < length; i++) {
        arr[i] = value;
    }
    return arr;
}



/***/ }),

/***/ "./node_modules/vscode/vscode/src/vs/editor/common/model/textModelTokens.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/vscode/vscode/src/vs/editor/common/model/textModelTokens.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefaultBackgroundTokenizer: () => (/* binding */ DefaultBackgroundTokenizer),
/* harmony export */   RangePriorityQueueImpl: () => (/* binding */ RangePriorityQueueImpl),
/* harmony export */   TokenizationStateStore: () => (/* binding */ TokenizationStateStore),
/* harmony export */   TokenizerWithStateStore: () => (/* binding */ TokenizerWithStateStore),
/* harmony export */   TokenizerWithStateStoreAndTextModel: () => (/* binding */ TokenizerWithStateStoreAndTextModel),
/* harmony export */   TrackingTokenizationStateStore: () => (/* binding */ TrackingTokenizationStateStore)
/* harmony export */ });
/* harmony import */ var _base_common_async_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/async.js */ "./node_modules/vscode/vscode/src/vs/base/common/async.js");
/* harmony import */ var _base_common_errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../base/common/errors.js */ "./node_modules/vscode/vscode/src/vs/base/common/errors.js");
/* harmony import */ var _base_common_platform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../base/common/platform.js */ "./node_modules/vscode/vscode/src/vs/base/common/platform.js");
/* harmony import */ var _base_common_stopwatch_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../base/common/stopwatch.js */ "./node_modules/vscode/vscode/src/vs/base/common/stopwatch.js");
/* harmony import */ var _core_eolCounter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/eolCounter.js */ "./node_modules/vscode/vscode/src/vs/editor/common/core/eolCounter.js");
/* harmony import */ var _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/lineRange.js */ "./node_modules/vscode/vscode/src/vs/editor/common/core/lineRange.js");
/* harmony import */ var _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/offsetRange.js */ "./node_modules/vscode/vscode/src/vs/editor/common/core/offsetRange.js");
/* harmony import */ var _languages_nullTokenize_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../languages/nullTokenize.js */ "./node_modules/vscode/vscode/src/vs/editor/common/languages/nullTokenize.js");
/* harmony import */ var _fixedArray_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./fixedArray.js */ "./node_modules/vscode/vscode/src/vs/editor/common/model/fixedArray.js");
/* harmony import */ var _tokens_contiguousMultilineTokensBuilder_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../tokens/contiguousMultilineTokensBuilder.js */ "./node_modules/vscode/vscode/src/vs/editor/common/tokens/contiguousMultilineTokensBuilder.js");
/* harmony import */ var _tokens_lineTokens_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../tokens/lineTokens.js */ "./node_modules/vscode/vscode/src/vs/editor/common/tokens/lineTokens.js");











class TokenizerWithStateStore {
    constructor(lineCount, tokenizationSupport) {
        this.tokenizationSupport = tokenizationSupport;
        this.initialState = this.tokenizationSupport.getInitialState();
        this.store = ( new TrackingTokenizationStateStore(lineCount));
    }
    getStartState(lineNumber) {
        return this.store.getStartState(lineNumber, this.initialState);
    }
    getFirstInvalidLine() {
        return this.store.getFirstInvalidLine(this.initialState);
    }
}
class TokenizerWithStateStoreAndTextModel extends TokenizerWithStateStore {
    constructor(lineCount, tokenizationSupport, _textModel, _languageIdCodec) {
        super(lineCount, tokenizationSupport);
        this._textModel = _textModel;
        this._languageIdCodec = _languageIdCodec;
    }
    updateTokensUntilLine(builder, lineNumber) {
        const languageId = this._textModel.getLanguageId();
        while (true) {
            const lineToTokenize = this.getFirstInvalidLine();
            if (!lineToTokenize || lineToTokenize.lineNumber > lineNumber) {
                break;
            }
            const text = this._textModel.getLineContent(lineToTokenize.lineNumber);
            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineToTokenize.startState);
            builder.add(lineToTokenize.lineNumber, r.tokens);
            this.store.setEndState(lineToTokenize.lineNumber, r.endState);
        }
    }
    getTokenTypeIfInsertingCharacter(position, character) {
        const lineStartState = this.getStartState(position.lineNumber);
        if (!lineStartState) {
            return 0 ;
        }
        const languageId = this._textModel.getLanguageId();
        const lineContent = this._textModel.getLineContent(position.lineNumber);
        const text = (lineContent.substring(0, position.column - 1)
            + character
            + lineContent.substring(position.column - 1));
        const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineStartState);
        const lineTokens = ( new _tokens_lineTokens_js__WEBPACK_IMPORTED_MODULE_10__.LineTokens(r.tokens, text, this._languageIdCodec));
        if (lineTokens.getCount() === 0) {
            return 0 ;
        }
        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
        return lineTokens.getStandardTokenType(tokenIndex);
    }
    tokenizeLineWithEdit(lineNumber, edit) {
        const lineStartState = this.getStartState(lineNumber);
        if (!lineStartState) {
            return { mainLineTokens: null, additionalLines: null };
        }
        const curLineContent = this._textModel.getLineContent(lineNumber);
        const newLineContent = edit.lineEdit.apply(curLineContent);
        const languageId = this._textModel.getLanguageIdAtPosition(lineNumber, 0);
        const result = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, newLineContent, true, lineStartState);
        let additionalLines = null;
        if (edit.additionalLines) {
            additionalLines = [];
            let state = result.endState;
            for (const line of edit.additionalLines) {
                const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, line, true, state);
                additionalLines.push(( new _tokens_lineTokens_js__WEBPACK_IMPORTED_MODULE_10__.LineTokens(r.tokens, line, this._languageIdCodec)));
                state = r.endState;
            }
        }
        const mainLineTokens = ( new _tokens_lineTokens_js__WEBPACK_IMPORTED_MODULE_10__.LineTokens(result.tokens, newLineContent, this._languageIdCodec));
        return { mainLineTokens, additionalLines };
    }
    hasAccurateTokensForLine(lineNumber) {
        const firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();
        return (lineNumber < firstInvalidLineNumber);
    }
    isCheapToTokenize(lineNumber) {
        const firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();
        if (lineNumber < firstInvalidLineNumber) {
            return true;
        }
        if (lineNumber === firstInvalidLineNumber
            && this._textModel.getLineLength(lineNumber) < 2048 ) {
            return true;
        }
        return false;
    }
    tokenizeHeuristically(builder, startLineNumber, endLineNumber) {
        if (endLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {
            return { heuristicTokens: false };
        }
        if (startLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {
            this.updateTokensUntilLine(builder, endLineNumber);
            return { heuristicTokens: false };
        }
        let state = this.guessStartState(startLineNumber);
        const languageId = this._textModel.getLanguageId();
        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
            const text = this._textModel.getLineContent(lineNumber);
            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, state);
            builder.add(lineNumber, r.tokens);
            state = r.endState;
        }
        return { heuristicTokens: true };
    }
    guessStartState(lineNumber) {
        let nonWhitespaceColumn = this._textModel.getLineFirstNonWhitespaceColumn(lineNumber);
        const likelyRelevantLines = [];
        let initialState = null;
        for (let i = lineNumber - 1; nonWhitespaceColumn > 1 && i >= 1; i--) {
            const newNonWhitespaceIndex = this._textModel.getLineFirstNonWhitespaceColumn(i);
            if (newNonWhitespaceIndex === 0) {
                continue;
            }
            if (newNonWhitespaceIndex < nonWhitespaceColumn) {
                likelyRelevantLines.push(this._textModel.getLineContent(i));
                nonWhitespaceColumn = newNonWhitespaceIndex;
                initialState = this.getStartState(i);
                if (initialState) {
                    break;
                }
            }
        }
        if (!initialState) {
            initialState = this.tokenizationSupport.getInitialState();
        }
        likelyRelevantLines.reverse();
        const languageId = this._textModel.getLanguageId();
        let state = initialState;
        for (const line of likelyRelevantLines) {
            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, line, false, state);
            state = r.endState;
        }
        return state;
    }
}
class TrackingTokenizationStateStore {
    constructor(lineCount) {
        this.lineCount = lineCount;
        this._tokenizationStateStore = ( new TokenizationStateStore());
        this._invalidEndStatesLineNumbers = ( new RangePriorityQueueImpl());
        this._invalidEndStatesLineNumbers.addRange(( new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_6__.OffsetRange(1, lineCount + 1)));
    }
    getEndState(lineNumber) {
        return this._tokenizationStateStore.getEndState(lineNumber);
    }
    setEndState(lineNumber, state) {
        if (!state) {
            throw ( new _base_common_errors_js__WEBPACK_IMPORTED_MODULE_1__.BugIndicatingError('Cannot set null/undefined state'));
        }
        this._invalidEndStatesLineNumbers.delete(lineNumber);
        const r = this._tokenizationStateStore.setEndState(lineNumber, state);
        if (r && lineNumber < this.lineCount) {
            this._invalidEndStatesLineNumbers.addRange(( new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_6__.OffsetRange(lineNumber + 1, lineNumber + 2)));
        }
        return r;
    }
    acceptChange(range, newLineCount) {
        this.lineCount += newLineCount - range.length;
        this._tokenizationStateStore.acceptChange(range, newLineCount);
        this._invalidEndStatesLineNumbers.addRangeAndResize(( new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_6__.OffsetRange(range.startLineNumber, range.endLineNumberExclusive)), newLineCount);
    }
    acceptChanges(changes) {
        for (const c of changes) {
            const [eolCount] = (0,_core_eolCounter_js__WEBPACK_IMPORTED_MODULE_4__.countEOL)(c.text);
            this.acceptChange(( new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__.LineRange(c.range.startLineNumber, c.range.endLineNumber + 1)), eolCount + 1);
        }
    }
    invalidateEndStateRange(range) {
        this._invalidEndStatesLineNumbers.addRange(( new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_6__.OffsetRange(range.startLineNumber, range.endLineNumberExclusive)));
    }
    getFirstInvalidEndStateLineNumber() { return this._invalidEndStatesLineNumbers.min; }
    getFirstInvalidEndStateLineNumberOrMax() {
        return this.getFirstInvalidEndStateLineNumber() || Number.MAX_SAFE_INTEGER;
    }
    allStatesValid() { return this._invalidEndStatesLineNumbers.min === null; }
    getStartState(lineNumber, initialState) {
        if (lineNumber === 1) {
            return initialState;
        }
        return this.getEndState(lineNumber - 1);
    }
    getFirstInvalidLine(initialState) {
        const lineNumber = this.getFirstInvalidEndStateLineNumber();
        if (lineNumber === null) {
            return null;
        }
        const startState = this.getStartState(lineNumber, initialState);
        if (!startState) {
            throw ( new _base_common_errors_js__WEBPACK_IMPORTED_MODULE_1__.BugIndicatingError('Start state must be defined'));
        }
        return { lineNumber, startState };
    }
}
class TokenizationStateStore {
    constructor() {
        this._lineEndStates = ( new _fixedArray_js__WEBPACK_IMPORTED_MODULE_8__.FixedArray(null));
    }
    getEndState(lineNumber) {
        return this._lineEndStates.get(lineNumber);
    }
    setEndState(lineNumber, state) {
        const oldState = this._lineEndStates.get(lineNumber);
        if (oldState && oldState.equals(state)) {
            return false;
        }
        this._lineEndStates.set(lineNumber, state);
        return true;
    }
    acceptChange(range, newLineCount) {
        let length = range.length;
        if (newLineCount > 0 && length > 0) {
            length--;
            newLineCount--;
        }
        this._lineEndStates.replace(range.startLineNumber, length, newLineCount);
    }
    acceptChanges(changes) {
        for (const c of changes) {
            const [eolCount] = (0,_core_eolCounter_js__WEBPACK_IMPORTED_MODULE_4__.countEOL)(c.text);
            this.acceptChange(( new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__.LineRange(c.range.startLineNumber, c.range.endLineNumber + 1)), eolCount + 1);
        }
    }
}
class RangePriorityQueueImpl {
    constructor() {
        this._ranges = [];
    }
    getRanges() {
        return this._ranges;
    }
    get min() {
        if (this._ranges.length === 0) {
            return null;
        }
        return this._ranges[0].start;
    }
    removeMin() {
        if (this._ranges.length === 0) {
            return null;
        }
        const range = this._ranges[0];
        if (range.start + 1 === range.endExclusive) {
            this._ranges.shift();
        }
        else {
            this._ranges[0] = ( new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_6__.OffsetRange(range.start + 1, range.endExclusive));
        }
        return range.start;
    }
    delete(value) {
        const idx = this._ranges.findIndex(r => r.contains(value));
        if (idx !== -1) {
            const range = this._ranges[idx];
            if (range.start === value) {
                if (range.endExclusive === value + 1) {
                    this._ranges.splice(idx, 1);
                }
                else {
                    this._ranges[idx] = ( new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_6__.OffsetRange(value + 1, range.endExclusive));
                }
            }
            else {
                if (range.endExclusive === value + 1) {
                    this._ranges[idx] = ( new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_6__.OffsetRange(range.start, value));
                }
                else {
                    this._ranges.splice(idx, 1, ( new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_6__.OffsetRange(range.start, value)), ( new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_6__.OffsetRange(value + 1, range.endExclusive)));
                }
            }
        }
    }
    addRange(range) {
        _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_6__.OffsetRange.addRange(range, this._ranges);
    }
    addRangeAndResize(range, newLength) {
        let idxFirstMightBeIntersecting = 0;
        while (!(idxFirstMightBeIntersecting >= this._ranges.length || range.start <= this._ranges[idxFirstMightBeIntersecting].endExclusive)) {
            idxFirstMightBeIntersecting++;
        }
        let idxFirstIsAfter = idxFirstMightBeIntersecting;
        while (!(idxFirstIsAfter >= this._ranges.length || range.endExclusive < this._ranges[idxFirstIsAfter].start)) {
            idxFirstIsAfter++;
        }
        const delta = newLength - range.length;
        for (let i = idxFirstIsAfter; i < this._ranges.length; i++) {
            this._ranges[i] = this._ranges[i].delta(delta);
        }
        if (idxFirstMightBeIntersecting === idxFirstIsAfter) {
            const newRange = ( new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_6__.OffsetRange(range.start, range.start + newLength));
            if (!newRange.isEmpty) {
                this._ranges.splice(idxFirstMightBeIntersecting, 0, newRange);
            }
        }
        else {
            const start = Math.min(range.start, this._ranges[idxFirstMightBeIntersecting].start);
            const endEx = Math.max(range.endExclusive, this._ranges[idxFirstIsAfter - 1].endExclusive);
            const newRange = ( new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_6__.OffsetRange(start, endEx + delta));
            if (!newRange.isEmpty) {
                this._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting, newRange);
            }
            else {
                this._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting);
            }
        }
    }
    toString() {
        return ( this._ranges.map(r => ( r.toString()))).join(' + ');
    }
}
function safeTokenize(languageIdCodec, languageId, tokenizationSupport, text, hasEOL, state) {
    let r = null;
    if (tokenizationSupport) {
        try {
            r = tokenizationSupport.tokenizeEncoded(text, hasEOL, state.clone());
        }
        catch (e) {
            (0,_base_common_errors_js__WEBPACK_IMPORTED_MODULE_1__.onUnexpectedError)(e);
        }
    }
    if (!r) {
        r = (0,_languages_nullTokenize_js__WEBPACK_IMPORTED_MODULE_7__.nullTokenizeEncoded)(languageIdCodec.encodeLanguageId(languageId), state);
    }
    _tokens_lineTokens_js__WEBPACK_IMPORTED_MODULE_10__.LineTokens.convertToEndOffset(r.tokens, text.length);
    return r;
}
class DefaultBackgroundTokenizer {
    constructor(_tokenizerWithStateStore, _backgroundTokenStore) {
        this._tokenizerWithStateStore = _tokenizerWithStateStore;
        this._backgroundTokenStore = _backgroundTokenStore;
        this._isDisposed = false;
        this._isScheduled = false;
    }
    dispose() {
        this._isDisposed = true;
    }
    handleChanges() {
        this._beginBackgroundTokenization();
    }
    _beginBackgroundTokenization() {
        if (this._isScheduled || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {
            return;
        }
        this._isScheduled = true;
        (0,_base_common_async_js__WEBPACK_IMPORTED_MODULE_0__.runWhenGlobalIdle)((deadline) => {
            this._isScheduled = false;
            this._backgroundTokenizeWithDeadline(deadline);
        });
    }
    _backgroundTokenizeWithDeadline(deadline) {
        const endTime = Date.now() + deadline.timeRemaining();
        const execute = () => {
            if (this._isDisposed || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {
                return;
            }
            this._backgroundTokenizeForAtLeast1ms();
            if (Date.now() < endTime) {
                (0,_base_common_platform_js__WEBPACK_IMPORTED_MODULE_2__.setTimeout0)(execute);
            }
            else {
                this._beginBackgroundTokenization();
            }
        };
        execute();
    }
    _backgroundTokenizeForAtLeast1ms() {
        const lineCount = this._tokenizerWithStateStore._textModel.getLineCount();
        const builder = ( new _tokens_contiguousMultilineTokensBuilder_js__WEBPACK_IMPORTED_MODULE_9__.ContiguousMultilineTokensBuilder());
        const sw = _base_common_stopwatch_js__WEBPACK_IMPORTED_MODULE_3__.StopWatch.create(false);
        do {
            if (sw.elapsed() > 1) {
                break;
            }
            const tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);
            if (tokenizedLineNumber >= lineCount) {
                break;
            }
        } while (this._hasLinesToTokenize());
        this._backgroundTokenStore.setTokens(builder.finalize());
        this.checkFinished();
    }
    _hasLinesToTokenize() {
        if (!this._tokenizerWithStateStore) {
            return false;
        }
        return !this._tokenizerWithStateStore.store.allStatesValid();
    }
    _tokenizeOneInvalidLine(builder) {
        const firstInvalidLine = this._tokenizerWithStateStore?.getFirstInvalidLine();
        if (!firstInvalidLine) {
            return this._tokenizerWithStateStore._textModel.getLineCount() + 1;
        }
        this._tokenizerWithStateStore.updateTokensUntilLine(builder, firstInvalidLine.lineNumber);
        return firstInvalidLine.lineNumber;
    }
    checkFinished() {
        if (this._isDisposed) {
            return;
        }
        if (this._tokenizerWithStateStore.store.allStatesValid()) {
            this._backgroundTokenStore.backgroundTokenizationFinished();
        }
    }
    requestTokens(startLineNumber, endLineNumberExclusive) {
        this._tokenizerWithStateStore.store.invalidateEndStateRange(( new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__.LineRange(startLineNumber, endLineNumberExclusive)));
    }
}



/***/ }),

/***/ "./node_modules/vscode/vscode/src/vs/editor/common/tokens/contiguousMultilineTokens.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/vscode/vscode/src/vs/editor/common/tokens/contiguousMultilineTokens.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ContiguousMultilineTokens: () => (/* binding */ ContiguousMultilineTokens)
/* harmony export */ });
/* harmony import */ var _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/arrays.js */ "./node_modules/vscode/vscode/src/vs/base/common/arrays.js");
/* harmony import */ var _base_common_buffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../base/common/buffer.js */ "./node_modules/vscode/vscode/src/vs/base/common/buffer.js");
/* harmony import */ var _core_position_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/position.js */ "./node_modules/vscode/vscode/src/vs/editor/common/core/position.js");
/* harmony import */ var _core_eolCounter_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/eolCounter.js */ "./node_modules/vscode/vscode/src/vs/editor/common/core/eolCounter.js");
/* harmony import */ var _contiguousTokensEditing_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./contiguousTokensEditing.js */ "./node_modules/vscode/vscode/src/vs/editor/common/tokens/contiguousTokensEditing.js");
/* harmony import */ var _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/lineRange.js */ "./node_modules/vscode/vscode/src/vs/editor/common/core/lineRange.js");






class ContiguousMultilineTokens {
    static deserialize(buff, offset, result) {
        const view32 = ( new Uint32Array(buff.buffer));
        const startLineNumber = (0,_base_common_buffer_js__WEBPACK_IMPORTED_MODULE_1__.readUInt32BE)(buff, offset);
        offset += 4;
        const count = (0,_base_common_buffer_js__WEBPACK_IMPORTED_MODULE_1__.readUInt32BE)(buff, offset);
        offset += 4;
        const tokens = [];
        for (let i = 0; i < count; i++) {
            const byteCount = (0,_base_common_buffer_js__WEBPACK_IMPORTED_MODULE_1__.readUInt32BE)(buff, offset);
            offset += 4;
            tokens.push(view32.subarray(offset / 4, offset / 4 + byteCount / 4));
            offset += byteCount;
        }
        result.push(( new ContiguousMultilineTokens(startLineNumber, tokens)));
        return offset;
    }
    get startLineNumber() {
        return this._startLineNumber;
    }
    get endLineNumber() {
        return this._startLineNumber + this._tokens.length - 1;
    }
    constructor(startLineNumber, tokens) {
        this._startLineNumber = startLineNumber;
        this._tokens = tokens;
    }
    getLineRange() {
        return ( new _core_lineRange_js__WEBPACK_IMPORTED_MODULE_5__.LineRange(this._startLineNumber, this._startLineNumber + this._tokens.length));
    }
    getLineTokens(lineNumber) {
        return this._tokens[lineNumber - this._startLineNumber];
    }
    appendLineTokens(lineTokens) {
        this._tokens.push(lineTokens);
    }
    serializeSize() {
        let result = 0;
        result += 4;
        result += 4;
        for (let i = 0; i < this._tokens.length; i++) {
            const lineTokens = this._tokens[i];
            if (!(lineTokens instanceof Uint32Array)) {
                throw ( new Error(`Not supported!`));
            }
            result += 4;
            result += lineTokens.byteLength;
        }
        return result;
    }
    serialize(destination, offset) {
        (0,_base_common_buffer_js__WEBPACK_IMPORTED_MODULE_1__.writeUInt32BE)(destination, this._startLineNumber, offset);
        offset += 4;
        (0,_base_common_buffer_js__WEBPACK_IMPORTED_MODULE_1__.writeUInt32BE)(destination, this._tokens.length, offset);
        offset += 4;
        for (let i = 0; i < this._tokens.length; i++) {
            const lineTokens = this._tokens[i];
            if (!(lineTokens instanceof Uint32Array)) {
                throw ( new Error(`Not supported!`));
            }
            (0,_base_common_buffer_js__WEBPACK_IMPORTED_MODULE_1__.writeUInt32BE)(destination, lineTokens.byteLength, offset);
            offset += 4;
            destination.set(( new Uint8Array(lineTokens.buffer)), offset);
            offset += lineTokens.byteLength;
        }
        return offset;
    }
    applyEdit(range, text) {
        const [eolCount, firstLineLength] = (0,_core_eolCounter_js__WEBPACK_IMPORTED_MODULE_3__.countEOL)(text);
        this._acceptDeleteRange(range);
        this._acceptInsertText(( new _core_position_js__WEBPACK_IMPORTED_MODULE_2__.Position(range.startLineNumber, range.startColumn)), eolCount, firstLineLength);
    }
    _acceptDeleteRange(range) {
        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {
            return;
        }
        const firstLineIndex = range.startLineNumber - this._startLineNumber;
        const lastLineIndex = range.endLineNumber - this._startLineNumber;
        if (lastLineIndex < 0) {
            const deletedLinesCount = lastLineIndex - firstLineIndex;
            this._startLineNumber -= deletedLinesCount;
            return;
        }
        if (firstLineIndex >= this._tokens.length) {
            return;
        }
        if (firstLineIndex < 0 && lastLineIndex >= this._tokens.length) {
            this._startLineNumber = 0;
            this._tokens = [];
            return;
        }
        if (firstLineIndex === lastLineIndex) {
            this._tokens[firstLineIndex] = _contiguousTokensEditing_js__WEBPACK_IMPORTED_MODULE_4__.ContiguousTokensEditing.delete(this._tokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);
            return;
        }
        if (firstLineIndex >= 0) {
            this._tokens[firstLineIndex] = _contiguousTokensEditing_js__WEBPACK_IMPORTED_MODULE_4__.ContiguousTokensEditing.deleteEnding(this._tokens[firstLineIndex], range.startColumn - 1);
            if (lastLineIndex < this._tokens.length) {
                const lastLineTokens = _contiguousTokensEditing_js__WEBPACK_IMPORTED_MODULE_4__.ContiguousTokensEditing.deleteBeginning(this._tokens[lastLineIndex], range.endColumn - 1);
                this._tokens[firstLineIndex] = _contiguousTokensEditing_js__WEBPACK_IMPORTED_MODULE_4__.ContiguousTokensEditing.append(this._tokens[firstLineIndex], lastLineTokens);
                this._tokens.splice(firstLineIndex + 1, lastLineIndex - firstLineIndex);
            }
            else {
                this._tokens[firstLineIndex] = _contiguousTokensEditing_js__WEBPACK_IMPORTED_MODULE_4__.ContiguousTokensEditing.append(this._tokens[firstLineIndex], null);
                this._tokens = this._tokens.slice(0, firstLineIndex + 1);
            }
        }
        else {
            const deletedBefore = -firstLineIndex;
            this._startLineNumber -= deletedBefore;
            this._tokens[lastLineIndex] = _contiguousTokensEditing_js__WEBPACK_IMPORTED_MODULE_4__.ContiguousTokensEditing.deleteBeginning(this._tokens[lastLineIndex], range.endColumn - 1);
            this._tokens = this._tokens.slice(lastLineIndex);
        }
    }
    _acceptInsertText(position, eolCount, firstLineLength) {
        if (eolCount === 0 && firstLineLength === 0) {
            return;
        }
        const lineIndex = position.lineNumber - this._startLineNumber;
        if (lineIndex < 0) {
            this._startLineNumber += eolCount;
            return;
        }
        if (lineIndex >= this._tokens.length) {
            return;
        }
        if (eolCount === 0) {
            this._tokens[lineIndex] = _contiguousTokensEditing_js__WEBPACK_IMPORTED_MODULE_4__.ContiguousTokensEditing.insert(this._tokens[lineIndex], position.column - 1, firstLineLength);
            return;
        }
        this._tokens[lineIndex] = _contiguousTokensEditing_js__WEBPACK_IMPORTED_MODULE_4__.ContiguousTokensEditing.deleteEnding(this._tokens[lineIndex], position.column - 1);
        this._tokens[lineIndex] = _contiguousTokensEditing_js__WEBPACK_IMPORTED_MODULE_4__.ContiguousTokensEditing.insert(this._tokens[lineIndex], position.column - 1, firstLineLength);
        this._insertLines(position.lineNumber, eolCount);
    }
    _insertLines(insertIndex, insertCount) {
        if (insertCount === 0) {
            return;
        }
        const lineTokens = [];
        for (let i = 0; i < insertCount; i++) {
            lineTokens[i] = null;
        }
        this._tokens = (0,_base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__.arrayInsert)(this._tokens, insertIndex, lineTokens);
    }
}



/***/ }),

/***/ "./node_modules/vscode/vscode/src/vs/editor/common/tokens/contiguousMultilineTokensBuilder.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/vscode/vscode/src/vs/editor/common/tokens/contiguousMultilineTokensBuilder.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ContiguousMultilineTokensBuilder: () => (/* binding */ ContiguousMultilineTokensBuilder)
/* harmony export */ });
/* harmony import */ var _base_common_buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/buffer.js */ "./node_modules/vscode/vscode/src/vs/base/common/buffer.js");
/* harmony import */ var _contiguousMultilineTokens_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./contiguousMultilineTokens.js */ "./node_modules/vscode/vscode/src/vs/editor/common/tokens/contiguousMultilineTokens.js");


class ContiguousMultilineTokensBuilder {
    static deserialize(buff) {
        let offset = 0;
        const count = (0,_base_common_buffer_js__WEBPACK_IMPORTED_MODULE_0__.readUInt32BE)(buff, offset);
        offset += 4;
        const result = [];
        for (let i = 0; i < count; i++) {
            offset = _contiguousMultilineTokens_js__WEBPACK_IMPORTED_MODULE_1__.ContiguousMultilineTokens.deserialize(buff, offset, result);
        }
        return result;
    }
    constructor() {
        this._tokens = [];
    }
    add(lineNumber, lineTokens) {
        if (this._tokens.length > 0) {
            const last = this._tokens[this._tokens.length - 1];
            if (last.endLineNumber + 1 === lineNumber) {
                last.appendLineTokens(lineTokens);
                return;
            }
        }
        this._tokens.push(( new _contiguousMultilineTokens_js__WEBPACK_IMPORTED_MODULE_1__.ContiguousMultilineTokens(lineNumber, [lineTokens])));
    }
    finalize() {
        return this._tokens;
    }
    serialize() {
        const size = this._serializeSize();
        const result = ( new Uint8Array(size));
        this._serialize(result);
        return result;
    }
    _serializeSize() {
        let result = 0;
        result += 4;
        for (let i = 0; i < this._tokens.length; i++) {
            result += this._tokens[i].serializeSize();
        }
        return result;
    }
    _serialize(destination) {
        let offset = 0;
        (0,_base_common_buffer_js__WEBPACK_IMPORTED_MODULE_0__.writeUInt32BE)(destination, this._tokens.length, offset);
        offset += 4;
        for (let i = 0; i < this._tokens.length; i++) {
            offset = this._tokens[i].serialize(destination, offset);
        }
    }
}



/***/ }),

/***/ "./node_modules/vscode/vscode/src/vs/editor/common/tokens/contiguousTokensEditing.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/vscode/vscode/src/vs/editor/common/tokens/contiguousTokensEditing.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ContiguousTokensEditing: () => (/* binding */ ContiguousTokensEditing),
/* harmony export */   EMPTY_LINE_TOKENS: () => (/* binding */ EMPTY_LINE_TOKENS),
/* harmony export */   toUint32Array: () => (/* binding */ toUint32Array)
/* harmony export */ });
/* harmony import */ var _lineTokens_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lineTokens.js */ "./node_modules/vscode/vscode/src/vs/editor/common/tokens/lineTokens.js");

const EMPTY_LINE_TOKENS = (( new Uint32Array(0))).buffer;
class ContiguousTokensEditing {
    static deleteBeginning(lineTokens, toChIndex) {
        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {
            return lineTokens;
        }
        return ContiguousTokensEditing.delete(lineTokens, 0, toChIndex);
    }
    static deleteEnding(lineTokens, fromChIndex) {
        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {
            return lineTokens;
        }
        const tokens = toUint32Array(lineTokens);
        const lineTextLength = tokens[tokens.length - 2];
        return ContiguousTokensEditing.delete(lineTokens, fromChIndex, lineTextLength);
    }
    static delete(lineTokens, fromChIndex, toChIndex) {
        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {
            return lineTokens;
        }
        const tokens = toUint32Array(lineTokens);
        const tokensCount = (tokens.length >>> 1);
        if (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {
            return EMPTY_LINE_TOKENS;
        }
        const fromTokenIndex = _lineTokens_js__WEBPACK_IMPORTED_MODULE_0__.LineTokens.findIndexInTokensArray(tokens, fromChIndex);
        const fromTokenStartOffset = (fromTokenIndex > 0 ? tokens[(fromTokenIndex - 1) << 1] : 0);
        const fromTokenEndOffset = tokens[fromTokenIndex << 1];
        if (toChIndex < fromTokenEndOffset) {
            const delta = (toChIndex - fromChIndex);
            for (let i = fromTokenIndex; i < tokensCount; i++) {
                tokens[i << 1] -= delta;
            }
            return lineTokens;
        }
        let dest;
        let lastEnd;
        if (fromTokenStartOffset !== fromChIndex) {
            tokens[fromTokenIndex << 1] = fromChIndex;
            dest = ((fromTokenIndex + 1) << 1);
            lastEnd = fromChIndex;
        }
        else {
            dest = (fromTokenIndex << 1);
            lastEnd = fromTokenStartOffset;
        }
        const delta = (toChIndex - fromChIndex);
        for (let tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {
            const tokenEndOffset = tokens[tokenIndex << 1] - delta;
            if (tokenEndOffset > lastEnd) {
                tokens[dest++] = tokenEndOffset;
                tokens[dest++] = tokens[(tokenIndex << 1) + 1];
                lastEnd = tokenEndOffset;
            }
        }
        if (dest === tokens.length) {
            return lineTokens;
        }
        const tmp = ( new Uint32Array(dest));
        tmp.set(tokens.subarray(0, dest), 0);
        return tmp.buffer;
    }
    static append(lineTokens, _otherTokens) {
        if (_otherTokens === EMPTY_LINE_TOKENS) {
            return lineTokens;
        }
        if (lineTokens === EMPTY_LINE_TOKENS) {
            return _otherTokens;
        }
        if (lineTokens === null) {
            return lineTokens;
        }
        if (_otherTokens === null) {
            return null;
        }
        const myTokens = toUint32Array(lineTokens);
        const otherTokens = toUint32Array(_otherTokens);
        const otherTokensCount = (otherTokens.length >>> 1);
        const result = ( new Uint32Array(myTokens.length + otherTokens.length));
        result.set(myTokens, 0);
        let dest = myTokens.length;
        const delta = myTokens[myTokens.length - 2];
        for (let i = 0; i < otherTokensCount; i++) {
            result[dest++] = otherTokens[(i << 1)] + delta;
            result[dest++] = otherTokens[(i << 1) + 1];
        }
        return result.buffer;
    }
    static insert(lineTokens, chIndex, textLength) {
        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {
            return lineTokens;
        }
        const tokens = toUint32Array(lineTokens);
        const tokensCount = (tokens.length >>> 1);
        let fromTokenIndex = _lineTokens_js__WEBPACK_IMPORTED_MODULE_0__.LineTokens.findIndexInTokensArray(tokens, chIndex);
        if (fromTokenIndex > 0) {
            const fromTokenStartOffset = tokens[(fromTokenIndex - 1) << 1];
            if (fromTokenStartOffset === chIndex) {
                fromTokenIndex--;
            }
        }
        for (let tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {
            tokens[tokenIndex << 1] += textLength;
        }
        return lineTokens;
    }
}
function toUint32Array(arr) {
    if (arr instanceof Uint32Array) {
        return arr;
    }
    else {
        return ( new Uint32Array(arr));
    }
}



/***/ }),

/***/ "./node_modules/vscode/vscode/src/vs/editor/common/tokens/lineTokens.js":
/*!******************************************************************************!*\
  !*** ./node_modules/vscode/vscode/src/vs/editor/common/tokens/lineTokens.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LineTokens: () => (/* binding */ LineTokens),
/* harmony export */   getStandardTokenTypeAtPosition: () => (/* binding */ getStandardTokenTypeAtPosition)
/* harmony export */ });
/* harmony import */ var _encodedTokenAttributes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../encodedTokenAttributes.js */ "./node_modules/vscode/vscode/src/vs/editor/common/encodedTokenAttributes.js");
/* harmony import */ var _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/offsetRange.js */ "./node_modules/vscode/vscode/src/vs/editor/common/core/offsetRange.js");
/* harmony import */ var _tokenArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tokenArray.js */ "./node_modules/vscode/vscode/src/vs/editor/common/tokens/tokenArray.js");



class LineTokens {
    static createEmpty(lineContent, decoder) {
        const defaultMetadata = LineTokens.defaultTokenMetadata;
        const tokens = ( new Uint32Array(2));
        tokens[0] = lineContent.length;
        tokens[1] = defaultMetadata;
        return ( new LineTokens(tokens, lineContent, decoder));
    }
    static createFromTextAndMetadata(data, decoder) {
        let offset = 0;
        let fullText = '';
        const tokens = ( new Array());
        for (const { text, metadata } of data) {
            tokens.push(offset + text.length, metadata);
            offset += text.length;
            fullText += text;
        }
        return ( new LineTokens(( new Uint32Array(tokens)), fullText, decoder));
    }
    static convertToEndOffset(tokens, lineTextLength) {
        const tokenCount = (tokens.length >>> 1);
        const lastTokenIndex = tokenCount - 1;
        for (let tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {
            tokens[tokenIndex << 1] = tokens[(tokenIndex + 1) << 1];
        }
        tokens[lastTokenIndex << 1] = lineTextLength;
    }
    static findIndexInTokensArray(tokens, desiredIndex) {
        if (tokens.length <= 2) {
            return 0;
        }
        let low = 0;
        let high = (tokens.length >>> 1) - 1;
        while (low < high) {
            const mid = low + Math.floor((high - low) / 2);
            const endOffset = tokens[(mid << 1)];
            if (endOffset === desiredIndex) {
                return mid + 1;
            }
            else if (endOffset < desiredIndex) {
                low = mid + 1;
            }
            else if (endOffset > desiredIndex) {
                high = mid;
            }
        }
        return low;
    }
    static { this.defaultTokenMetadata = (((0  << 11) )
        | ((1  << 15) )
        | ((2  << 24) )) >>> 0; }
    constructor(tokens, text, decoder) {
        this._lineTokensBrand = undefined;
        this._tokens = tokens;
        this._tokensCount = (this._tokens.length >>> 1);
        this._text = text;
        this.languageIdCodec = decoder;
    }
    equals(other) {
        if (other instanceof LineTokens) {
            return this.slicedEquals(other, 0, this._tokensCount);
        }
        return false;
    }
    slicedEquals(other, sliceFromTokenIndex, sliceTokenCount) {
        if (this._text !== other._text) {
            return false;
        }
        if (this._tokensCount !== other._tokensCount) {
            return false;
        }
        const from = (sliceFromTokenIndex << 1);
        const to = from + (sliceTokenCount << 1);
        for (let i = from; i < to; i++) {
            if (this._tokens[i] !== other._tokens[i]) {
                return false;
            }
        }
        return true;
    }
    getLineContent() {
        return this._text;
    }
    getCount() {
        return this._tokensCount;
    }
    getStartOffset(tokenIndex) {
        if (tokenIndex > 0) {
            return this._tokens[(tokenIndex - 1) << 1];
        }
        return 0;
    }
    getMetadata(tokenIndex) {
        const metadata = this._tokens[(tokenIndex << 1) + 1];
        return metadata;
    }
    getLanguageId(tokenIndex) {
        const metadata = this._tokens[(tokenIndex << 1) + 1];
        const languageId = _encodedTokenAttributes_js__WEBPACK_IMPORTED_MODULE_0__.TokenMetadata.getLanguageId(metadata);
        return this.languageIdCodec.decodeLanguageId(languageId);
    }
    getStandardTokenType(tokenIndex) {
        const metadata = this._tokens[(tokenIndex << 1) + 1];
        return _encodedTokenAttributes_js__WEBPACK_IMPORTED_MODULE_0__.TokenMetadata.getTokenType(metadata);
    }
    getForeground(tokenIndex) {
        const metadata = this._tokens[(tokenIndex << 1) + 1];
        return _encodedTokenAttributes_js__WEBPACK_IMPORTED_MODULE_0__.TokenMetadata.getForeground(metadata);
    }
    getClassName(tokenIndex) {
        const metadata = this._tokens[(tokenIndex << 1) + 1];
        return _encodedTokenAttributes_js__WEBPACK_IMPORTED_MODULE_0__.TokenMetadata.getClassNameFromMetadata(metadata);
    }
    getInlineStyle(tokenIndex, colorMap) {
        const metadata = this._tokens[(tokenIndex << 1) + 1];
        return _encodedTokenAttributes_js__WEBPACK_IMPORTED_MODULE_0__.TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);
    }
    getPresentation(tokenIndex) {
        const metadata = this._tokens[(tokenIndex << 1) + 1];
        return _encodedTokenAttributes_js__WEBPACK_IMPORTED_MODULE_0__.TokenMetadata.getPresentationFromMetadata(metadata);
    }
    getEndOffset(tokenIndex) {
        return this._tokens[tokenIndex << 1];
    }
    findTokenIndexAtOffset(offset) {
        return LineTokens.findIndexInTokensArray(this._tokens, offset);
    }
    inflate() {
        return this;
    }
    sliceAndInflate(startOffset, endOffset, deltaOffset) {
        return ( new SliceLineTokens(this, startOffset, endOffset, deltaOffset));
    }
    withInserted(insertTokens) {
        if (insertTokens.length === 0) {
            return this;
        }
        let nextOriginalTokenIdx = 0;
        let nextInsertTokenIdx = 0;
        let text = '';
        const newTokens = ( new Array());
        let originalEndOffset = 0;
        while (true) {
            const nextOriginalTokenEndOffset = nextOriginalTokenIdx < this._tokensCount ? this._tokens[nextOriginalTokenIdx << 1] : -1;
            const nextInsertToken = nextInsertTokenIdx < insertTokens.length ? insertTokens[nextInsertTokenIdx] : null;
            if (nextOriginalTokenEndOffset !== -1 && (nextInsertToken === null || nextOriginalTokenEndOffset <= nextInsertToken.offset)) {
                text += this._text.substring(originalEndOffset, nextOriginalTokenEndOffset);
                const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];
                newTokens.push(text.length, metadata);
                nextOriginalTokenIdx++;
                originalEndOffset = nextOriginalTokenEndOffset;
            }
            else if (nextInsertToken) {
                if (nextInsertToken.offset > originalEndOffset) {
                    text += this._text.substring(originalEndOffset, nextInsertToken.offset);
                    const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];
                    newTokens.push(text.length, metadata);
                    originalEndOffset = nextInsertToken.offset;
                }
                text += nextInsertToken.text;
                newTokens.push(text.length, nextInsertToken.tokenMetadata);
                nextInsertTokenIdx++;
            }
            else {
                break;
            }
        }
        return ( new LineTokens(( new Uint32Array(newTokens)), text, this.languageIdCodec));
    }
    getTokensInRange(range) {
        const builder = ( new _tokenArray_js__WEBPACK_IMPORTED_MODULE_2__.TokenArrayBuilder());
        const startTokenIndex = this.findTokenIndexAtOffset(range.start);
        const endTokenIndex = this.findTokenIndexAtOffset(range.endExclusive);
        for (let tokenIndex = startTokenIndex; tokenIndex <= endTokenIndex; tokenIndex++) {
            const tokenRange = ( new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_1__.OffsetRange(this.getStartOffset(tokenIndex), this.getEndOffset(tokenIndex)));
            const length = tokenRange.intersectionLength(range);
            if (length > 0) {
                builder.add(length, this.getMetadata(tokenIndex));
            }
        }
        return builder.build();
    }
    getTokenText(tokenIndex) {
        const startOffset = this.getStartOffset(tokenIndex);
        const endOffset = this.getEndOffset(tokenIndex);
        const text = this._text.substring(startOffset, endOffset);
        return text;
    }
    forEach(callback) {
        const tokenCount = this.getCount();
        for (let tokenIndex = 0; tokenIndex < tokenCount; tokenIndex++) {
            callback(tokenIndex);
        }
    }
}
class SliceLineTokens {
    constructor(source, startOffset, endOffset, deltaOffset) {
        this._source = source;
        this._startOffset = startOffset;
        this._endOffset = endOffset;
        this._deltaOffset = deltaOffset;
        this._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);
        this.languageIdCodec = source.languageIdCodec;
        this._tokensCount = 0;
        for (let i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {
            const tokenStartOffset = source.getStartOffset(i);
            if (tokenStartOffset >= endOffset) {
                break;
            }
            this._tokensCount++;
        }
    }
    getMetadata(tokenIndex) {
        return this._source.getMetadata(this._firstTokenIndex + tokenIndex);
    }
    getLanguageId(tokenIndex) {
        return this._source.getLanguageId(this._firstTokenIndex + tokenIndex);
    }
    getLineContent() {
        return this._source.getLineContent().substring(this._startOffset, this._endOffset);
    }
    equals(other) {
        if (other instanceof SliceLineTokens) {
            return (this._startOffset === other._startOffset
                && this._endOffset === other._endOffset
                && this._deltaOffset === other._deltaOffset
                && this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount));
        }
        return false;
    }
    getCount() {
        return this._tokensCount;
    }
    getStandardTokenType(tokenIndex) {
        return this._source.getStandardTokenType(this._firstTokenIndex + tokenIndex);
    }
    getForeground(tokenIndex) {
        return this._source.getForeground(this._firstTokenIndex + tokenIndex);
    }
    getEndOffset(tokenIndex) {
        const tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);
        return Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;
    }
    getClassName(tokenIndex) {
        return this._source.getClassName(this._firstTokenIndex + tokenIndex);
    }
    getInlineStyle(tokenIndex, colorMap) {
        return this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);
    }
    getPresentation(tokenIndex) {
        return this._source.getPresentation(this._firstTokenIndex + tokenIndex);
    }
    findTokenIndexAtOffset(offset) {
        return this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;
    }
    getTokenText(tokenIndex) {
        const adjustedTokenIndex = this._firstTokenIndex + tokenIndex;
        const tokenStartOffset = this._source.getStartOffset(adjustedTokenIndex);
        const tokenEndOffset = this._source.getEndOffset(adjustedTokenIndex);
        let text = this._source.getTokenText(adjustedTokenIndex);
        if (tokenStartOffset < this._startOffset) {
            text = text.substring(this._startOffset - tokenStartOffset);
        }
        if (tokenEndOffset > this._endOffset) {
            text = text.substring(0, text.length - (tokenEndOffset - this._endOffset));
        }
        return text;
    }
    forEach(callback) {
        for (let tokenIndex = 0; tokenIndex < this.getCount(); tokenIndex++) {
            callback(tokenIndex);
        }
    }
}
function getStandardTokenTypeAtPosition(model, position) {
    const lineNumber = position.lineNumber;
    if (!model.tokenization.isCheapToTokenize(lineNumber)) {
        return undefined;
    }
    model.tokenization.forceTokenization(lineNumber);
    const lineTokens = model.tokenization.getLineTokens(lineNumber);
    const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);
    const tokenType = lineTokens.getStandardTokenType(tokenIndex);
    return tokenType;
}



/***/ }),

/***/ "./node_modules/vscode/vscode/src/vs/editor/common/tokens/tokenArray.js":
/*!******************************************************************************!*\
  !*** ./node_modules/vscode/vscode/src/vs/editor/common/tokens/tokenArray.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TokenArray: () => (/* binding */ TokenArray),
/* harmony export */   TokenArrayBuilder: () => (/* binding */ TokenArrayBuilder),
/* harmony export */   TokenInfo: () => (/* binding */ TokenInfo)
/* harmony export */ });
/* harmony import */ var _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/offsetRange.js */ "./node_modules/vscode/vscode/src/vs/editor/common/core/offsetRange.js");

class TokenArray {
    static create(tokenInfo) {
        return ( new TokenArray(tokenInfo));
    }
    constructor(_tokenInfo) {
        this._tokenInfo = _tokenInfo;
    }
    forEach(cb) {
        let lengthSum = 0;
        for (const tokenInfo of this._tokenInfo) {
            const range = ( new _core_offsetRange_js__WEBPACK_IMPORTED_MODULE_0__.OffsetRange(lengthSum, lengthSum + tokenInfo.length));
            cb(range, tokenInfo);
            lengthSum += tokenInfo.length;
        }
    }
    slice(range) {
        const result = [];
        let lengthSum = 0;
        for (const tokenInfo of this._tokenInfo) {
            const tokenStart = lengthSum;
            const tokenEndEx = tokenStart + tokenInfo.length;
            if (tokenEndEx > range.start) {
                if (tokenStart >= range.endExclusive) {
                    break;
                }
                const deltaBefore = Math.max(0, range.start - tokenStart);
                const deltaAfter = Math.max(0, tokenEndEx - range.endExclusive);
                result.push(( new TokenInfo(tokenInfo.length - deltaBefore - deltaAfter, tokenInfo.metadata)));
            }
            lengthSum += tokenInfo.length;
        }
        return TokenArray.create(result);
    }
}
class TokenInfo {
    constructor(length, metadata) {
        this.length = length;
        this.metadata = metadata;
    }
}
class TokenArrayBuilder {
    constructor() {
        this._tokens = [];
    }
    add(length, metadata) {
        this._tokens.push(( new TokenInfo(length, metadata)));
    }
    build() {
        return TokenArray.create(this._tokens);
    }
}



/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/******/ // expose the modules object (__webpack_modules__)
/******/ __webpack_require__.m = __webpack_modules__;
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/chunk loaded */
/******/ (() => {
/******/ 	var deferred = [];
/******/ 	__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 		if(chunkIds) {
/******/ 			priority = priority || 0;
/******/ 			for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 			deferred[i] = [chunkIds, fn, priority];
/******/ 			return;
/******/ 		}
/******/ 		var notFulfilled = Infinity;
/******/ 		for (var i = 0; i < deferred.length; i++) {
/******/ 			var [chunkIds, fn, priority] = deferred[i];
/******/ 			var fulfilled = true;
/******/ 			for (var j = 0; j < chunkIds.length; j++) {
/******/ 				if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 					chunkIds.splice(j--, 1);
/******/ 				} else {
/******/ 					fulfilled = false;
/******/ 					if(priority < notFulfilled) notFulfilled = priority;
/******/ 				}
/******/ 			}
/******/ 			if(fulfilled) {
/******/ 				deferred.splice(i--, 1)
/******/ 				var r = fn();
/******/ 				if (r !== undefined) result = r;
/******/ 			}
/******/ 		}
/******/ 		return result;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/create fake namespace object */
/******/ (() => {
/******/ 	var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 	var leafPrototypes;
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 16: return value when it's Promise-like
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = this(value);
/******/ 		if(mode & 8) return value;
/******/ 		if(typeof value === 'object' && value) {
/******/ 			if((mode & 4) && value.__esModule) return value;
/******/ 			if((mode & 16) && typeof value.then === 'function') return value;
/******/ 		}
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		var def = {};
/******/ 		leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 		for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 			Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 		}
/******/ 		def['default'] = () => (value);
/******/ 		__webpack_require__.d(ns, def);
/******/ 		return ns;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/ensure chunk */
/******/ (() => {
/******/ 	__webpack_require__.f = {};
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = (chunkId) => {
/******/ 		return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 			__webpack_require__.f[key](chunkId, promises);
/******/ 			return promises;
/******/ 		}, []));
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/get javascript chunk filename */
/******/ (() => {
/******/ 	// This function allow to reference async chunks
/******/ 	__webpack_require__.u = (chunkId) => {
/******/ 		// return url for filenames based on template
/******/ 		return "" + chunkId + ".immt_editor.js";
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/import chunk loading */
/******/ (() => {
/******/ 	// no baseURI
/******/ 	
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// [resolve, Promise] = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"vendors-node_modules_codingame_monaco-vscode-textmate-service-override_worker_js": 0
/******/ 	};
/******/ 	
/******/ 	var installChunk = (data) => {
/******/ 		var {ids, modules, runtime} = data;
/******/ 		// add "modules" to the modules object,
/******/ 		// then flag all "ids" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0;
/******/ 		for(moduleId in modules) {
/******/ 			if(__webpack_require__.o(modules, moduleId)) {
/******/ 				__webpack_require__.m[moduleId] = modules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(runtime) runtime(__webpack_require__);
/******/ 		for(;i < ids.length; i++) {
/******/ 			chunkId = ids[i];
/******/ 			if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 				installedChunks[chunkId][0]();
/******/ 			}
/******/ 			installedChunks[ids[i]] = 0;
/******/ 		}
/******/ 		__webpack_require__.O();
/******/ 	}
/******/ 	
/******/ 	__webpack_require__.f.j = (chunkId, promises) => {
/******/ 			// import() chunk loading for javascript
/******/ 			var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 			if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 	
/******/ 				// a Promise means "currently loading".
/******/ 				if(installedChunkData) {
/******/ 					promises.push(installedChunkData[1]);
/******/ 				} else {
/******/ 					if(true) { // all chunks have JS
/******/ 						// setup Promise in chunk cache
/******/ 						var promise = import("./" + __webpack_require__.u(chunkId)).then(installChunk, (e) => {
/******/ 							if(installedChunks[chunkId] !== 0) installedChunks[chunkId] = undefined;
/******/ 							throw e;
/******/ 						});
/******/ 						var promise = Promise.race([promise, new Promise((resolve) => (installedChunkData = installedChunks[chunkId] = [resolve]))])
/******/ 						promises.push(installedChunkData[1] = promise);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 	};
/******/ 	
/******/ 	// no prefetching
/******/ 	
/******/ 	// no preloaded
/******/ 	
/******/ 	// no external install chunk
/******/ 	
/******/ 	__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ })();
/******/ 
/************************************************************************/
/******/ 
/******/ // startup
/******/ // Load entry module and return exports
/******/ // This entry module depends on other loaded chunks and execution need to be delayed
/******/ var __webpack_exports__ = __webpack_require__.O(undefined, ["vendors-node_modules_vscode_vscode_src_vs_base_common_assert_js-node_modules_vscode_vscode_sr-39c9f0","vendors-node_modules_vscode_vscode_src_vs_base_common_buffer_js-node_modules_vscode_vscode_sr-2c9cae","vendors-node_modules_vscode_vscode_src_vs_base_common_worker_simpleWorker_js-node_modules_vsc-6729ec","vendors-node_modules_codingame_monaco-vscode-textmate-service-override_vscode_src_vs_workbenc-f788c8"], () => (__webpack_require__("./node_modules/@codingame/monaco-vscode-textmate-service-override/worker.js")))
/******/ __webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 

//# sourceMappingURL=vendors-node_modules_codingame_monaco-vscode-textmate-service-override_worker_js.immt_editor.js.map