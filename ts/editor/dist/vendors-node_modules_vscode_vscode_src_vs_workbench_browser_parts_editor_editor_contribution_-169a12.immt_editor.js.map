{"version":3,"file":"vendors-node_modules_vscode_vscode_src_vs_workbench_browser_parts_editor_editor_contribution_-169a12.immt_editor.js","mappings":";;;;;;;;;;;AAAqD;AAC6B;AAClF,wFAA8B,CAAC,8DAAc,KAAK,8DAAc;;;;;;;;;;;;;;;;;;;;;;;;;;ACFuB;AACmB;AACoB;AAChD;AACY;AACY;AACG;AAC5B;AACW;AAC3B;AACwC;AACrG,kDAAkD,iEAAU;AAC5D,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,sEAAe;AACrF,6DAA6D,4DAAW;AACxE,uDAAuD,4DAAW;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,kCAAkC;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0HAA0H,oBAAoB;AAC9I,mEAAmE,6BAA6B;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,gEAAgE;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,+CAA+C;AAC/F,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iGAAiG,OAAO;AACxG,gEAAgE,QAAQ;AACxE;AACA;AACA;AACA,+FAA+F,kEAAkE;AACjK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA,yFAAyF,qDAAqD;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,mBAAmB;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA,6FAA6F,qDAAqD;AAClJ;AACA;AACA,SAAS;AACT,2DAA2D,uEAAY;AACvE;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ,kEAAO;AACf;AACA;AACA;AACA;AACA;AACA,mBAAmB,wEAAU;AAC7B,MAAM,qEAAO,IAAI,gIAA0B;AAC3C,MAAM,qEAAO,IAAI,gFAAY;AAC7B,MAAM,qEAAO,IAAI,4FAAc;AAC/B,MAAM,qEAAO,IAAI,wGAAoB;AACrC,MAAM,qEAAO,IAAI,2GAAmB;AACpC,MAAM,qEAAO,IAAI,4EAAW;AAC5B,MAAM,qEAAO,IAAI,uFAAc;AAC/B,MAAM,qEAAO,IAAI,qGAAmB;AACpC;AAC0B;;;;;;;;;;;;;;;;;;;;;;;;;;ACvN6D;AAC1B;AAC2B;AACI;AACH;AACb;AACV;AACoC;AACzC;AACW;AACZ;AAC5D;AACA,oDAAoD,iEAAU;AAC9D,aAAa;AACb,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,KAAK,GAAG,SAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,0DAAS;AACnD,+CAA+C,4DAAW;AAC1D,0EAA0E,0DAAO;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,QAAQ;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,sEAAe;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,qCAAqC;AAC7F;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ,wDAAK,iCAAiC,kEAAO;AACrD;AACA;AACA,aAAa,gEAAM;AACnB;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,0FAAqB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yGAAyG,iBAAiB;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,QAAQ;AACpF;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mGAAmG,iBAAiB;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,qBAAqB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2EAAQ,IAAI,+DAAgB;AACvD;AACA;AACA;AACA,qBAAqB,gEAAQ,kBAAkB,iBAAiB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA,yDAAyD,QAAQ;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,wEAAU;AAClD,MAAM,qEAAO,IAAI,wGAAoB;AACrC,MAAM,qEAAO,IAAI,wFAAe;AAChC;AAC2B;;;;;;;;;;;;;;;;;;;AChWyD;AACrC;AACgC;AAC1B;AACrD,wDAAwD,wDAAW;AACnE;AACA;AACA;AACA;AACA;AACA,oBAAoB,uDAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wEAAU;AAChC,MAAM,qEAAO,IAAI,iFAAY;AAC7B;AAC6B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtC6D;AAC+B;AAClB;AACpB;AACE;AACQ;AACS;AACnB;AACU;AACY;AACnB;AAC2C;AACpC;AAC3B;AACN;AACI;AAC0B;AACH;AACgC;AACJ;AACnH;AACA,wEAAwE,sGAA+B;AACvG;AACA,eAAe,kEAAoB;AACnC;AACA;AACA,eAAe,yEAA0B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,sEAAe;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mEAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yDAAK;AACrC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,6DAAO;AAC5C,qCAAqC,6DAAO;AAC5C,qCAAqC,6DAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB,GAAG,MAAM;AAChD;AACA;AACA;AACA;AACA;AACA,sBAAsB,oBAAoB,EAAE,0BAA0B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,mEAAqB;AAC7F;AACA,oEAAoE,iEAAmB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,2FAAuB;AACzF,0BAA0B,aAAa;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,kFAAiB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yEAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,2BAA2B,yEAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mEAAO;AAC1B;AACA,YAAY,wEAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAO;AACf;AACA;AACA;AACA,wCAAwC,wEAAU;AAClD,MAAM,qEAAO,IAAI,kGAAqB;AACtC,MAAM,qEAAO,IAAI,4FAAgB;AACjC,MAAM,qEAAO,IAAI,yFAAiB;AAClC,MAAM,qEAAO,KAAK,mFAAa;AAC/B,MAAM,qEAAO,KAAK,iFAAY;AAC9B,MAAM,qEAAO,KAAK,iIAA0B;AAC5C,MAAM,qEAAO,KAAK,6FAAc;AAChC,MAAM,qEAAO,KAAK,uFAAY;AAC9B,MAAM,qEAAO,KAAK,oHAAiC;AACnD,MAAM,qEAAO,KAAK,mHAAyB;AAC3C;AAC2B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvUmB;AACuC;AACG;AACW;AAC1B;AACW;AACgB;AACrC;AACD;AACkC;AAC9B;AACsC;AACd;AACY;AACvC;AAC+B;AACsB;AAC1B;AAClB;AACV;AACP;AACuK;AACtI;AAC3B;AAC7D;AACA,4CAA4C,yGAAoB;AAChE,2CAA2C,8FAAkB;AAC7D,yCAAyC,6FAAgB;AACzD,kBAAkB,2EAAgC;AAClD;AACA;AACA;AACA;AACA,oDAAoD,0FAAqB;AACzE;AACA;AACA,+BAA+B,mEAAmE;AAClG,+BAA+B,qEAAqE;AACpG;AACA;AACA,+BAA+B,2DAA2D;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,oHAAwB;AAC7D;AACA;AACA,eAAe,QAAQ,KAAK,mEAAO,CAAC,qEAAsB,2BAA2B,mBAAmB,+DAAgB,UAAU;AAClI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2BAA2B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,6FAAc;AACrD,6CAA6C,wGAAoB;AACjE,8CAA8C,kGAAqB;AACnE;AACA;AACA;AACA;AACA,aAAa,4EAAmB;AAChC,6BAA6B,kEAAQ,GAAG,mDAAmD,iDAAQ,yHAAyH;AAC5N,sDAAsD,QAAQ;AAC9D;AACA,6BAA6B,kEAAQ,GAAG,kFAAkF,iDAAQ,0BAA0B,iDAAQ,qEAAqE;AACzO;AACA;AACA,sCAAsC,QAAQ,KAAK,2DAAI;AACvD,0BAA0B,iEAAU;AACpC,2BAA2B,iDAAQ;AACnC;AACA,sCAAsC,EAAE,IAAI,EAAE;AAC9C,sCAAsC,QAAQ;AAC9C,oBAAoB,4EAAc;AAClC;AACA,2BAA2B;AAC3B,aAAa;AACb;AACA;AACA;AACA,mGAAmB;AACnB;AACA;AACA;AACA,QAAQ,oEAAoB;AAC5B;AACA,+CAA+C,0BAA0B;AACzE;AACA,CAAC;AACD,mGAAmB;AACnB;AACA;AACA,aAAa,kEAAQ;AACrB,WAAW,SAAS,kEAAQ,oCAAoC;AAChE,QAAQ,uFAAuC;AAC/C;AACA,+CAA+C,sDAAsD;AACrG;AACA,CAAC;AACD,mGAAmB;AACnB,QAAQ,uEAAuB;AAC/B;AACA;AACA;AACA;AACA,+CAA+C,0BAA0B;AACzE;AACA,CAAC;AACD,mGAAmB;AACnB;AACA;AACA;AACA,WAAW,6BAA6B;AACxC,WAAW,SAAS,kEAAQ,oBAAoB;AAChD,QAAQ,mEAAmB;AAC3B;AACA,+DAA+D,yGAAoB,mBAAmB,YAAY;AAClH;AACA,CAAC;AACD,mFAAgB;AAChB,QAAQ,4EAA4B;AACpC;AACA,iDAAiD,yGAAoB;AACrE,gCAAgC,sGAAsB,+BAA+B,6FAAc,qCAAqC,wFAAY;AACpJ;AACA;AACA;AACA;AACA;AACA,8DAA8D,OAAO;AACrE;AACA,4DAA4D,YAAY;AACxE;AACA,CAAC;AACD,mFAAgB;AAChB,QAAQ,qEAAqB;AAC7B;AACA,2CAA2C,6FAAc;AACzD,kDAAkD,oCAAoC;AACtF;AACA;AACA,CAAC;AACD,mFAAgB;AAChB,QAAQ,sEAAsB;AAC9B;AACA,gDAAgD,yGAAoB;AACpE,2CAA2C,6FAAc;AACzD,sBAAsB,2EAAgC;AACtD;AACA;AACA;AACA,6BAA6B,2DAA2D;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,QAAQ,oCAAoC,aAAa;AAClH;AACA;AACA,qDAAqD,wGAAoB;AACzE,wCAAwC,iDAAQ;AAChD;AACA,oCAAoC,EAAE,IAAI,EAAE;AAC5C,kCAAkC,QAAQ;AAC1C,gBAAgB,4EAAc;AAC9B;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;AC9L2E;AACf;AACE;AACL;AAC1D,EAAE,2EAAQ,IAAI,+DAAgB;AAC9B,YAAY,kEAAoB;AAChC;AACA,mDAAmD,wEAAe;AAClE,KAAK;AACL;AACA,8BAA8B,wEAAe;AAC7C;AACA,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;ACZoD;AACmC;AACxC;AACqC;AACf;AACZ;AACG;AACqB;AAChB;AAClE;AACA;AACA;AACA,mBAAmB,qEAAe;AAClC;AACA,4BAA4B,qEAAI;AAChC;AACA;AACA;AACA;AACA;AACA,iCAAiC,iFAAa;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oDAAG;AACX;AACA;AACA;AACA,yBAAyB,kEAAY;AACrC;AACA;AACA,8BAA8B,wDAAU;AACxC;AACA;AACA,WAAW,qEAAsB,8CAA8C,mBAAmB,+DAAgB,UAAU;AAC5H;AACA;AACA;AACA;AACA,mBAAmB,qEAAe;AAClC,4BAA4B,iFAAa,kDAAkD,kEAAY;AACvG;AACA;AACA;AACA;AACA;AACA,4BAA4B,qEAAI;AAChC,8BAA8B,gEAAQ,uDAAuD,wDAAU;AACvG;AACA;AACA;AACA,gBAAgB,oDAAG;AACnB;AACA;AACA,sCAAsC,wDAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oDAAG;AACnC,8EAA8E,sBAAsB;AACpG;AACA;AACA;AACA;AACA,6CAA6C,qEAAsB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uFAAY;AAC1C;AACA,mBAAmB,qEAAe;AAClC,4BAA4B,qEAAI;AAChC,8BAA8B,gEAAQ,qDAAqD,wDAAU;AACrG;AACA;AACA;AACA,iCAAiC,wDAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8F;;;;;;;;;;;;;;;;;;;;;;;;;AC5GP;AACoC;AACd;AACnB;AACpB;AACF;AACA;AACL;AAC4C;AAC1B;AACjF,wDAAwD,4GAAyB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8EAAY;AACxB;AACA;AACA,YAAY,8EAAY;AACxB;AACA;AACA;AACA,YAAY,mFAAiB,mBAAmB,8EAAY;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8EAAY;AACxB;AACA;AACA;AACA;AACA,YAAY,kEAAO;AACnB;AACA;AACA,YAAY,uFAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kEAAO;AACpB;AACA;AACA,oBAAoB,+EAAa;AACjC;AACA;AACA;AACA;AACA;AACA,gFAAgF,gEAAU,GAAG,kEAAY;AACzG;AACA;AACA,gBAAgB,8EAAY;AAC5B;AACA;AACA,gBAAgB,mFAAiB,YAAY,8EAAY;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wEAAU;AAChC,MAAM,qEAAO,IAAI,4EAAc;AAC/B,MAAM,qEAAO,IAAI,yFAAa;AAC9B,MAAM,qEAAO,IAAI,0GAAqB;AACtC;AAC6B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjF0D;AACY;AAC2I;AAC1K;AACoB;AACd;AACI;AACI;AAChB;AACb;AACW;AACY;AAC+B;AACpC;AACS;AAClB;AAC6C;AACf;AACrB;AACqC;AAC7C;AACoB;AACd;AACiC;AACrC;AACoC;AACjB;AAC4B;AAC9C;AACP;AAC6B;AACxF;AACA,kEAAkE,kEAAU;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,0DAAO;AACpE;AACA,+DAA+D,0DAAO;AACtE;AACA,wDAAwD,0DAAO;AAC/D;AACA,sDAAsD,0DAAO;AAC7D;AACA,sDAAsD,0DAAO;AAC7D;AACA,yDAAyD,0DAAO;AAChE;AACA,0EAA0E,0DAAO;AACjF;AACA;AACA,kDAAkD,4DAAW;AAC7D;AACA;AACA,uFAAuF,sFAAe;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,uEAAe;AACtD;AACA,4CAA4C,6BAA6B;AACzE,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,6CAA6C,2BAA2B;AACxE,SAAS;AACT,QAAQ,wDAAK;AACb,YAAY,mEAAO;AACnB,SAAS;AACT;AACA;AACA,qDAAqD,4DAAW;AAChE;AACA,8BAA8B,iEAAQ,CAAC,iEAAQ;AAC/C,gBAAgB,qEAAsB,2BAA2B,mBAAmB,+DAAgB,UAAU;AAC9G,gBAAgB,qEAAsB,2BAA2B,mBAAmB,+DAAgB,YAAY;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mEAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qEAAW;AAC7C,qCAAqC,oEAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gEAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,iDAAiD;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,6EAAgB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+DAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,0FAAqB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+EAAY,mBAAmB,+EAAY;AAC3D;AACA;AACA,gBAAgB,oFAAiB,mBAAmB,+EAAY;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+EAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA,kEAAkE,iBAAiB;AACnF;AACA;AACA;AACA;AACA;AACA,qFAAqF,2BAA2B;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iEAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,6CAA6C,wFAAkB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+EAAY,aAAa,+EAAY;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iEAAQ;AACvB;AACA;AACA;AACA,sBAAsB,gEAAa;AACnC;AACA,YAAY,2EAAgB;AAC5B;AACA;AACA,aAAa,gEAAa;AAC1B;AACA;AACA;AACA;AACA,gBAAgB,mFAAgC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gEAAa;AACvC;AACA;AACA;AACA,6EAA6E,oEAAS,IAAI,8BAA8B;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,2EAAwB;AACzC;AACA;AACA;AACA;AACA,oBAAoB,mFAAgC;AACpD;AACA;AACA;AACA;AACA;AACA,8BAA8B,2EAAwB,sBAAsB;AAC5E;AACA;AACA,iFAAiF,oEAAS;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iEAAQ,OAAO,4DAAQ;AACtC;AACA;AACA,gBAAgB,iCAAiC;AACjD;AACA;AACA;AACA;AACA;AACA,iFAAiF,mBAAmB,OAAO,2CAA2C;AACtJ;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,4DAAW;AAC3C;AACA;AACA;AACA,gBAAgB,2EAAwB;AACxC,iCAAiC,qEAAsB,iCAAiC,mBAAmB,+DAAgB,OAAO;AAClI,oBAAoB,oDAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,+EAAe;AACvE;AACA;AACA;AACA,oBAAoB,6EAA0B;AAC9C,wBAAwB,oDAAG;AAC3B;AACA;AACA,wBAAwB,oDAAG;AAC3B;AACA;AACA,wBAAwB,oDAAG;AAC3B;AACA;AACA,wBAAwB,oDAAG;AAC3B;AACA;AACA;AACA;AACA,oBAAoB,4EAAyB;AAC7C,wBAAwB,oDAAG;AAC3B;AACA;AACA,wBAAwB,oDAAG;AAC3B;AACA;AACA;AACA;AACA,yBAAyB,wEAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oDAAG;AAC5B,uBAAuB,oDAAG;AAC1B,2CAA2C,+DAAgB,uCAAuC,+DAAgB;AAClH;AACA,oBAAoB,oDAAG,gBAAgB,mEAAW;AAClD;AACA;AACA;AACA;AACA;AACA,aAAa,mEAAW;AACxB;AACA,gBAAgB,oDAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oDAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,2BAA2B;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gEAAa;AAC9B;AACA;AACA;AACA;AACA,oBAAoB,mFAAgC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,oFAAmB;AACpD,6BAA6B,oFAAmB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kBAAkB;AAC3C;AACA,qDAAqD,iBAAiB;AACtE;AACA;AACA,iDAAiD,iBAAiB;AAClE;AACA;AACA;AACA,kCAAkC,4DAAQ,wCAAwC,iBAAiB;AACnG;AACA;AACA;AACA;AACA,SAAS;AACT,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,sEAAW;AACrD,qDAAqD,qDAAqD;AAC1G;AACA;AACA,qDAAqD,uBAAuB,qCAAqC;AACjH;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iEAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,4DAAQ,sCAAsC,iBAAiB;AAC7E;AACA;AACA,SAAS;AACT,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA,iCAAiC,iBAAiB;AAClD;AACA;AACA;AACA;AACA;AACA,gEAAgE,mEAAO;AACvE;AACA;AACA;AACA,oCAAoC,wEAAU;AAC9C,MAAM,qEAAO,IAAI,yFAAoB;AACrC,MAAM,qEAAO,IAAI,kGAAqB;AACtC,MAAM,qEAAO,IAAI,iFAAY;AAC7B,MAAM,qEAAO,IAAI,2GAAqB;AACtC,MAAM,qEAAO,IAAI,sGAAwB;AACzC,MAAM,qEAAO,IAAI,qGAAmB;AACpC,MAAM,qEAAO,IAAI,6FAAsB;AACvC,MAAM,qEAAO,IAAI,gHAA6B;AAC9C,MAAM,qEAAO,IAAI,wEAAY;AAC7B,MAAM,qEAAO,KAAK,8FAAkB;AACpC;AACyB;;;;;;;;;;;;;;;;;;;;;ACtwBkF;AAC3B;AACI;AACP;AACL;AACN;AAClE;AACA,4CAA4C,iFAAoB;AAChE,8CAA8C,0GAAqB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yDAAU;AACrC;AACA,qBAAqB,+EAAgB;AACrC;AACA;AACA;AACA;AACA;AACA,mBAAmB,2EAAwB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yDAAU;AAC1C,0BAA0B,0FAAiC;AAC3D,4DAA4D,WAAW;AACvE;AACA;AACA;AACA;AACA;AACA,gCAAgC,+DAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8GAA8G,gEAAa;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,0FAAiC;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7HkE;AAC9B;AACmB;AACf;AACsC;AAC8E;AACzE;AAC3C;AACe;AACY;AACI;AACD;AAC3B;AACX;AACgD;AACnB;AACM;AACM;AAC5B;AAClE,wDAAwD,kEAAU;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,4DAAW;AACjD,mCAAmC,2EAAQ,IAAI,+DAAgB;AAC/D;AACA;AACA;AACA;AACA,gBAAgB,yEAA0B;AAC1C,mBAAmB,yEAA0B;AAC7C,oBAAoB,yEAA0B;AAC9C,sBAAsB,8FAAwB;AAC9C,SAAS,IAAI;AACb,4CAA4C,uCAAuC;AACnF,4DAA4D,+CAA+C;AAC3G,oDAAoD,2CAA2C;AAC/F,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,YAAY,6EAA0B;AACtC;AACA;AACA,YAAY,4EAAyB;AACrC;AACA;AACA,4DAA4D,8EAAe;AAC3E;AACA,YAAY,kFAA+B;AAC3C;AACA;AACA,4DAA4D,0FAAqB;AACjF;AACA;AACA,yGAAyG,4DAAO;AAChH;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,4DAAO;AAC1D,wEAAwE,8DAA8D;AACtI;AACA;AACA,wEAAwE,gEAAgE;AACxI;AACA,iHAAiH,iGAAuB;AACxI;AACA;AACA,wDAAwD,qDAAG;AAC3D,2DAA2D,oEAAQ;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,+FAAuB;AACvF,aAAa;AACb,2CAA2C,iGAAuB;AAClE;AACA;AACA,kDAAkD,+FAAuB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,oEAAoE,sBAAsB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wDAAK;AACb;AACA;AACA;AACA,sBAAsB,wEAAU;AAChC,MAAM,qEAAO,IAAI,6GAA0B;AAC3C,MAAM,qEAAO,IAAI,kGAAqB;AACtC,MAAM,qEAAO,IAAI,qGAAmB;AACpC,MAAM,qEAAO,IAAI,kFAAY;AAC7B,MAAM,qEAAO,IAAI,oGAAsB;AACvC;AAC6B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnJ0D;AACuC;AAC1B;AACtB;AACK;AACL;AACI;AACF;AACsB;AAC9B;AAC0C;AACxB;AACV;AACoC;AAChB;AACpG;AACA,oEAAoE,sGAA+B;AACnG,aAAa;AACb,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,yEAA0B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,uEAAe;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kEAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,MAAM,IAAI,YAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,0EAAe;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,yEAAsB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kEAAO;AAC1B;AACA,YAAY,gFAA6B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAAO;AACf;AACA;AACA;AACA,wDAAwD,wEAAU;AAClE,MAAM,qEAAO,IAAI,mFAAgB;AACjC,MAAM,qEAAO,IAAI,kFAAa;AAC9B,MAAM,qEAAO,IAAI,mFAAc;AAC/B,MAAM,qEAAO,IAAI,iFAAY;AAC7B,MAAM,qEAAO,IAAI,2GAA4B;AAC7C,MAAM,qEAAO,IAAI,6EAAY;AAC7B,MAAM,qEAAO,IAAI,wHAA0B;AAC3C,MAAM,qEAAO,IAAI,0FAAiB;AAClC,MAAM,qEAAO,IAAI,oHAAiC;AAClD,MAAM,qEAAO,KAAK,0GAAyB;AAC3C;AACmC","sources":["webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/browser/parts/editor/editor.contribution._autosave.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/browser/parts/editor/editorAutoSave.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/browser/parts/editor/editorsObserver.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/common/editor/binaryEditorModel.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/contrib/files/browser/editors/fileEditorInput.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/contrib/files/browser/fileCommands._save.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/contrib/files/browser/files.contribution._fileEditorFactory.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/contrib/files/browser/files.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/services/editor/browser/codeEditorService.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/services/editor/browser/editorService.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/services/editor/common/editorGroupFinder.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/services/textfile/common/textEditorService.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/services/untitled/common/untitledTextEditorInput.js"],"sourcesContent":["import { EditorAutoSave } from './editorAutoSave.js';\nimport { registerWorkbenchContribution2 } from '../../../common/contributions.js';\nregisterWorkbenchContribution2(EditorAutoSave.ID, EditorAutoSave, 2 );\n","import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';\nimport { Disposable, DisposableStore, toDisposable, dispose } from '../../../../base/common/lifecycle.js';\nimport { IFilesConfigurationService } from '../../../services/filesConfiguration/common/filesConfigurationService.service.js';\nimport { IHostService } from '../../../services/host/browser/host.service.js';\nimport { IEditorService } from '../../../services/editor/common/editorService.service.js';\nimport { IEditorGroupsService } from '../../../services/editor/common/editorGroupsService.service.js';\nimport { IWorkingCopyService } from '../../../services/workingCopy/common/workingCopyService.service.js';\nimport { ILogService } from '../../../../platform/log/common/log.service.js';\nimport { IMarkerService } from '../../../../platform/markers/common/markers.service.js';\nimport { ResourceMap } from '../../../../base/common/map.js';\nimport { IUriIdentityService } from '../../../../platform/uriIdentity/common/uriIdentity.service.js';\nlet EditorAutoSave = class EditorAutoSave extends Disposable {\n    static { this.ID = 'workbench.contrib.editorAutoSave'; }\n    constructor(filesConfigurationService, hostService, editorService, editorGroupService, workingCopyService, logService, markerService, uriIdentityService) {\n        super();\n        this.filesConfigurationService = filesConfigurationService;\n        this.hostService = hostService;\n        this.editorService = editorService;\n        this.editorGroupService = editorGroupService;\n        this.workingCopyService = workingCopyService;\n        this.logService = logService;\n        this.markerService = markerService;\n        this.uriIdentityService = uriIdentityService;\n        this.scheduledAutoSavesAfterDelay = ( new Map());\n        this.lastActiveEditor = undefined;\n        this.lastActiveGroupId = undefined;\n        this.lastActiveEditorControlDisposable = this._register(( new DisposableStore()));\n        this.waitingOnConditionAutoSaveWorkingCopies = ( new ResourceMap(resource => this.uriIdentityService.extUri.getComparisonKey(resource)));\n        this.waitingOnConditionAutoSaveEditors = ( new ResourceMap(resource => this.uriIdentityService.extUri.getComparisonKey(resource)));\n        for (const dirtyWorkingCopy of this.workingCopyService.dirtyWorkingCopies) {\n            this.onDidRegister(dirtyWorkingCopy);\n        }\n        this.registerListeners();\n    }\n    registerListeners() {\n        this._register(this.hostService.onDidChangeFocus(focused => this.onWindowFocusChange(focused)));\n        this._register(this.hostService.onDidChangeActiveWindow(() => this.onActiveWindowChange()));\n        this._register(this.editorService.onDidActiveEditorChange(() => this.onDidActiveEditorChange()));\n        this._register(this.filesConfigurationService.onDidChangeAutoSaveConfiguration(() => this.onDidChangeAutoSaveConfiguration()));\n        this._register(this.workingCopyService.onDidRegister(workingCopy => this.onDidRegister(workingCopy)));\n        this._register(this.workingCopyService.onDidUnregister(workingCopy => this.onDidUnregister(workingCopy)));\n        this._register(this.workingCopyService.onDidChangeDirty(workingCopy => this.onDidChangeDirty(workingCopy)));\n        this._register(this.workingCopyService.onDidChangeContent(workingCopy => this.onDidChangeContent(workingCopy)));\n        this._register(this.markerService.onMarkerChanged(e => this.onConditionChanged(e, 3 )));\n        this._register(this.filesConfigurationService.onDidChangeAutoSaveDisabled(resource => this.onConditionChanged([resource], 4 )));\n    }\n    onConditionChanged(resources, condition) {\n        for (const resource of resources) {\n            const workingCopyResult = this.waitingOnConditionAutoSaveWorkingCopies.get(resource);\n            if (workingCopyResult?.condition === condition) {\n                if (workingCopyResult.workingCopy.isDirty() &&\n                    this.filesConfigurationService.getAutoSaveMode(workingCopyResult.workingCopy.resource, workingCopyResult.reason).mode !== 0 ) {\n                    this.discardAutoSave(workingCopyResult.workingCopy);\n                    this.logService.trace(`[editor auto save] running auto save from condition change event`, ( workingCopyResult.workingCopy.resource.toString()), workingCopyResult.workingCopy.typeId);\n                    workingCopyResult.workingCopy.save({ reason: workingCopyResult.reason });\n                }\n            }\n            else {\n                const editorResult = this.waitingOnConditionAutoSaveEditors.get(resource);\n                if (editorResult?.condition === condition &&\n                    !editorResult.editor.editor.isDisposed() &&\n                    editorResult.editor.editor.isDirty() &&\n                    this.filesConfigurationService.getAutoSaveMode(editorResult.editor.editor, editorResult.reason).mode !== 0 ) {\n                    this.waitingOnConditionAutoSaveEditors.delete(resource);\n                    this.logService.trace(`[editor auto save] running auto save from condition change event with reason ${editorResult.reason}`);\n                    this.editorService.save(editorResult.editor, { reason: editorResult.reason });\n                }\n            }\n        }\n    }\n    onWindowFocusChange(focused) {\n        if (!focused) {\n            this.maybeTriggerAutoSave(4 );\n        }\n    }\n    onActiveWindowChange() {\n        this.maybeTriggerAutoSave(4 );\n    }\n    onDidActiveEditorChange() {\n        if (this.lastActiveEditor && typeof this.lastActiveGroupId === 'number') {\n            this.maybeTriggerAutoSave(3 , { groupId: this.lastActiveGroupId, editor: this.lastActiveEditor });\n        }\n        const activeGroup = this.editorGroupService.activeGroup;\n        const activeEditor = this.lastActiveEditor = activeGroup.activeEditor ?? undefined;\n        this.lastActiveGroupId = activeGroup.id;\n        this.lastActiveEditorControlDisposable.clear();\n        const activeEditorPane = this.editorService.activeEditorPane;\n        if (activeEditor && activeEditorPane) {\n            this.lastActiveEditorControlDisposable.add(activeEditorPane.onDidBlur(() => {\n                this.maybeTriggerAutoSave(3 , { groupId: activeGroup.id, editor: activeEditor });\n            }));\n        }\n    }\n    maybeTriggerAutoSave(reason, editorIdentifier) {\n        if (editorIdentifier) {\n            if (!editorIdentifier.editor.isDirty() ||\n                editorIdentifier.editor.isReadonly() ||\n                editorIdentifier.editor.hasCapability(4 )) {\n                return;\n            }\n            const autoSaveMode = this.filesConfigurationService.getAutoSaveMode(editorIdentifier.editor, reason);\n            if (autoSaveMode.mode !== 0 ) {\n                if ((reason === 4  && ((autoSaveMode.mode === 3  || autoSaveMode.mode === 4) )) ||\n                    ((reason === 3  && autoSaveMode.mode === 3) )) {\n                    this.logService.trace(`[editor auto save] triggering auto save with reason ${reason}`);\n                    this.editorService.save(editorIdentifier, { reason });\n                }\n            }\n            else if (editorIdentifier.editor.resource && ((autoSaveMode.reason === 3  || autoSaveMode.reason === 4) )) {\n                this.waitingOnConditionAutoSaveEditors.set(editorIdentifier.editor.resource, { editor: editorIdentifier, reason, condition: autoSaveMode.reason });\n            }\n        }\n        else {\n            this.saveAllDirtyAutoSaveables(reason);\n        }\n    }\n    onDidChangeAutoSaveConfiguration() {\n        let reason = undefined;\n        switch (this.filesConfigurationService.getAutoSaveMode(undefined).mode) {\n            case 3 :\n                reason = 3 ;\n                break;\n            case 4 :\n                reason = 4 ;\n                break;\n            case 1 :\n            case 2 :\n                reason = 2 ;\n                break;\n        }\n        if (reason) {\n            this.saveAllDirtyAutoSaveables(reason);\n        }\n    }\n    saveAllDirtyAutoSaveables(reason) {\n        for (const workingCopy of this.workingCopyService.dirtyWorkingCopies) {\n            if (workingCopy.capabilities & 2 ) {\n                continue;\n            }\n            const autoSaveMode = this.filesConfigurationService.getAutoSaveMode(workingCopy.resource, reason);\n            if (autoSaveMode.mode !== 0 ) {\n                workingCopy.save({ reason });\n            }\n            else if (autoSaveMode.reason === 3  || autoSaveMode.reason === 4 ) {\n                this.waitingOnConditionAutoSaveWorkingCopies.set(workingCopy.resource, { workingCopy, reason, condition: autoSaveMode.reason });\n            }\n        }\n    }\n    onDidRegister(workingCopy) {\n        if (workingCopy.isDirty()) {\n            this.scheduleAutoSave(workingCopy);\n        }\n    }\n    onDidUnregister(workingCopy) {\n        this.discardAutoSave(workingCopy);\n    }\n    onDidChangeDirty(workingCopy) {\n        if (workingCopy.isDirty()) {\n            this.scheduleAutoSave(workingCopy);\n        }\n        else {\n            this.discardAutoSave(workingCopy);\n        }\n    }\n    onDidChangeContent(workingCopy) {\n        if (workingCopy.isDirty()) {\n            this.scheduleAutoSave(workingCopy);\n        }\n    }\n    scheduleAutoSave(workingCopy) {\n        if (workingCopy.capabilities & 2 ) {\n            return;\n        }\n        const autoSaveAfterDelay = this.filesConfigurationService.getAutoSaveConfiguration(workingCopy.resource).autoSaveDelay;\n        if (typeof autoSaveAfterDelay !== 'number') {\n            return;\n        }\n        this.discardAutoSave(workingCopy);\n        this.logService.trace(`[editor auto save] scheduling auto save after ${autoSaveAfterDelay}ms`, ( workingCopy.resource.toString()), workingCopy.typeId);\n        const handle = setTimeout(() => {\n            this.discardAutoSave(workingCopy);\n            if (workingCopy.isDirty()) {\n                const reason = 2 ;\n                const autoSaveMode = this.filesConfigurationService.getAutoSaveMode(workingCopy.resource, reason);\n                if (autoSaveMode.mode !== 0 ) {\n                    this.logService.trace(`[editor auto save] running auto save`, ( workingCopy.resource.toString()), workingCopy.typeId);\n                    workingCopy.save({ reason });\n                }\n                else if (autoSaveMode.reason === 3  || autoSaveMode.reason === 4 ) {\n                    this.waitingOnConditionAutoSaveWorkingCopies.set(workingCopy.resource, { workingCopy, reason, condition: autoSaveMode.reason });\n                }\n            }\n        }, autoSaveAfterDelay);\n        this.scheduledAutoSavesAfterDelay.set(workingCopy, toDisposable(() => {\n            this.logService.trace(`[editor auto save] clearing pending auto save`, ( workingCopy.resource.toString()), workingCopy.typeId);\n            clearTimeout(handle);\n        }));\n    }\n    discardAutoSave(workingCopy) {\n        dispose(this.scheduledAutoSavesAfterDelay.get(workingCopy));\n        this.scheduledAutoSavesAfterDelay.delete(workingCopy);\n        this.waitingOnConditionAutoSaveWorkingCopies.delete(workingCopy.resource);\n        this.waitingOnConditionAutoSaveEditors.delete(workingCopy.resource);\n    }\n};\nEditorAutoSave = ( __decorate([\n    ( __param(0, IFilesConfigurationService)),\n    ( __param(1, IHostService)),\n    ( __param(2, IEditorService)),\n    ( __param(3, IEditorGroupsService)),\n    ( __param(4, IWorkingCopyService)),\n    ( __param(5, ILogService)),\n    ( __param(6, IMarkerService)),\n    ( __param(7, IUriIdentityService))\n], EditorAutoSave));\nexport { EditorAutoSave };\n","import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';\nimport { EditorExtensions } from '../../../common/editor.js';\nimport { SideBySideEditorInput } from '../../../common/editor/sideBySideEditorInput.js';\nimport { Disposable, dispose, DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { IStorageService } from '../../../../platform/storage/common/storage.service.js';\nimport { Registry } from '../../../../platform/registry/common/platform.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { IEditorGroupsService } from '../../../services/editor/common/editorGroupsService.service.js';\nimport { coalesce } from '../../../../base/common/arrays.js';\nimport { LinkedMap, ResourceMap } from '../../../../base/common/map.js';\nimport { equals } from '../../../../base/common/objects.js';\nvar EditorsObserver_1;\nlet EditorsObserver = class EditorsObserver extends Disposable {\n    static { EditorsObserver_1 = this; }\n    static { this.STORAGE_KEY = 'editors.mru'; }\n    get count() {\n        return this.mostRecentEditorsMap.size;\n    }\n    get editors() {\n        return [...( this.mostRecentEditorsMap.values())];\n    }\n    hasEditor(editor) {\n        const editors = this.editorsPerResourceCounter.get(editor.resource);\n        return editors?.has(this.toIdentifier(editor)) ?? false;\n    }\n    hasEditors(resource) {\n        return ( this.editorsPerResourceCounter.has(resource));\n    }\n    toIdentifier(arg1, editorId) {\n        if (typeof arg1 !== 'string') {\n            return this.toIdentifier(arg1.typeId, arg1.editorId);\n        }\n        if (editorId) {\n            return `${arg1}/${editorId}`;\n        }\n        return arg1;\n    }\n    constructor(editorGroupsContainer, editorGroupService, storageService) {\n        super();\n        this.editorGroupService = editorGroupService;\n        this.storageService = storageService;\n        this.keyMap = ( new Map());\n        this.mostRecentEditorsMap = ( new LinkedMap());\n        this.editorsPerResourceCounter = ( new ResourceMap());\n        this._onDidMostRecentlyActiveEditorsChange = this._register(( new Emitter()));\n        this.onDidMostRecentlyActiveEditorsChange = this._onDidMostRecentlyActiveEditorsChange.event;\n        this.editorGroupsContainer = editorGroupsContainer ?? editorGroupService;\n        this.isScoped = !!editorGroupsContainer;\n        this.registerListeners();\n        this.loadState();\n    }\n    registerListeners() {\n        this._register(this.editorGroupsContainer.onDidAddGroup(group => this.onGroupAdded(group)));\n        this._register(this.editorGroupService.onDidChangeEditorPartOptions(e => this.onDidChangeEditorPartOptions(e)));\n        this._register(this.storageService.onWillSaveState(() => this.saveState()));\n    }\n    onGroupAdded(group) {\n        const groupEditorsMru = group.getEditors(0 );\n        for (let i = groupEditorsMru.length - 1; i >= 0; i--) {\n            this.addMostRecentEditor(group, groupEditorsMru[i], false , true );\n        }\n        if (this.editorGroupsContainer.activeGroup === group && group.activeEditor) {\n            this.addMostRecentEditor(group, group.activeEditor, true , false );\n        }\n        this.registerGroupListeners(group);\n    }\n    registerGroupListeners(group) {\n        const groupDisposables = ( new DisposableStore());\n        groupDisposables.add(group.onDidModelChange(e => {\n            switch (e.kind) {\n                case 0 : {\n                    if (this.editorGroupsContainer.activeGroup === group && group.activeEditor) {\n                        this.addMostRecentEditor(group, group.activeEditor, true , false );\n                    }\n                    break;\n                }\n                case 5 : {\n                    if (e.editor) {\n                        this.addMostRecentEditor(group, e.editor, false , true );\n                        this.ensureOpenedEditorsLimit({ groupId: group.id, editor: e.editor }, group.id);\n                    }\n                    break;\n                }\n            }\n        }));\n        groupDisposables.add(group.onDidCloseEditor(e => {\n            this.removeMostRecentEditor(group, e.editor);\n        }));\n        groupDisposables.add(group.onDidActiveEditorChange(e => {\n            if (e.editor) {\n                this.addMostRecentEditor(group, e.editor, this.editorGroupsContainer.activeGroup === group, false );\n            }\n        }));\n        Event.once(group.onWillDispose)(() => dispose(groupDisposables));\n    }\n    onDidChangeEditorPartOptions(event) {\n        if (!equals(event.newPartOptions.limit, event.oldPartOptions.limit)) {\n            const activeGroup = this.editorGroupsContainer.activeGroup;\n            let exclude = undefined;\n            if (activeGroup.activeEditor) {\n                exclude = { editor: activeGroup.activeEditor, groupId: activeGroup.id };\n            }\n            this.ensureOpenedEditorsLimit(exclude);\n        }\n    }\n    addMostRecentEditor(group, editor, isActive, isNew) {\n        const key = this.ensureKey(group, editor);\n        const mostRecentEditor = this.mostRecentEditorsMap.first;\n        if (isActive || !mostRecentEditor) {\n            this.mostRecentEditorsMap.set(key, key, mostRecentEditor ? 1  : undefined);\n        }\n        else {\n            this.mostRecentEditorsMap.set(key, key, 1 );\n            this.mostRecentEditorsMap.set(mostRecentEditor, mostRecentEditor, 1 );\n        }\n        if (isNew) {\n            this.updateEditorResourcesMap(editor, true);\n        }\n        this._onDidMostRecentlyActiveEditorsChange.fire();\n    }\n    updateEditorResourcesMap(editor, add) {\n        let resource = undefined;\n        let typeId = undefined;\n        let editorId = undefined;\n        if (editor instanceof SideBySideEditorInput) {\n            resource = editor.primary.resource;\n            typeId = editor.primary.typeId;\n            editorId = editor.primary.editorId;\n        }\n        else {\n            resource = editor.resource;\n            typeId = editor.typeId;\n            editorId = editor.editorId;\n        }\n        if (!resource) {\n            return;\n        }\n        const identifier = this.toIdentifier(typeId, editorId);\n        if (add) {\n            let editorsPerResource = this.editorsPerResourceCounter.get(resource);\n            if (!editorsPerResource) {\n                editorsPerResource = ( new Map());\n                this.editorsPerResourceCounter.set(resource, editorsPerResource);\n            }\n            editorsPerResource.set(identifier, (editorsPerResource.get(identifier) ?? 0) + 1);\n        }\n        else {\n            const editorsPerResource = this.editorsPerResourceCounter.get(resource);\n            if (editorsPerResource) {\n                const counter = editorsPerResource.get(identifier) ?? 0;\n                if (counter > 1) {\n                    editorsPerResource.set(identifier, counter - 1);\n                }\n                else {\n                    editorsPerResource.delete(identifier);\n                    if (editorsPerResource.size === 0) {\n                        this.editorsPerResourceCounter.delete(resource);\n                    }\n                }\n            }\n        }\n    }\n    removeMostRecentEditor(group, editor) {\n        this.updateEditorResourcesMap(editor, false);\n        const key = this.findKey(group, editor);\n        if (key) {\n            this.mostRecentEditorsMap.delete(key);\n            const map = this.keyMap.get(group.id);\n            if (map && map.delete(key.editor) && map.size === 0) {\n                this.keyMap.delete(group.id);\n            }\n            this._onDidMostRecentlyActiveEditorsChange.fire();\n        }\n    }\n    findKey(group, editor) {\n        const groupMap = this.keyMap.get(group.id);\n        if (!groupMap) {\n            return undefined;\n        }\n        return groupMap.get(editor);\n    }\n    ensureKey(group, editor) {\n        let groupMap = this.keyMap.get(group.id);\n        if (!groupMap) {\n            groupMap = ( new Map());\n            this.keyMap.set(group.id, groupMap);\n        }\n        let key = groupMap.get(editor);\n        if (!key) {\n            key = { groupId: group.id, editor };\n            groupMap.set(editor, key);\n        }\n        return key;\n    }\n    async ensureOpenedEditorsLimit(exclude, groupId) {\n        if (!this.editorGroupService.partOptions.limit?.enabled ||\n            typeof this.editorGroupService.partOptions.limit.value !== 'number' ||\n            this.editorGroupService.partOptions.limit.value <= 0) {\n            return;\n        }\n        const limit = this.editorGroupService.partOptions.limit.value;\n        if (this.editorGroupService.partOptions.limit?.perEditorGroup) {\n            if (typeof groupId === 'number') {\n                const group = this.editorGroupsContainer.getGroup(groupId);\n                if (group) {\n                    await this.doEnsureOpenedEditorsLimit(limit, ( group.getEditors(0 ).map(editor => ({ editor, groupId }))), exclude);\n                }\n            }\n            else {\n                for (const group of this.editorGroupsContainer.groups) {\n                    await this.ensureOpenedEditorsLimit(exclude, group.id);\n                }\n            }\n        }\n        else {\n            await this.doEnsureOpenedEditorsLimit(limit, [...( this.mostRecentEditorsMap.values())], exclude);\n        }\n    }\n    async doEnsureOpenedEditorsLimit(limit, mostRecentEditors, exclude) {\n        let mostRecentEditorsCountingForLimit;\n        if (this.editorGroupService.partOptions.limit?.excludeDirty) {\n            mostRecentEditorsCountingForLimit = mostRecentEditors.filter(({ editor }) => {\n                if ((editor.isDirty() && !editor.isSaving()) || editor.hasCapability(512 )) {\n                    return false;\n                }\n                return true;\n            });\n        }\n        else {\n            mostRecentEditorsCountingForLimit = mostRecentEditors;\n        }\n        if (limit >= mostRecentEditorsCountingForLimit.length) {\n            return;\n        }\n        const leastRecentlyClosableEditors = mostRecentEditorsCountingForLimit.reverse().filter(({ editor, groupId }) => {\n            if ((editor.isDirty() && !editor.isSaving()) || editor.hasCapability(512 )) {\n                return false;\n            }\n            if (exclude && editor === exclude.editor && groupId === exclude.groupId) {\n                return false;\n            }\n            if (this.editorGroupsContainer.getGroup(groupId)?.isSticky(editor)) {\n                return false;\n            }\n            return true;\n        });\n        let editorsToCloseCount = mostRecentEditorsCountingForLimit.length - limit;\n        const mapGroupToEditorsToClose = ( new Map());\n        for (const { groupId, editor } of leastRecentlyClosableEditors) {\n            let editorsInGroupToClose = mapGroupToEditorsToClose.get(groupId);\n            if (!editorsInGroupToClose) {\n                editorsInGroupToClose = [];\n                mapGroupToEditorsToClose.set(groupId, editorsInGroupToClose);\n            }\n            editorsInGroupToClose.push(editor);\n            editorsToCloseCount--;\n            if (editorsToCloseCount === 0) {\n                break;\n            }\n        }\n        for (const [groupId, editors] of mapGroupToEditorsToClose) {\n            const group = this.editorGroupsContainer.getGroup(groupId);\n            if (group) {\n                await group.closeEditors(editors, { preserveFocus: true });\n            }\n        }\n    }\n    saveState() {\n        if (this.isScoped) {\n            return;\n        }\n        if (this.mostRecentEditorsMap.isEmpty()) {\n            this.storageService.remove(EditorsObserver_1.STORAGE_KEY, 1 );\n        }\n        else {\n            this.storageService.store(EditorsObserver_1.STORAGE_KEY, JSON.stringify(this.serialize()), 1 , 1 );\n        }\n    }\n    serialize() {\n        const registry = ( Registry.as(EditorExtensions.EditorFactory));\n        const entries = [...( this.mostRecentEditorsMap.values())];\n        const mapGroupToSerializableEditorsOfGroup = ( new Map());\n        return {\n            entries: coalesce(( entries.map(({ editor, groupId }) => {\n                const group = this.editorGroupsContainer.getGroup(groupId);\n                if (!group) {\n                    return undefined;\n                }\n                let serializableEditorsOfGroup = mapGroupToSerializableEditorsOfGroup.get(group);\n                if (!serializableEditorsOfGroup) {\n                    serializableEditorsOfGroup = group.getEditors(1 ).filter(editor => {\n                        const editorSerializer = registry.getEditorSerializer(editor);\n                        return editorSerializer?.canSerialize(editor);\n                    });\n                    mapGroupToSerializableEditorsOfGroup.set(group, serializableEditorsOfGroup);\n                }\n                const index = serializableEditorsOfGroup.indexOf(editor);\n                if (index === -1) {\n                    return undefined;\n                }\n                return { groupId, index };\n            })))\n        };\n    }\n    async loadState() {\n        if (this.editorGroupsContainer === this.editorGroupService.mainPart || this.editorGroupsContainer === this.editorGroupService) {\n            await this.editorGroupService.whenReady;\n        }\n        let hasRestorableState = false;\n        if (!this.isScoped) {\n            const serialized = this.storageService.get(EditorsObserver_1.STORAGE_KEY, 1 );\n            if (serialized) {\n                hasRestorableState = true;\n                this.deserialize(JSON.parse(serialized));\n            }\n        }\n        if (!hasRestorableState) {\n            const groups = this.editorGroupsContainer.getGroups(1 );\n            for (let i = groups.length - 1; i >= 0; i--) {\n                const group = groups[i];\n                const groupEditorsMru = group.getEditors(0 );\n                for (let i = groupEditorsMru.length - 1; i >= 0; i--) {\n                    this.addMostRecentEditor(group, groupEditorsMru[i], true , true );\n                }\n            }\n        }\n        for (const group of this.editorGroupsContainer.groups) {\n            this.registerGroupListeners(group);\n        }\n    }\n    deserialize(serialized) {\n        const mapValues = [];\n        for (const { groupId, index } of serialized.entries) {\n            const group = this.editorGroupsContainer.getGroup(groupId);\n            if (!group) {\n                continue;\n            }\n            const editor = group.getEditorByIndex(index);\n            if (!editor) {\n                continue;\n            }\n            const editorIdentifier = this.ensureKey(group, editor);\n            mapValues.push([editorIdentifier, editorIdentifier]);\n            this.updateEditorResourcesMap(editor, true);\n        }\n        this.mostRecentEditorsMap.fromJSON(mapValues);\n    }\n};\nEditorsObserver = EditorsObserver_1 = ( __decorate([\n    ( __param(1, IEditorGroupsService)),\n    ( __param(2, IStorageService))\n], EditorsObserver));\nexport { EditorsObserver };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { EditorModel } from './editorModel.js';\nimport { IFileService } from '../../../platform/files/common/files.service.js';\nimport { Mimes } from '../../../base/common/mime.js';\nlet BinaryEditorModel = class BinaryEditorModel extends EditorModel {\n    constructor(resource, name, fileService) {\n        super();\n        this.resource = resource;\n        this.name = name;\n        this.fileService = fileService;\n        this.mime = Mimes.binary;\n    }\n    getName() {\n        return this.name;\n    }\n    getSize() {\n        return this.size;\n    }\n    getMime() {\n        return this.mime;\n    }\n    getETag() {\n        return this.etag;\n    }\n    async resolve() {\n        if (this.fileService.hasProvider(this.resource)) {\n            const stat = await this.fileService.stat(this.resource);\n            this.etag = stat.etag;\n            if (typeof stat.size === 'number') {\n                this.size = stat.size;\n            }\n        }\n        return super.resolve();\n    }\n};\nBinaryEditorModel = ( __decorate([\n    ( __param(2, IFileService))\n], BinaryEditorModel));\nexport { BinaryEditorModel };\n","import { __decorate, __param } from '../../../../../../../../external/tslib/tslib.es6.js';\nimport { DEFAULT_EDITOR_ASSOCIATION, findViewStateForEditor, isResourceEditorInput } from '../../../../common/editor.js';\nimport { AbstractTextResourceEditorInput } from '../../../../common/editor/textResourceEditorInput.js';\nimport { BinaryEditorModel } from '../../../../common/editor/binaryEditorModel.js';\nimport { IFileService } from '../../../../../platform/files/common/files.service.js';\nimport { ITextFileService } from '../../../../services/textfile/common/textfiles.service.js';\nimport { IInstantiationService } from '../../../../../platform/instantiation/common/instantiation.js';\nimport { DisposableStore, dispose } from '../../../../../base/common/lifecycle.js';\nimport { ITextModelService } from '../../../../../editor/common/services/resolverService.js';\nimport { FILE_EDITOR_INPUT_ID, BINARY_FILE_EDITOR_ID, TEXT_FILE_EDITOR_ID } from '../../common/files.js';\nimport { ILabelService } from '../../../../../platform/label/common/label.service.js';\nimport { IFilesConfigurationService } from '../../../../services/filesConfiguration/common/filesConfigurationService.service.js';\nimport { IEditorService } from '../../../../services/editor/common/editorService.service.js';\nimport { isEqual } from '../../../../../base/common/resources.js';\nimport { Event } from '../../../../../base/common/event.js';\nimport { Schemas } from '../../../../../base/common/network.js';\nimport { createTextBufferFactory } from '../../../../../editor/common/model/textModel.js';\nimport { IPathService } from '../../../../services/path/common/pathService.service.js';\nimport { ITextResourceConfigurationService } from '../../../../../editor/common/services/textResourceConfiguration.js';\nimport { ICustomEditorLabelService } from '../../../../services/editor/common/customEditorLabelService.service.js';\nvar FileEditorInput_1;\nlet FileEditorInput = FileEditorInput_1 = class FileEditorInput extends AbstractTextResourceEditorInput {\n    get typeId() {\n        return FILE_EDITOR_INPUT_ID;\n    }\n    get editorId() {\n        return DEFAULT_EDITOR_ASSOCIATION.id;\n    }\n    get capabilities() {\n        let capabilities = 32 ;\n        if (this.model) {\n            if (this.model.isReadonly()) {\n                capabilities |= 2 ;\n            }\n        }\n        else {\n            if (this.fileService.hasProvider(this.resource)) {\n                if (this.filesConfigurationService.isReadonly(this.resource)) {\n                    capabilities |= 2 ;\n                }\n            }\n            else {\n                capabilities |= 4 ;\n            }\n        }\n        if (!((capabilities & 2) )) {\n            capabilities |= 128 ;\n        }\n        return capabilities;\n    }\n    constructor(resource, preferredResource, preferredName, preferredDescription, preferredEncoding, preferredLanguageId, preferredContents, instantiationService, textFileService, textModelService, labelService, fileService, filesConfigurationService, editorService, pathService, textResourceConfigurationService, customEditorLabelService) {\n        super(resource, preferredResource, editorService, textFileService, labelService, fileService, filesConfigurationService, textResourceConfigurationService, customEditorLabelService);\n        this.instantiationService = instantiationService;\n        this.textModelService = textModelService;\n        this.pathService = pathService;\n        this.forceOpenAs = 0 ;\n        this.model = undefined;\n        this.cachedTextFileModelReference = undefined;\n        this.modelListeners = this._register(( new DisposableStore()));\n        this.model = this.textFileService.files.get(resource);\n        if (preferredName) {\n            this.setPreferredName(preferredName);\n        }\n        if (preferredDescription) {\n            this.setPreferredDescription(preferredDescription);\n        }\n        if (preferredEncoding) {\n            this.setPreferredEncoding(preferredEncoding);\n        }\n        if (preferredLanguageId) {\n            this.setPreferredLanguageId(preferredLanguageId);\n        }\n        if (typeof preferredContents === 'string') {\n            this.setPreferredContents(preferredContents);\n        }\n        this._register(this.textFileService.files.onDidCreate(model => this.onDidCreateTextFileModel(model)));\n        if (this.model) {\n            this.registerModelListeners(this.model);\n        }\n    }\n    onDidCreateTextFileModel(model) {\n        if (isEqual(model.resource, this.resource)) {\n            this.model = model;\n            this.registerModelListeners(model);\n        }\n    }\n    registerModelListeners(model) {\n        this.modelListeners.clear();\n        this.modelListeners.add(model.onDidChangeDirty(() => this._onDidChangeDirty.fire()));\n        this.modelListeners.add(model.onDidChangeReadonly(() => this._onDidChangeCapabilities.fire()));\n        this.modelListeners.add(model.onDidSaveError(() => this._onDidChangeDirty.fire()));\n        this.modelListeners.add(Event.once(model.onWillDispose)(() => {\n            this.modelListeners.clear();\n            this.model = undefined;\n        }));\n    }\n    getName() {\n        return this.preferredName || super.getName();\n    }\n    setPreferredName(name) {\n        if (!this.allowLabelOverride()) {\n            return;\n        }\n        if (this.preferredName !== name) {\n            this.preferredName = name;\n            this._onDidChangeLabel.fire();\n        }\n    }\n    allowLabelOverride() {\n        return this.resource.scheme !== this.pathService.defaultUriScheme &&\n            this.resource.scheme !== Schemas.vscodeUserData &&\n            this.resource.scheme !== Schemas.file &&\n            this.resource.scheme !== Schemas.vscodeRemote;\n    }\n    getPreferredName() {\n        return this.preferredName;\n    }\n    isReadonly() {\n        return this.model ? this.model.isReadonly() : this.filesConfigurationService.isReadonly(this.resource);\n    }\n    getDescription(verbosity) {\n        return this.preferredDescription || super.getDescription(verbosity);\n    }\n    setPreferredDescription(description) {\n        if (!this.allowLabelOverride()) {\n            return;\n        }\n        if (this.preferredDescription !== description) {\n            this.preferredDescription = description;\n            this._onDidChangeLabel.fire();\n        }\n    }\n    getPreferredDescription() {\n        return this.preferredDescription;\n    }\n    getTitle(verbosity) {\n        let title = super.getTitle(verbosity);\n        const preferredTitle = this.getPreferredTitle();\n        if (preferredTitle) {\n            title = `${preferredTitle} (${title})`;\n        }\n        return title;\n    }\n    getPreferredTitle() {\n        if (this.preferredName && this.preferredDescription) {\n            return `${this.preferredName} ${this.preferredDescription}`;\n        }\n        if (this.preferredName || this.preferredDescription) {\n            return this.preferredName ?? this.preferredDescription;\n        }\n        return undefined;\n    }\n    getEncoding() {\n        if (this.model) {\n            return this.model.getEncoding();\n        }\n        return this.preferredEncoding;\n    }\n    getPreferredEncoding() {\n        return this.preferredEncoding;\n    }\n    async setEncoding(encoding, mode) {\n        this.setPreferredEncoding(encoding);\n        return this.model?.setEncoding(encoding, mode);\n    }\n    setPreferredEncoding(encoding) {\n        this.preferredEncoding = encoding;\n        this.setForceOpenAsText();\n    }\n    getLanguageId() {\n        if (this.model) {\n            return this.model.getLanguageId();\n        }\n        return this.preferredLanguageId;\n    }\n    getPreferredLanguageId() {\n        return this.preferredLanguageId;\n    }\n    setLanguageId(languageId, source) {\n        this.setPreferredLanguageId(languageId);\n        this.model?.setLanguageId(languageId, source);\n    }\n    setPreferredLanguageId(languageId) {\n        this.preferredLanguageId = languageId;\n        this.setForceOpenAsText();\n    }\n    setPreferredContents(contents) {\n        this.preferredContents = contents;\n        this.setForceOpenAsText();\n    }\n    setForceOpenAsText() {\n        this.forceOpenAs = 1 ;\n    }\n    setForceOpenAsBinary() {\n        this.forceOpenAs = 2 ;\n    }\n    isDirty() {\n        return !!(this.model?.isDirty());\n    }\n    isSaving() {\n        if (this.model?.hasState(0 ) || this.model?.hasState(3 ) || this.model?.hasState(5 )) {\n            return false;\n        }\n        if (this.filesConfigurationService.hasShortAutoSaveDelay(this)) {\n            return true;\n        }\n        return super.isSaving();\n    }\n    prefersEditorPane(editorPanes) {\n        if (this.forceOpenAs === 2 ) {\n            return editorPanes.find(editorPane => editorPane.typeId === BINARY_FILE_EDITOR_ID);\n        }\n        return editorPanes.find(editorPane => editorPane.typeId === TEXT_FILE_EDITOR_ID);\n    }\n    resolve(options) {\n        if (this.forceOpenAs === 2 ) {\n            return this.doResolveAsBinary();\n        }\n        return this.doResolveAsText(options);\n    }\n    async doResolveAsText(options) {\n        try {\n            const preferredContents = this.preferredContents;\n            this.preferredContents = undefined;\n            await this.textFileService.files.resolve(this.resource, {\n                languageId: this.preferredLanguageId,\n                encoding: this.preferredEncoding,\n                contents: typeof preferredContents === 'string' ? createTextBufferFactory(preferredContents) : undefined,\n                reload: { async: true },\n                allowBinary: this.forceOpenAs === 1 ,\n                reason: 1 ,\n                limits: this.ensureLimits(options)\n            });\n            if (!this.cachedTextFileModelReference) {\n                this.cachedTextFileModelReference = await this.textModelService.createModelReference(this.resource);\n            }\n            const model = this.cachedTextFileModelReference.object;\n            if (this.isDisposed()) {\n                this.disposeModelReference();\n            }\n            return model;\n        }\n        catch (error) {\n            if (error.textFileOperationResult === 0 ) {\n                return this.doResolveAsBinary();\n            }\n            throw error;\n        }\n    }\n    async doResolveAsBinary() {\n        const model = this.instantiationService.createInstance(BinaryEditorModel, this.preferredResource, this.getName());\n        await model.resolve();\n        return model;\n    }\n    isResolved() {\n        return !!this.model;\n    }\n    async rename(group, target) {\n        return {\n            editor: {\n                resource: target,\n                encoding: this.getEncoding(),\n                options: {\n                    viewState: findViewStateForEditor(this, group, this.editorService)\n                }\n            }\n        };\n    }\n    toUntyped(options) {\n        const untypedInput = {\n            resource: this.preferredResource,\n            forceFile: true,\n            options: {\n                override: this.editorId\n            }\n        };\n        if (typeof options?.preserveViewState === 'number') {\n            untypedInput.encoding = this.getEncoding();\n            untypedInput.languageId = this.getLanguageId();\n            untypedInput.contents = (() => {\n                const model = this.textFileService.files.get(this.resource);\n                if (model?.isDirty() && !model.textEditorModel.isTooLargeForHeapOperation()) {\n                    return model.textEditorModel.getValue();\n                }\n                return undefined;\n            })();\n            untypedInput.options = {\n                ...untypedInput.options,\n                viewState: findViewStateForEditor(this, options.preserveViewState, this.editorService)\n            };\n        }\n        return untypedInput;\n    }\n    matches(otherInput) {\n        if (this === otherInput) {\n            return true;\n        }\n        if (otherInput instanceof FileEditorInput_1) {\n            return isEqual(otherInput.resource, this.resource);\n        }\n        if (isResourceEditorInput(otherInput)) {\n            return super.matches(otherInput);\n        }\n        return false;\n    }\n    dispose() {\n        this.model = undefined;\n        this.disposeModelReference();\n        super.dispose();\n    }\n    disposeModelReference() {\n        dispose(this.cachedTextFileModelReference);\n        this.cachedTextFileModelReference = undefined;\n    }\n};\nFileEditorInput = FileEditorInput_1 = ( __decorate([\n    ( __param(7, IInstantiationService)),\n    ( __param(8, ITextFileService)),\n    ( __param(9, ITextModelService)),\n    ( __param(10, ILabelService)),\n    ( __param(11, IFileService)),\n    ( __param(12, IFilesConfigurationService)),\n    ( __param(13, IEditorService)),\n    ( __param(14, IPathService)),\n    ( __param(15, ITextResourceConfigurationService)),\n    ( __param(16, ICustomEditorLabelService))\n], FileEditorInput));\nexport { FileEditorInput };\n","import { localize } from '../../../../nls.js';\nimport { EditorResourceAccessor, SideBySideEditor } from '../../../common/editor.js';\nimport { SideBySideEditorInput } from '../../../common/editor/sideBySideEditorInput.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { toErrorMessage } from '../../../../base/common/errorMessage.js';\nimport { CommandsRegistry } from '../../../../platform/commands/common/commands.js';\nimport { KeybindingsRegistry } from '../../../../platform/keybinding/common/keybindingsRegistry.js';\nimport { KeyChord } from '../../../../base/common/keyCodes.js';\nimport { getOpenEditorsViewMultiSelection } from './files.js';\nimport { resolveCommandsContext } from '../../../browser/parts/editor/editorCommandsContext.js';\nimport '../../../../platform/notification/common/notification.js';\nimport { INotificationService } from '../../../../platform/notification/common/notification.service.js';\nimport { IEditorService } from '../../../services/editor/common/editorService.service.js';\nimport { IEditorGroupsService } from '../../../services/editor/common/editorGroupsService.service.js';\nimport { isEqual } from '../../../../base/common/resources.js';\nimport { ICodeEditorService } from '../../../../editor/browser/services/codeEditorService.js';\nimport { EmbeddedCodeEditorWidget } from '../../../../editor/browser/widget/codeEditor/embeddedCodeEditorWidget.js';\nimport { ITextFileService } from '../../../services/textfile/common/textfiles.service.js';\nimport { isCancellationError } from '../../../../base/common/errors.js';\nimport { toAction } from '../../../../base/common/actions.js';\nimport { hash } from '../../../../base/common/hash.js';\nimport { SAVE_FILE_COMMAND_ID, SAVE_FILE_WITHOUT_FORMATTING_COMMAND_ID, SAVE_FILE_AS_COMMAND_ID, SAVE_ALL_COMMAND_ID, SAVE_ALL_IN_GROUP_COMMAND_ID, SAVE_FILES_COMMAND_ID, REVERT_FILE_COMMAND_ID } from './fileConstants.js';\nimport { IListService } from '../../../../platform/list/browser/listService.service.js';\nimport Severity$1 from '../../../../base/common/severity.js';\nasync function saveSelectedEditors(accessor, options) {\n    const editorGroupService = accessor.get(IEditorGroupsService);\n    const codeEditorService = accessor.get(ICodeEditorService);\n    const textFileService = accessor.get(ITextFileService);\n    let editors = getOpenEditorsViewMultiSelection(accessor);\n    if (!editors) {\n        const activeGroup = editorGroupService.activeGroup;\n        if (activeGroup.activeEditor) {\n            editors = [];\n            if (activeGroup.activeEditor instanceof SideBySideEditorInput &&\n                !options?.saveAs && !(activeGroup.activeEditor.primary.hasCapability(4 ) || activeGroup.activeEditor.secondary.hasCapability(4 )) &&\n                activeGroup.activeEditor.secondary.isModified()) {\n                editors.push({ groupId: activeGroup.id, editor: activeGroup.activeEditor.primary });\n                editors.push({ groupId: activeGroup.id, editor: activeGroup.activeEditor.secondary });\n            }\n            else {\n                editors.push({ groupId: activeGroup.id, editor: activeGroup.activeEditor });\n            }\n        }\n    }\n    if (!editors || editors.length === 0) {\n        return;\n    }\n    await doSaveEditors(accessor, editors, options);\n    const focusedCodeEditor = codeEditorService.getFocusedCodeEditor();\n    if (focusedCodeEditor instanceof EmbeddedCodeEditorWidget && !focusedCodeEditor.isSimpleWidget) {\n        const resource = focusedCodeEditor.getModel()?.uri;\n        if (resource && !( (editors.some(\n            ({ editor }) => isEqual(EditorResourceAccessor.getCanonicalUri(editor, { supportSideBySide: SideBySideEditor.PRIMARY }), resource)\n        )))) {\n            const model = textFileService.files.get(resource);\n            if (!model?.isReadonly()) {\n                await textFileService.save(resource, options);\n            }\n        }\n    }\n}\nfunction saveDirtyEditorsOfGroups(accessor, groups, options) {\n    const dirtyEditors = [];\n    for (const group of groups) {\n        for (const editor of group.getEditors(0 )) {\n            if (editor.isDirty()) {\n                dirtyEditors.push({ groupId: group.id, editor });\n            }\n        }\n    }\n    return doSaveEditors(accessor, dirtyEditors, options);\n}\nasync function doSaveEditors(accessor, editors, options) {\n    const editorService = accessor.get(IEditorService);\n    const notificationService = accessor.get(INotificationService);\n    const instantiationService = accessor.get(IInstantiationService);\n    try {\n        await editorService.save(editors, options);\n    }\n    catch (error) {\n        if (!isCancellationError(error)) {\n            const actions = [toAction({ id: 'workbench.action.files.saveEditors', label: ( localize(3749, \"Retry\")), run: () => instantiationService.invokeFunction(accessor => doSaveEditors(accessor, editors, options)) })];\n            const editorsToRevert = editors.filter(({ editor }) => !editor.hasCapability(4 ) );\n            if (editorsToRevert.length > 0) {\n                actions.push(toAction({ id: 'workbench.action.files.revertEditors', label: editorsToRevert.length > 1 ? ( localize(3750, \"Revert All\")) : ( localize(3751, \"Revert\")), run: () => editorService.revert(editorsToRevert) }));\n            }\n            notificationService.notify({\n                id: ( (editors.map(({ editor }) => hash(editor.resource?.toString())))).join(),\n                severity: Severity$1.Error,\n                message: ( localize(\n                    3752,\n                    \"Failed to save '{0}': {1}\",\n                    ( (editors.map(({ editor }) => editor.getName()))).join(', '),\n                    toErrorMessage(error, false)\n                )),\n                actions: { primary: actions }\n            });\n        }\n    }\n}\nKeybindingsRegistry.registerCommandAndKeybindingRule({\n    when: undefined,\n    weight: 200 ,\n    primary: 2048  | 49 ,\n    id: SAVE_FILE_COMMAND_ID,\n    handler: accessor => {\n        return saveSelectedEditors(accessor, { reason: 1 , force: true  });\n    }\n});\nKeybindingsRegistry.registerCommandAndKeybindingRule({\n    when: undefined,\n    weight: 200 ,\n    primary: KeyChord(2048  | 41 , 49 ),\n    win: { primary: KeyChord(2048  | 41 , 2048  | 1024  | 49 ) },\n    id: SAVE_FILE_WITHOUT_FORMATTING_COMMAND_ID,\n    handler: accessor => {\n        return saveSelectedEditors(accessor, { reason: 1 , force: true , skipSaveParticipants: true });\n    }\n});\nKeybindingsRegistry.registerCommandAndKeybindingRule({\n    id: SAVE_FILE_AS_COMMAND_ID,\n    weight: 200 ,\n    when: undefined,\n    primary: 2048  | 1024  | 49 ,\n    handler: accessor => {\n        return saveSelectedEditors(accessor, { reason: 1 , saveAs: true });\n    }\n});\nKeybindingsRegistry.registerCommandAndKeybindingRule({\n    when: undefined,\n    weight: 200 ,\n    primary: undefined,\n    mac: { primary: 2048  | 512  | 49  },\n    win: { primary: KeyChord(2048  | 41 , 49 ) },\n    id: SAVE_ALL_COMMAND_ID,\n    handler: accessor => {\n        return saveDirtyEditorsOfGroups(accessor, accessor.get(IEditorGroupsService).getGroups(1 ), { reason: 1  });\n    }\n});\nCommandsRegistry.registerCommand({\n    id: SAVE_ALL_IN_GROUP_COMMAND_ID,\n    handler: (accessor, _, editorContext) => {\n        const editorGroupsService = accessor.get(IEditorGroupsService);\n        const resolvedContext = resolveCommandsContext([editorContext], accessor.get(IEditorService), editorGroupsService, accessor.get(IListService));\n        let groups = undefined;\n        if (!resolvedContext.groupedEditors.length) {\n            groups = editorGroupsService.getGroups(1 );\n        }\n        else {\n            groups = ( (resolvedContext.groupedEditors.map(({ group }) => group)));\n        }\n        return saveDirtyEditorsOfGroups(accessor, groups, { reason: 1  });\n    }\n});\nCommandsRegistry.registerCommand({\n    id: SAVE_FILES_COMMAND_ID,\n    handler: async (accessor) => {\n        const editorService = accessor.get(IEditorService);\n        const res = await editorService.saveAll({ includeUntitled: false, reason: 1  });\n        return res.success;\n    }\n});\nCommandsRegistry.registerCommand({\n    id: REVERT_FILE_COMMAND_ID,\n    handler: async (accessor) => {\n        const editorGroupService = accessor.get(IEditorGroupsService);\n        const editorService = accessor.get(IEditorService);\n        let editors = getOpenEditorsViewMultiSelection(accessor);\n        if (!editors) {\n            const activeGroup = editorGroupService.activeGroup;\n            if (activeGroup.activeEditor) {\n                editors = [{ groupId: activeGroup.id, editor: activeGroup.activeEditor }];\n            }\n        }\n        if (!editors || editors.length === 0) {\n            return;\n        }\n        try {\n            await editorService.revert(editors.filter(({ editor }) => !editor.hasCapability(4 ) ), { force: true });\n        }\n        catch (error) {\n            const notificationService = accessor.get(INotificationService);\n            notificationService.error(( localize(\n                3753,\n                \"Failed to revert '{0}': {1}\",\n                ( (editors.map(({ editor }) => editor.getName()))).join(', '),\n                toErrorMessage(error, false)\n            )));\n        }\n    }\n});\n","import { Registry } from '../../../../platform/registry/common/platform.js';\nimport { EditorExtensions } from '../../../common/editor.js';\nimport { FileEditorInput } from './editors/fileEditorInput.js';\nimport { FILE_EDITOR_INPUT_ID } from '../common/files.js';\n( Registry.as(EditorExtensions.EditorFactory)).registerFileEditorFactory({\n    typeId: FILE_EDITOR_INPUT_ID,\n    createFileEditor: (resource, preferredResource, preferredName, preferredDescription, preferredEncoding, preferredLanguageId, preferredContents, instantiationService) => {\n        return instantiationService.createInstance(FileEditorInput, resource, preferredResource, preferredName, preferredDescription, preferredEncoding, preferredLanguageId, preferredContents);\n    },\n    isFileEditor: (obj) => {\n        return obj instanceof FileEditorInput;\n    }\n});\n","import { URI } from '../../../../base/common/uri.js';\nimport { IListService } from '../../../../platform/list/browser/listService.service.js';\nimport { OpenEditor } from '../common/files.js';\nimport { EditorResourceAccessor, SideBySideEditor } from '../../../common/editor.js';\nimport { List } from '../../../../base/browser/ui/list/listWidget.js';\nimport { ExplorerItem } from '../common/explorerModel.js';\nimport { coalesce } from '../../../../base/common/arrays.js';\nimport { AsyncDataTree } from '../../../../base/browser/ui/tree/asyncDataTree.js';\nimport { isActiveElement } from '../../../../base/browser/dom.js';\nfunction getFocus(listService) {\n    const list = listService.lastFocusedList;\n    const element = list?.getHTMLElement();\n    if (element && isActiveElement(element)) {\n        let focus;\n        if (list instanceof List) {\n            const focused = list.getFocusedElements();\n            if (focused.length) {\n                focus = focused[0];\n            }\n        }\n        else if (list instanceof AsyncDataTree) {\n            const focused = list.getFocus();\n            if (focused.length) {\n                focus = focused[0];\n            }\n        }\n        return focus;\n    }\n    return undefined;\n}\nfunction getResourceForCommand(commandArg, editorService, listService) {\n    if (URI.isUri(commandArg)) {\n        return commandArg;\n    }\n    const focus = getFocus(listService);\n    if (focus instanceof ExplorerItem) {\n        return focus.resource;\n    }\n    else if (focus instanceof OpenEditor) {\n        return focus.getResource();\n    }\n    return EditorResourceAccessor.getOriginalUri(editorService.activeEditor, { supportSideBySide: SideBySideEditor.PRIMARY });\n}\nfunction getMultiSelectedResources(commandArg, listService, editorSerice, editorGroupService, explorerService) {\n    const list = listService.lastFocusedList;\n    const element = list?.getHTMLElement();\n    if (element && isActiveElement(element)) {\n        if (list instanceof AsyncDataTree && list.getFocus().every(item => item instanceof ExplorerItem)) {\n            const context = explorerService.getContext(true, true);\n            if (context.length) {\n                return ( context.map(c => c.resource));\n            }\n        }\n        if (list instanceof List) {\n            const selection = coalesce(( list.getSelectedElements().filter(s => s instanceof OpenEditor).map((oe) => oe.getResource())));\n            const focusedElements = list.getFocusedElements();\n            const focus = focusedElements.length ? focusedElements[0] : undefined;\n            let mainUriStr = undefined;\n            if (URI.isUri(commandArg)) {\n                mainUriStr = ( commandArg.toString());\n            }\n            else if (focus instanceof OpenEditor) {\n                const focusedResource = focus.getResource();\n                mainUriStr = focusedResource ? ( focusedResource.toString()) : undefined;\n            }\n            const mainIndex = selection.findIndex(s => ( s.toString()) === mainUriStr);\n            if (mainIndex !== -1) {\n                const mainResource = selection[mainIndex];\n                selection.splice(mainIndex, 1);\n                selection.unshift(mainResource);\n                return selection;\n            }\n        }\n    }\n    const activeGroup = editorGroupService.activeGroup;\n    const selection = activeGroup.selectedEditors;\n    if (selection.length > 1 && URI.isUri(commandArg)) {\n        const mainEditorSelectionIndex = selection.findIndex(e => e.matches({ resource: commandArg }));\n        if (mainEditorSelectionIndex !== -1) {\n            const mainEditor = selection[mainEditorSelectionIndex];\n            selection.splice(mainEditorSelectionIndex, 1);\n            selection.unshift(mainEditor);\n            return ( selection.map(editor => EditorResourceAccessor.getOriginalUri(editor))).filter(uri => !!uri);\n        }\n    }\n    const result = getResourceForCommand(commandArg, editorSerice, listService);\n    return !!result ? [result] : [];\n}\nfunction getOpenEditorsViewMultiSelection(accessor) {\n    const list = accessor.get(IListService).lastFocusedList;\n    const element = list?.getHTMLElement();\n    if (element && isActiveElement(element)) {\n        if (list instanceof List) {\n            const selection = coalesce(list.getSelectedElements().filter(s => s instanceof OpenEditor));\n            const focusedElements = list.getFocusedElements();\n            const focus = focusedElements.length ? focusedElements[0] : undefined;\n            let mainEditor = undefined;\n            if (focus instanceof OpenEditor) {\n                mainEditor = focus;\n            }\n            if (( selection.some(s => s === mainEditor))) {\n                return selection;\n            }\n            return mainEditor ? [mainEditor] : undefined;\n        }\n    }\n    return undefined;\n}\nexport { getMultiSelectedResources, getOpenEditorsViewMultiSelection, getResourceForCommand };\n","import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';\nimport { isCodeEditor, isDiffEditor, isCompositeEditor, getCodeEditor } from '../../../../editor/browser/editorBrowser.js';\nimport { AbstractCodeEditorService } from '../../../../editor/browser/services/abstractCodeEditorService.js';\nimport { IThemeService } from '../../../../platform/theme/common/themeService.service.js';\nimport { SIDE_GROUP, ACTIVE_GROUP } from '../common/editorService.js';\nimport { IEditorService } from '../common/editorService.service.js';\nimport '../../../../platform/instantiation/common/instantiation.js';\nimport { isEqual } from '../../../../base/common/resources.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.service.js';\nimport { applyTextEditorOptions } from '../../../common/editor/editorOptions.js';\nlet CodeEditorService = class CodeEditorService extends AbstractCodeEditorService {\n    constructor(editorService, themeService, configurationService) {\n        super(themeService);\n        this.editorService = editorService;\n        this.configurationService = configurationService;\n        this._register(this.registerCodeEditorOpenHandler(this.doOpenCodeEditor.bind(this)));\n        this._register(this.registerCodeEditorOpenHandler(this.doOpenCodeEditorFromDiff.bind(this)));\n    }\n    getActiveCodeEditor() {\n        const activeTextEditorControl = this.editorService.activeTextEditorControl;\n        if (isCodeEditor(activeTextEditorControl)) {\n            return activeTextEditorControl;\n        }\n        if (isDiffEditor(activeTextEditorControl)) {\n            return activeTextEditorControl.getModifiedEditor();\n        }\n        const activeControl = this.editorService.activeEditorPane?.getControl();\n        if (isCompositeEditor(activeControl) && isCodeEditor(activeControl.activeCodeEditor)) {\n            return activeControl.activeCodeEditor;\n        }\n        return null;\n    }\n    async doOpenCodeEditorFromDiff(input, source, sideBySide) {\n        const activeTextEditorControl = this.editorService.activeTextEditorControl;\n        if (!sideBySide &&\n            isDiffEditor(activeTextEditorControl) &&\n            input.options &&\n            input.resource &&\n            source === activeTextEditorControl.getModifiedEditor() &&\n            activeTextEditorControl.getModel() &&\n            isEqual(input.resource, activeTextEditorControl.getModel()?.modified.uri)\n        ) {\n            const targetEditor = activeTextEditorControl.getModifiedEditor();\n            applyTextEditorOptions(input.options, targetEditor, 0 );\n            return targetEditor;\n        }\n        return null;\n    }\n    async doOpenCodeEditor(input, source, sideBySide) {\n        const enablePreviewFromCodeNavigation = this.configurationService.getValue().workbench?.editor?.enablePreviewFromCodeNavigation;\n        if (!enablePreviewFromCodeNavigation &&\n            source &&\n            !input.options?.pinned &&\n            !sideBySide &&\n            !isEqual(source.getModel()?.uri, input.resource)\n        ) {\n            for (const visiblePane of this.editorService.visibleEditorPanes) {\n                if (getCodeEditor(visiblePane.getControl()) === source) {\n                    visiblePane.group.pinEditor();\n                    break;\n                }\n            }\n        }\n        const control = await this.editorService.openEditor(input, sideBySide ? SIDE_GROUP : ACTIVE_GROUP);\n        if (control) {\n            const widget = control.getControl();\n            if (isCodeEditor(widget)) {\n                return widget;\n            }\n            if (isCompositeEditor(widget) && isCodeEditor(widget.activeCodeEditor)) {\n                return widget.activeCodeEditor;\n            }\n        }\n        return null;\n    }\n};\nCodeEditorService = ( __decorate([\n    ( __param(0, IEditorService)),\n    ( __param(1, IThemeService)),\n    ( __param(2, IConfigurationService))\n], CodeEditorService));\nexport { CodeEditorService };\n","import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { EditorResourceAccessor, SideBySideEditor, isEditorInput, isEditorInputWithOptions, isResourceMergeEditorInput, isResourceDiffEditorInput, isResourceEditorInput, isEditorInputWithOptionsAndGroup } from '../../../common/editor.js';\nimport { EditorInput } from '../../../common/editor/editorInput.js';\nimport { SideBySideEditorInput } from '../../../common/editor/sideBySideEditorInput.js';\nimport { ResourceMap, ResourceSet } from '../../../../base/common/map.js';\nimport { FileChangesEvent } from '../../../../platform/files/common/files.js';\nimport { IFileService } from '../../../../platform/files/common/files.service.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { joinPath } from '../../../../base/common/resources.js';\nimport { DiffEditorInput } from '../../../common/editor/diffEditorInput.js';\nimport { SideBySideEditor as SideBySideEditor$1 } from '../../../browser/parts/editor/sideBySideEditor.js';\nimport { isEditorReplacement } from '../common/editorGroupsService.js';\nimport { IEditorGroupsService } from '../common/editorGroupsService.service.js';\nimport { isPreferredGroup } from '../common/editorService.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.service.js';\nimport { Disposable, dispose, DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { distinct, coalesce } from '../../../../base/common/arrays.js';\nimport { isCodeEditor, isDiffEditor, isCompositeEditor } from '../../../../editor/browser/editorBrowser.js';\nimport { isUndefined } from '../../../../base/common/types.js';\nimport { EditorsObserver } from '../../../browser/parts/editor/editorsObserver.js';\nimport { timeout, Promises } from '../../../../base/common/async.js';\nimport { IWorkspaceContextService } from '../../../../platform/workspace/common/workspace.service.js';\nimport { indexOfPath } from '../../../../base/common/extpath.js';\nimport { IUriIdentityService } from '../../../../platform/uriIdentity/common/uriIdentity.service.js';\nimport { IEditorResolverService } from '../common/editorResolverService.service.js';\nimport { IWorkspaceTrustRequestService } from '../../../../platform/workspace/common/workspaceTrust.service.js';\nimport { IHostService } from '../../host/browser/host.service.js';\nimport { findGroup } from '../common/editorGroupFinder.js';\nimport { ITextEditorService } from '../../textfile/common/textEditorService.service.js';\nvar EditorService_1;\nlet EditorService = EditorService_1 = class EditorService extends Disposable {\n    constructor(editorGroupsContainer, editorGroupService, instantiationService, fileService, configurationService, contextService, uriIdentityService, editorResolverService, workspaceTrustRequestService, hostService, textEditorService) {\n        super();\n        this.editorGroupService = editorGroupService;\n        this.instantiationService = instantiationService;\n        this.fileService = fileService;\n        this.configurationService = configurationService;\n        this.contextService = contextService;\n        this.uriIdentityService = uriIdentityService;\n        this.editorResolverService = editorResolverService;\n        this.workspaceTrustRequestService = workspaceTrustRequestService;\n        this.hostService = hostService;\n        this.textEditorService = textEditorService;\n        this._onDidActiveEditorChange = this._register(( new Emitter()));\n        this.onDidActiveEditorChange = this._onDidActiveEditorChange.event;\n        this._onDidVisibleEditorsChange = this._register(( new Emitter()));\n        this.onDidVisibleEditorsChange = this._onDidVisibleEditorsChange.event;\n        this._onDidEditorsChange = this._register(( new Emitter()));\n        this.onDidEditorsChange = this._onDidEditorsChange.event;\n        this._onWillOpenEditor = this._register(( new Emitter()));\n        this.onWillOpenEditor = this._onWillOpenEditor.event;\n        this._onDidCloseEditor = this._register(( new Emitter()));\n        this.onDidCloseEditor = this._onDidCloseEditor.event;\n        this._onDidOpenEditorFail = this._register(( new Emitter()));\n        this.onDidOpenEditorFail = this._onDidOpenEditorFail.event;\n        this._onDidMostRecentlyActiveEditorsChange = this._register(( new Emitter()));\n        this.onDidMostRecentlyActiveEditorsChange = this._onDidMostRecentlyActiveEditorsChange.event;\n        this.lastActiveEditor = undefined;\n        this.activeOutOfWorkspaceWatchers = ( new ResourceMap());\n        this.closeOnFileDelete = false;\n        this.editorGroupsContainer = editorGroupsContainer ?? editorGroupService;\n        this.editorsObserver = this._register(this.instantiationService.createInstance(EditorsObserver, this.editorGroupsContainer));\n        this.onConfigurationUpdated();\n        this.registerListeners();\n    }\n    createScoped(editorGroupsContainer, disposables) {\n        return disposables.add(( new EditorService_1(\n            editorGroupsContainer === 'main' ? this.editorGroupService.mainPart : editorGroupsContainer,\n            this.editorGroupService,\n            this.instantiationService,\n            this.fileService,\n            this.configurationService,\n            this.contextService,\n            this.uriIdentityService,\n            this.editorResolverService,\n            this.workspaceTrustRequestService,\n            this.hostService,\n            this.textEditorService\n        )));\n    }\n    registerListeners() {\n        if (this.editorGroupsContainer === this.editorGroupService.mainPart || this.editorGroupsContainer === this.editorGroupService) {\n            this.editorGroupService.whenReady.then(() => this.onEditorGroupsReady());\n        }\n        else {\n            this.onEditorGroupsReady();\n        }\n        this._register(this.editorGroupsContainer.onDidChangeActiveGroup(group => this.handleActiveEditorChange(group)));\n        this._register(this.editorGroupsContainer.onDidAddGroup(group => this.registerGroupListeners(group)));\n        this._register(this.editorsObserver.onDidMostRecentlyActiveEditorsChange(() => this._onDidMostRecentlyActiveEditorsChange.fire()));\n        this._register(this.onDidVisibleEditorsChange(() => this.handleVisibleEditorsChange()));\n        this._register(this.fileService.onDidRunOperation(e => this.onDidRunFileOperation(e)));\n        this._register(this.fileService.onDidFilesChange(e => this.onDidFilesChange(e)));\n        this._register(this.configurationService.onDidChangeConfiguration(e => this.onConfigurationUpdated(e)));\n    }\n    onEditorGroupsReady() {\n        for (const group of this.editorGroupsContainer.groups) {\n            this.registerGroupListeners(group);\n        }\n        if (this.activeEditor) {\n            this.doHandleActiveEditorChangeEvent();\n            this._onDidVisibleEditorsChange.fire();\n        }\n    }\n    handleActiveEditorChange(group) {\n        if (group !== this.editorGroupsContainer.activeGroup) {\n            return;\n        }\n        if (!this.lastActiveEditor && !group.activeEditor) {\n            return;\n        }\n        this.doHandleActiveEditorChangeEvent();\n    }\n    doHandleActiveEditorChangeEvent() {\n        const activeGroup = this.editorGroupsContainer.activeGroup;\n        this.lastActiveEditor = activeGroup.activeEditor ?? undefined;\n        this._onDidActiveEditorChange.fire();\n    }\n    registerGroupListeners(group) {\n        const groupDisposables = ( new DisposableStore());\n        groupDisposables.add(group.onDidModelChange(e => {\n            this._onDidEditorsChange.fire({ groupId: group.id, event: e });\n        }));\n        groupDisposables.add(group.onDidActiveEditorChange(() => {\n            this.handleActiveEditorChange(group);\n            this._onDidVisibleEditorsChange.fire();\n        }));\n        groupDisposables.add(group.onWillOpenEditor(e => {\n            this._onWillOpenEditor.fire(e);\n        }));\n        groupDisposables.add(group.onDidCloseEditor(e => {\n            this._onDidCloseEditor.fire(e);\n        }));\n        groupDisposables.add(group.onDidOpenEditorFail(editor => {\n            this._onDidOpenEditorFail.fire({ editor, groupId: group.id });\n        }));\n        Event.once(group.onWillDispose)(() => {\n            dispose(groupDisposables);\n        });\n    }\n    handleVisibleEditorsChange() {\n        const visibleOutOfWorkspaceResources = ( new ResourceSet());\n        for (const editor of this.visibleEditors) {\n            const resources = distinct(coalesce([\n                EditorResourceAccessor.getCanonicalUri(editor, { supportSideBySide: SideBySideEditor.PRIMARY }),\n                EditorResourceAccessor.getCanonicalUri(editor, { supportSideBySide: SideBySideEditor.SECONDARY })\n            ]), resource => ( resource.toString()));\n            for (const resource of resources) {\n                if (this.fileService.hasProvider(resource) && !this.contextService.isInsideWorkspace(resource)) {\n                    visibleOutOfWorkspaceResources.add(resource);\n                }\n            }\n        }\n        for (const resource of ( this.activeOutOfWorkspaceWatchers.keys())) {\n            if (!( visibleOutOfWorkspaceResources.has(resource))) {\n                dispose(this.activeOutOfWorkspaceWatchers.get(resource));\n                this.activeOutOfWorkspaceWatchers.delete(resource);\n            }\n        }\n        for (const resource of ( visibleOutOfWorkspaceResources.keys())) {\n            if (!this.activeOutOfWorkspaceWatchers.get(resource)) {\n                const disposable = this.fileService.watch(resource);\n                this.activeOutOfWorkspaceWatchers.set(resource, disposable);\n            }\n        }\n    }\n    async onDidRunFileOperation(e) {\n        if (e.isOperation(2 )) {\n            this.handleMovedFile(e.resource, e.target.resource);\n        }\n        if (e.isOperation(1 ) || e.isOperation(2 )) {\n            this.handleDeletedFile(e.resource, false, e.target ? e.target.resource : undefined);\n        }\n    }\n    onDidFilesChange(e) {\n        if (e.gotDeleted()) {\n            this.handleDeletedFile(e, true);\n        }\n    }\n    async handleMovedFile(source, target) {\n        for (const group of this.editorGroupsContainer.groups) {\n            const replacements = [];\n            for (const editor of group.editors) {\n                const resource = editor.resource;\n                if (!resource || !this.uriIdentityService.extUri.isEqualOrParent(resource, source)) {\n                    continue;\n                }\n                let targetResource;\n                if (this.uriIdentityService.extUri.isEqual(source, resource)) {\n                    targetResource = target;\n                }\n                else {\n                    const index = indexOfPath(resource.path, source.path, this.uriIdentityService.extUri.ignorePathCasing(resource));\n                    targetResource = joinPath(target, resource.path.substr(index + source.path.length + 1));\n                }\n                const moveResult = await editor.rename(group.id, targetResource);\n                if (!moveResult) {\n                    return;\n                }\n                const optionOverrides = {\n                    preserveFocus: true,\n                    pinned: group.isPinned(editor),\n                    sticky: group.isSticky(editor),\n                    index: group.getIndexOfEditor(editor),\n                    inactive: !group.isActive(editor)\n                };\n                if (isEditorInput(moveResult.editor)) {\n                    replacements.push({\n                        editor,\n                        replacement: moveResult.editor,\n                        options: {\n                            ...moveResult.options,\n                            ...optionOverrides\n                        }\n                    });\n                }\n                else {\n                    replacements.push({\n                        editor,\n                        replacement: {\n                            ...moveResult.editor,\n                            options: {\n                                ...moveResult.editor.options,\n                                ...optionOverrides\n                            }\n                        }\n                    });\n                }\n            }\n            if (replacements.length) {\n                this.replaceEditors(replacements, group);\n            }\n        }\n    }\n    onConfigurationUpdated(e) {\n        if (e && !e.affectsConfiguration('workbench.editor.closeOnFileDelete')) {\n            return;\n        }\n        const configuration = this.configurationService.getValue();\n        if (typeof configuration.workbench?.editor?.closeOnFileDelete === 'boolean') {\n            this.closeOnFileDelete = configuration.workbench.editor.closeOnFileDelete;\n        }\n        else {\n            this.closeOnFileDelete = false;\n        }\n    }\n    handleDeletedFile(arg1, isExternal, movedTo) {\n        for (const editor of this.getAllNonDirtyEditors({ includeUntitled: false, supportSideBySide: true })) {\n            (async () => {\n                const resource = editor.resource;\n                if (!resource) {\n                    return;\n                }\n                if (this.closeOnFileDelete || !isExternal) {\n                    if (movedTo && this.uriIdentityService.extUri.isEqualOrParent(resource, movedTo)) {\n                        return;\n                    }\n                    let matches = false;\n                    if (arg1 instanceof FileChangesEvent) {\n                        matches = arg1.contains(resource, 2 );\n                    }\n                    else {\n                        matches = this.uriIdentityService.extUri.isEqualOrParent(resource, arg1);\n                    }\n                    if (!matches) {\n                        return;\n                    }\n                    let exists = false;\n                    if (isExternal && this.fileService.hasProvider(resource)) {\n                        await timeout(100);\n                        exists = await this.fileService.exists(resource);\n                    }\n                    if (!exists && !editor.isDisposed()) {\n                        editor.dispose();\n                    }\n                }\n            })();\n        }\n    }\n    getAllNonDirtyEditors(options) {\n        const editors = [];\n        function conditionallyAddEditor(editor) {\n            if (editor.hasCapability(4 ) && !options.includeUntitled) {\n                return;\n            }\n            if (editor.isDirty()) {\n                return;\n            }\n            editors.push(editor);\n        }\n        for (const editor of this.editors) {\n            if (options.supportSideBySide && editor instanceof SideBySideEditorInput) {\n                conditionallyAddEditor(editor.primary);\n                conditionallyAddEditor(editor.secondary);\n            }\n            else {\n                conditionallyAddEditor(editor);\n            }\n        }\n        return editors;\n    }\n    get activeEditorPane() {\n        return this.editorGroupsContainer.activeGroup?.activeEditorPane;\n    }\n    get activeTextEditorControl() {\n        const activeEditorPane = this.activeEditorPane;\n        if (activeEditorPane) {\n            const activeControl = activeEditorPane.getControl();\n            if (isCodeEditor(activeControl) || isDiffEditor(activeControl)) {\n                return activeControl;\n            }\n            if (isCompositeEditor(activeControl) && isCodeEditor(activeControl.activeCodeEditor)) {\n                return activeControl.activeCodeEditor;\n            }\n        }\n        return undefined;\n    }\n    get activeTextEditorLanguageId() {\n        let activeCodeEditor = undefined;\n        const activeTextEditorControl = this.activeTextEditorControl;\n        if (isDiffEditor(activeTextEditorControl)) {\n            activeCodeEditor = activeTextEditorControl.getModifiedEditor();\n        }\n        else {\n            activeCodeEditor = activeTextEditorControl;\n        }\n        return activeCodeEditor?.getModel()?.getLanguageId();\n    }\n    get count() {\n        return this.editorsObserver.count;\n    }\n    get editors() {\n        return ( this.getEditors(1 ).map(({ editor }) => editor));\n    }\n    getEditors(order, options) {\n        switch (order) {\n            case 0 :\n                if (options?.excludeSticky) {\n                    return this.editorsObserver.editors.filter(({ groupId, editor }) => !this.editorGroupsContainer.getGroup(groupId)?.isSticky(editor));\n                }\n                return this.editorsObserver.editors;\n            case 1 : {\n                const editors = [];\n                for (const group of this.editorGroupsContainer.getGroups(2 )) {\n                    editors.push(...( group.getEditors(1 , options).map(editor => ({ editor, groupId: group.id }))));\n                }\n                return editors;\n            }\n        }\n    }\n    get activeEditor() {\n        const activeGroup = this.editorGroupsContainer.activeGroup;\n        return activeGroup ? activeGroup.activeEditor ?? undefined : undefined;\n    }\n    get visibleEditorPanes() {\n        return coalesce(( this.editorGroupsContainer.groups.map(group => group.activeEditorPane)));\n    }\n    get visibleTextEditorControls() {\n        const visibleTextEditorControls = [];\n        for (const visibleEditorPane of this.visibleEditorPanes) {\n            const controls = [];\n            if (visibleEditorPane instanceof SideBySideEditor$1) {\n                controls.push(visibleEditorPane.getPrimaryEditorPane()?.getControl());\n                controls.push(visibleEditorPane.getSecondaryEditorPane()?.getControl());\n            }\n            else {\n                controls.push(visibleEditorPane.getControl());\n            }\n            for (const control of controls) {\n                if (isCodeEditor(control) || isDiffEditor(control)) {\n                    visibleTextEditorControls.push(control);\n                }\n            }\n        }\n        return visibleTextEditorControls;\n    }\n    get visibleEditors() {\n        return coalesce(( this.editorGroupsContainer.groups.map(group => group.activeEditor)));\n    }\n    async openEditor(editor, optionsOrPreferredGroup, preferredGroup) {\n        let typedEditor = undefined;\n        let options = isEditorInput(editor) ? optionsOrPreferredGroup : editor.options;\n        let group = undefined;\n        if (isPreferredGroup(optionsOrPreferredGroup)) {\n            preferredGroup = optionsOrPreferredGroup;\n        }\n        if (!isEditorInput(editor)) {\n            const resolvedEditor = await this.editorResolverService.resolveEditor(editor, preferredGroup);\n            if (resolvedEditor === 1 ) {\n                return;\n            }\n            if (isEditorInputWithOptionsAndGroup(resolvedEditor)) {\n                typedEditor = resolvedEditor.editor;\n                options = resolvedEditor.options;\n                group = resolvedEditor.group;\n            }\n        }\n        if (!typedEditor) {\n            typedEditor = isEditorInput(editor) ? editor : await this.textEditorService.resolveTextEditor(editor);\n        }\n        if (!group) {\n            let activation = undefined;\n            const findGroupResult = this.instantiationService.invokeFunction(findGroup, { editor: typedEditor, options }, preferredGroup);\n            if (findGroupResult instanceof Promise) {\n                ([group, activation] = await findGroupResult);\n            }\n            else {\n                ([group, activation] = findGroupResult);\n            }\n            if (activation) {\n                options = { ...options, activation };\n            }\n        }\n        return group.openEditor(typedEditor, options);\n    }\n    async openEditors(editors, preferredGroup, options) {\n        if (options?.validateTrust) {\n            const editorsTrusted = await this.handleWorkspaceTrust(editors);\n            if (!editorsTrusted) {\n                return [];\n            }\n        }\n        const mapGroupToTypedEditors = ( new Map());\n        for (const editor of editors) {\n            let typedEditor = undefined;\n            let group = undefined;\n            if (!isEditorInputWithOptions(editor)) {\n                const resolvedEditor = await this.editorResolverService.resolveEditor(editor, preferredGroup);\n                if (resolvedEditor === 1 ) {\n                    continue;\n                }\n                if (isEditorInputWithOptionsAndGroup(resolvedEditor)) {\n                    typedEditor = resolvedEditor;\n                    group = resolvedEditor.group;\n                }\n            }\n            if (!typedEditor) {\n                typedEditor = isEditorInputWithOptions(editor) ? editor : { editor: await this.textEditorService.resolveTextEditor(editor), options: editor.options };\n            }\n            if (!group) {\n                const findGroupResult = this.instantiationService.invokeFunction(findGroup, typedEditor, preferredGroup);\n                if (findGroupResult instanceof Promise) {\n                    ([group] = await findGroupResult);\n                }\n                else {\n                    ([group] = findGroupResult);\n                }\n            }\n            let targetGroupEditors = mapGroupToTypedEditors.get(group);\n            if (!targetGroupEditors) {\n                targetGroupEditors = [];\n                mapGroupToTypedEditors.set(group, targetGroupEditors);\n            }\n            targetGroupEditors.push(typedEditor);\n        }\n        const result = [];\n        for (const [group, editors] of mapGroupToTypedEditors) {\n            result.push(group.openEditors(editors));\n        }\n        return coalesce(await Promises.settled(result));\n    }\n    async handleWorkspaceTrust(editors) {\n        const { resources, diffMode, mergeMode } = this.extractEditorResources(editors);\n        const trustResult = await this.workspaceTrustRequestService.requestOpenFilesTrust(resources);\n        switch (trustResult) {\n            case 1 :\n                return true;\n            case 2 :\n                await this.hostService.openWindow(( resources.map(resource => ({ fileUri: resource }))), { forceNewWindow: true, diffMode, mergeMode });\n                return false;\n            case 3 :\n                return false;\n        }\n    }\n    extractEditorResources(editors) {\n        const resources = ( new ResourceSet());\n        let diffMode = false;\n        let mergeMode = false;\n        for (const editor of editors) {\n            if (isEditorInputWithOptions(editor)) {\n                const resource = EditorResourceAccessor.getOriginalUri(editor.editor, { supportSideBySide: SideBySideEditor.BOTH });\n                if (URI.isUri(resource)) {\n                    resources.add(resource);\n                }\n                else if (resource) {\n                    if (resource.primary) {\n                        resources.add(resource.primary);\n                    }\n                    if (resource.secondary) {\n                        resources.add(resource.secondary);\n                    }\n                    diffMode = editor.editor instanceof DiffEditorInput;\n                }\n            }\n            else {\n                if (isResourceMergeEditorInput(editor)) {\n                    if (URI.isUri(editor.input1)) {\n                        resources.add(editor.input1.resource);\n                    }\n                    if (URI.isUri(editor.input2)) {\n                        resources.add(editor.input2.resource);\n                    }\n                    if (URI.isUri(editor.base)) {\n                        resources.add(editor.base.resource);\n                    }\n                    if (URI.isUri(editor.result)) {\n                        resources.add(editor.result.resource);\n                    }\n                    mergeMode = true;\n                }\n                if (isResourceDiffEditorInput(editor)) {\n                    if (URI.isUri(editor.original.resource)) {\n                        resources.add(editor.original.resource);\n                    }\n                    if (URI.isUri(editor.modified.resource)) {\n                        resources.add(editor.modified.resource);\n                    }\n                    diffMode = true;\n                }\n                else if (isResourceEditorInput(editor)) {\n                    resources.add(editor.resource);\n                }\n            }\n        }\n        return {\n            resources: Array.from(( resources.keys())),\n            diffMode,\n            mergeMode\n        };\n    }\n    isOpened(editor) {\n        return this.editorsObserver.hasEditor({\n            resource: this.uriIdentityService.asCanonicalUri(editor.resource),\n            typeId: editor.typeId,\n            editorId: editor.editorId\n        });\n    }\n    isVisible(editor) {\n        for (const group of this.editorGroupsContainer.groups) {\n            if (group.activeEditor?.matches(editor)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    async closeEditor({ editor, groupId }, options) {\n        const group = this.editorGroupsContainer.getGroup(groupId);\n        await group?.closeEditor(editor, options);\n    }\n    async closeEditors(editors, options) {\n        const mapGroupToEditors = ( new Map());\n        for (const { editor, groupId } of editors) {\n            const group = this.editorGroupsContainer.getGroup(groupId);\n            if (!group) {\n                continue;\n            }\n            let editors = mapGroupToEditors.get(group);\n            if (!editors) {\n                editors = [];\n                mapGroupToEditors.set(group, editors);\n            }\n            editors.push(editor);\n        }\n        for (const [group, editors] of mapGroupToEditors) {\n            await group.closeEditors(editors, options);\n        }\n    }\n    findEditors(arg1, options, arg2) {\n        const resource = URI.isUri(arg1) ? arg1 : arg1.resource;\n        const typeId = URI.isUri(arg1) ? undefined : arg1.typeId;\n        if (options?.supportSideBySide !== SideBySideEditor.ANY && options?.supportSideBySide !== SideBySideEditor.SECONDARY) {\n            if (!this.editorsObserver.hasEditors(resource)) {\n                if (URI.isUri(arg1) || isUndefined(arg2)) {\n                    return [];\n                }\n                return undefined;\n            }\n        }\n        if (!isUndefined(arg2)) {\n            const targetGroup = typeof arg2 === 'number' ? this.editorGroupsContainer.getGroup(arg2) : arg2;\n            if (URI.isUri(arg1)) {\n                if (!targetGroup) {\n                    return [];\n                }\n                return targetGroup.findEditors(resource, options);\n            }\n            else {\n                if (!targetGroup) {\n                    return undefined;\n                }\n                const editors = targetGroup.findEditors(resource, options);\n                for (const editor of editors) {\n                    if (editor.typeId === typeId) {\n                        return editor;\n                    }\n                }\n                return undefined;\n            }\n        }\n        else {\n            const result = [];\n            for (const group of this.editorGroupsContainer.getGroups(1 )) {\n                const editors = [];\n                if (URI.isUri(arg1)) {\n                    editors.push(...this.findEditors(arg1, options, group));\n                }\n                else {\n                    const editor = this.findEditors(arg1, options, group);\n                    if (editor) {\n                        editors.push(editor);\n                    }\n                }\n                result.push(...( editors.map(editor => ({ editor, groupId: group.id }))));\n            }\n            return result;\n        }\n    }\n    async replaceEditors(replacements, group) {\n        const targetGroup = typeof group === 'number' ? this.editorGroupsContainer.getGroup(group) : group;\n        const typedReplacements = [];\n        for (const replacement of replacements) {\n            let typedReplacement = undefined;\n            if (!isEditorInput(replacement.replacement)) {\n                const resolvedEditor = await this.editorResolverService.resolveEditor(replacement.replacement, targetGroup);\n                if (resolvedEditor === 1 ) {\n                    continue;\n                }\n                if (isEditorInputWithOptionsAndGroup(resolvedEditor)) {\n                    typedReplacement = {\n                        editor: replacement.editor,\n                        replacement: resolvedEditor.editor,\n                        options: resolvedEditor.options,\n                        forceReplaceDirty: replacement.forceReplaceDirty\n                    };\n                }\n            }\n            if (!typedReplacement) {\n                typedReplacement = {\n                    editor: replacement.editor,\n                    replacement: isEditorReplacement(replacement) ? replacement.replacement : await this.textEditorService.resolveTextEditor(replacement.replacement),\n                    options: isEditorReplacement(replacement) ? replacement.options : replacement.replacement.options,\n                    forceReplaceDirty: replacement.forceReplaceDirty\n                };\n            }\n            typedReplacements.push(typedReplacement);\n        }\n        return targetGroup?.replaceEditors(typedReplacements);\n    }\n    async save(editors, options) {\n        if (!Array.isArray(editors)) {\n            editors = [editors];\n        }\n        const uniqueEditors = this.getUniqueEditors(editors);\n        const editorsToSaveParallel = [];\n        const editorsToSaveSequentially = [];\n        if (options?.saveAs) {\n            editorsToSaveSequentially.push(...uniqueEditors);\n        }\n        else {\n            for (const { groupId, editor } of uniqueEditors) {\n                if (editor.hasCapability(4 )) {\n                    editorsToSaveSequentially.push({ groupId, editor });\n                }\n                else {\n                    editorsToSaveParallel.push({ groupId, editor });\n                }\n            }\n        }\n        const saveResults = await Promises.settled(( editorsToSaveParallel.map(({ groupId, editor }) => {\n            if (options?.reason === 1 ) {\n                this.editorGroupsContainer.getGroup(groupId)?.pinEditor(editor);\n            }\n            return editor.save(groupId, options);\n        })));\n        for (const { groupId, editor } of editorsToSaveSequentially) {\n            if (editor.isDisposed()) {\n                continue;\n            }\n            const editorPane = await this.openEditor(editor, groupId);\n            const editorOptions = {\n                pinned: true,\n                viewState: editorPane?.getViewState()\n            };\n            const result = options?.saveAs ? await editor.saveAs(groupId, options) : await editor.save(groupId, options);\n            saveResults.push(result);\n            if (!result) {\n                break;\n            }\n            if (!editor.matches(result)) {\n                const targetGroups = editor.hasCapability(4 ) ? ( this.editorGroupsContainer.groups.map(group => group.id) ) : [groupId];\n                for (const targetGroup of targetGroups) {\n                    if (result instanceof EditorInput) {\n                        await this.replaceEditors([{ editor, replacement: result, options: editorOptions }], targetGroup);\n                    }\n                    else {\n                        await this.replaceEditors([{ editor, replacement: { ...result, options: editorOptions } }], targetGroup);\n                    }\n                }\n            }\n        }\n        return {\n            success: saveResults.every(result => !!result),\n            editors: coalesce(saveResults)\n        };\n    }\n    saveAll(options) {\n        return this.save(this.getAllModifiedEditors(options), options);\n    }\n    async revert(editors, options) {\n        if (!Array.isArray(editors)) {\n            editors = [editors];\n        }\n        const uniqueEditors = this.getUniqueEditors(editors);\n        await Promises.settled(( uniqueEditors.map(async ({ groupId, editor }) => {\n            this.editorGroupsContainer.getGroup(groupId)?.pinEditor(editor);\n            return editor.revert(groupId, options);\n        })));\n        return !( uniqueEditors.some(({ editor }) => editor.isDirty()));\n    }\n    async revertAll(options) {\n        return this.revert(this.getAllModifiedEditors(options), options);\n    }\n    getAllModifiedEditors(options) {\n        const editors = [];\n        for (const group of this.editorGroupsContainer.getGroups(1 )) {\n            for (const editor of group.getEditors(0 )) {\n                if (!editor.isModified()) {\n                    continue;\n                }\n                if ((typeof options?.includeUntitled === 'boolean' || !options?.includeUntitled?.includeScratchpad)\n                    && editor.hasCapability(512 )) {\n                    continue;\n                }\n                if (!options?.includeUntitled && editor.hasCapability(4 )) {\n                    continue;\n                }\n                if (options?.excludeSticky && group.isSticky(editor)) {\n                    continue;\n                }\n                editors.push({ groupId: group.id, editor });\n            }\n        }\n        return editors;\n    }\n    getUniqueEditors(editors) {\n        const uniqueEditors = [];\n        for (const { editor, groupId } of editors) {\n            if (( uniqueEditors.some(uniqueEditor => uniqueEditor.editor.matches(editor)))) {\n                continue;\n            }\n            uniqueEditors.push({ editor, groupId });\n        }\n        return uniqueEditors;\n    }\n    dispose() {\n        super.dispose();\n        this.activeOutOfWorkspaceWatchers.forEach(disposable => dispose(disposable));\n        this.activeOutOfWorkspaceWatchers.clear();\n    }\n};\nEditorService = EditorService_1 = ( __decorate([\n    ( __param(1, IEditorGroupsService)),\n    ( __param(2, IInstantiationService)),\n    ( __param(3, IFileService)),\n    ( __param(4, IConfigurationService)),\n    ( __param(5, IWorkspaceContextService)),\n    ( __param(6, IUriIdentityService)),\n    ( __param(7, IEditorResolverService)),\n    ( __param(8, IWorkspaceTrustRequestService)),\n    ( __param(9, IHostService)),\n    ( __param(10, ITextEditorService))\n], EditorService));\nexport { EditorService };\n","import { IConfigurationService } from '../../../../platform/configuration/common/configuration.service.js';\nimport { EditorActivation } from '../../../../platform/editor/common/editor.js';\nimport { isEditorInput, isEditorInputWithOptions } from '../../../common/editor.js';\nimport { preferredSideBySideGroupDirection } from './editorGroupsService.js';\nimport { IEditorGroupsService } from './editorGroupsService.service.js';\nimport { SIDE_GROUP, AUX_WINDOW_GROUP } from './editorService.js';\nfunction findGroup(accessor, editor, preferredGroup) {\n    const editorGroupService = accessor.get(IEditorGroupsService);\n    const configurationService = accessor.get(IConfigurationService);\n    const group = doFindGroup(editor, preferredGroup, editorGroupService, configurationService);\n    if (group instanceof Promise) {\n        return group.then(group => handleGroupActivation(group, editor, preferredGroup, editorGroupService));\n    }\n    return handleGroupActivation(group, editor, preferredGroup, editorGroupService);\n}\nfunction handleGroupActivation(group, editor, preferredGroup, editorGroupService) {\n    let activation = undefined;\n    if (editorGroupService.activeGroup !== group &&\n        editor.options && !editor.options.inactive &&\n        editor.options.preserveFocus &&\n        typeof editor.options.activation !== 'number' &&\n        preferredGroup !== SIDE_GROUP\n    ) {\n        activation = EditorActivation.ACTIVATE;\n    }\n    return [group, activation];\n}\nfunction doFindGroup(input, preferredGroup, editorGroupService, configurationService) {\n    let group;\n    const editor = isEditorInputWithOptions(input) ? input.editor : input;\n    const options = input.options;\n    if (preferredGroup && typeof preferredGroup !== 'number') {\n        group = preferredGroup;\n    }\n    else if (typeof preferredGroup === 'number' && preferredGroup >= 0) {\n        group = editorGroupService.getGroup(preferredGroup);\n    }\n    else if (preferredGroup === SIDE_GROUP) {\n        const direction = preferredSideBySideGroupDirection(configurationService);\n        let candidateGroup = editorGroupService.findGroup({ direction });\n        if (!candidateGroup || isGroupLockedForEditor(candidateGroup, editor)) {\n            candidateGroup = editorGroupService.addGroup(editorGroupService.activeGroup, direction);\n        }\n        group = candidateGroup;\n    }\n    else if (preferredGroup === AUX_WINDOW_GROUP) {\n        group = editorGroupService.createAuxiliaryEditorPart().then(group => group.activeGroup);\n    }\n    else if (!options || typeof options.index !== 'number') {\n        const groupsByLastActive = editorGroupService.getGroups(1 );\n        if (options?.revealIfVisible) {\n            for (const lastActiveGroup of groupsByLastActive) {\n                if (isActive(lastActiveGroup, editor)) {\n                    group = lastActiveGroup;\n                    break;\n                }\n            }\n        }\n        if (!group) {\n            if (options?.revealIfOpened || configurationService.getValue('workbench.editor.revealIfOpen') || (isEditorInput(editor) && editor.hasCapability(8 ))) {\n                let groupWithInputActive = undefined;\n                let groupWithInputOpened = undefined;\n                for (const group of groupsByLastActive) {\n                    if (isOpened(group, editor)) {\n                        if (!groupWithInputOpened) {\n                            groupWithInputOpened = group;\n                        }\n                        if (!groupWithInputActive && group.isActive(editor)) {\n                            groupWithInputActive = group;\n                        }\n                    }\n                    if (groupWithInputOpened && groupWithInputActive) {\n                        break;\n                    }\n                }\n                group = groupWithInputActive || groupWithInputOpened;\n            }\n        }\n    }\n    if (!group) {\n        let candidateGroup = editorGroupService.activeGroup;\n        if (isGroupLockedForEditor(candidateGroup, editor)) {\n            for (const group of editorGroupService.getGroups(1 )) {\n                if (isGroupLockedForEditor(group, editor)) {\n                    continue;\n                }\n                candidateGroup = group;\n                break;\n            }\n            if (isGroupLockedForEditor(candidateGroup, editor)) {\n                group = editorGroupService.addGroup(candidateGroup, preferredSideBySideGroupDirection(configurationService));\n            }\n            else {\n                group = candidateGroup;\n            }\n        }\n        else {\n            group = candidateGroup;\n        }\n    }\n    return group;\n}\nfunction isGroupLockedForEditor(group, editor) {\n    if (!group.isLocked) {\n        return false;\n    }\n    if (isOpened(group, editor)) {\n        return false;\n    }\n    return true;\n}\nfunction isActive(group, editor) {\n    if (!group.activeEditor) {\n        return false;\n    }\n    return group.activeEditor.matches(editor);\n}\nfunction isOpened(group, editor) {\n    for (const typedEditor of group.editors) {\n        if (typedEditor.matches(editor)) {\n            return true;\n        }\n    }\n    return false;\n}\nexport { findGroup };\n","import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';\nimport { Event } from '../../../../base/common/event.js';\nimport { Registry } from '../../../../platform/registry/common/platform.js';\nimport { ResourceMap } from '../../../../base/common/map.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { EditorExtensions, DEFAULT_EDITOR_ASSOCIATION, isResourceMergeEditorInput, isResourceDiffEditorInput, isResourceSideBySideEditorInput } from '../../../common/editor.js';\nimport { IUntitledTextEditorService } from '../../untitled/common/untitledTextEditorService.service.js';\nimport { Schemas } from '../../../../base/common/network.js';\nimport { DiffEditorInput } from '../../../common/editor/diffEditorInput.js';\nimport { SideBySideEditorInput } from '../../../common/editor/sideBySideEditorInput.js';\nimport { TextResourceEditorInput } from '../../../common/editor/textResourceEditorInput.js';\nimport { UntitledTextEditorInput } from '../../untitled/common/untitledTextEditorInput.js';\nimport { basename } from '../../../../base/common/resources.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IUriIdentityService } from '../../../../platform/uriIdentity/common/uriIdentity.service.js';\nimport { IFileService } from '../../../../platform/files/common/files.service.js';\nimport { RegisteredEditorPriority } from '../../editor/common/editorResolverService.js';\nimport { IEditorResolverService } from '../../editor/common/editorResolverService.service.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nlet TextEditorService = class TextEditorService extends Disposable {\n    constructor(untitledTextEditorService, instantiationService, uriIdentityService, fileService, editorResolverService) {\n        super();\n        this.untitledTextEditorService = untitledTextEditorService;\n        this.instantiationService = instantiationService;\n        this.uriIdentityService = uriIdentityService;\n        this.fileService = fileService;\n        this.editorResolverService = editorResolverService;\n        this.editorInputCache = ( new ResourceMap());\n        this.fileEditorFactory = ( Registry.as(EditorExtensions.EditorFactory)).getFileEditorFactory();\n        this.registerDefaultEditor();\n    }\n    registerDefaultEditor() {\n        this._register(this.editorResolverService.registerEditor('*', {\n            id: DEFAULT_EDITOR_ASSOCIATION.id,\n            label: DEFAULT_EDITOR_ASSOCIATION.displayName,\n            detail: DEFAULT_EDITOR_ASSOCIATION.providerDisplayName,\n            priority: RegisteredEditorPriority.builtin\n        }, {}, {\n            createEditorInput: editor => ({ editor: this.createTextEditor(editor) }),\n            createUntitledEditorInput: untitledEditor => ({ editor: this.createTextEditor(untitledEditor) }),\n            createDiffEditorInput: diffEditor => ({ editor: this.createTextEditor(diffEditor) })\n        }));\n    }\n    async resolveTextEditor(input) {\n        return this.createTextEditor(input);\n    }\n    createTextEditor(input) {\n        if (isResourceMergeEditorInput(input)) {\n            return this.createTextEditor(input.result);\n        }\n        if (isResourceDiffEditorInput(input)) {\n            const original = this.createTextEditor(input.original);\n            const modified = this.createTextEditor(input.modified);\n            return this.instantiationService.createInstance(DiffEditorInput, input.label, input.description, original, modified, undefined);\n        }\n        if (isResourceSideBySideEditorInput(input)) {\n            const primary = this.createTextEditor(input.primary);\n            const secondary = this.createTextEditor(input.secondary);\n            return this.instantiationService.createInstance(SideBySideEditorInput, input.label, input.description, secondary, primary);\n        }\n        const untitledInput = input;\n        if (untitledInput.forceUntitled || !untitledInput.resource || (untitledInput.resource.scheme === Schemas.untitled)) {\n            const untitledOptions = {\n                languageId: untitledInput.languageId,\n                initialValue: untitledInput.contents,\n                encoding: untitledInput.encoding\n            };\n            let untitledModel;\n            if (untitledInput.resource?.scheme === Schemas.untitled) {\n                untitledModel = this.untitledTextEditorService.create({ untitledResource: untitledInput.resource, ...untitledOptions });\n            }\n            else {\n                untitledModel = this.untitledTextEditorService.create({ associatedResource: untitledInput.resource, ...untitledOptions });\n            }\n            return this.createOrGetCached(untitledModel.resource, () => this.instantiationService.createInstance(UntitledTextEditorInput, untitledModel));\n        }\n        const textResourceEditorInput = input;\n        if (textResourceEditorInput.resource instanceof URI) {\n            const label = textResourceEditorInput.label || basename(textResourceEditorInput.resource);\n            const preferredResource = textResourceEditorInput.resource;\n            const canonicalResource = this.uriIdentityService.asCanonicalUri(preferredResource);\n            return this.createOrGetCached(canonicalResource, () => {\n                if (textResourceEditorInput.forceFile || this.fileService.hasProvider(canonicalResource)) {\n                    return this.fileEditorFactory.createFileEditor(canonicalResource, preferredResource, textResourceEditorInput.label, textResourceEditorInput.description, textResourceEditorInput.encoding, textResourceEditorInput.languageId, textResourceEditorInput.contents, this.instantiationService);\n                }\n                return this.instantiationService.createInstance(TextResourceEditorInput, canonicalResource, textResourceEditorInput.label, textResourceEditorInput.description, textResourceEditorInput.languageId, textResourceEditorInput.contents);\n            }, cachedInput => {\n                if (cachedInput instanceof UntitledTextEditorInput) {\n                    return;\n                }\n                else if (!(cachedInput instanceof TextResourceEditorInput)) {\n                    cachedInput.setPreferredResource(preferredResource);\n                    if (textResourceEditorInput.label) {\n                        cachedInput.setPreferredName(textResourceEditorInput.label);\n                    }\n                    if (textResourceEditorInput.description) {\n                        cachedInput.setPreferredDescription(textResourceEditorInput.description);\n                    }\n                    if (textResourceEditorInput.encoding) {\n                        cachedInput.setPreferredEncoding(textResourceEditorInput.encoding);\n                    }\n                    if (textResourceEditorInput.languageId) {\n                        cachedInput.setPreferredLanguageId(textResourceEditorInput.languageId);\n                    }\n                    if (typeof textResourceEditorInput.contents === 'string') {\n                        cachedInput.setPreferredContents(textResourceEditorInput.contents);\n                    }\n                }\n                else {\n                    if (label) {\n                        cachedInput.setName(label);\n                    }\n                    if (textResourceEditorInput.description) {\n                        cachedInput.setDescription(textResourceEditorInput.description);\n                    }\n                    if (textResourceEditorInput.languageId) {\n                        cachedInput.setPreferredLanguageId(textResourceEditorInput.languageId);\n                    }\n                    if (typeof textResourceEditorInput.contents === 'string') {\n                        cachedInput.setPreferredContents(textResourceEditorInput.contents);\n                    }\n                }\n            });\n        }\n        throw ( new Error(\n            `ITextEditorService: Unable to create texteditor from ${JSON.stringify(input)}`\n        ));\n    }\n    createOrGetCached(resource, factoryFn, cachedFn) {\n        let input = this.editorInputCache.get(resource);\n        if (input) {\n            cachedFn?.(input);\n            return input;\n        }\n        input = factoryFn();\n        this.editorInputCache.set(resource, input);\n        Event.once(input.onWillDispose)(() => this.editorInputCache.delete(resource));\n        return input;\n    }\n};\nTextEditorService = ( __decorate([\n    ( __param(0, IUntitledTextEditorService)),\n    ( __param(1, IInstantiationService)),\n    ( __param(2, IUriIdentityService)),\n    ( __param(3, IFileService)),\n    ( __param(4, IEditorResolverService))\n], TextEditorService));\nexport { TextEditorService };\n","import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';\nimport { DEFAULT_EDITOR_ASSOCIATION, findViewStateForEditor, isUntitledResourceEditorInput } from '../../../common/editor.js';\nimport { AbstractTextResourceEditorInput } from '../../../common/editor/textResourceEditorInput.js';\nimport { ITextFileService } from '../../textfile/common/textfiles.service.js';\nimport { ILabelService } from '../../../../platform/label/common/label.service.js';\nimport { IEditorService } from '../../editor/common/editorService.service.js';\nimport { IFileService } from '../../../../platform/files/common/files.service.js';\nimport { isEqual, toLocalResource } from '../../../../base/common/resources.js';\nimport { IWorkbenchEnvironmentService } from '../../environment/common/environmentService.service.js';\nimport { IPathService } from '../../path/common/pathService.service.js';\nimport { IFilesConfigurationService } from '../../filesConfiguration/common/filesConfigurationService.service.js';\nimport { ITextModelService } from '../../../../editor/common/services/resolverService.js';\nimport { DisposableStore, dispose } from '../../../../base/common/lifecycle.js';\nimport { ITextResourceConfigurationService } from '../../../../editor/common/services/textResourceConfiguration.js';\nimport { ICustomEditorLabelService } from '../../editor/common/customEditorLabelService.service.js';\nvar UntitledTextEditorInput_1;\nlet UntitledTextEditorInput = class UntitledTextEditorInput extends AbstractTextResourceEditorInput {\n    static { UntitledTextEditorInput_1 = this; }\n    static { this.ID = 'workbench.editors.untitledEditorInput'; }\n    get typeId() {\n        return UntitledTextEditorInput_1.ID;\n    }\n    get editorId() {\n        return DEFAULT_EDITOR_ASSOCIATION.id;\n    }\n    constructor(model, textFileService, labelService, editorService, fileService, environmentService, pathService, filesConfigurationService, textModelService, textResourceConfigurationService, customEditorLabelService) {\n        super(model.resource, undefined, editorService, textFileService, labelService, fileService, filesConfigurationService, textResourceConfigurationService, customEditorLabelService);\n        this.model = model;\n        this.environmentService = environmentService;\n        this.pathService = pathService;\n        this.textModelService = textModelService;\n        this.modelResolve = undefined;\n        this.modelDisposables = this._register(( new DisposableStore()));\n        this.cachedUntitledTextEditorModelReference = undefined;\n        this.registerModelListeners(model);\n        this._register(this.textFileService.untitled.onDidCreate(model => this.onDidCreateUntitledModel(model)));\n    }\n    registerModelListeners(model) {\n        this.modelDisposables.clear();\n        this.modelDisposables.add(model.onDidChangeDirty(() => this._onDidChangeDirty.fire()));\n        this.modelDisposables.add(model.onDidChangeName(() => this._onDidChangeLabel.fire()));\n        this.modelDisposables.add(model.onDidRevert(() => this.dispose()));\n    }\n    onDidCreateUntitledModel(model) {\n        if (isEqual(model.resource, this.model.resource) && model !== this.model) {\n            this.model = model;\n            this.registerModelListeners(model);\n        }\n    }\n    getName() {\n        return this.model.name;\n    }\n    getDescription(verbosity = 1 ) {\n        if (!this.model.hasAssociatedFilePath) {\n            const descriptionCandidate = this.resource.path;\n            if (descriptionCandidate !== this.getName()) {\n                return descriptionCandidate;\n            }\n            return undefined;\n        }\n        return super.getDescription(verbosity);\n    }\n    getTitle(verbosity) {\n        if (!this.model.hasAssociatedFilePath) {\n            const name = this.getName();\n            const description = this.getDescription();\n            if (description && description !== name) {\n                return `${name}  ${description}`;\n            }\n            return name;\n        }\n        return super.getTitle(verbosity);\n    }\n    isDirty() {\n        return this.model.isDirty();\n    }\n    getEncoding() {\n        return this.model.getEncoding();\n    }\n    setEncoding(encoding, mode ) {\n        return this.model.setEncoding(encoding);\n    }\n    get hasLanguageSetExplicitly() { return this.model.hasLanguageSetExplicitly; }\n    get hasAssociatedFilePath() { return this.model.hasAssociatedFilePath; }\n    setLanguageId(languageId, source) {\n        this.model.setLanguageId(languageId, source);\n    }\n    getLanguageId() {\n        return this.model.getLanguageId();\n    }\n    async resolve() {\n        if (!this.modelResolve) {\n            this.modelResolve = (async () => {\n                this.cachedUntitledTextEditorModelReference = await this.textModelService.createModelReference(this.resource);\n            })();\n        }\n        await this.modelResolve;\n        if (this.isDisposed()) {\n            this.disposeModelReference();\n        }\n        return this.model;\n    }\n    toUntyped(options) {\n        const untypedInput = {\n            resource: this.model.hasAssociatedFilePath ? toLocalResource(this.model.resource, this.environmentService.remoteAuthority, this.pathService.defaultUriScheme) : this.resource,\n            forceUntitled: true,\n            options: {\n                override: this.editorId\n            }\n        };\n        if (typeof options?.preserveViewState === 'number') {\n            untypedInput.encoding = this.getEncoding();\n            untypedInput.languageId = this.getLanguageId();\n            untypedInput.contents = this.model.isModified() ? this.model.textEditorModel?.getValue() : undefined;\n            untypedInput.options.viewState = findViewStateForEditor(this, options.preserveViewState, this.editorService);\n            if (typeof untypedInput.contents === 'string' && !this.model.hasAssociatedFilePath && !options.preserveResource) {\n                untypedInput.resource = undefined;\n            }\n        }\n        return untypedInput;\n    }\n    matches(otherInput) {\n        if (this === otherInput) {\n            return true;\n        }\n        if (otherInput instanceof UntitledTextEditorInput_1) {\n            return isEqual(otherInput.resource, this.resource);\n        }\n        if (isUntitledResourceEditorInput(otherInput)) {\n            return super.matches(otherInput);\n        }\n        return false;\n    }\n    dispose() {\n        this.modelResolve = undefined;\n        this.disposeModelReference();\n        super.dispose();\n    }\n    disposeModelReference() {\n        dispose(this.cachedUntitledTextEditorModelReference);\n        this.cachedUntitledTextEditorModelReference = undefined;\n    }\n};\nUntitledTextEditorInput = UntitledTextEditorInput_1 = ( __decorate([\n    ( __param(1, ITextFileService)),\n    ( __param(2, ILabelService)),\n    ( __param(3, IEditorService)),\n    ( __param(4, IFileService)),\n    ( __param(5, IWorkbenchEnvironmentService)),\n    ( __param(6, IPathService)),\n    ( __param(7, IFilesConfigurationService)),\n    ( __param(8, ITextModelService)),\n    ( __param(9, ITextResourceConfigurationService)),\n    ( __param(10, ICustomEditorLabelService))\n], UntitledTextEditorInput));\nexport { UntitledTextEditorInput };\n"],"names":[],"sourceRoot":""}