{"version":3,"file":"vendors-node_modules_vscode_vscode_src_vs_platform_theme_common_tokenClassificationRegistry_j-43a9f3.immt_editor.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAiE;AACX;AACE;AACb;AACuD;AACrC;AAC7D;AACA;AACA;AACA;AACA,qCAAqC,UAAU;AAC/C,6BAA6B,UAAU,UAAU,8BAA8B,EAAE,UAAU,KAAK,oCAAoC,EAAE,UAAU;AAChJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,wDAAK;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,wDAAK;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,wDAAK;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wDAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA,yCAAyC,0DAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,mCAAmC,iDAAQ;AAC3C;AACA;AACA;AACA,2CAA2C,iDAAQ;AACnD;AACA;AACA,yBAAyB;AACzB;AACA;AACA,kDAAkD,iDAAQ;AAC1D,yBAAyB;AACzB;AACA;AACA,2CAA2C,iDAAQ;AACnD;AACA;AACA;AACA;AACA,mDAAmD,iDAAQ;AAC3D;AACA;AACA;AACA;AACA,kCAAkC,SAAS,iDAAQ,yDAAyD;AAC5G,kCAAkC,gBAAgB;AAClD,kCAAkC,cAAc;AAChD,kCAAkC,mBAAmB;AACrD,kCAAkC,uBAAuB;AACzD,kCAAkC,qBAAqB;AACvD,kCAAkC,0BAA0B;AAC5D,kCAAkC,8BAA8B;AAChE,kCAAkC,wBAAwB;AAC1D,kCAAkC,4BAA4B;AAC9D,kCAAkC,iCAAiC;AACnE,kCAAkC,+BAA+B;AACjE,kCAAkC,mCAAmC;AACrE,kCAAkC,wCAAwC;AAC1E,kCAAkC,sCAAsC;AACxE,kCAAkC;AAClC;AACA,yBAAyB;AACzB;AACA;AACA,2CAA2C,iDAAQ;AACnD;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,2CAA2C,iDAAQ;AACnD;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,2CAA2C,iDAAQ;AACnD;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,2CAA2C,iDAAQ;AACnD;AACA;AACA;AACA;AACA,qBAAqB;AACrB,wCAAwC,QAAQ,eAAe,UAAU,iBAAiB,OAAO,KAAK;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA,gDAAgD,GAAG;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,mBAAmB,wDAAwD,EAAE,+DAA+D;AAC5I;AACA;AACA;AACA,6CAA6C,oBAAoB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,GAAG;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,EAAE,MAAM,kCAAkC;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,kEAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,eAAe;AAC1E;AACA;AACA;AACA;AACA;AACA,mCAAmC,iDAAQ;AAC3C,kCAAkC,iDAAQ;AAC1C,mCAAmC,iDAAQ;AAC3C,kCAAkC,iDAAQ;AAC1C,kCAAkC,iDAAQ;AAC1C,oCAAoC,iDAAQ;AAC5C,qCAAqC,iDAAQ;AAC7C,gCAAgC,iDAAQ;AACxC,kCAAkC,iDAAQ;AAC1C,iCAAiC,iDAAQ;AACzC,qCAAqC,iDAAQ;AAC7C,gCAAgC,iDAAQ;AACxC,yCAAyC,iDAAQ;AACjD,oCAAoC,iDAAQ;AAC5C,kCAAkC,iDAAQ;AAC1C,kCAAkC,iDAAQ;AAC1C,iCAAiC,iDAAQ;AACzC,oCAAoC,iDAAQ;AAC5C,qCAAqC,iDAAQ;AAC7C,oCAAoC,iDAAQ;AAC5C,sCAAsC,iDAAQ;AAC9C,iCAAiC,iDAAQ;AACzC,qCAAqC,iDAAQ;AAC7C,iCAAiC,iDAAQ;AACzC,oDAAoD,iDAAQ;AAC5D,sDAAsD,iDAAQ;AAC9D,+CAA+C,iDAAQ;AACvD,iDAAiD,iDAAQ;AACzD,mDAAmD,iDAAQ;AAC3D,qDAAqD,iDAAQ;AAC7D,8CAA8C,iDAAQ;AACtD,iDAAiD,iDAAQ;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,SAAS,UAAU,GAAG;AAClD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kEAAQ,IAAI,uFAAY;AACjD;AACA,uBAAuB,mEAAgB;AACvC;AACA;AACA;AACA;AACA,CAAC;AAC+I;;;;;;;;;;;;;;;;AC5dhJ;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,UAAU;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;;;;;;;;;;;;;;;;;AC1GwD;AACV;AAC1F,+BAA+B,uGAAsB,CAAC,yFAAa;AACjC","sources":["webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/theme/common/tokenClassificationRegistry.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/services/textMate/common/TMHelper.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/services/themes/common/workbenchThemeService.service.js"],"sourcesContent":["import { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Color } from '../../../base/common/color.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { localize } from '../../../nls.js';\nimport { Extensions as Extensions$1 } from '../../jsonschemas/common/jsonContributionRegistry.js';\nimport { Registry } from '../../registry/common/platform.js';\nconst TOKEN_TYPE_WILDCARD = '*';\nconst TOKEN_CLASSIFIER_LANGUAGE_SEPARATOR = ':';\nconst CLASSIFIER_MODIFIER_SEPARATOR = '.';\nconst idPattern = '\\\\w+[-_\\\\w+]*';\nconst typeAndModifierIdPattern = `^${idPattern}$`;\nconst selectorPattern = `^(${idPattern}|\\\\*)(\\\\${CLASSIFIER_MODIFIER_SEPARATOR}${idPattern})*(${TOKEN_CLASSIFIER_LANGUAGE_SEPARATOR}${idPattern})?$`;\nconst fontStylePattern = '^(\\\\s*(italic|bold|underline|strikethrough))*\\\\s*$';\nclass TokenStyle {\n    constructor(foreground, bold, underline, strikethrough, italic) {\n        this.foreground = foreground;\n        this.bold = bold;\n        this.underline = underline;\n        this.strikethrough = strikethrough;\n        this.italic = italic;\n    }\n}\n( ((function(TokenStyle) {\n    function toJSONObject(style) {\n        return {\n            _foreground: style.foreground === undefined ? null : Color.Format.CSS.formatHexA(style.foreground, true),\n            _bold: style.bold === undefined ? null : style.bold,\n            _underline: style.underline === undefined ? null : style.underline,\n            _italic: style.italic === undefined ? null : style.italic,\n            _strikethrough: style.strikethrough === undefined ? null : style.strikethrough,\n        };\n    }\n    TokenStyle.toJSONObject = toJSONObject;\n    function fromJSONObject(obj) {\n        if (obj) {\n            const boolOrUndef = (b) => (typeof b === 'boolean') ? b : undefined;\n            const colorOrUndef = (s) => (typeof s === 'string') ? ( (Color.fromHex(s))) : undefined;\n            return (\n                 (new TokenStyle(\n                    colorOrUndef(obj._foreground),\n                    boolOrUndef(obj._bold),\n                    boolOrUndef(obj._underline),\n                    boolOrUndef(obj._strikethrough),\n                    boolOrUndef(obj._italic)\n                ))\n            );\n        }\n        return undefined;\n    }\n    TokenStyle.fromJSONObject = fromJSONObject;\n    function equals(s1, s2) {\n        if (s1 === s2) {\n            return true;\n        }\n        return s1 !== undefined && s2 !== undefined\n            && (s1.foreground instanceof Color ? s1.foreground.equals(s2.foreground) : s2.foreground === undefined)\n            && s1.bold === s2.bold\n            && s1.underline === s2.underline\n            && s1.strikethrough === s2.strikethrough\n            && s1.italic === s2.italic;\n    }\n    TokenStyle.equals = equals;\n    function is(s) {\n        return s instanceof TokenStyle;\n    }\n    TokenStyle.is = is;\n    function fromData(data) {\n        return (\n             (new TokenStyle(\n                data.foreground,\n                data.bold,\n                data.underline,\n                data.strikethrough,\n                data.italic\n            ))\n        );\n    }\n    TokenStyle.fromData = fromData;\n    function fromSettings(foreground, fontStyle, bold, underline, strikethrough, italic) {\n        let foregroundColor = undefined;\n        if (foreground !== undefined) {\n            foregroundColor = ( (Color.fromHex(foreground)));\n        }\n        if (fontStyle !== undefined) {\n            bold = italic = underline = strikethrough = false;\n            const expression = /italic|bold|underline|strikethrough/g;\n            let match;\n            while ((match = expression.exec(fontStyle))) {\n                switch (match[0]) {\n                    case 'bold':\n                        bold = true;\n                        break;\n                    case 'italic':\n                        italic = true;\n                        break;\n                    case 'underline':\n                        underline = true;\n                        break;\n                    case 'strikethrough':\n                        strikethrough = true;\n                        break;\n                }\n            }\n        }\n        return (\n             (new TokenStyle(foregroundColor, bold, underline, strikethrough, italic))\n        );\n    }\n    TokenStyle.fromSettings = fromSettings;\n})(TokenStyle || (TokenStyle = {}))));\nvar SemanticTokenRule;\n( ((function(SemanticTokenRule) {\n    function fromJSONObject(registry, o) {\n        if (o && typeof o._selector === 'string' && o._style) {\n            const style = TokenStyle.fromJSONObject(o._style);\n            if (style) {\n                try {\n                    return { selector: registry.parseTokenSelector(o._selector), style };\n                }\n                catch (_ignore) {\n                }\n            }\n        }\n        return undefined;\n    }\n    SemanticTokenRule.fromJSONObject = fromJSONObject;\n    function toJSONObject(rule) {\n        return {\n            _selector: rule.selector.id,\n            _style: TokenStyle.toJSONObject(rule.style)\n        };\n    }\n    SemanticTokenRule.toJSONObject = toJSONObject;\n    function equals(r1, r2) {\n        if (r1 === r2) {\n            return true;\n        }\n        return r1 !== undefined && r2 !== undefined\n            && r1.selector && r2.selector && r1.selector.id === r2.selector.id\n            && TokenStyle.equals(r1.style, r2.style);\n    }\n    SemanticTokenRule.equals = equals;\n    function is(r) {\n        return r && r.selector && typeof r.selector.id === 'string' && TokenStyle.is(r.style);\n    }\n    SemanticTokenRule.is = is;\n})(SemanticTokenRule || (SemanticTokenRule = {}))));\nconst Extensions = {\n    TokenClassificationContribution: 'base.contributions.tokenClassification'\n};\nclass TokenClassificationRegistry {\n    constructor() {\n        this._onDidChangeSchema = ( (new Emitter()));\n        this.onDidChangeSchema = this._onDidChangeSchema.event;\n        this.currentTypeNumber = 0;\n        this.currentModifierBit = 1;\n        this.tokenStylingDefaultRules = [];\n        this.tokenStylingSchema = {\n            type: 'object',\n            properties: {},\n            patternProperties: {\n                [selectorPattern]: getStylingSchemeEntry()\n            },\n            additionalProperties: false,\n            definitions: {\n                style: {\n                    type: 'object',\n                    description: ( localize(7072, 'Colors and styles for the token.')),\n                    properties: {\n                        foreground: {\n                            type: 'string',\n                            description: ( localize(7073, 'Foreground color for the token.')),\n                            format: 'color-hex',\n                            default: '#ff0000'\n                        },\n                        background: {\n                            type: 'string',\n                            deprecationMessage: ( localize(7074, 'Token background colors are currently not supported.'))\n                        },\n                        fontStyle: {\n                            type: 'string',\n                            description: ( localize(\n                                7075,\n                                'Sets the all font styles of the rule: \\'italic\\', \\'bold\\', \\'underline\\' or \\'strikethrough\\' or a combination. All styles that are not listed are unset. The empty string unsets all styles.'\n                            )),\n                            pattern: fontStylePattern,\n                            patternErrorMessage: ( localize(\n                                7076,\n                                'Font style must be \\'italic\\', \\'bold\\', \\'underline\\' or \\'strikethrough\\' or a combination. The empty string unsets all styles.'\n                            )),\n                            defaultSnippets: [\n                                { label: ( localize(7077, 'None (clear inherited style)')), bodyText: '\"\"' },\n                                { body: 'italic' },\n                                { body: 'bold' },\n                                { body: 'underline' },\n                                { body: 'strikethrough' },\n                                { body: 'italic bold' },\n                                { body: 'italic underline' },\n                                { body: 'italic strikethrough' },\n                                { body: 'bold underline' },\n                                { body: 'bold strikethrough' },\n                                { body: 'underline strikethrough' },\n                                { body: 'italic bold underline' },\n                                { body: 'italic bold strikethrough' },\n                                { body: 'italic underline strikethrough' },\n                                { body: 'bold underline strikethrough' },\n                                { body: 'italic bold underline strikethrough' }\n                            ]\n                        },\n                        bold: {\n                            type: 'boolean',\n                            description: ( localize(\n                                7078,\n                                'Sets or unsets the font style to bold. Note, the presence of \\'fontStyle\\' overrides this setting.'\n                            )),\n                        },\n                        italic: {\n                            type: 'boolean',\n                            description: ( localize(\n                                7079,\n                                'Sets or unsets the font style to italic. Note, the presence of \\'fontStyle\\' overrides this setting.'\n                            )),\n                        },\n                        underline: {\n                            type: 'boolean',\n                            description: ( localize(\n                                7080,\n                                'Sets or unsets the font style to underline. Note, the presence of \\'fontStyle\\' overrides this setting.'\n                            )),\n                        },\n                        strikethrough: {\n                            type: 'boolean',\n                            description: ( localize(\n                                7081,\n                                'Sets or unsets the font style to strikethrough. Note, the presence of \\'fontStyle\\' overrides this setting.'\n                            )),\n                        }\n                    },\n                    defaultSnippets: [{ body: { foreground: '${1:#FF0000}', fontStyle: '${2:bold}' } }]\n                }\n            }\n        };\n        this.tokenTypeById = Object.create(null);\n        this.tokenModifierById = Object.create(null);\n        this.typeHierarchy = Object.create(null);\n    }\n    registerTokenType(id, description, superType, deprecationMessage) {\n        if (!id.match(typeAndModifierIdPattern)) {\n            throw ( (new Error('Invalid token type id.')));\n        }\n        if (superType && !superType.match(typeAndModifierIdPattern)) {\n            throw ( (new Error('Invalid token super type id.')));\n        }\n        const num = this.currentTypeNumber++;\n        const tokenStyleContribution = { num, id, superType, description, deprecationMessage };\n        this.tokenTypeById[id] = tokenStyleContribution;\n        const stylingSchemeEntry = getStylingSchemeEntry(description, deprecationMessage);\n        this.tokenStylingSchema.properties[id] = stylingSchemeEntry;\n        this.typeHierarchy = Object.create(null);\n    }\n    registerTokenModifier(id, description, deprecationMessage) {\n        if (!id.match(typeAndModifierIdPattern)) {\n            throw ( (new Error('Invalid token modifier id.')));\n        }\n        const num = this.currentModifierBit;\n        this.currentModifierBit = this.currentModifierBit * 2;\n        const tokenStyleContribution = { num, id, description, deprecationMessage };\n        this.tokenModifierById[id] = tokenStyleContribution;\n        this.tokenStylingSchema.properties[`*.${id}`] = getStylingSchemeEntry(description, deprecationMessage);\n    }\n    parseTokenSelector(selectorString, language) {\n        const selector = parseClassifierString(selectorString, language);\n        if (!selector.type) {\n            return {\n                match: () => -1,\n                id: '$invalid'\n            };\n        }\n        return {\n            match: (type, modifiers, language) => {\n                let score = 0;\n                if (selector.language !== undefined) {\n                    if (selector.language !== language) {\n                        return -1;\n                    }\n                    score += 10;\n                }\n                if (selector.type !== TOKEN_TYPE_WILDCARD) {\n                    const hierarchy = this.getTypeHierarchy(type);\n                    const level = hierarchy.indexOf(selector.type);\n                    if (level === -1) {\n                        return -1;\n                    }\n                    score += (100 - level);\n                }\n                for (const selectorModifier of selector.modifiers) {\n                    if (modifiers.indexOf(selectorModifier) === -1) {\n                        return -1;\n                    }\n                }\n                return score + selector.modifiers.length * 100;\n            },\n            id: `${[selector.type, ...selector.modifiers.sort()].join('.')}${selector.language !== undefined ? ':' + selector.language : ''}`\n        };\n    }\n    registerTokenStyleDefault(selector, defaults) {\n        this.tokenStylingDefaultRules.push({ selector, defaults });\n    }\n    deregisterTokenStyleDefault(selector) {\n        const selectorString = selector.id;\n        this.tokenStylingDefaultRules = this.tokenStylingDefaultRules.filter(r => r.selector.id !== selectorString);\n    }\n    deregisterTokenType(id) {\n        delete this.tokenTypeById[id];\n        delete this.tokenStylingSchema.properties[id];\n        this.typeHierarchy = Object.create(null);\n    }\n    deregisterTokenModifier(id) {\n        delete this.tokenModifierById[id];\n        delete this.tokenStylingSchema.properties[`*.${id}`];\n    }\n    getTokenTypes() {\n        return (\n             (( (Object.keys(this.tokenTypeById))).map(id => this.tokenTypeById[id]))\n        );\n    }\n    getTokenModifiers() {\n        return (\n             (( (Object.keys(this.tokenModifierById))).map(id => this.tokenModifierById[id]))\n        );\n    }\n    getTokenStylingSchema() {\n        return this.tokenStylingSchema;\n    }\n    getTokenStylingDefaultRules() {\n        return this.tokenStylingDefaultRules;\n    }\n    getTypeHierarchy(typeId) {\n        let hierarchy = this.typeHierarchy[typeId];\n        if (!hierarchy) {\n            this.typeHierarchy[typeId] = hierarchy = [typeId];\n            let type = this.tokenTypeById[typeId];\n            while (type && type.superType) {\n                hierarchy.push(type.superType);\n                type = this.tokenTypeById[type.superType];\n            }\n        }\n        return hierarchy;\n    }\n    toString() {\n        const sorter = (a, b) => {\n            const cat1 = a.indexOf('.') === -1 ? 0 : 1;\n            const cat2 = b.indexOf('.') === -1 ? 0 : 1;\n            if (cat1 !== cat2) {\n                return cat1 - cat2;\n            }\n            return a.localeCompare(b);\n        };\n        return ( (( (Object.keys(this.tokenTypeById))).sort(sorter).map(k => `- \\`${k}\\`: ${this.tokenTypeById[k].description}`))).join('\\n');\n    }\n}\nconst CHAR_LANGUAGE = TOKEN_CLASSIFIER_LANGUAGE_SEPARATOR.charCodeAt(0);\nconst CHAR_MODIFIER = CLASSIFIER_MODIFIER_SEPARATOR.charCodeAt(0);\nfunction parseClassifierString(s, defaultLanguage) {\n    let k = s.length;\n    let language = defaultLanguage;\n    const modifiers = [];\n    for (let i = k - 1; i >= 0; i--) {\n        const ch = s.charCodeAt(i);\n        if (ch === CHAR_LANGUAGE || ch === CHAR_MODIFIER) {\n            const segment = s.substring(i + 1, k);\n            k = i;\n            if (ch === CHAR_LANGUAGE) {\n                language = segment;\n            }\n            else {\n                modifiers.push(segment);\n            }\n        }\n    }\n    const type = s.substring(0, k);\n    return { type, modifiers, language };\n}\nconst tokenClassificationRegistry = createDefaultTokenClassificationRegistry();\nRegistry.add(Extensions.TokenClassificationContribution, tokenClassificationRegistry);\nfunction createDefaultTokenClassificationRegistry() {\n    const registry = ( (new TokenClassificationRegistry()));\n    function registerTokenType(id, description, scopesToProbe = [], superType, deprecationMessage) {\n        registry.registerTokenType(id, description, superType, deprecationMessage);\n        if (scopesToProbe) {\n            registerTokenStyleDefault(id, scopesToProbe);\n        }\n        return id;\n    }\n    function registerTokenStyleDefault(selectorString, scopesToProbe) {\n        try {\n            const selector = registry.parseTokenSelector(selectorString);\n            registry.registerTokenStyleDefault(selector, { scopesToProbe });\n        }\n        catch (e) {\n            console.log(e);\n        }\n    }\n    registerTokenType('comment', ( localize(7082, \"Style for comments.\")), [['comment']]);\n    registerTokenType('string', ( localize(7083, \"Style for strings.\")), [['string']]);\n    registerTokenType('keyword', ( localize(7084, \"Style for keywords.\")), [['keyword.control']]);\n    registerTokenType('number', ( localize(7085, \"Style for numbers.\")), [['constant.numeric']]);\n    registerTokenType('regexp', ( localize(7086, \"Style for expressions.\")), [['constant.regexp']]);\n    registerTokenType('operator', ( localize(7087, \"Style for operators.\")), [['keyword.operator']]);\n    registerTokenType('namespace', ( localize(7088, \"Style for namespaces.\")), [['entity.name.namespace']]);\n    registerTokenType('type', ( localize(7089, \"Style for types.\")), [['entity.name.type'], ['support.type']]);\n    registerTokenType('struct', ( localize(7090, \"Style for structs.\")), [['entity.name.type.struct']]);\n    registerTokenType('class', ( localize(7091, \"Style for classes.\")), [['entity.name.type.class'], ['support.class']]);\n    registerTokenType('interface', ( localize(7092, \"Style for interfaces.\")), [['entity.name.type.interface']]);\n    registerTokenType('enum', ( localize(7093, \"Style for enums.\")), [['entity.name.type.enum']]);\n    registerTokenType('typeParameter', ( localize(7094, \"Style for type parameters.\")), [['entity.name.type.parameter']]);\n    registerTokenType('function', ( localize(7095, \"Style for functions\")), [['entity.name.function'], ['support.function']]);\n    registerTokenType('member', ( localize(7096, \"Style for member functions\")), [], 'method', 'Deprecated use `method` instead');\n    registerTokenType('method', ( localize(7097, \"Style for method (member functions)\")), [['entity.name.function.member'], ['support.function']]);\n    registerTokenType('macro', ( localize(7098, \"Style for macros.\")), [['entity.name.function.preprocessor']]);\n    registerTokenType('variable', ( localize(7099, \"Style for variables.\")), [['variable.other.readwrite'], ['entity.name.variable']]);\n    registerTokenType('parameter', ( localize(7100, \"Style for parameters.\")), [['variable.parameter']]);\n    registerTokenType('property', ( localize(7101, \"Style for properties.\")), [['variable.other.property']]);\n    registerTokenType('enumMember', ( localize(7102, \"Style for enum members.\")), [['variable.other.enummember']]);\n    registerTokenType('event', ( localize(7103, \"Style for events.\")), [['variable.other.event']]);\n    registerTokenType('decorator', ( localize(7104, \"Style for decorators & annotations.\")), [['entity.name.decorator'], ['entity.name.function']]);\n    registerTokenType('label', ( localize(7105, \"Style for labels. \")), undefined);\n    registry.registerTokenModifier('declaration', ( localize(7106, \"Style for all symbol declarations.\")), undefined);\n    registry.registerTokenModifier('documentation', ( localize(7107, \"Style to use for references in documentation.\")), undefined);\n    registry.registerTokenModifier('static', ( localize(7108, \"Style to use for symbols that are static.\")), undefined);\n    registry.registerTokenModifier('abstract', ( localize(7109, \"Style to use for symbols that are abstract.\")), undefined);\n    registry.registerTokenModifier('deprecated', ( localize(7110, \"Style to use for symbols that are deprecated.\")), undefined);\n    registry.registerTokenModifier('modification', ( localize(7111, \"Style to use for write accesses.\")), undefined);\n    registry.registerTokenModifier('async', ( localize(7112, \"Style to use for symbols that are async.\")), undefined);\n    registry.registerTokenModifier('readonly', ( localize(7113, \"Style to use for symbols that are read-only.\")), undefined);\n    registerTokenStyleDefault('variable.readonly', [['variable.other.constant']]);\n    registerTokenStyleDefault('property.readonly', [['variable.other.constant.property']]);\n    registerTokenStyleDefault('type.defaultLibrary', [['support.type']]);\n    registerTokenStyleDefault('class.defaultLibrary', [['support.class']]);\n    registerTokenStyleDefault('interface.defaultLibrary', [['support.class']]);\n    registerTokenStyleDefault('variable.defaultLibrary', [['support.variable'], ['support.other.variable']]);\n    registerTokenStyleDefault('variable.defaultLibrary.readonly', [['support.constant']]);\n    registerTokenStyleDefault('property.defaultLibrary', [['support.variable.property']]);\n    registerTokenStyleDefault('property.defaultLibrary.readonly', [['support.constant.property']]);\n    registerTokenStyleDefault('function.defaultLibrary', [['support.function']]);\n    registerTokenStyleDefault('member.defaultLibrary', [['support.function']]);\n    return registry;\n}\nfunction getTokenClassificationRegistry() {\n    return tokenClassificationRegistry;\n}\nfunction getStylingSchemeEntry(description, deprecationMessage) {\n    return {\n        description,\n        deprecationMessage,\n        defaultSnippets: [{ body: '${1:#ff0000}' }],\n        anyOf: [\n            {\n                type: 'string',\n                format: 'color-hex'\n            },\n            {\n                $ref: '#/definitions/style'\n            }\n        ]\n    };\n}\nconst tokenStylingSchemaId = 'vscode://schemas/token-styling';\nconst schemaRegistry = ( Registry.as(Extensions$1.JSONContribution));\nschemaRegistry.registerSchema(tokenStylingSchemaId, tokenClassificationRegistry.getTokenStylingSchema());\nconst delayer = ( (new RunOnceScheduler(() => schemaRegistry.notifySchemaChanged(tokenStylingSchemaId), 200)));\ntokenClassificationRegistry.onDidChangeSchema(() => {\n    if (!delayer.isScheduled()) {\n        delayer.schedule();\n    }\n});\nexport { SemanticTokenRule, TokenStyle, getTokenClassificationRegistry, parseClassifierString, tokenStylingSchemaId, typeAndModifierIdPattern };\n","function findMatchingThemeRule(theme, scopes, onlyColorRules = true) {\n    for (let i = scopes.length - 1; i >= 0; i--) {\n        const parentScopes = scopes.slice(0, i);\n        const scope = scopes[i];\n        const r = findMatchingThemeRule2(theme, scope, parentScopes, onlyColorRules);\n        if (r) {\n            return r;\n        }\n    }\n    return null;\n}\nfunction findMatchingThemeRule2(theme, scope, parentScopes, onlyColorRules) {\n    let result = null;\n    for (let i = theme.tokenColors.length - 1; i >= 0; i--) {\n        const rule = theme.tokenColors[i];\n        if (onlyColorRules && !rule.settings.foreground) {\n            continue;\n        }\n        let selectors;\n        if (typeof rule.scope === 'string') {\n            selectors = ( rule.scope.split(/,/).map(scope => scope.trim()));\n        }\n        else if (Array.isArray(rule.scope)) {\n            selectors = rule.scope;\n        }\n        else {\n            continue;\n        }\n        for (let j = 0, lenJ = selectors.length; j < lenJ; j++) {\n            const rawSelector = selectors[j];\n            const themeRule = ( new ThemeRule(rawSelector, rule.settings));\n            if (themeRule.matches(scope, parentScopes)) {\n                if (themeRule.isMoreSpecific(result)) {\n                    result = themeRule;\n                }\n            }\n        }\n    }\n    return result;\n}\nclass ThemeRule {\n    constructor(rawSelector, settings) {\n        this.rawSelector = rawSelector;\n        this.settings = settings;\n        const rawSelectorPieces = this.rawSelector.split(/ /);\n        this.scope = rawSelectorPieces[rawSelectorPieces.length - 1];\n        this.parentScopes = rawSelectorPieces.slice(0, rawSelectorPieces.length - 1);\n    }\n    matches(scope, parentScopes) {\n        return ThemeRule._matches(this.scope, this.parentScopes, scope, parentScopes);\n    }\n    static _cmp(a, b) {\n        if (a === null && b === null) {\n            return 0;\n        }\n        if (a === null) {\n            return -1;\n        }\n        if (b === null) {\n            return 1;\n        }\n        if (a.scope.length !== b.scope.length) {\n            return a.scope.length - b.scope.length;\n        }\n        const aParentScopesLen = a.parentScopes.length;\n        const bParentScopesLen = b.parentScopes.length;\n        if (aParentScopesLen !== bParentScopesLen) {\n            return aParentScopesLen - bParentScopesLen;\n        }\n        for (let i = 0; i < aParentScopesLen; i++) {\n            const aLen = a.parentScopes[i].length;\n            const bLen = b.parentScopes[i].length;\n            if (aLen !== bLen) {\n                return aLen - bLen;\n            }\n        }\n        return 0;\n    }\n    isMoreSpecific(other) {\n        return (ThemeRule._cmp(this, other) > 0);\n    }\n    static _matchesOne(selectorScope, scope) {\n        const selectorPrefix = selectorScope + '.';\n        if (selectorScope === scope || scope.substring(0, selectorPrefix.length) === selectorPrefix) {\n            return true;\n        }\n        return false;\n    }\n    static _matches(selectorScope, selectorParentScopes, scope, parentScopes) {\n        if (!this._matchesOne(selectorScope, scope)) {\n            return false;\n        }\n        let selectorParentIndex = selectorParentScopes.length - 1;\n        let parentIndex = parentScopes.length - 1;\n        while (selectorParentIndex >= 0 && parentIndex >= 0) {\n            if (this._matchesOne(selectorParentScopes[selectorParentIndex], parentScopes[parentIndex])) {\n                selectorParentIndex--;\n            }\n            parentIndex--;\n        }\n        if (selectorParentIndex === -1) {\n            return true;\n        }\n        return false;\n    }\n}\nexport { ThemeRule, findMatchingThemeRule };\n","import { refineServiceDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IThemeService } from '../../../../platform/theme/common/themeService.service.js';\nconst IWorkbenchThemeService = refineServiceDecorator(IThemeService);\nexport { IWorkbenchThemeService };\n"],"names":[],"sourceRoot":""}