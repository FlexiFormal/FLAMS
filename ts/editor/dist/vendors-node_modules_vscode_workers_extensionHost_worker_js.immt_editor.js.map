{"version":3,"file":"vendors-node_modules_vscode_workers_extensionHost_worker_js.immt_editor.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4CAA4C,IAAI,kBAAkB,IAAI,MAAM;AAC5E;AACA;AACA,eAAe;AACf,cAAc;AACd,cAAc;AACd,gBAAgB;AAChB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,IAAI;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA,4BAA4B,IAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,IAAI;AACtC,iCAAiC,IAAI;AACrC,+BAA+B,IAAI,IAAI,WAAW;AAClD,iCAAiC,KAAK,IAAI,YAAY;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,IAAI,IAAI,eAAe,SAAS,KAAK;AACzE;AACA;AACA;AACA;AACA,8CAA8C,IAAI,EAAE,KAAK;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD,sDAAsD;AACtD;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA,2DAA2D,IAAI,yBAAyB,aAAa,IAAI;AACzG,mDAAmD,IAAI,yBAAyB,SAAS,GAAG,SAAS,GAAG,WAAW,GAAG;AACtH,4DAA4D,IAAI,yBAAyB;AACzF,6DAA6D,IAAI,yBAAyB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,IAAI,MAAM,EAAE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,EAAE,GAAG,GAAG;AAC5D,4CAA4C,EAAE,GAAG,EAAE;AACnD;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,4CAA4C;AAC5C;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB,mBAAmB,IAAI,GAAG,GAAG,sBAAsB,GAAG,6CAA6C,IAAI;AACvG,eAAe,IAAI,aAAa,GAAG,aAAa,GAAG,cAAc,GAAG;AACpE,oBAAoB,IAAI,GAAG,IAAI;AAC/B,4BAA4B,IAAI;AAChC,mJAAmJ,IAAI;AACvJ;AACA,8BAA8B,EAAE;AAChC,2BAA2B,IAAI,KAAK,GAAG,GAAG,GAAG;AAC7C,+BAA+B,IAAI;AACnC,4BAA4B,IAAI,EAAE,IAAI;AACtC,yBAAyB,IAAI;AAC7B;AACA;AACA;AACA;AACA,qBAAqB,IAAI;AACzB;AACA;AACA;AACA,uBAAuB,IAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,IAAI;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,IAAI,EAAE,IAAI;AACrC;AACA;AACA,8BAA8B,IAAI;AAClC,0BAA0B,IAAI,KAAK,GAAG,kBAAkB,GAAG;AAC3D,wBAAwB,IAAI;AAC5B;AACA;AACA;AACA,6BAA6B,IAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA;AACA,2BAA2B,IAAI,EAAE,IAAI;AACrC,8BAA8B,IAAI;AAClC,wBAAwB,EAAE;AAC1B,0BAA0B,IAAI,KAAK,GAAG,kBAAkB,GAAG;AAC3D,wBAAwB,IAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,IAAI,EAAE,IAAI;AACzC;AACA;AACA,kCAAkC,IAAI;AACtC,8BAA8B,IAAI,KAAK,GAAG,kBAAkB,GAAG;AAC/D,4BAA4B,IAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,GAAG;AAC9C,oEAAoE,GAAG;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,IAAI;AACtB;AACA,yBAAyB,IAAI;AAC7B;AACA;AACA,iCAAiC,KAAK;AACtC;AACA;AACA,kCAAkC,IAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,eAAe,EAAE;AACxD;AACA,gBAAgB,GAAG;AACnB,sCAAsC,GAAG,8CAA8C,GAAG;AAC1F;AACA,0BAA0B,EAAE,IAAI,EAAE;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,KAAK;AACpD,iDAAiD,EAAE,kCAAkC,KAAK,6CAA6C,KAAK;AAC5I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sCAAsC,UAAU;AAC5E;AACA,iCAAiC,GAAG,iCAAiC,GAAG,6EAA6E,GAAG,+BAA+B,GAAG,gCAAgC,GAAG;AAC7N;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,GAAG;AAC9B;AACA,iCAAiC,GAAG;AACpC,oBAAoB,IAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,aAAa;AACjE;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,aAAa;AAClE;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,aAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,aAAa;AACjE;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,aAAa;AAClE;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qBAAqB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA,gCAAgC,KAAK;AACrC;AACA,WAAW,MAAM;AACjB;AACA;AACA,cAAc,eAAe;AAC7B,oBAAoB,MAAM,GAAG,gCAAgC,KAAK,MAAM;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,yBAAyB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,qBAAqB,gCAAgC;AACrD;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA,kCAAkC,YAAY;AAC9C;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA,oCAAoC,YAAY;AAChD;AACA;AACA,6BAA6B,KAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,wBAAwB,KAAK;AAC7B;AACA;AACA;AACA;AACA;AACA,kBAAkB,MAAM,SAAS,YAAY;AAC7C,kBAAkB,KAAK;AACvB,oCAAoC,KAAK;AACzC;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,0BAA0B,gCAAgC;AAC1D;AACA,SAAS,QAAQ;AACjB,sBAAsB,gCAAgC;AACtD;AACA,eAAe,MAAM;AACrB,wBAAwB,KAAK;AAC7B;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB,uBAAuB,gCAAgC;AACvD;AACA,WAAW,qBAAqB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA,+BAA+B,KAAK,SAAS,KAAK;AAClD;AACA,8BAA8B,MAAM;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA,SAAS,MAAM;AACf;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA,UAAU,MAAM;AAChB;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA,wFAAwF,cAAc;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,qCAAqC;AAC5E,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA,oFAAoF,cAAc;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,aAAa;AACtE;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,KAAK;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,KAAK;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,KAAK;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,SAAS;AACT;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2R;AAC3R;;;;;;;;;;;;;;;;ACj7EiF;AACjF,oBAAoB,4EAAa;AACR;;;;;;;;;;;;;;;ACFzB,cAAc;AACgB;;;;;;;;;;;;;;;;ACD9B;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA,oCAAoC;AACpC;AAC+B;;;;;;;;;;;;;;;;ACTgC;AAC/D;AACA;AACA,+BAA+B,yDAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oCAAoC;AAC1D,4BAA4B,oCAAoC;AAChE,4BAA4B,oCAAoC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,yCAAyC;AACzC,uCAAuC;AACvC,yCAAyC;AACzC,uCAAuC;AACvC,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,CAAC,yDAAM,EAAE,yDAAM;AAClB,QAAQ,yDAAM;AACd;AACsC;;;;;;;;;;;;;;;;;;;;;;;AC39BD;AACO;AACJ;AACxC,qBAAqB,qDAAU;AAC/B;AACA;AACA,kDAAkD,8CAAO;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,cAAc;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gBAAgB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,cAAc;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gBAAgB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gBAAgB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qDAAU;AACrC;AACA;AACA,gDAAgD,8CAAO;AACvD;AACA,+CAA+C,8CAAO;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,eAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrKvD;AACD;AAChC,8CAA8C,0CAAI;AAClD,oDAAoD,oCAAoC;AACxF;AACA;AACA;AACA;AACA,CAAC;AACD,0CAA0C,0CAAI;AAC9C,oDAAoD,eAAe;AACnE;AACA;AACA;AACA,CAAC;AACD,yDAAyD,0CAAI;AAC7D,oDAAoD,sCAAsC;AAC1F;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yCAAG;AAClC,mCAAmC,yCAAG;AACtC;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuT;;;;;;;;;;;;;;;;;;;;;;ACrOhR;AACE;AACA;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,IAAI,sDAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kDAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oDAAQ;AACvB,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AAC6G;;;;;;;;;;;;;;;;;;;ACtGtE;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iDAAQ;AACzB;AACA,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;AACA,iBAAiB,iDAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C;AACA;AACA;AACA,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C;AACA;AACA;AACA;AACA;AACA,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C;AACA;AACA;AACA,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C;AACA;AACA;AACA,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C;AACA;AACA;AACA;AACA;AACA,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C;AACA;AACA;AACA,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C;AACA;AACA;AACA,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C;AACA;AACA;AACA;AACA;AACA,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C;AACA;AACA;AACA,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iDAAQ,QAAQ,GAAG;AACvC,oBAAoB,iDAAQ,QAAQ,GAAG;AACvC;AACA;AACA;AACA,oBAAoB,iDAAQ,QAAQ,GAAG;AACvC,oBAAoB,iDAAQ,QAAQ,GAAG;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C;AACA;AACA;AACA,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C;AACA;AACA;AACA;AACA;AACA,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C;AACA;AACA;AACA,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C;AACA;AACA;AACA,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C;AACA;AACA;AACA;AACA;AACA,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C;AACA;AACA;AACA,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C,wBAAwB,iDAAQ,QAAQ,GAAG;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iDAAQ,QAAQ,GAAG;AACvC,oBAAoB,iDAAQ,QAAQ,GAAG;AACvC;AACA;AACA;AACA,oBAAoB,iDAAQ,QAAQ,GAAG;AACvC,oBAAoB,iDAAQ,QAAQ,GAAG;AACvC;AACA;AACA;AACA;AACA;AACA,oBAAoB,iDAAQ,QAAQ,GAAG;AACvC,oBAAoB,iDAAQ,QAAQ,GAAG;AACvC;AACA;AACA;AACA,oBAAoB,iDAAQ,QAAQ,GAAG;AACvC,oBAAoB,iDAAQ,QAAQ,GAAG;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iDAAQ;AACzB;AACA;AACA,iBAAiB,iDAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iDAAQ,QAAQ,EAAE;AACnC;AACA;AACA,iBAAiB,iDAAQ,QAAQ,EAAE;AACnC;AACA;AACA,iBAAiB,iDAAQ,QAAQ,GAAG;AACpC;AACA;AACA,iBAAiB,iDAAQ,QAAQ,GAAG;AACpC;AACA,aAAa,iDAAQ,QAAQ,GAAG;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsE;;;;;;;;;;;;;;;;;AC/OtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,IAAI;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,IAAI;AAC1C,8CAA8C,IAAI;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA,4CAA4C,IAAI;AAChD,8CAA8C,IAAI;AAClD,gDAAgD,IAAI;AACpD,gDAAgD,IAAI;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,KAAK;AACL;AACuC;;;;;;;;;;;;;;;;;;;;ACrGA;AACD;AACE;AACxC;AACA;AACA,iBAAiB,iDAAQ;AACzB;AACA,cAAc,EAAE,GAAG,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA,iBAAiB,iDAAQ,iCAAiC,EAAE;AAC5D;AACA,kCAAkC,iDAAQ;AAC1C;AACA;AACA;AACA,iBAAiB,iDAAQ;AACzB;AACA;AACA,uBAAuB,oDAAQ;AAC/B;AACA;AACA,qBAAqB,iDAAQ,QAAQ,GAAG,EAAE,GAAG;AAC7C;AACA;AACA;AACA,QAAQ,mDAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iDAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5ElC;AAC4B;AACmC;AACnG;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iEAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,4BAA4B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wCAAwC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sBAAsB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,6EAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,sBAAsB;AACrE;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,YAAY,6BAA6B;AACzC;AACA;AACA;AACA,YAAY,2DAA2D;AACvE;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA,kBAAkB,8DAA8D;AAChF;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6CAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wEAA2B;AACzD;AACA;AACA;AACA;AACA,kBAAkB,wDAAwD;AAC1E;AACA;AACA;AACA;AACA,+FAA+F,iDAAiD;AAChJ;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,6FAA6F,iDAAiD;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6DAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,yBAAyB;AACtE;AACA;AACA;AACA,kFAAkF,+BAA+B;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,0BAA0B;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoQ;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACloB/O;AACmB;AACO;AACX;AACsB;AAClB;AACqB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,cAAc;AACpC;AACA,yBAAyB,WAAW,GAAG,cAAc,GAAG,WAAW,EAAE,oBAAoB,WAAW,EAAE,cAAc,QAAQ;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mEAAsB;AACxD;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,sDAAsD,wDAAwD;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,mEAAsB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,cAAc,6CAA6C;AAC3D,gBAAgB,+DAA+D;AAC/E;AACA;AACA,oBAAoB,6CAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,QAAQ,GAAG,4BAA4B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4DAAe,mBAAmB,iDAAO;AACtD;AACA;AACA,6BAA6B,kDAAK,gCAAgC,yCAAG;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,KAAK;AAC/B,+BAA+B,KAAK;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yCAAG,KAAK,2CAAK;AACvC,4FAA4F,yCAAG;AAC/F,0BAA0B,yCAAG;AAC7B,0BAA0B,2CAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,qBAAqB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;AACA;AACA,oBAAoB,qDAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA,2BAA2B,kDAAQ;AACnC;AACA;AACA,wDAAwD,iDAAO;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qDAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,OAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqG;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChgBvD;AACA;AACL;AACa;AACvB;AAC/B;AACA;AACA;AACA;AACA,kBAAkB,2DAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,2DAAW;AACrF,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kDAAkD;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,4CAA4C;AAC3E;AACA;AACA;AACA;AACA;AACA,+BAA+B,mEAAsB;AACrD;AACA;AACA,4BAA4B,MAAM;AAClC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,sDAAO,GAAG,wCAAG,qBAAqB,wCAAG;AAC9G;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,+BAA+B,EAAE,OAAO;AACnD;AACA,WAAW,+BAA+B;AAC1C;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,MAAM;AAC5C;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA,aAAa;AACb;AAC4N;;;;;;;;;;;;;;;;;;;;;;;AC5IhL;AACP;AACM;AAC3C;AACA;AACA,aAAa,oDAAS,oBAAoB,KAAK,oDAAS,wBAAwB;AAChF;AACA;AACA,gDAAgD,kBAAkB;AAClE;AACA,qFAAqF,MAAM;AAC3F;AACA,sDAAsD,kBAAkB;AACxE;AACA,iEAAiE,MAAM;AACvE;AACA,qDAAqD,kBAAkB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,aAAa;AAClF;AACA,+CAA+C,oDAAS,mBAAmB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,YAAY,oBAAoB;AAChC;AACA,eAAe,yDAAY;AAC3B;AACA,kDAAkD,kDAAK;AACvD;AACA,oBAAoB,yDAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgI;;;;;;;;;;;;;;;;ACrEhI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyC;;;;;;;;;;;;;;;;;;;;;;ACVzC;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2CAA2C;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,0BAA0B,uBAAuB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,yEAAyE;AAC/G,SAAS;AACT;AACA,sCAAsC,2EAA2E;AACjH,0CAA0C,oEAAoE;AAC9G,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,wEAAwE;AAC9G,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sBAAsB,wEAAwE;AAC9F;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,0BAA0B,uBAAuB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8G;;;;;;;;;;;;;;;AC5zB9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA,6BAA6B,WAAW,YAAY,GAAG,MAAM;AAC7D;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C,6BAA6B,EAAE,IAAI,0BAA0B;AAC7D;AACA;AACA,kBAAkB,iCAAiC,IAAI,YAAY,GAAG,EAAE,uBAAuB;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzHyB;AACX;AACa;AACG;AACH;AAC3D;AACA,YAAY,+CAA+C;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mDAAS;AAC/B;AACA;AACA,0BAA0B,mDAAS;AACnC;AACA;AACA;AACA;AACA;AACA,kFAAkF,2CAAK,6BAA6B,2CAAK;AACzH,0DAA0D,qBAAqB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2CAAK,GAAG,2CAAK;AAC7C;AACA;AACA;AACA,gCAAgC,2CAAK,GAAG,2CAAK;AAC7C,kCAAkC,iDAAM,GAAG,+DAAoB;AAC/D;AACA;AACA;AACA;AACA;AACA,2EAA2E,2CAAK,6BAA6B,2CAAK;AAClH,0CAA0C,qBAAqB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,UAAU,IAAI,kBAAkB;AACnF;AACA;AACA;AACA,kDAAkD,mDAAS;AAC3D,QAAQ,2DAAc;AACtB;AACA;AACA;AACA;AACA;AACA,sCAAsC,4CAAE;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mDAAS;AACrB,iCAAiC,sDAAS;AAC1C;AACA,gCAAgC,kDAAK,qBAAqB,2CAAK,MAAM,EAAE,2CAAK,KAAK;AACjF,qCAAqC;AACrC;AACA;AACA,QAAQ,mDAAS;AACjB,yBAAyB,sDAAS;AAClC;AACA,oEAAoE,iEAAoB;AACxF,oBAAoB,iDAAiD;AACrE;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA,wCAAwC,yCAAG;AAC3C;AACA;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA,4CAA4C,cAAc;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2CAA2C;AAC/E,8DAA8D,qBAAqB;AACnF;AACA;AACA,6CAA6C,yCAAyC;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oBAAoB;AACrB;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA,gCAAgC,gCAAgC;AAChE;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,oCAAoC,sCAAsC;AAC1E;AACA;AACA;AACA;AACA;AACA,oCAAoC,6CAA6C;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gCAAgC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,QAAQ,qDAAW;AACnB,+DAA+D,qDAAW;AAC1E;AACA;AACA;AACA;AACA,QAAQ,qDAAW;AACnB;AACA;AACA,QAAQ,mDAAS;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,6CAA6C,2CAAK,GAAG,2CAAK;AAC1D;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACgK;;;;;;;;;;;;;;;;;;;ACnQzH;AACR;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wCAAG;AAC/B;AACA;AACA;AACA,2BAA2B,gDAAQ;AACnC;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoC;;;;;;;;;;;;;;;;;;;;ACjDA;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iDAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iDAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uBAAuB,GAAG,uBAAuB,EAAE,eAAe;AAChF;AAC+F;;;;;;;;;;;;;;;ACvG/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6B;;;;;;;;;;;;;;;;;;;;AC1M7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2F;;;;;;;;;;;;;;;;ACvE3F,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,wBAAwB,4DAA4D;AACpF;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;AACD;AACA;AAC0B;;;;;;;;;;;;;;;;AC9Ee;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,kDAAQ;AACvD;AACA;AACA,gDAAgD,kDAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,OAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiC;;;;;;;;;;;;;;;;ACpLe;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6DAAgB;AAC5B;AACA;AACA,YAAY,6DAAgB,qBAAqB,6DAAgB;AACjE;AACA;AACA,YAAY,6DAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACiC;;;;;;;;;;;;;;;;;;;;;ACzCK;AACkE;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+BAA+B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,6DAAgB;AAC9B,cAAc,uEAA0B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,UAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2BAA2B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,6DAAgB;AAC9B,cAAc,uEAA0B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8DAAiB;AACpC;AACA;AACA,mBAAmB,8DAAiB;AACpC;AACA;AACA;AACA;AACA;AACA,mBAAmB,oDAAO;AAC1B;AACA;AACA,mBAAmB,oDAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mDAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mDAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4F;;;;;;;;;;;;;;;;;;ACpmBpD;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,6BAA6B,IAAI,iCAAiC;AAC/E;AACA;AACA;AACA;AACA,oCAAoC,iDAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B,KAAK,iCAAiC;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,GAAG,GAAG,SAAS;AACnC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AACoB;;;;;;;;;;;;;;;;;;;ACtFZ;AACR;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wCAAG;AAC/B;AACA,2BAA2B,gDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwF;;;;;;;;;;;;;;;;ACpDxF,gCAAgC,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,GAAG;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAC+B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtDwB;AACa;AACG;AACH;AACP;AACnB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,8DAAM;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B,kBAAkB,iDAAQ;AAC1B,kBAAkB,iDAAQ;AAC1B;AACA;AACA;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC,aAAa;AACb;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,eAAe,iDAAQ;AAC7E;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,sBAAsB,iDAAQ;AAC9B,sBAAsB,iDAAQ;AAC9B;AACA;AACA;AACA,sBAAsB,iDAAQ;AAC9B;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,sBAAsB,iDAAQ;AAC9B,sBAAsB,iDAAQ;AAC9B,sBAAsB,iDAAQ;AAC9B;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,0BAA0B,iEAAW;AACrC,aAAa;AACb;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,mCAAmC,iDAAQ;AAC3C;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,mCAAmC,iDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,mCAAmC,iDAAQ;AAC3C;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,mCAAmC,iDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iDAAQ;AACnC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,aAAa;AACb,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iDAAQ;AAC5C;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,4DAA4D,IAAI;AAChE,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B,kBAAkB,iDAAQ;AAC1B,kBAAkB,iDAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA,sCAAsC,iDAAQ;AAC9C;AACA;AACA;AACA,aAAa;AACb;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC,aAAa;AACb;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gHAAgH;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iDAAQ;AAC9B;AACA;AACA;AACA,sBAAsB,iDAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iDAAQ;AAC9B,sBAAsB,iDAAQ;AAC9B,sBAAsB,iDAAQ;AAC9B;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC,aAAa;AACb;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA,sBAAsB,iDAAQ;AAC9B,sBAAsB,iDAAQ;AAC9B;AACA,mFAAmF,EAAE;AACrF,wBAAwB,iEAAW;AACnC;AACA,sBAAsB,iDAAQ;AAC9B;AACA,kFAAkF,EAAE;AACpF,wBAAwB,iEAAW;AACnC;AACA,sBAAsB,iDAAQ;AAC9B;AACA,aAAa;AACb;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C;AACA,sFAAsF,GAAG,gDAAgD,GAAG;AAC5I;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C;AACA,gGAAgG,GAAG;AACnG;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC,aAAa;AACb;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6GAA6G,uBAAuB,iDAAQ;AAC5I;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC,aAAa;AACb;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC,aAAa;AACb;AACA;AACA;AACA;AACA,sBAAsB,iDAAQ;AAC9B;AACA;AACA;AACA,sBAAsB,iDAAQ;AAC9B;AACA;AACA;AACA,sBAAsB,iDAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC,aAAa;AACb;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC,aAAa;AACb;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC,aAAa;AACb;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC,aAAa;AACb;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC,aAAa;AACb;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iEAAW;AAC3B;AACA;AACA;AACA;AACA;AACA,gCAAgC,mBAAmB;AACnD;AACA;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA,qCAAqC,iDAAQ,8DAA8D,iDAAQ,kDAAkD,iDAAQ;AAC7K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iDAAQ;AAC3C,iBAAiB;AACjB;AACA;AACA;AACA,mCAAmC,iDAAQ;AAC3C,iBAAiB;AACjB;AACA;AACA;AACA,mCAAmC,iDAAQ;AAC3C,iBAAiB;AACjB,aAAa;AACb;AACA,mCAAmC,iDAAQ;AAC3C;AACA,4QAA4Q,EAAE;AAC9Q;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,gBAAgB,2BAA2B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gCAAgC;AACpE;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B,kBAAkB,iDAAQ;AAC1B,kBAAkB,iDAAQ;AAC1B,kBAAkB,iDAAQ;AAC1B;AACA;AACA,2BAA2B,iDAAQ;AACnC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+BAA+B,iDAAQ;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,iDAAQ;AACvD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iDAAQ;AAC9B,sBAAsB,iDAAQ;AAC9B,sBAAsB,iDAAQ;AAC9B;AACA;AACA,+BAA+B,iDAAQ;AACvC,aAAa;AACb;AACA;AACA;AACA;AACA,sBAAsB,iDAAQ;AAC9B,sBAAsB,iDAAQ;AAC9B,sBAAsB,iDAAQ;AAC9B;AACA;AACA,+BAA+B,iDAAQ;AACvC,aAAa;AACb;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC,aAAa;AACb;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC,aAAa;AACb;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC,aAAa;AACb;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,8BAA8B,0BAA0B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB,+DAAQ;AACzB,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,iBAAiB,+DAAQ;AACzB,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,sBAAsB,iDAAQ;AAC9B;AACA;AACA;AACA,sBAAsB,iDAAQ;AAC9B;AACA;AACA;AACA,sBAAsB,iDAAQ;AAC9B;AACA,+BAA+B,iDAAQ;AACvC,aAAa;AACb;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,sBAAsB,iDAAQ;AAC9B;AACA;AACA;AACA,sBAAsB,iDAAQ;AAC9B;AACA;AACA;AACA,sBAAsB,iDAAQ;AAC9B;AACA,+BAA+B,iDAAQ;AACvC,aAAa;AACb;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,6EAAqB;AAC1C,gDAAgD,6EAAqB;AACrE;AACA;AACA;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C;AACA,wFAAwF,GAAG;AAC3F;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iDAAQ;AAC9B,sBAAsB,iDAAQ;AAC9B,sBAAsB,iDAAQ;AAC9B;AACA;AACA,+BAA+B,iDAAQ;AACvC,aAAa;AACb;AACA;AACA;AACA;AACA,sBAAsB,iDAAQ;AAC9B;AACA;AACA;AACA,sBAAsB,iDAAQ;AAC9B,sBAAsB,iDAAQ;AAC9B;AACA;AACA,+BAA+B,iDAAQ;AACvC,aAAa;AACb;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC,aAAa;AACb;AACA;AACA;AACA;AACA,sBAAsB,iDAAQ;AAC9B,sBAAsB,iDAAQ;AAC9B;AACA;AACA;AACA,sBAAsB,iDAAQ;AAC9B;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iDAAQ;AAC9B,sBAAsB,iDAAQ;AAC9B;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,sBAAsB,iDAAQ;AAC9B;AACA;AACA;AACA,sBAAsB,iDAAQ;AAC9B;AACA;AACA;AACA,sBAAsB,iDAAQ;AAC9B;AACA;AACA;AACA,sBAAsB,iDAAQ;AAC9B;AACA;AACA,uCAAuC,iDAAQ;AAC/C;AACA,2JAA2J,GAAG,KAAK,EAAE;AACrK;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC,aAAa;AACb;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC,aAAa;AACb;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC,aAAa;AACb;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,sCAAsC,iDAAQ;AAC9C,aAAa;AACb;AACA;AACA,sCAAsC,iDAAQ;AAC9C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C,aAAa;AACb;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C,aAAa;AACb;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C,aAAa;AACb;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C,aAAa;AACb;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C,aAAa;AACb;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C,aAAa;AACb;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C,aAAa;AACb;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C,aAAa;AACb;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C,aAAa;AACb;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C,aAAa;AACb;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C,aAAa;AACb;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C,aAAa;AACb;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C,aAAa;AACb;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C,aAAa;AACb;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C,aAAa;AACb;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C,aAAa;AACb;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C,aAAa;AACb;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C,aAAa;AACb;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C,aAAa;AACb;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C,aAAa;AACb;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C,aAAa;AACb;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C,aAAa;AACb;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C,aAAa;AACb;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C,aAAa;AACb;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C,aAAa;AACb;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C,aAAa;AACb;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C,aAAa;AACb;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C,aAAa;AACb;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA,aAAa;AACb;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iDAAQ;AAC3C;AACA;AACA;AACA;AACA,iBAAiB;AACjB,mCAAmC,iDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iDAAQ;AAC9B,sBAAsB,iDAAQ;AAC9B,sBAAsB,iDAAQ;AAC9B,sBAAsB,iDAAQ;AAC9B;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iDAAQ;AAC9B;AACA;AACA;AACA,sBAAsB,iDAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C,aAAa;AACb;AACA;AACA,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iDAAQ;AAC9B;AACA;AACA;AACA,sBAAsB,iDAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iEAAW,8BAA8B,6DAAO;AACjE;AACA,eAAe,iEAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,uBAAuB,iDAAQ;AACzC;AACA,iIAAiI;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA,mCAAmC,iDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,iDAAQ;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B,kBAAkB,iDAAQ;AAC1B;AACA;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B,kBAAkB,iDAAQ;AAC1B,kBAAkB,iDAAQ;AAC1B;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B;AACA;AACA;AACA;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B,kBAAkB,iDAAQ;AAC1B;AACA;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B,kBAAkB,iDAAQ;AAC1B;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B,kBAAkB,iDAAQ;AAC1B;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B;AACA,mCAAmC,iDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,uBAAuB,iDAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B,kBAAkB,iDAAQ;AAC1B,kBAAkB,iDAAQ;AAC1B;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,uBAAuB,iDAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA,qEAAqE,eAAe,iDAAQ;AAC5F;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,uBAAuB,iDAAQ;AACzC;AACA;AACA;AACA;AACA;AACA,6BAA6B,iEAAW;AACxC,gBAAgB,iDAAQ;AACxB;AACA;AACA;AACA,gBAAgB,iDAAQ;AACxB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B,kBAAkB,iDAAQ;AAC1B;AACA,mCAAmC,iDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B,kBAAkB,iDAAQ;AAC1B;AACA,mCAAmC,iDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B,kBAAkB,iDAAQ;AAC1B,kBAAkB,iDAAQ;AAC1B;AACA,mCAAmC,iDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B,kBAAkB,iDAAQ;AAC1B;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ,2FAA2F,iDAAQ;AACpI;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA,SAAS,6DAAO;AAChB;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B,kBAAkB,iDAAQ;AAC1B;AACA;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA,uBAAuB,iDAAQ;AAC/B,kBAAkB,6DAAO;AACzB,KAAK;AACL;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B,kBAAkB,iDAAQ;AAC1B,kBAAkB,iDAAQ;AAC1B;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B,kBAAkB,iDAAQ;AAC1B,kBAAkB,iDAAQ;AAC1B,kBAAkB,iDAAQ;AAC1B;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,uBAAuB,iDAAQ;AACzC;AACA,4DAA4D,EAAE,gBAAgB,GAAG;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,uBAAuB,iDAAQ;AACzC;AACA,8DAA8D,EAAE,gBAAgB,GAAG;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B,kBAAkB,iDAAQ;AAC1B;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B;AACA;AACA;AACA;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B,kBAAkB,iDAAQ;AAC1B;AACA;AACA;AACA;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B,kBAAkB,iDAAQ;AAC1B,kBAAkB,iDAAQ;AAC1B;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B,kBAAkB,iDAAQ;AAC1B;AACA;AACA;AACA;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAqB;AAC7B,UAAU,eAAe,iDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B,kBAAkB,iDAAQ;AAC1B,kBAAkB,iDAAQ;AAC1B,kBAAkB,iDAAQ;AAC1B;AACA;AACA;AACA;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,uBAAuB,iDAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,uBAAuB,iDAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2d;;;;;;;;;;;;;;;;;;;;AC/8HzZ;AACA;AACJ;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wEAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B,yBAAyB,oEAAY;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,wEAAe;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACgE;;;;;;;;;;;;;;;;;;ACvG4B;AACzC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kBAAkB,GAAG,4BAA4B;AAC/E;AACA;AACA,8BAA8B,kBAAkB,GAAG,4BAA4B;AAC/E;AACA,2BAA2B,kBAAkB,GAAG,4BAA4B,UAAU,4BAA4B;AAClH;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qEAAa;AACrB;AACA,wBAAwB,SAAS;AACjC,YAAY,qEAAa;AACzB;AACA;AACA;AACA;AACA;AACA,oBAAoB,oEAAY;AAChC;AACA,eAAe,gEAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qEAAa;AACrB;AACA,QAAQ,qEAAa;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oEAAY;AACxC;AACA,4BAA4B,oEAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;;;;;;;;;;;;;;;ACnQtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACiC;;;;;;;;;;;;;;;;;;ACZiB;AACI;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gEAAgE;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,kBAAkB,+DAAS;AACjE;AACA,6DAA6D,2DAAK;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmC;;;;;;;;;;;;;;;;;ACxGnC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,SAAS;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,wBAAwB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8E;;;;;;;;;;;;;;;;;;;;;;;;ACxG5B;AACN;AACD;AACuE;AAClC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oDAAQ;AAClC;AACA,6BAA6B,oDAAQ;AACrC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,oBAAoB,oDAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oBAAoB;AAC1C,sBAAsB,gIAAgI;AACtJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,qBAAqB,oDAAQ;AAC7B,2BAA2B,oDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oDAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uDAAQ;AACzC;AACA,6BAA6B,uDAAQ;AACrC;AACA;AACA;AACA;AACA,gCAAgC,oDAAQ;AACxC;AACA;AACA,iCAAiC,uDAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uDAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oDAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,qBAAqB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,oDAAQ;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,oEAAe,OAAO,iDAAK;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,+BAA+B,yDAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,iEAAY;AACnD,gDAAgD,gDAAS,OAAO,iDAAK;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,oEAAe,OAAO,iDAAK;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oDAAQ;AAClC,oBAAoB,mCAAmC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,oDAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wDAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS,oDAAQ,sBAAsB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kEAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C,YAAY,wDAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C,sBAAsB,2FAA2F;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC,kBAAkB,sFAAsF;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oDAAQ;AACjC,+BAA+B,oDAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oDAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oDAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oDAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oDAAQ;AAC7B,2BAA2B,oDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oDAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oDAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oDAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAkB;AAC1B;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C,YAAY,wDAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wDAAQ;AAC5B;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA,oBAAoB,kEAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oDAAQ;AAC7B,4BAA4B,oDAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oDAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oDAAQ;AAChC,iBAAiB,oDAAQ;AACzB,kBAAkB,oDAAQ;AAC1B,mBAAmB,oDAAQ;AAC3B;AACA;AACA;AACA,kBAAkB,oDAAQ;AAC1B;AACA;AACA;AACA,gCAAgC,oDAAQ;AACxC;AACA;AACA;AACA;AACA,6BAA6B,uDAAO;AACpC;AACA;AACA;AACA,QAAQ,yDAAS;AACjB;AACA;AACA;AACA,wBAAwB,oDAAQ;AAChC,iBAAiB,oDAAQ;AACzB,kBAAkB,oDAAQ;AAC1B,mBAAmB,oDAAQ;AAC3B;AACA;AACA,0BAA0B,oDAAQ;AAClC;AACA;AACA;AACA,+BAA+B,oDAAQ;AACvC;AACA;AACA;AACA;AACA,6BAA6B,yDAAS;AACtC;AACA;AACA;AACA,QAAQ,yDAAS;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACsF;;;;;;;;;;;;;;;;;;;;;;;AC79C3B;AACsH;AACrI;AACM;AACC;AACC;AACE;AACY;AAClE,kCAAkC,iEAAU;AAC5C;AACA;AACA,wDAAwD,0DAAO;AAC/D;AACA;AACA;AACA;AACA;AACA,gCAAgC,4DAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iDAAK;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,4BAA4B;AAC9E;AACA;AACA;AACA,8CAA8C,mBAAmB;AACjE,wBAAwB,wEAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gFAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+EAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,qEAAY;AACjE;AACA;AACA;AACA,sCAAsC,oEAAW;AACjD;AACA;AACA,yDAAyD,uFAA8B;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,6DAAQ;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,WAAW;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA,wEAAwE,0CAA0C;AAClH;AACA;AACA;AACA,gCAAgC,gFAAuB;AACvD;AACA;AACA;AACA,+DAA+D,wDAAwD;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,2DAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,SAAS;AACnF;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,gFAAuB;AACtG;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uDAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,iDAAK;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA,mDAAmD,iDAAK;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,6DAAQ;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,iDAAK;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,6DAAQ;AACpE;AACA;AACA;AACA;AACA,oCAAoC,iDAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iDAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iDAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iDAAK;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iDAAK;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iDAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAK;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAK;AACvB;AACA;AACA;AACA;AACA;AACA;AAC+B;;;;;;;;;;;;;;;;;;AC7eyG;AAC9C;AAC3B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA,qCAAqC,uEAAoB;AACzD,kCAAkC,2DAAY;AAC9C;AACA;AACA,iCAAiC,wEAAmB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0EAAiB;AACjC,2BAA2B,uEAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mEAAgB;AAC3C,+BAA+B,2DAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oEAAW;AAC9C;AACA;AACA,sDAAsD,uFAA8B;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uEAAoB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACsC;;;;;;;;;;;;;;;;;;;;;;;;AClJtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2I;;;;;;;;;;;;;;;;;;ACxVjF;AACQ;AAClE;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,wEAAc;AACvB;AACA;AACA,WAAW,4DAAQ;AACnB;AACA;AACA;AACA,SAAS,wEAAc;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AAC4D;;;;;;;;;;;;;;;;ACzH5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2D;;;;;;;;;;;;;;;;;;;;;;;;;ACrBT;AAClD;AACA;AACA;AACA;AACA,yDAAyD,oDAAG;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,oDAAG;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kDAAkD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,KAAK,KAAK,oCAAoC;AAC/F;AACA;AACA;AACA;AACA,6CAA6C,KAAK,KAAK,oCAAoC,KAAK,oBAAoB;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,KAAK,KAAK,oBAAoB,KAAK,qBAAqB;AACjG;AACA;AACA;AACA,qCAAqC,KAAK,KAAK,oBAAoB,KAAK,qBAAqB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6O;;;;;;;;;;;;;;;;AC7H/J;AAC9E,gCAAgC,uFAAe;AACd;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACFiC;AACH;AACV;AACU;AACK;AACwB;AAChB;AAC1B;AAC4D;AACD;AAChD;AAC7D;AACA,0CAA0C,mEAAU;AACpD;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wEAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,6BAA6B,8BAA8B;AAC3D;AACA;AACA,yCAAyC,oBAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wEAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kEAAS;AAClC,0BAA0B,kEAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,8DAAM;AAC/D;AACA;AACA;AACA,oCAAoC,gEAAQ;AAC5C;AACA;AACA,mCAAmC,kEAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gEAAQ;AAClC;AACA;AACA;AACA;AACA,qCAAqC,kEAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+DAAQ,iBAAiB,+DAAQ;AACrD;AACA;AACA;AACA;AACA,0BAA0B,kEAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kEAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAmB;AAC3B,YAAY,8EAAuB;AACnC,gEAAgE,8DAAM,gBAAgB,qFAA0B;AAChH;AACA;AACA;AACA,QAAQ,iEAAc;AACtB;AACA;AACA;AACA;AACA,YAAY,8EAAuB;AACnC,gCAAgC,qFAA0B;AAC1D;AACA;AACA;AACA,0BAA0B,+DAAY;AACtC;AACA,wDAAwD,8DAAM;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,wEAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+DAA+D;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2DAAK;AACrB;AACA;AACA;AACA,2EAA2E,WAAW,IAAI,EAAE;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,mEAAQ,IAAI,iEAAU;AAChE;AACA;AACA,yBAAyB,+DAAY,oEAAoE,WAAW,IAAI,QAAQ;AAChI;AACA,8GAA8G,WAAW,IAAI,QAAQ;AACrI,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,gBAAgB,8EAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,gBAAgB,8EAAuB;AACvC;AACA;AACA;AACA;AACA;AACA,iCAAiC,qFAA0B;AAC3D;AACA,8BAA8B,+DAAY;AAC1C,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,2BAA2B,iEAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,0DAAO;AACxD;AACA;AACA;AACA;AACA,uBAAuB,wDAAK,KAAK,wDAAK,wFAAwF,wDAAK;AACnI;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,uCAAuC;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,4DAAW;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA,6CAA6C,qFAA0B;AACvE;AACA;AACA;AACA;AACA;AACA,+CAA+C,+DAAQ;AACvD;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,gBAAgB,0BAA0B;AAC1C;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,gBAAgB,qCAAqC;AACrD;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,gBAAgB,qCAAqC;AACrD;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,gBAAgB,qCAAqC;AACrD;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,gBAAgB,qCAAqC;AACrD;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,qCAAqC;AACrD;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qCAAqC;AACrD,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,UAAU;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,wBAAwB,4BAA4B;AACpD,uCAAuC,2BAA2B;AAClE;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAG;AAC1B;AACA,SAAS,QAAQ,4DAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4DAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6DAAQ;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+DAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA,YAAY,0BAA0B;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,4DAA4D,uDAAuD,IAAI,0DAA0D,qDAAqD;AACpS;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wEAAqB;AACpD,+BAA+B,wEAAqB;AACpD,qBAAqB,+DAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACgJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9hCtF;AACF;AACgD;AAC7D;AACwB;AAC+B;AACrC;AAC7D;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD,sBAAsB,cAAc;AACpC,8BAA8B,cAAc;AAC5C,0BAA0B,cAAc;AACxC,qCAAqC,cAAc;AACnD,yBAAyB,cAAc;AACvC,2BAA2B,cAAc;AACzC;AACA;AACA,gCAAgC,kEAAQ,IAAI,uFAAY;AACxD;AACA;AACA;AACA;AACA,yCAAyC,0DAAO;AAChD;AACA,gDAAgD,0DAAO;AACvD;AACA;AACA;AACA;AACA,qBAAqB,iDAAQ;AAC7B;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,YAAY;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,YAAY;AAC1D;AACA,2BAA2B,aAAa;AACxC;AACA;AACA;AACA;AACA;AACA,8CAA8C,YAAY;AAC1D;AACA;AACA;AACA;AACA;AACA,8CAA8C,qCAAqC;AACnF;AACA;AACA;AACA;AACA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA,sEAAsE,mCAAmC;AACzG;AACA,yFAAyF,eAAe;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,qCAAqC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,oEAAa;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iDAAQ;AACnC;AACA,8DAA8D,GAAG;AACjE,gBAAgB,gFAA6B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,+DAAQ;AAC5C,iBAAiB,kEAAW,+BAA+B,+DAAQ;AACnE;AACA,8CAA8C,mCAAmC;AACjF;AACA;AACA,sCAAsC,YAAY,GAAG,UAAU;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,gCAAgC,+DAAQ;AACxC;AACA,2CAA2C,kEAAW,0BAA0B,+DAAQ;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,YAAY,GAAG,UAAU;AAC3D;AACA;AACA,sBAAsB,IAAI,+DAAQ,kDAAkD;AACpF;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,+BAA+B;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wEAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,wEAAiB;AACtD,0CAA0C,wEAAiB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,mBAAmB;AACtE;AACA;AACA,+BAA+B,iDAAQ;AACvC,gCAAgC,iDAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iDAAQ;AACnC,4BAA4B,iDAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kEAAW;AACvB;AACA;AACA;AACA,YAAY,kEAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,4BAA4B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gEAAQ;AACnB;AACA;AACA,yEAAyE,OAAO,GAAG,mBAAmB;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAQ;AACR;AACA;AACA,iBAAiB,iDAAQ;AACzB;AACA;AACA,iBAAiB,iDAAQ;AACzB;AACA,+BAA+B,EAAE;AACjC;AACA;AACA;AACA;AACA,iBAAiB,iDAAQ;AACzB;AACA,+BAA+B,EAAE;AACjC;AACA;AACA;AACA;AACA,iBAAiB,iDAAQ;AACzB;AACA,+BAA+B,EAAE,0BAA0B,GAAG,4BAA4B,EAAE;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+DAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwb;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpmBvT;AAC3D;AAC/B;AACI;AACsB;AACjE;AACA;AACA;AACA,6BAA6B,iEAAW;AACxC,+BAA+B,6DAAO;AACtC,iCAAiC,+DAAS;AAC1C,6BAA6B,2DAAK;AAClC,mCAAmC,iEAAW,KAAK,2DAAK;AACxD,8BAA8B,4DAAM;AACpC,iCAAiC,+DAAS;AAC1C,gCAAgC,8DAAQ;AACxC,gCAAgC,8DAAQ;AACxC;AACA;AACA,cAAc,uEAAe;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iDAAQ;AACnC,0BAA0B,iDAAQ;AAClC;AACA;AACA;AACA,4BAA4B,iDAAQ;AACpC,kCAAkC,iDAAQ;AAC1C,+BAA+B,iDAAQ;AACvC,8BAA8B,iDAAQ;AACtC,6BAA6B,iDAAQ;AACrC,4BAA4B,iDAAQ;AACpC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gDAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,mFAAmF;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,4DAA4D,gDAAO,kCAAkC;AAChJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,wBAAwB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,kCAAkC;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,gDAAO;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,4EAAmB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iGAAiG;AAC5I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iDAAQ,kBAAkB,EAAE,cAAc,EAAE,eAAe,gDAAO;AAC5F;AACA,uBAAuB,gDAAO;AAC9B,mCAAmC,yCAAyC;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,+BAA+B,sCAAsC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sCAAsC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iDAAQ,gCAAgC,EAAE;AACxE,8BAA8B,iDAAQ;AACtC;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,6DAA6D,WAAW,IAAI,kBAAkB;AAC9F;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,UAAU,MAAM,WAAW;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,UAAU,MAAM,cAAc;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,UAAU,UAAU,cAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,UAAU,MAAM,WAAW;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,UAAU,IAAI,WAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,UAAU,KAAK,WAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,UAAU,IAAI,WAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,UAAU,KAAK,WAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB,GAAG,kBAAkB;AAC1D;AACA,kBAAkB,UAAU,KAAK,MAAM;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,SAAS;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C,oCAAoC,iBAAiB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,SAAS;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C,oCAAoC,iBAAiB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,oBAAoB;AAC3D;AACA;AACA,uCAAuC,2HAA2H;AAClK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4e;;;;;;;;;;;;;;;;ACtmD9Z;AAC9E,6BAA6B,uFAAe;AACd;;;;;;;;;;;;;;;;;ACFgC;AACnB;AAC3C;AACA;AACA;AACA,qBAAqB,iDAAQ,sBAAsB,EAAE;AACrD;AACA,qBAAqB,iDAAQ,sBAAsB,GAAG,IAAI,EAAE;AAC5D;AACA,qBAAqB,iDAAQ,sBAAsB,EAAE,GAAG,GAAG,IAAI,EAAE;AACjE;AACA;AACA;AACA;AACA,6CAA6C,iDAAQ;AACrD,wCAAwC,iDAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,OAAO,EAAE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oEAAY,0BAA0B,wBAAwB;AACpF;AACA;AACA,aAAa;AACb,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,2CAA2C;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,2CAA2C;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,4BAA4B,4CAA4C;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,wCAAwC;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uGAAuG;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wCAAwC;AACpE;AACA;AACA;AACA;AACA;AACmB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpQyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,kFAAkF;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kDAAS;AAC5C,oCAAoC,kDAAS;AACggB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5Jze;AACP;AACoC;AAC5B;AACnB;AACe;AACV;AAC0B;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0EAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,gBAAgB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ,GAAG,aAAa,EAAE,2CAA2C,oBAAoB,OAAO;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,UAAU,GAAG,KAAK;AAChC;AACA;AACA;AACA;AACA;AACA,iEAAiE,iFAAmB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sFAAqB;AACvC,oBAAoB,sFAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iFAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA,6EAA6E,IAAI;AACjF,0FAA0F,IAAI;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,6DAAO;AAChB;AACA;AACA;AACA;AACA,uDAAuD,oDAAG;AAC1D;AACA;AACA;AACA;AACA,2DAA2D,oDAAG;AAC9D;AACA;AACA;AACA,yEAAyE,uEAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0EAAiB,0BAA0B,8DAAQ,EAAE,yDAAI;AACpF;AACA;AACA;AACkR;;;;;;;;;;;;;;;;;;ACxJ/M;AACS;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iFAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA,+CAA+C,iFAAmB,wBAAwB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yEAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACkE;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzDY;AACpB;AACf;AAC0B;AACjB;AACU;AAC9D;AACA,iCAAiC,EAAE,KAAK,EAAE,KAAK,EAAE;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gEAAU,UAAU,iDAAQ;AACtD;AACA;AACA;AACA,0BAA0B,gEAAU,UAAU,iDAAQ,mBAAmB,EAAE;AAC3E;AACA;AACA;AACA,0BAA0B,gEAAU,UAAU,iDAAQ;AACtD;AACA,wBAAwB,EAAE;AAC1B;AACA;AACA;AACA;AACA;AACA,0BAA0B,gEAAU,UAAU,iDAAQ;AACtD;AACA,wBAAwB,EAAE;AAC1B;AACA;AACA;AACA;AACA;AACA,0BAA0B,gEAAU,UAAU,iDAAQ;AACtD;AACA,wBAAwB,EAAE;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gEAAU,UAAU,iDAAQ;AAC1D;AACA,4BAA4B,EAAE;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gEAAU,UAAU,iDAAQ;AAC1D;AACA,4BAA4B,EAAE;AAC9B;AACA;AACA;AACA;AACA;AACA,8BAA8B,gEAAU,UAAU,iDAAQ;AAC1D;AACA,4BAA4B,EAAE,sDAAsD,EAAE,OAAO,EAAE;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gEAAU,YAAY,iDAAQ;AAC5D;AACA,4BAA4B,EAAE;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gEAAU,UAAU,iDAAQ,mBAAmB,EAAE;AAC/E;AACA;AACA;AACA,iCAAiC,mEAAQ;AACzC,iBAAiB,0EAAe;AAChC,kCAAkC,gEAAU,YAAY,iDAAQ;AAChE;AACA,uCAAuC,EAAE,6CAA6C,EAAE;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gEAAU,UAAU,iDAAQ;AAC1D;AACA,4BAA4B,EAAE;AAC9B;AACA;AACA;AACA;AACA;AACA,oCAAoC,mEAAQ;AAC5C,iBAAiB,0EAAe;AAChC,kCAAkC,gEAAU,YAAY,iDAAQ;AAChE;AACA,0CAA0C,EAAE,6CAA6C,EAAE;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,6DAAa;AACtB,0BAA0B,gEAAU,UAAU,iDAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gEAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gEAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,uEAAe;AAC/E;AACA,4BAA4B,iEAAiB;AAC7C,iBAAiB,wBAAwB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA,gEAAgE,EAAE;AAClE;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA,gEAAgE,GAAG,MAAM,EAAE;AAC3E,qGAAqG,EAAE;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iDAAQ;AAC/B;AACA,qDAAqD,EAAE;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iDAAQ;AACnC;AACA,yDAAyD,EAAE;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iDAAQ;AACnC;AACA,yDAAyD,EAAE;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iDAAQ;AAC/B;AACA,oDAAoD,EAAE,uBAAuB,EAAE;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AAC2K;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnZxG;AACA;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yEAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,4EAAa,kBAAkB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA;AACsY;;;;;;;;;;;;;;;AC1ItY;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AAC2B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/YmD;AACxC;AACG;AACgB;AACP;AACP;AACc;AACC;AACN;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wEAAwE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kEAAkE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,iDAAQ;AACvD;AACA;AACA;AACA;AACA,2BAA2B,MAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA,aAAa;AACb;AACA;AACA;AACA,4BAA4B,sDAAI;AAChC,0BAA0B,gFAAiB;AAC3C;AACA;AACA,SAAS;AACT,8BAA8B,sDAAI;AAClC,4BAA4B,gFAAiB;AAC7C;AACA;AACA,SAAS;AACT,8BAA8B,sDAAI;AAClC,4BAA4B,gFAAiB;AAC7C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,wBAAwB;AACnE;AACA;AACA,2CAA2C,uBAAuB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oDAAG,QAAQ,qBAAqB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb,aAAa;AACb,aAAa;AACb,aAAa;AACb;AACA,aAAa,+DAAQ;AACrB;AACA;AACA;AACA,qBAAqB,iDAAQ,MAAM,EAAE;AACrC;AACA;AACA,qBAAqB,iDAAQ,MAAM,EAAE;AACrC;AACA;AACA,qBAAqB,iDAAQ,MAAM,EAAE;AACrC;AACA;AACA,qBAAqB,iDAAQ,MAAM,EAAE;AACrC;AACA,iBAAiB,iDAAQ,MAAM,EAAE;AACjC;AACA;AACA;AACA,gEAAgE,4DAAO;AACvE,+DAA+D,4DAAO;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAK;AACb;AACA;AACA;AACA;AACu7B;;;;;;;;;;;;;;;;;;;;;;;ACxX/3B;AAC2C;AACzC;AAChB;AACQ;AAC9B;AACpB,oCAAoC,iEAAU;AAC9C,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,wEAAiB;AACxE;AACA;AACA;AACA;AACA,kCAAkC,sEAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,MAAM;AAC/E;AACA;AACA;AACA,4FAA4F,MAAM;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0CAA0C,kBAAkB,KAAK,QAAQ,GAAG;AACxG;AACA;AACA,4BAA4B,0CAA0C,kBAAkB,KAAK,QAAQ,GAAG;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oDAAG;AACrB;AACA,KAAK;AACL;AACA;AACA,2DAA2D,0DAAQ,MAAM,gEAAU;AACnF,iBAAiB;AACjB;AACA;AACA;AAC6E;;;;;;;;;;;;;;;AC3F7E;AACA;AACA;AACA;AACA;AACA;AACA;AAC0B;;;;;;;;;;;;;;;;;ACPwB;AAClD;AACA;AACA,sCAAsC,2DAAc;AACpD,iCAAiC,2DAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AAC6D;;;;;;;;;;;;;;;;ACX7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,IAAI,oBAAoB,yCAAyC,qBAAqB,wCAAwC;AACvJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuB;;;;;;;;;;;;;;;;;;ACnFvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA,6CAA6C,WAAW;AACxD;AACA;AACA,2CAA2C,WAAW;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiF;;;;;;;;;;;;;;;;;;;;;;;;ACrCjB;AACF;AAC0B;AACtC;AACf;AAC+B;AACP;AACK;AAChE;AACA;AACA;AACA;AACA,4FAA4F,oBAAoB;AAChH;AACA;AACA;AACA,kCAAkC,oEAAiB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oEAAqB;AAChD,4EAA4E,4CAAK;AACjF;AACA;AACA;AACA;AACA,YAAY,kEAAO;AACnB;AACA;AACA,oBAAoB,uEAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oEAAY;AAC1C;AACA;AACA;AACA,+EAA+E,GAAG;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,2DAAc;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oDAAK;AACzC;AACA;AACA;AACA;AACA,wDAAwD,WAAW,6BAA6B,cAAc;AAC9G;AACA;AACA;AACA;AACA;AACA,0EAA0E,WAAW,cAAc,wBAAwB,iBAAiB,aAAa;AACzJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,2DAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,2DAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,GAAG;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4CAAK;AACjC;AACA,yBAAyB,kBAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,oDAAK;AAC1C;AACA;AACA,4DAA4D,IAAI,aAAa,eAAe;AAC5F;AACA;AACA,8CAA8C,2DAAc;AAC5D,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO;AAChC;AACA,8CAA8C,2DAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,2DAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,UAAU;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kEAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,kEAAU;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA,mDAAmD,uEAAY;AAC/D;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,aAAa;AACb,wBAAwB;AACxB;AACA,mBAAmB;AACnB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,OAAO,aAAa,GAAG;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,OAAO,UAAU,GAAG;AACpD;AACA;AACA;AACA;AACA;AACA,eAAe,sCAAsC,EAAE,UAAU;AACjE,eAAe,oBAAoB;AACnC,0BAA0B,eAAe,kBAAkB,yBAAyB;AACpF;AACA;AACA;AACA;AACA;AACA;AACuC;;;;;;;;;;;;;;;AC5WvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6B;;;;;;;;;;;;;;;;;;ACnB2B;AACkB;AACb;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,0DAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gFAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,kEAAQ;AACc;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxCqB;AAC2B;AACd;AACJ;AACW;AACL;AAChB;AACmB;AACM;AACjB;AACoB;AACtE;AACA,WAAW,+DAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,MAAM;AAC/D;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA,gBAAgB,4EAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iEAAU;AACvC;AACA;AACA;AACA,0DAA0D,0DAAO;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iEAAU;AAC9C;AACA;AACA;AACA;AACA,+BAA+B,4DAAW;AAC1C,yDAAyD,0DAAO;AAChE;AACA,0DAA0D,0DAAO;AACjE;AACA,4DAA4D,0DAAO;AACnE;AACA;AACA;AACA,6DAA6D,yCAAyC;AACtG;AACA;AACA;AACA;AACA,YAAY,+DAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+DAAQ,mDAAmD,0DAAI;AAClF;AACA;AACA;AACA,8GAA8G,gBAAgB;AAC9H;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+DAAQ,iBAAiB,mEAAQ,mBAAmB,aAAa;AAChF;AACA;AACA,YAAY,oDAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,mCAAmC;AACtF,4CAA4C,gCAAgC;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,qCAAqC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,0DAAO;AACjD;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,4BAA4B,iDAAQ;AAC1E,sCAAsC,4BAA4B,iDAAQ;AAC1E,qCAAqC,2BAA2B,iDAAQ;AACxE,wCAAwC,8BAA8B,iDAAQ;AAC9E,sCAAsC,4BAA4B,iDAAQ;AAC1E,oCAAoC,0BAA0B,iDAAQ;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,4EAAa;AACgO;;;;;;;;;;;;;;;;;ACtahM;AAC9E,sBAAsB,uFAAe;AACrC,yBAAyB,uFAAe;AACD;;;;;;;;;;;;;;;;;ACHwB;AACpB;AAC3C,yBAAyB,iEAAU;AACnC;AACA;AACA,4BAA4B,oDAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsB;;;;;;;;;;;;;;;;;;ACpCoC;AACf;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,iDAAQ;AACtD,gDAAgD,iDAAQ;AACxD,6CAA6C,iDAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gEAAU;AAC3B,iBAAiB,gEAAU;AAC3B,iBAAiB,gEAAU;AAC3B,iBAAiB,gEAAU;AAC3B;AACA;AACA;AACA;AACA;AACA,8CAA8C,gEAAU;AACxD,gDAAgD,gEAAU;AAC1D,6CAA6C,gEAAU;AACvD,6CAA6C,gEAAU;AACvD;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AACI;;;;;;;;;;;;;;;;;;;;;;;AC5Ge;AACiB;AACvE;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD;AACrD;AACA;AACA;AACA;AACA;AACA,CAAC,kDAAkD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kDAAkD;AACnD;AACA;AACA;AACA,0BAA0B,wDAAK;AAC/B,qCAAqC,wDAAK;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgI;;;;;;;;;;;;;;;AC3ChI;AAC2B;;;;;;;;;;;;;;;;ACDmD;AAC9E,0BAA0B,uFAAe;AACd;;;;;;;;;;;;;;;;;;;;;;;ACFyD;AACpB;AACe;AACe;AACrC;AACzD;AACA,eAAe;AACf,gBAAgB;AAChB;AACA,CAAC;AACD;AACA,aAAa,8BAA8B,cAAc;AACzD,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,iEAAU;AAClE;AACA;AACA,8BAA8B,kEAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,uBAAuB,uEAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wEAAU;AAChC,MAAM,qEAAO,IAAI,kEAAgB;AACjC;AACA,mCAAmC,iEAAU;AAC7C;AACA;AACA;AACA;AACA,gEAAgE,sEAAe;AAC/E;AACA;AACA;AACA;AACA,wCAAwC,iFAAuB;AAC/D;AACA;AACA;AACA;AACA,SAAS;AACT,6CAA6C,uEAAY;AACzD,6CAA6C,uEAAY;AACzD,6CAA6C,uEAAY;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkF;;;;;;;;;;;;;;;;;ACjFJ;AAC9E,2BAA2B,uFAAe;AAC1C,iCAAiC,uFAAe;AACI;;;;;;;;;;;;;;;;;ACHA;AACe;AACnE;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAE,CAAC,+DAAQ;AACnB,QAAQ,0DAAE,CAAC,+DAAQ;AACnB,QAAQ,0DAAE;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoB;;;;;;;;;;;;;;;;;;;;ACpB8C;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,QAAQ;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,UAAU,GAAG,UAAU;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,8EAA8E;AAC9E;AACA,2CAA2C,oEAAgB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwJ;;;;;;;;;;;;;;;;;;AC9D9F;AAC1D;AACA,0BAA0B,4DAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,aAAa;AACvB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AAC6E;;;;;;;;;;;;;;;;;;;;;;;;;;ACpCb;AACC;AACF;AACpB;AACsC;AACpB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,iEAAU;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,eAAe,IAAI,YAAY;AACpE,iCAAiC,QAAQ,oEAAoE;AAC7G;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA,qCAAqC,QAAQ,wBAAwB,uEAAe;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sEAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sEAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,kEAAQ,IAAI,sFAAU;AAC3D;AACA;AACA;AACA;AACA,iBAAiB,iDAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,yBAAyB,gBAAgB;AACzC,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,sBAAsB,iDAAQ;AAC9B,sBAAsB,iDAAQ;AAC9B,sBAAsB,iDAAQ;AAC9B;AACA;AACA;AACA,sBAAsB,iDAAQ;AAC9B;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA,aAAa;AACb;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,yFAAyF;AAC1I;AACA;AAC0F;;;;;;;;;;;;;;;;AC5LZ;AAC9E,0BAA0B,uFAAe;AACd;;;;;;;;;;;;;;;;ACFmD;AAC9E,0BAA0B,uFAAe;AACd;;;;;;;;;;;;;;;;;;ACF3B;AACA;AACA;AACA;AAC2H;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACJ1D;AACE;AACzB;AACD;AAC4E;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,+DAAoB;AACxE,8DAA8D,8EAAmC;AACjG,oDAAoD,mEAAwB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4EAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,sDAAsD,GAAG,GAAG;AACtE,UAAU,uDAAuD;AACjE,UAAU,sDAAsD,GAAG,wBAAwB,GAAG,aAAa,GAAG,IAAI;AAClH,UAAU,mHAAmH;AAC7H,UAAU,0EAA0E,KAAK,uBAAuB,MAAM,sFAAsF,IAAI,oEAAoE;AACpR,UAAU;AACV;AACA;AACA;AACA,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA;AACA;AACA,WAAW,uEAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACqM;;;;;;;;;;;;;;;;;;;;AC3IrM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,wBAAwB,iHAAiH;AACzI,KAAK;AACL;AAC0P;;;;;;;;;;;;;;;ACtB1P;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5CiC;AACN;AACqB;AAClB;AACN;AACC;AACP;AACP;AACuD;AACrC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wDAAwD;AAChF;AACA;AACA;AACA;AACA;AACA,qCAAqC,+DAAQ;AAC7C,qEAAqE,+DAAQ,cAAc,+DAAQ;AACnG;AACA;AACA;AACA;AACA,8BAA8B,+BAA+B,oDAAG,sBAAsB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA,mCAAmC,0DAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+BAA+B,iDAAQ;AACzE;AACA;AACA,4BAA4B;AAC5B,yCAAyC,+BAA+B,iDAAQ;AAChF,qBAAqB;AACrB;AACA,wCAAwC,QAAQ,6BAA6B;AAC7E;AACA,aAAa;AACb;AACA;AACA;AACA,qCAAqC,6BAA6B,gEAAS,oBAAoB;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,aAAa,IAAI,GAAG;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,oDAAoD,YAAY,MAAM,GAAG;AACzE;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gEAAS;AAC5B;AACA;AACA,sCAAsC,cAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,cAAc,SAAS,KAAK,GAAG,gEAAS,gDAAgD,GAAG,oBAAoB;AACxJ;AACA;AACA;AACA,mDAAmD,gEAAS;AAC5D,yCAAyC,cAAc,SAAS,KAAK;AACrE;AACA;AACA;AACA;AACA;AACA,kEAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sFAAwB;AAC1D;AACA;AACA,0CAA0C,eAAe;AACzD;AACA;AACA;AACA;AACA,yBAAyB,kEAAQ,IAAI,uFAAY;AACjD;AACA,uBAAuB,mEAAgB;AACvC;AACA;AACA;AACA;AACA,CAAC;AACD,iDAAiD,6DAAO,UAAU,iDAAQ;AAC1E,oEAAoE,6DAAO,YAAY,iDAAQ;AAC/F,4DAA4D,6DAAO,cAAc,iDAAQ;AACzF,gBAAgB,gEAAS,QAAQ,6DAAO;AACxC,wBAAwB,gEAAS,QAAQ,6DAAO;AACuH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7LnF;AAC5B;AACO;AACzB;AACI;AACkD;AAC9B;AAC9D;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0DAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,iEAAU;AAC1E;AACA;AACA;AACA;AACA,qCAAqC,0DAAO;AAC5C;AACA,qCAAqC,0DAAO;AAC5C;AACA,4CAA4C,0DAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,WAAW,GAAG,YAAY,gBAAgB,UAAU;AAC5I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F,wBAAwB,GAAG,yBAAyB;AACjJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F,WAAW,GAAG,WAAW;AACvH;AACA;AACA;AACA,gDAAgD,8DAA8D;AAC9G;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,WAAW,GAAG,YAAY;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,4BAA4B;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,WAAW,GAAG,YAAY,gBAAgB,UAAU;AACnJ;AACA;AACA;AACA,+BAA+B;AAC/B,gCAAgC,iBAAiB,oCAAoC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,wEAAU;AACpC,MAAM,qEAAO,IAAI,mEAAW;AAC5B,MAAM,qEAAO,IAAI,iGAAqB;AACtC;AACqP;;;;;;;;;;;;;;;;ACtUvK;AAC9E,8BAA8B,uFAAe;AACd;;;;;;;;;;;;;;;;ACF+C;AAC9E,mCAAmC,uFAAe;AACd;;;;;;;;;;;;;;;ACFpC;AACA;AACA;AACA;AACA;AACA,CAAC,4DAA4D;AACzB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNO;AACsB;AACa;AACsD;AAClF;AACQ;AAC1D;AACA;AACA,6DAA6D,oDAAG;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA,oBAAoB,8DAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,oDAAG;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oDAAG;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gFAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gFAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mEAAQ;AACvB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,cAAc,+BAA+B,8EAAmB,YAAY;AAC5E,cAAc;AACd;AACA;AACA;AACA;AACA,6BAA6B,oBAAoB;AACjD,4BAA4B,QAAQ,iDAAQ,6DAA6D;AACzG;AACA;AACA,WAAW,iFAA0B;AACrC;AACA;AACA;AACA,QAAQ,oDAAG;AACX;AACA;AACA;AACA;AACA;AACA,4BAA4B,4DAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,6DAAO,SAAS,kEAAS;AACtE;AACA;AAC4d;;;;;;;;;;;;;;;;AClK9Y;AAC9E,mCAAmC,uFAAe;AACd;;;;;;;;;;;;;;;ACFpC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS,eAAe,gBAAgB;AAC/D;AACA;AACiB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3B8D;AAC8B;AAC9C;AACQ;AACE;AACf;AACR;AACqC;AACF;AACI;AACrB;AACuB;AACR;AACpB;AAC2B;AACX;AACc;AACC;AACL;AACZ;AAChB;AACqB;AACd;AACX;AACI;AACI;AACR;AACI;AACL;AACK;AACK;AACD;AACD;AACF;AACD;AACR;AACiC;AACD;AAC5B;AACqB;AAClB;AACF;AACa;AACY;AACxB;AACiB;AACO;AACf;AACE;AACT;AACE;AACQ;AACI;AACP;AACX;AACqB;AACV;AACD;AACF;AACoC;AAC5B;AACJ;AACA;AACI;AACd;AACuB;AAC3B;AACE;AACM;AACH;AACf;AACO;AACU;AACb;AACE;AACM;AACH;AACY;AAClB;AACmD;AAC7B;AACkB;AAClC;AACG;AACJ;AACE;AACE;AACS;AACJ;AACqhJ;AACzhJ;AACiB;AAC5B;AACO;AACW;AACH;AACV;AACM;AACkC;AACT;AAC4B;AACiD;AACrG;AAC3D;AACA,kCAAkC,gFAAuB;AACzD,+CAA+C,8EAAsB;AACrE,mDAAmD,sFAA0B;AAC7E,0CAA0C,kFAAwB;AAClE,0CAA0C,oEAAiB;AAC3D,0CAA0C,oEAAiB;AAC3D,8CAA8C,4EAAqB;AACnE,wCAAwC,qFAAsB;AAC9D,qCAAqC,sEAAkB;AACvD,wCAAwC,gEAAe;AACvD,+CAA+C,4EAAsB;AACrE,8CAA8C,gFAAc;AAC5D,2CAA2C,6EAAW;AACtD,8CAA8C,4EAAqB;AACnE,+CAA+C,4FAA6B;AAC5E,uCAAuC,8DAAc;AACrD,4CAA4C,wEAAmB;AAC/D,2CAA2C,sEAAkB;AAC7D,+CAA+C,8EAAsB;AACrE,+CAA+C,8EAAsB;AACrE,+CAA+C,8EAAsB;AACrE,oBAAoB,iEAAc;AAClC,oBAAoB,iEAAc;AAClC,oBAAoB,iEAAc;AAClC,oBAAoB,iEAAc;AAClC,oBAAoB,iEAAc;AAClC,oBAAoB,iEAAc;AAClC,oBAAoB,iEAAc;AAClC,oBAAoB,iEAAc;AAClC,oBAAoB,iEAAc;AAClC,oBAAoB,iEAAc;AAClC,oBAAoB,iEAAc;AAClC,oBAAoB,iEAAc;AAClC,oBAAoB,iEAAc;AAClC,oBAAoB,iEAAc;AAClC,+CAA+C,iEAAc,kCAAkC,wEAAmB;AAClH,uDAAuD,iEAAc,0CAA0C,wFAA2B;AAC1I,4CAA4C,iEAAc,+BAA+B,kEAAgB;AACzG,mDAAmD,iEAAc,sCAAsC,gFAAuB;AAC9H,4DAA4D,iEAAc,+CAA+C,kGAAgC;AACzJ,gDAAgD,iEAAc,mCAAmC,0EAAoB;AACrH,0CAA0C,iEAAc,6BAA6B,8DAAc;AACnG,wCAAwC,iEAAc,2BAA2B,0DAAY;AAC7F,iDAAiD,iEAAc,oCAAoC,qEAAqB;AACxH,gDAAgD,iEAAc,mCAAmC,wFAA2B;AAC5H,wCAAwC,iEAAc,oBAAoB,yDAAW;AACrF,6CAA6C,iEAAc,yBAAyB,mEAAgB;AACpG,4DAA4D,iEAAc,wCAAwC,gGAA8B;AAChJ,2DAA2D,iEAAc,uCAAuC,+FAA8B,6DAA6D,8DAAW;AACtN,4CAA4C,iEAAc,wBAAwB,2EAAyB;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,iEAAc,iCAAiC,mFAAwB;AAC5H,mDAAmD,iEAAc,+BAA+B,+EAAsB;AACtH,mDAAmD,iEAAc,+BAA+B,+EAAsB;AACtH,qDAAqD,iEAAc,iCAAiC,mFAAwB;AAC5H,mEAAmE,iEAAc,+CAA+C,+GAAsC,4DAA4D,8DAAW;AAC7O,2CAA2C,iEAAc,uBAAuB,mEAAc;AAC9F,6CAA6C,iEAAc,yBAAyB,mEAAgB,wBAAwB,8DAAW;AACvI,gDAAgD,iEAAc,4BAA4B,uEAAmB,wBAAwB,8DAAW;AAChJ,+CAA+C,iEAAc,2BAA2B,uEAAkB;AAC1G;AACA;AACA;AACA;AACA;AACA,6CAA6C,iEAAc,yBAAyB,mEAAgB;AACpG,oDAAoD,iEAAc,gCAAgC,iFAAuB;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,iEAAc,0BAA0B,sEAAiB;AACvG,8CAA8C,iEAAc,0BAA0B,qEAAiB;AACvG,mDAAmD,iEAAc,sCAAsC,6FAA6B;AACpI,6CAA6C,iEAAc,mBAAmB,6EAAsB;AACpG,uCAAuC,iEAAc,mBAAmB,uDAAU;AAClF,6CAA6C,iEAAc,yBAAyB,mEAAgB;AACpG,yCAAyC,iEAAc,qBAAqB,2DAAY;AACxF,2CAA2C,iEAAc,kBAAkB,2EAAqB;AAChG,4CAA4C,iEAAc,wBAAwB,iEAAe,wBAAwB,8DAAW;AACpI,gDAAgD,iEAAc,4BAA4B,yEAAmB;AAC7G,2CAA2C,iEAAc,uBAAuB,+DAAc;AAC9F,4CAA4C,iEAAc,wBAAwB,iEAAe;AACjG,4CAA4C,iEAAc,wBAAwB,gEAAe;AACjG;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,iEAAc,6BAA6B,2EAAoB;AAChH,iDAAiD,iEAAc,6BAA6B,2EAAoB;AAChH;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,iEAAc,4BAA4B,wEAAmB;AAC7G,2CAA2C,iEAAc,8BAA8B,gEAAe;AACtG,8CAA8C,iEAAc,0BAA0B,oEAAiB;AACvG,0DAA0D,iEAAc,sCAAsC,4FAA6B;AAC3I,oBAAoB,iEAAc,2BAA2B,uEAAkB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,iEAAc,2BAA2B,uEAAkB;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,iEAAc,6BAA6B,2EAAoB;AAChH,sDAAsD,iEAAc,kCAAkC,qFAAyB;AAC/H,wDAAwD,iEAAc,oCAAoC,uFAAyB;AACnI,qDAAqD,iEAAc,iCAAiC,iFAAwB;AAC5H,6CAA6C,iEAAc,yBAAyB,mEAAgB;AACpG,0CAA0C,iEAAc,sBAAsB,6DAAa;AAC3F,8CAA8C,iEAAc,0BAA0B,oEAAiB;AACvG,qCAAqC,iEAAc;AACnD;AACA,mCAAmC,mEAAgB;AACnD,mCAAmC,mEAAgB;AACnD,wCAAwC,6EAAqB;AAC7D,iCAAiC,+DAAc;AAC/C,IAAI,uEAAkB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iFAAyB;AACjD,mEAAmE,2BAA2B,4BAA4B,kBAAkB;AAC5I,8BAA8B;AAC9B;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,2BAA2B;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oGAAuB;AAC/C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,oBAAoB,oGAAuB;AAC3C;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC,kGAAkG,cAAc;AAChH,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,8BAA8B,0CAA0C;AACxE,8BAA8B,0CAA0C;AACxE,6BAA6B,0CAA0C;AACvE,4BAA4B,sCAAsC;AAClE,4BAA4B,oDAAoD;AAChF,4BAA4B,sCAAsC;AAClE,8BAA8B,2CAA2C;AACzE,8BAA8B,gCAAgC;AAC9D;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,uBAAuB,sEAAe;AACtC,aAAa;AACb;AACA,gBAAgB,yEAAsB;AACtC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,oEAAoE,6CAA6C;AACjH;AACA;AACA,wBAAwB,sEAAa,MAAM,4DAAO,UAAU,sEAAa,MAAM,4DAAO;AACtF;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,uBAAuB,sFAAa;AACpC,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA;AACA,cAAc,4DAAa;AAC3B,cAAc,4DAAa;AAC3B;AACA;AACA,qBAAqB,iGAAoB;AACzC;AACA;AACA;AACA;AACA,iCAAiC,mEAAS;AAC1C;AACA;AACA;AACA;AACA,qCAAqC,mEAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,sCAAsC,mEAAS;AAC/C;AACA;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC,oCAAoC,8FAAsB;AAC1D;AACA;AACA;AACA,sCAAsC,mEAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,oBAAoB,iGAAoB;AACxC,6CAA6C,wDAAK;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,wCAAwC,wEAAgB;AACxD;AACA,oBAAoB,oFAAgB;AACpC;AACA;AACA,uBAAuB,yEAAK;AAC5B,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,oBAAoB,oGAAuB;AAC3C;AACA;AACA,oBAAoB,oGAAuB;AAC3C;AACA;AACA,oBAAoB,oGAAuB;AAC3C;AACA;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,iHAAiH,iGAAoB;AACrI;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,oBAAoB,oDAAG,kDAAkD,4DAAO;AAChF;AACA;AACA,wCAAwC,oDAAG;AAC3C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,oEAAoE,gEAAU;AAC9E,aAAa;AACb;AACA,oEAAoE,gEAAU;AAC9E,aAAa;AACb;AACA,oEAAoE,gEAAU;AAC9E,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,iEAAiE,UAAU,+DAAgB,gBAAgB,8BAA8B,eAAe;AACxJ,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,2EAA2E;AAC3E;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,0BAA0B,iEAAa;AACvC,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,0BAA0B,iEAAa;AACvC,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,0BAA0B,iEAAa;AACvC,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,oBAAoB,oGAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,0BAA0B,iEAAa;AACvC,aAAa;AACb;AACA;AACA;AACA;AACA,iDAAiD,oDAAG;AACpD;AACA,yBAAyB,oDAAG;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,qBAAqB;AAC1F,uCAAuC,4DAAO;AAC9C;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,oBAAoB,oDAAG;AACvB;AACA;AACA;AACA;AACA,0BAA0B,oDAAG,uDAAuD,8BAA8B;AAClH;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,4GAA4G,iGAAoB;AAChI,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA,uBAAuB,6EAAkB;AACzC,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,kHAAkH,kGAAqC;AACvJ,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,sFAAsF,uCAAuC;AAC7H;AACA,4GAA4G;AAC5G,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,oHAAoH,iGAAoB;AACxI,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,mCAAmC;AAC3H;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oGAAuB;AACvC;AACA;AACA;AACA;AACA;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA;AACA;AACA;AACA;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA;AACA;AACA,2FAA2F;AAC3F,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,oGAAuB;AACvC;AACA,aAAa;AACb;AACA;AACA;AACA,gBAAgB,oGAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yDAAU;AAClC,kCAAkC,mEAAoB;AACtD,oCAAoC,qEAAsB;AAC1D,+BAA+B,gEAAiB;AAChD,gCAAgC,iEAAkB;AAClD,uCAAuC,wEAAyB;AAChE,+BAA+B,gEAAiB;AAChD,uCAAuC,wEAAyB;AAChE,+BAA+B,qEAAiB;AAChD,qCAAqC,iFAAuB;AAC5D,iCAAiC,sEAAmB;AACpD,wBAAwB,yDAAU;AAClC,4BAA4B,6DAAc;AAC1C,mCAAmC,oEAAqB;AACxD,sBAAsB,uDAAQ;AAC9B,mBAAmB,oDAAK;AACxB,8BAA8B,+DAAgB;AAC9C,+BAA+B,gEAAiB;AAChD,4BAA4B,6DAAc;AAC1C,yBAAyB,0DAAW;AACpC,0BAA0B,2DAAY;AACtC,2CAA2C,4EAA6B;AACxE,gCAAgC,iEAAkB;AAClD,wCAAwC,yEAA0B;AAClE,gCAAgC,iEAAkB;AAClD,4BAA4B,6DAAc;AAC1C,gCAAgC,iEAAkB;AAClD,+BAA+B,gEAAiB;AAChD,4BAA4B,6DAAc;AAC1C,mCAAmC,oEAAqB;AACxD,iCAAiC,kEAAmB;AACpD,6BAA6B,8DAAe;AAC5C,oCAAoC,qEAAsB;AAC1D,8CAA8C,+EAAgC;AAC9E,yCAAyC,0EAA2B;AACpE,gCAAgC,iEAAkB;AAClD,mDAAmD,kGAAqC;AACxF,8BAA8B,+DAAgB;AAC9C,gCAAgC,iEAAkB;AAClD,qCAAqC,sEAAuB;AAC5D,wBAAwB,yDAAU;AAClC,0CAA0C,2EAA4B;AACtE,gCAAgC,iEAAkB;AAClD,2BAA2B,4DAAa;AACxC,wBAAwB,yDAAU;AAClC,+BAA+B,gEAAiB;AAChD,mCAAmC,oEAAqB;AACxD,oCAAoC,qEAAsB;AAC1D,0BAA0B,2DAAY;AACtC,4BAA4B,6DAAc;AAC1C,uBAAuB,wDAAS;AAChC,4CAA4C,6EAA8B;AAC1E,mCAAmC,oEAAqB;AACxD,6BAA6B,8DAAe;AAC5C,uCAAuC,wEAAyB;AAChE,8CAA8C,+EAAgC;AAC9E,yCAAyC,0EAA2B;AACpE,0BAA0B,0DAAO;AACjC,2BAA2B,4DAAa;AACxC,2BAA2B,4DAAa;AACxC,uCAAuC,wEAAyB;AAChE,4BAA4B,6DAAc;AAC1C,4BAA4B,6DAAc;AAC1C,6BAA6B,6DAAc;AAC3C,6BAA6B,8DAAe;AAC5C,sBAAsB,sEAAQ;AAC9B,4BAA4B,4EAAc;AAC1C,0BAA0B,2DAAY;AACtC,8BAA8B,+DAAgB;AAC9C,gCAAgC,iEAAkB;AAClD,kCAAkC,+DAAgB;AAClD,kCAAkC,mEAAoB;AACtD,mBAAmB,oDAAK;AACxB,0BAA0B,2DAAY;AACtC,kCAAkC,mEAAoB;AACtD,0BAA0B,2FAAY;AACtC,sBAAsB,uDAAQ;AAC9B,4BAA4B,6DAAc;AAC1C,+BAA+B,uEAAiB;AAChD,kCAAkC,mEAAoB;AACtD,mCAAmC,oEAAqB;AACxD,sBAAsB,uDAAQ;AAC9B,8BAA8B,+DAAgB;AAC9C,8BAA8B,+DAAgB;AAC9C,sCAAsC,uEAAwB;AAC9D,+BAA+B,gEAAiB;AAChD,mBAAmB,oDAAK;AACxB,6BAA6B,8DAAe;AAC5C,uBAAuB,wDAAS;AAChC,4BAA4B,6DAAc;AAC1C,4BAA4B,6DAAc;AAC1C,mCAAmC,oEAAqB;AACxD,gCAAgC,iEAAkB;AAClD,iCAAiC,kEAAmB;AACpD,kCAAkC,mEAAoB;AACtD,4BAA4B,6DAAc;AAC1C,0BAA0B,2DAAY;AACtC,2BAA2B,4DAAa;AACxC,sCAAsC,uEAAwB;AAC9D,kCAAkC,mEAAoB;AACtD,2BAA2B,4DAAa;AACxC,8BAA8B,+DAAgB;AAC9C,+BAA+B,gEAAiB;AAChD,gCAAgC,iEAAkB;AAClD,+BAA+B,gEAAiB;AAChD,wBAAwB,yDAAU;AAClC,uBAAuB,wDAAS;AAChC,kBAAkB,mDAAI;AACtB,uBAAuB,wDAAS;AAChC,2BAA2B,4DAAa;AACxC,4BAA4B,6DAAc;AAC1C,uBAAuB,wDAAS;AAChC,0BAA0B,2DAAY;AACtC,6CAA6C,sEAAuB;AACpE,oCAAoC,qEAAsB;AAC1D,8BAA8B,+DAAgB;AAC9C,6BAA6B,8DAAe;AAC5C,gCAAgC,iEAAkB;AAClD,yDAAyD,0FAA2C;AACpG,oCAAoC,qEAAsB;AAC1D,sBAAsB,uDAAQ;AAC9B,6BAA6B,8DAAe;AAC5C,mCAAmC,yFAAqB;AACxD,wCAAwC,yEAA0B;AAClE,kCAAkC,mEAAoB;AACtD,2CAA2C,4EAA6B;AACxE,6BAA6B,8DAAe;AAC5C,sCAAsC,uEAAwB;AAC9D,wBAAwB,yDAAU;AAClC,uBAAuB,wDAAS;AAChC,sBAAsB,uDAAQ;AAC9B,mCAAmC,oEAAqB;AACxD,sCAAsC,uEAAwB;AAC9D,+BAA+B,gEAAiB;AAChD,oBAAoB,yFAAM;AAC1B,iBAAiB,oDAAG;AACpB,wBAAwB,yDAAU;AAClC,2BAA2B,4DAAa;AACxC,sCAAsC,uEAAwB;AAC9D,8BAA8B,+DAAgB;AAC9C,yCAAyC,0EAA2B;AACpE,+BAA+B,gEAAiB;AAChD,uBAAuB,wDAAS;AAChC,gCAAgC,iEAAkB;AAClD,2BAA2B,4DAAa;AACxC,0CAA0C,2EAA4B;AACtE,+BAA+B,gEAAiB;AAChD,sCAAsC,uEAAwB;AAC9D,iDAAiD,kFAAmC;AACpF,8BAA8B,+DAAgB;AAC9C,0BAA0B,2DAAY;AACtC,2BAA2B,4DAAa;AACxC,8BAA8B,+DAAgB;AAC9C,wCAAwC,yEAA0B;AAClE,8BAA8B,+DAAgB;AAC9C,0BAA0B,2DAAY;AACtC,oCAAoC,qEAAsB;AAC1D,4CAA4C,6EAA8B;AAC1E,sCAAsC,uEAAwB;AAC9D,gCAAgC,iEAAkB;AAClD,oCAAoC,qEAAsB;AAC1D,uCAAuC,wEAAyB;AAChE,wCAAwC,yEAA0B;AAClE,yCAAyC,0EAA2B;AACpE,0BAA0B,2DAAY;AACtC,wCAAwC,yEAA0B;AAClE,0CAA0C,2EAA4B;AACtE,4BAA4B,6DAAc;AAC1C,iCAAiC,kEAAmB;AACpD,6BAA6B,8DAAe;AAC5C,4BAA4B,6DAAc;AAC1C,yBAAyB,0DAAW;AACpC,mCAAmC,oEAAqB;AACxD,qBAAqB,sDAAO;AAC5B,gCAAgC,iEAAkB;AAClD,2CAA2C,sGAA6B;AACxE,0BAA0B,2DAAY;AACtC,8BAA8B,+DAAgB;AAC9C,+BAA+B,gEAAiB;AAChD,0BAA0B,2DAAY;AACtC,2BAA2B,2DAAY;AACvC,+BAA+B,gEAAiB;AAChD,4BAA4B,6DAAc;AAC1C,iCAAiC,kEAAmB;AACpD,iCAAiC,kEAAmB;AACpD,oCAAoC,qEAAsB;AAC1D,+BAA+B,gEAAiB;AAChD,wCAAwC,yEAA0B;AAClE,0BAA0B,2DAAY;AACtC,8BAA8B,+DAAgB;AAC9C,+BAA+B,gEAAiB;AAChD,4BAA4B,mEAAoB;AAChD,8BAA8B,qEAAsB;AACpD,kCAAkC,yEAA0B;AAC5D,6BAA6B,oEAAqB;AAClD,8BAA8B,qEAAsB;AACpD,uCAAuC,qEAAsB;AAC7D,0BAA0B,iEAAkB;AAC5C,mCAAmC,oEAAqB;AACxD,mCAAmC,gGAAqB;AACxD,sBAAsB,kEAAQ;AAC9B,sCAAsC,iGAAwB;AAC9D,6CAA6C,8EAA+B;AAC5E,0BAA0B,2DAAY;AACtC,mDAAmD,oFAAqC;AACxF,6BAA6B,8DAAe;AAC5C,yBAAyB,0DAAW;AACpC,oCAAoC,qEAAsB;AAC1D,gCAAgC,iEAAkB;AAClD,gCAAgC,iEAAkB;AAClD,sCAAsC,uEAAwB;AAC9D,sCAAsC,uEAAwB;AAC9D,sCAAsC,uEAAwB;AAC9D,sCAAsC,uEAAwB;AAC9D,oCAAoC,qEAAsB;AAC1D,sCAAsC,uEAAwB;AAC9D,uCAAuC,wEAAyB;AAChE,uCAAuC,wEAAyB;AAChE,wCAAwC,wEAAyB;AACjE,0CAA0C,2EAA4B;AACtE,0CAA0C,2EAA4B;AACtE,qCAAqC,sEAAuB;AAC5D,sCAAsC,uEAAwB;AAC9D,yDAAyD,0FAA2C;AACpG,2CAA2C,4EAA6B;AACxE,iDAAiD,kFAAmC;AACpF,0CAA0C,2EAA4B;AACtE,kCAAkC,mEAAoB;AACtD,iDAAiD,kFAAmC;AACpF,6BAA6B,8DAAe;AAC5C,8BAA8B,+DAAgB;AAC9C,0BAA0B,2DAAY;AACtC,mCAAmC,oEAAqB;AACxD,qCAAqC,sEAAuB;AAC5D,0CAA0C,2EAA4B;AACtE,sCAAsC,uEAAwB;AAC9D,oDAAoD,0EAA2B;AAC/E,+CAA+C,oEAAqB;AACpE,mDAAmD,wEAAyB;AAC5E,gCAAgC,iEAAkB;AAClD,2BAA2B,4DAAa;AACxC,8BAA8B,+DAAgB;AAC9C,sCAAsC,uEAAwB;AAC9D,wBAAwB,yDAAU;AAClC,mCAAmC,oEAAqB;AACxD,mCAAmC,8FAAqB;AACxD,kCAAkC,6FAAoB;AACtD,gCAAgC,2FAAkB;AAClD,8CAA8C,sGAA6B;AAC3E;AACA;AACA;AAC6C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtsD4C;AACR;AACL;AACM;AACM;AACf;AACiC;AACN;AACjC;AACwB;AACxB;AACG;AACkB;AACwB;AAC7C;AACoC;AACZ;AACT;AACN;AACG;AACd;AACY;AACkD;AACrB;AACf;AACA;AACA;AAC8B;AACnD;AACtE,+FAAiB,CAAC,wFAA2B,EAAE,uFAA0B;AACzE,+FAAiB,CAAC,gFAAc,EAAE,2EAAoB;AACtD,+FAAiB,CAAC,4FAA6B,EAAE,2FAA4B;AAC7E,+FAAiB,CAAC,iEAAgB,EAAE,gEAAe;AACnD,+FAAiB,CAAC,8EAAsB,EAAE,6EAAqB;AAC/D,+FAAiB,CAAC,8EAAsB,EAAE,6EAAqB;AAC/D,+FAAiB,CAAC,2EAAqB,EAAE,0EAAoB;AAC7D,+FAAiB,CAAC,sFAA0B,EAAE,qFAAyB;AACvE,+FAAiB,CAAC,gEAAe,EAAE,+DAAc;AACjD,+FAAiB,CAAC,yEAAoB,EAAE,8EAAyB;AACjE,+FAAiB,CAAC,uEAAmB,EAAE,sEAAkB;AACzD,+FAAiB,CAAC,uFAA2B,EAAE,sFAA0B;AACzE,+FAAiB,CAAC,8EAAsB,EAAE,6EAAqB;AAC/D,+FAAiB,CAAC,8EAAsB,EAAE,6EAAqB;AAC/D,+FAAiB,CAAC,oEAAqB,EAAE,mEAAoB;AAC7D,+FAAiB,CAAC,8DAAc,EAAE,6DAAa;AAC/C,+FAAiB,CAAC,gEAAe,EAAE,+DAAc;AACjD,+FAAiB,CAAC,yDAAY,EAAE,8DAAiB;AACjD,+FAAiB,CAAC,+EAAuB,EAAE,oFAA4B;AACvE,+FAAiB,CAAC,kGAAgC,EAAE,iGAA+B;AACnF,+FAAiB,CAAC,4EAAqB,EAAE,2EAAoB;AAC7D,+FAAiB,CAAC,8DAAc,EAAE,6DAAa;AAC/C,+FAAiB,CAAC,mEAAiB,EAAE,kEAAgB;AACrD,+FAAiB,CAAC,wEAAmB,EAAE,uEAAkB;AACzD,+FAAiB,CAAC,oEAAiB,EAAE,mEAAgB;AACrD,+FAAiB,CAAC,sEAAkB,EAAE,qEAAiB;AACvD,+FAAiB,CAAC,iGAAgC,EAAE,uGAAsC;;;;;;;;;;;;;;;;;;;;ACvDE;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4DAA4D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kDAAkD;AACnD;AACA,gCAAgC,qGAAqB;AACrD,2BAA2B,qGAAqB;AAChD,gCAAgC,qGAAqB;AACrD,4BAA4B,qGAAqB;AACjD,6BAA6B,qGAAqB;AAClD,4BAA4B,qGAAqB;AACjD,+BAA+B,qGAAqB;AACpD,oCAAoC,qGAAqB;AACzD,2BAA2B,qGAAqB;AAChD,0BAA0B,qGAAqB;AAC/C,0BAA0B,qGAAqB;AAC/C,+BAA+B,qGAAqB;AACpD,yBAAyB,qGAAqB;AAC9C,8BAA8B,qGAAqB;AACnD,6BAA6B,qGAAqB;AAClD,6BAA6B,qGAAqB;AAClD,yBAAyB,qGAAqB;AAC9C,2BAA2B,qGAAqB;AAChD,0CAA0C,qGAAqB;AAC/D,6BAA6B,qGAAqB;AAClD,8BAA8B,qGAAqB;AACnD,4BAA4B,qGAAqB;AACjD,wBAAwB,qGAAqB;AAC7C,2BAA2B,qGAAqB;AAChD,iCAAiC,qGAAqB;AACtD,kCAAkC,qGAAqB;AACvD,2BAA2B,qGAAqB;AAChD,wBAAwB,qGAAqB;AAC7C,gCAAgC,qGAAqB;AACrD,+BAA+B,qGAAqB;AACpD,0BAA0B,qGAAqB;AAC/C,2BAA2B,qGAAqB;AAChD,2BAA2B,qGAAqB;AAChD,2BAA2B,qGAAqB;AAChD,6BAA6B,qGAAqB;AAClD,yBAAyB,qGAAqB;AAC9C,wBAAwB,qGAAqB;AAC7C,2BAA2B,qGAAqB;AAChD,iCAAiC,qGAAqB;AACtD,0CAA0C,qGAAqB;AAC/D,0BAA0B,qGAAqB;AAC/C,+BAA+B,qGAAqB;AACpD,8BAA8B,qGAAqB;AACnD,+BAA+B,qGAAqB;AACpD,sBAAsB,qGAAqB;AAC3C,4BAA4B,qGAAqB;AACjD,wCAAwC,qGAAqB;AAC7D,2BAA2B,qGAAqB;AAChD,4BAA4B,qGAAqB;AACjD,wCAAwC,qGAAqB;AAC7D,kCAAkC,qGAAqB;AACvD,qBAAqB,qGAAqB;AAC1C,wBAAwB,qGAAqB;AAC7C,uBAAuB,qGAAqB;AAC5C,sBAAsB,qGAAqB;AAC3C,wBAAwB,qGAAqB;AAC7C,8BAA8B,qGAAqB;AACnD,0BAA0B,qGAAqB;AAC/C,mCAAmC,qGAAqB;AACxD,iCAAiC,qGAAqB;AACtD,iCAAiC,qGAAqB;AACtD,mCAAmC,qGAAqB;AACxD,6BAA6B,qGAAqB;AAClD,yBAAyB,qGAAqB;AAC9C,+BAA+B,qGAAqB;AACpD,gCAAgC,qGAAqB;AACrD,0BAA0B,qGAAqB;AAC/C,yBAAyB,qGAAqB;AAC9C,8BAA8B,qGAAqB;AACnD,sCAAsC,qGAAqB;AAC3D,mCAAmC,qGAAqB;AACxD;AACA;AACA,yBAAyB,qGAAqB;AAC9C,uBAAuB,qGAAqB;AAC5C,4BAA4B,qGAAqB;AACjD,0BAA0B,qGAAqB;AAC/C,2BAA2B,qGAAqB;AAChD,0BAA0B,qGAAqB;AAC/C,kCAAkC,qGAAqB;AACvD,wBAAwB,qGAAqB;AAC7C,uCAAuC,qGAAqB;AAC5D,sCAAsC,qGAAqB;AAC3D,sBAAsB,qGAAqB;AAC3C,wBAAwB,qGAAqB;AAC7C,yBAAyB,qGAAqB;AAC9C,6BAA6B,qGAAqB;AAClD,qCAAqC,qGAAqB;AAC1D,wBAAwB,qGAAqB;AAC7C,+BAA+B,qGAAqB;AACpD,wBAAwB,qGAAqB;AAC7C,wBAAwB,qGAAqB;AAC7C,wBAAwB,qGAAqB;AAC7C,oBAAoB,qGAAqB;AACzC,+BAA+B,qGAAqB;AACpD,mCAAmC,qGAAqB;AACxD,8BAA8B,qGAAqB;AACnD,uCAAuC,qGAAqB;AAC5D,kBAAkB,qGAAqB;AACvC,qBAAqB,qGAAqB;AAC1C,mBAAmB,qGAAqB;AACxC,wBAAwB,qGAAqB;AAC7C,qBAAqB,qGAAqB;AAC1C,uBAAuB,qGAAqB;AAC5C,4BAA4B,qGAAqB;AACjD,4BAA4B,qGAAqB;AACjD,2BAA2B,qGAAqB;AAChD,2BAA2B,qGAAqB;AAChD,yBAAyB,qGAAqB;AAC9C,uBAAuB,qGAAqB;AAC5C,uBAAuB,qGAAqB;AAC5C,0BAA0B,qGAAqB;AAC/C,sBAAsB,qGAAqB;AAC3C,mBAAmB,qGAAqB;AACxC,yBAAyB,qGAAqB;AAC9C,qCAAqC,qGAAqB;AAC1D,4BAA4B,qGAAqB;AACjD,2BAA2B,qGAAqB;AAChD,uBAAuB,qGAAqB;AAC5C,gCAAgC,qGAAqB;AACrD,8BAA8B,qGAAqB;AACnD,8BAA8B,qGAAqB;AACnD,gCAAgC,qGAAqB;AACrD,8CAA8C,qGAAqB;AACnE,0BAA0B,qGAAqB;AAC/C,0BAA0B,qGAAqB;AAC/C,4BAA4B,qGAAqB;AACjD,iCAAiC,qGAAqB;AACtD,2BAA2B,qGAAqB;AAChD,qBAAqB,qGAAqB;AAC1C,yBAAyB,qGAAqB;AAC9C,mCAAmC,qGAAqB;AACxD,gCAAgC,qGAAqB;AACrD,sBAAsB,qGAAqB;AAC3C,4BAA4B,qGAAqB;AACjD,6BAA6B,qGAAqB;AAClD,6BAA6B,qGAAqB;AAClD,uBAAuB,qGAAqB;AAC5C,sBAAsB,qGAAqB;AAC3C,wBAAwB,qGAAqB;AAC7C,2BAA2B,qGAAqB;AAChD;AAC4G;;;;;;;;;;;;;;;;;ACrKxD;AACL;AAC/C;AACA;AACA;AACA;AACA,6CAA6C,6DAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wDAAU;AAC/B;AACA;AACA,SAAS;AACT;AACA;AACqC;;;;;;;;;;;;;;;;;;;;;;;;ACjC2B;AACa;AAC3B;AACmB;AAC0B;AACP;AACA;AAC6a;AAC9Q;AACvP;AACA;AACA,QAAQ,2DAAU;AAClB;AACA;AACA;AACA,SAAS,mEAAkB,MAAM,mEAAkB;AACnD,cAAc,iEAAgB;AAC9B;AACA,uBAAuB,wEAAiB;AACxC;AACA;AACA;AACA,QAAQ,2DAAU;AAClB;AACA;AACA;AACA,SAAS,mEAAkB;AAC3B,cAAc,iEAAgB;AAC9B;AACA;AACA,oBAAoB,sEAAc;AAClC;AACA;AACA,yCAAyC,+DAAiB;AAC1D;AACA;AACA;AACA,4BAA4B,iEAAU;AACtC;AACA,gCAAgC,sDAAQ,aAAa,4DAAK;AAC1D;AACA;AACA;AACA,6CAA6C,4DAAK;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAU;AAClB;AACA;AACA;AACA,SAAS,mEAAkB,YAAY,mEAAkB;AACzD,cAAc,iEAAgB;AAC9B;AACA,uBAAuB,+DAAQ;AAC/B;AACA;AACA,UAAU,2DAAU;AACpB;AACA;AACA;AACA,SAAS,mEAAkB,MAAM,mEAAkB,cAAc,mEAAkB;AACnF,cAAc,iEAAgB;AAC9B;AACA,uBAAuB,+DAAQ;AAC/B;AACA;AACA,UAAU,2DAAU;AACpB;AACA;AACA;AACA,SAAS,mEAAkB,MAAM,mEAAkB,iBAAiB,mEAAkB,wEAAwE,mEAAkB;AAChL,cAAc,iEAAgB;AAC9B;AACA,uBAAuB,+DAAQ;AAC/B;AACA;AACA;AACA,QAAQ,2DAAU;AAClB;AACA;AACA;AACA,SAAS,mEAAkB,MAAM,mEAAkB;AACnD,cAAc,iEAAgB;AAC9B;AACA;AACA;AACA;AACA,UAAU,2DAAU;AACpB;AACA;AACA;AACA,SAAS,mEAAkB,MAAM,mEAAkB;AACnD,cAAc,iEAAgB;AAC9B;AACA;AACA;AACA;AACA,UAAU,2DAAU;AACpB;AACA;AACA;AACA,SAAS,mEAAkB,MAAM,mEAAkB;AACnD,cAAc,iEAAgB;AAC9B;AACA;AACA;AACA;AACA,UAAU,2DAAU;AACpB;AACA;AACA;AACA,SAAS,mEAAkB,MAAM,mEAAkB;AACnD,cAAc,iEAAgB;AAC9B;AACA;AACA;AACA;AACA,UAAU,2DAAU;AACpB;AACA;AACA;AACA,SAAS,mEAAkB,MAAM,mEAAkB;AACnD,cAAc,iEAAgB;AAC9B;AACA;AACA;AACA;AACA,UAAU,2DAAU;AACpB;AACA;AACA;AACA,SAAS,mEAAkB,MAAM,mEAAkB;AACnD,cAAc,iEAAgB;AAC9B;AACA;AACA;AACA;AACA,UAAU,2DAAU;AACpB;AACA;AACA;AACA,SAAS,mEAAkB,MAAM,mEAAkB;AACnD,cAAc,iEAAgB;AAC9B;AACA;AACA;AACA;AACA,UAAU,2DAAU;AACpB;AACA;AACA;AACA,SAAS,mEAAkB,MAAM,mEAAkB;AACnD,cAAc,iEAAgB;AAC9B;AACA;AACA;AACA;AACA,UAAU,2DAAU;AACpB;AACA;AACA;AACA,SAAS,mEAAkB,MAAM,mEAAkB;AACnD,cAAc,iEAAgB;AAC9B;AACA,uBAAuB,+DAAQ;AAC/B;AACA;AACA,UAAU,2DAAU;AACpB;AACA;AACA;AACA,SAAS,mEAAkB,MAAM,mEAAkB;AACnD,cAAc,iEAAgB;AAC9B;AACA,uBAAuB,+DAAQ;AAC/B;AACA;AACA;AACA,QAAQ,2DAAU;AAClB;AACA;AACA;AACA,SAAS,mEAAkB,MAAM,mEAAkB;AACnD,cAAc,iEAAgB;AAC9B;AACA,uBAAuB,4DAAK;AAC5B;AACA;AACA,UAAU,2DAAU;AACpB;AACA;AACA;AACA,SAAS,mEAAkB,MAAM,mEAAkB;AACnD,cAAc,iEAAgB;AAC9B;AACA,uBAAuB,4DAAK;AAC5B;AACA;AACA;AACA,QAAQ,2DAAU;AAClB;AACA;AACA;AACA,SAAS,mEAAkB,YAAY,mEAAkB;AACzD;AACA;AACA,kDAAkD,sDAAQ;AAC1D,yBAAyB,+DAAU;AACnC;AACA,cAAc,iEAAgB;AAC9B;AACA;AACA;AACA,+BAA+B,4DAAc,CAAC,4DAAK;AACnD;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,QAAQ,2DAAU;AAClB;AACA;AACA;AACA,SAAS,mEAAkB;AAC3B,cAAc,iEAAgB;AAC9B;AACA;AACA,mCAAmC,sEAAe;AAClD;AACA;AACA;AACA;AACA,QAAQ,2DAAU;AAClB;AACA;AACA;AACA,SAAS,mEAAkB,MAAM,mEAAkB;AACnD,cAAc,iEAAgB;AAC9B;AACA,yBAAyB,wEAAiB;AAC1C;AACA;AACA,UAAU,2DAAU;AACpB;AACA;AACA;AACA,SAAS,mEAAkB;AAC3B,cAAc,iEAAgB;AAC9B;AACA,yBAAyB,gFAAyB;AAClD;AACA;AACA,UAAU,2DAAU;AACpB;AACA;AACA;AACA,SAAS,mEAAkB;AAC3B,cAAc,iEAAgB;AAC9B;AACA,yBAAyB,gFAAyB;AAClD;AACA;AACA;AACA,QAAQ,2DAAU;AAClB;AACA;AACA;AACA,SAAS,mEAAkB,MAAM,mEAAkB;AACnD,cAAc,iEAAgB;AAC9B;AACA;AACA;AACA;AACA,uBAAuB,4DAAK;AAC5B;AACA;AACA,SAAS;AACT;AACA,UAAU,2DAAU;AACpB;AACA;AACA;AACA,SAAS,mEAAkB,MAAM,mEAAkB,WAAW,mEAAkB;AAChF,cAAc,iEAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oEAAa;AAChC,SAAS;AACT;AACA;AACA,QAAQ,2DAAU;AAClB;AACA;AACA;AACA,SAAS,mEAAkB,MAAM,mEAAkB;AACnD,cAAc,iEAAgB;AAC9B;AACA,iCAAiC,mEAAY;AAC7C;AACA;AACA;AACA,QAAQ,2DAAU;AAClB;AACA;AACA;AACA,SAAS,mEAAkB;AAC3B,cAAc,iEAAgB;AAC9B;AACA;AACA;AACA,uBAAuB,kEAAoB;AAC3C,SAAS;AACT;AACA,UAAU,2DAAU;AACpB;AACA;AACA;AACA,SAAS,mEAAkB;AAC3B,cAAc,iEAAgB;AAC9B;AACA;AACA;AACA,sCAAsC,qGAAuB;AAC7D;AACA;AACA;AACA,uBAAuB,4DAAc;AACrC,SAAS;AACT;AACA,UAAU,2DAAU;AACpB;AACA;AACA;AACA,SAAS,mEAAkB,MAAM,mEAAkB;AACnD,cAAc,iEAAgB;AAC9B;AACA;AACA;AACA,uBAAuB,kEAAoB;AAC3C,SAAS;AACT;AACA,UAAU,2DAAU;AACpB;AACA;AACA;AACA,SAAS,mEAAkB,MAAM,mEAAkB;AACnD,cAAc,iEAAgB;AAC9B;AACA;AACA;AACA,sCAAsC,qGAAuB;AAC7D;AACA;AACA;AACA,uBAAuB,4DAAc;AACrC,SAAS;AACT;AACA;AACA,QAAQ,2DAAU;AAClB;AACA;AACA;AACA;AACA,YAAY,mEAAkB;AAC9B,YAAY,mEAAkB;AAC9B,YAAY,mEAAkB;AAC9B,YAAY,mEAAkB;AAC9B;AACA,cAAc,iEAAgB;AAC9B;AACA;AACA;AACA,+BAA+B,4DAAc;AAC7C;AACA,oEAAoE,qEAAc;AAClF,2BAA2B,4DAAc;AACzC;AACA;AACA;AACA;AACA,QAAQ,2DAAU;AAClB;AACA;AACA;AACA,SAAS,mEAAkB,MAAM,mEAAkB,WAAW,mEAAkB;AAChF,cAAc,iEAAgB;AAC9B;AACA,uBAAuB,oEAAa;AACpC;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ,2DAAU;AAClB;AACA;AACA;AACA,SAAS,mEAAkB,MAAM,mEAAkB;AACnD,cAAc,iEAAgB;AAC9B;AACA;AACA;AACA,+BAA+B,sDAAQ,CAAC,4DAAK;AAC7C,iBAAiB;AACjB;AACA;AACA;AACA;AACA,QAAQ,2DAAU;AAClB;AACA;AACA;AACA;AACA,YAAY,mEAAkB;AAC9B,kBAAkB,mEAAkB;AACpC;AACA;AACA,qBAAqB,mDAAO;AAC5B,qBAAqB,uDAAS,kBAAkB,gEAAW,WAAW,4DAAK;AAC3E;AACA,YAAY,mEAAkB;AAC9B,YAAY,mEAAkB;AAC9B;AACA,cAAc,iEAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,wDAAU,yCAAyC,4DAAc;AACzG;AACA,uCAAuC,oEAAa;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,QAAQ,2DAAU;AAClB;AACA;AACA;AACA,SAAS,mEAAkB;AAC3B,cAAc,iEAAgB;AAC9B;AACA;AACA;AACA;AACA,kCAAkC,8DAAgB,CAAC,4DAAK,eAAe,4DAAK;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,2DAAU;AACpB;AACA;AACA;AACA;AACA,kBAAkB,mEAAkB;AACpC;AACA;AACA,kCAAkC,mDAAO;AACzC,gBAAgB,4DAAK;AACrB;AACA,kBAAkB,mEAAkB;AACpC;AACA;AACA;AACA,wBAAwB,mBAAmB,4DAAK,gBAAgB;AAChE;AACA;AACA,cAAc,iEAAgB;AAC9B;AACA;AACA;AACA,wCAAwC,wEAAiB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAU;AAClB;AACA;AACA;AACA,SAAS,mEAAkB,MAAM,mEAAkB;AACnD,cAAc,iEAAgB;AAC9B;AACA;AACA,oCAAoC,gEAAS;AAC7C;AACA;AACA;AACA;AACA,QAAQ,2DAAU;AAClB;AACA;AACA;AACA,SAAS,mEAAkB;AAC3B,cAAc,iEAAgB;AAC9B;AACA;AACA;AACA,wCAAwC,mEAAY;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAU;AAClB;AACA;AACA;AACA;AACA;AACA,cAAc,iEAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,2EAA2E,uFAAgC;AAC3G;AACA,aAAa;AACb;AACA;AACA;AACA,QAAQ,2DAAU;AAClB;AACA;AACA;AACA;AACA,YAAY,mEAAkB;AAC9B,YAAY,mEAAkB;AAC9B,kBAAkB,mEAAkB;AACpC;AACA;AACA,wFAAwF,mDAAO;AAC/F,qBAAqB,yEAAkB;AACvC;AACA;AACA,cAAc,iEAAgB;AAC9B,gCAAgC,kEAAW;AAC3C,SAAS;AACT;AACA;AACA,QAAQ,2DAAU;AAClB;AACA;AACA;AACA;AACA,kBAAkB,mEAAkB;AACpC;AACA;AACA,qBAAqB,oDAAG,uCAAuC,0EAAiB,IAAI,4DAAO,OAAO,4DAAO;AACzG;AACA;AACA,kBAAkB,mEAAkB;AACpC;AACA;AACA;AACA,uDAAuD,iEAAU,wBAAwB,iEAAU,qBAAqB,4EAAqB;AAC7I;AACA,YAAY,mEAAkB;AAC9B;AACA,QAAQ,iEAAgB;AACxB;AACA,UAAU,2DAAU;AACpB;AACA;AACA;AACA;AACA,YAAY,mEAAkB;AAC9B,YAAY,mEAAkB;AAC9B,kBAAkB,mEAAkB;AACpC;AACA;AACA;AACA,uDAAuD,iEAAU,wBAAwB,iEAAU,qBAAqB,4EAAqB;AAC7I;AACA;AACA,QAAQ,iEAAgB;AACxB;AACA,UAAU,2DAAU;AACpB;AACA;AACA;AACA;AACA,YAAY,mEAAkB;AAC9B,YAAY,mEAAkB;AAC9B,YAAY,mEAAkB;AAC9B,kBAAkB,mEAAkB;AACpC;AACA;AACA;AACA,2BAA2B,iEAAU,qBAAqB,4EAAqB;AAC/E;AACA;AACA,QAAQ,iEAAgB;AACxB;AACA,UAAU,2DAAU;AACpB;AACA;AACA;AACA;AACA,YAAY,mEAAkB;AAC9B,kBAAkB,mEAAkB;AACpC;AACA;AACA;AACA;AACA;AACA,yBAAyB,oDAAG;AAC5B,0BAA0B,oDAAG;AAC7B,0BAA0B,oDAAG;AAC7B;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,QAAQ,iEAAgB;AACxB;AACA;AACA,QAAQ,2DAAU;AAClB;AACA;AACA;AACA,SAAS,mEAAkB,MAAM,mEAAkB;AACnD,cAAc,iEAAgB;AAC9B;AACA,yBAAyB,wEAAiB;AAC1C;AACA;AACA,UAAU,2DAAU;AACpB;AACA;AACA;AACA,SAAS,mEAAkB;AAC3B,cAAc,iEAAgB;AAC9B;AACA,yBAAyB,wEAAiB;AAC1C;AACA;AACA,UAAU,2DAAU;AACpB;AACA;AACA;AACA,SAAS,mEAAkB;AAC3B,cAAc,iEAAgB;AAC9B;AACA,yBAAyB,wEAAiB;AAC1C;AACA;AACA;AACA,QAAQ,2DAAU;AAClB;AACA;AACA;AACA,SAAS,mEAAkB;AAC3B,QAAQ,iEAAgB;AACxB;AACA;AACA,QAAQ,2DAAU;AAClB;AACA;AACA;AACA,SAAS,mEAAkB;AAC3B,QAAQ,iEAAgB;AACxB;AACA;AACA,QAAQ,2DAAU;AAClB;AACA;AACA;AACA;AACA,YAAY,mEAAkB;AAC9B,kBAAkB,mEAAkB;AACpC;AACA,QAAQ,iEAAgB;AACxB;AACA;AACA,QAAQ,2DAAU;AAClB;AACA;AACA;AACA;AACA,YAAY,mEAAkB;AAC9B,YAAY,mEAAkB;AAC9B,kBAAkB,mEAAkB;AACpC;AACA;AACA,uBAAuB,yEAAkB;AACzC,uBAAuB,yEAAkB;AACzC;AACA;AACA,cAAc,iEAAgB;AAC9B,2BAA2B,oEAAa;AACxC,SAAS;AACT;AACA;AACA,QAAQ,2DAAU;AAClB;AACA;AACA;AACA,eAAe,mEAAkB;AACjC;AACA;AACA;AACA;AACA,mDAAmD,4DAAK;AACxD,sCAAsC,uDAAS,mCAAmC,gEAAW;AAC7F;AACA;AACA,2CAA2C,+DAAU;AACrD;AACA,aAAa;AACb,QAAQ,iEAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,0FAAmB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2EAAc;AAC1B,wBAAwB,qEAAc;AACtC;AACA;AACA,wBAAwB,+DAAQ;AAChC;AACA;AACA;AACA;AAC8B;;;;;;;;;;;;;;;;;;;;;AChxBsD;AACM;AAChB;AACtB;AACQ;AAC5D,wCAAwC,gGAAe;AACvD;AACA;AACA;AACA;AACA,8CAA8C,6DAAW;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,MAAM,mBAAmB,oBAAoB;AAChH;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB,MAAM,GAAG,2BAA2B;AACtD;AACA;AACA,iCAAiC,wEAAU;AAC3C,MAAM,qEAAO,IAAI,qEAAkB;AACnC,MAAM,qEAAO,IAAI,4EAAW;AAC5B;AACuE;;;;;;;;;;;;;;;;;;;;;;;;AClCa;AACrB;AACX;AACL;AACyC;AACe;AACb;AAC9B;AAC5D,iCAAiC,gGAAe;AAChD;AACA;AACA;AACA,0CAA0C,0DAAO;AACjD;AACA,4CAA4C,6DAAW;AACvD;AACA;AACA;AACA,eAAe,wDAAK;AACpB;AACA,yBAAyB,sBAAsB;AAC/C;AACA,0EAA0E;AAC1E,4BAA4B,0FAAmB;AAC/C;AACA,gEAAgE,aAAa,EAAE,YAAY,EAAE,aAAa;AAC1G;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,GAAG;AACxE;AACA,gDAAgD,uCAAuC,mCAAmC;AAC1H;AACA;AACA,qBAAqB,wDAAU;AAC/B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,WAAW;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,WAAW;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,WAAW;AAC5F;AACA;AACA,2BAA2B,4GAA6B;AACxD,6CAA6C,YAAY,WAAW,qBAAqB;AACzF;AACA;AACA;AACA;AACA,0BAA0B,wEAAU;AACpC,MAAM,qEAAO,IAAI,qEAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyD;;;;;;;;;;;;;;;;;;;;ACpG2B;AAChC;AACQ;AACD;AACyC;AACpG;AACA;AACA,4CAA4C,6DAAW;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yGAA6B,CAAC,oEAAa;AACrE;AACA;AACA;AACA,qBAAqB,wEAAU;AAC/B,MAAM,qEAAO,IAAI,qEAAkB;AACnC;AAC4B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrB8B;AACO;AACK;AACd;AACI;AACiD;AAChD;AACC;AACA;AACH;AACT;AACsC;AACZ;AACM;AAC6B;AAC3D;AACqtB;AACwH;AACj4B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gEAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,6DAAgB;AACxD,kGAAkG,+EAAyB;AAC3H;AACA;AACA,kGAAkG,iFAAyB;AAC3H;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,sFAAsF,sEAAc;AACpG;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,uEAAwB;AAC7D,gCAAgC,gFAA0B;AAC1D;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,wBAAwB,mGAAuB;AAC/C;AACA,qCAAqC,0FAA2C;AAChF,gCAAgC,mGAA6C;AAC7E;AACA;AACA,iBAAiB;AACjB;AACA;AACA,oBAAoB,mGAAuB;AAC3C,qCAAqC,2EAA8B;AACnE,gCAAgC,oFAA4B;AAC5D;AACA;AACA,iBAAiB;AACjB;AACA;AACA,qCAAqC,uEAAwB;AAC7D,gCAAgC,6EAAqB;AACrD;AACA;AACA,iBAAiB;AACjB;AACA;AACA,qCAAqC,qEAAwB;AAC7D,gCAAgC,8EAAsB;AACtD;AACA;AACA,iBAAiB;AACjB;AACA;AACA,qCAAqC,4EAA+B;AACpE,gCAAgC,qFAA6B;AAC7D;AACA;AACA,iBAAiB;AACjB;AACA;AACA,qCAAqC,wEAAyB;AAC9D,uCAAuC,gEAAQ,cAAc,gFAAwB;AACrF;AACA;AACA,iBAAiB;AACjB;AACA;AACA,oBAAoB,mGAAuB;AAC3C,qCAAqC,sEAAuB;AAC5D,gCAAgC,+EAAyB;AACzD;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,wBAAwB,mGAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,iCAAiC;AACjC;AACA;AACA,iDAAiD,wEAA2B;AAC5E,4CAA4C,iFAAyB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,wEAA2B;AACpE,oCAAoC,iFAAyB;AAC7D;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,oBAAoB,mGAAuB;AAC3C,qCAAqC,2EAA8B;AACnE,gCAAgC,oFAA4B;AAC5D;AACA,iBAAiB;AACjB;AACA;AACA,oBAAoB,mGAAuB;AAC3C,qCAAqC,uEAA0B;AAC/D,gCAAgC,gFAAwB;AACxD;AACA;AACA,iBAAiB;AACjB;AACA;AACA,oBAAoB,mGAAuB;AAC3C,qCAAqC,kFAAqC;AAC1E,gCAAgC,2FAAmC;AACnE;AACA;AACA,iBAAiB;AACjB;AACA;AACA,oBAAoB,mGAAuB;AAC3C,qCAAqC,2EAA8B;AACnE,gCAAgC,oFAA4B;AAC5D;AACA;AACA,iBAAiB;AACjB;AACA;AACA,wCAAwC,uEAA0B;AAClE,wCAAwC,0FAA2C;AACnF,wCAAwC,kFAAqC;AAC7E,wCAAwC,sEAAuB;AAC/D,wCAAwC,2EAA8B;AACtE,wCAAwC,2EAA8B;AACtE,wCAAwC,mEAAoB;AAC5D,wCAAwC,wEAAyB;AACjE,wBAAwB,mGAAuB;AAC/C;AACA,wCAAwC,wEAA2B;AACnE;AACA;AACA,6CAA6C,wEAAyB;AACtE,gDAAgD,gEAAQ,cAAc,gFAAwB;AAC9F;AACA;AACA;AACA,oCAAoC,wEAAgB;AACpD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iCAAiC,iEAAU;AAC3C,aAAa;AACb,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,oEAAa;AACrE,2DAA2D,oEAAa;AACxE,6CAA6C,8DAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,gBAAgB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uEAAY;AAC3B;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB,6BAA6B;AAC7C;AACA;AACA;AACA;AACA,2BAA2B,wEAAgB;AAC3C,2CAA2C,gGAAoB;AAC/D;AACA;AACA,2EAA2E,SAAS,IAAI,8CAA8C,oEAAY,uBAAuB;AACzK;AACA;AACA,wBAAwB,mEAAM;AAC9B;AACA;AACA,2CAA2C,kFAAiB;AAC5D;AACA,2BAA2B,oEAAqB,WAAW,iEAAS,qCAAqC,6DAAK;AAC9G;AACA,gDAAgD,kFAAiB;AACjE;AACA,2BAA2B,sEAAuB;AAClD;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,0BAA0B,OAAO;AACjC;AACA;AACA;AACA;AACA,oBAAoB,6BAA6B;AACjD;AACA;AACA,2CAA2C,sEAAe;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wEAAgB;AAC/C,+CAA+C,gGAAoB;AACnE;AACA;AACA,oDAAoD,SAAS;AAC7D,yBAAyB,uEAAgB;AACzC;AACA;AACA;AACA;AACA;AACA,+FAA+F,YAAY;AAC3G,mDAAmD,iCAAiC,MAAM,SAAS,IAAI,IAAI;AAC3G,iCAAiC,gBAAgB,cAAc;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mGAAuB;AAC3C;AACA,yBAAyB;AACzB,aAAa;AACb;AACA;AACA;AACA,6BAA6B,iEAAkB;AAC/C;AACA;AACA,qBAAqB,gBAAgB,SAAS,4EAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uEAAe;AAC5C;AACA;AACA,kBAAkB;AAClB;AACA;AACA,qBAAqB,2EAAmB;AACxC;AACA;AACA,qBAAqB,sFAA8B;AACnD,6BAA6B,8DAAe;AAC5C;AACA;AACA,0BAA0B,gEAAQ,uBAAuB,wEAAgB;AACzE,yBAAyB,+DAAgB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mEAAM;AAC9B;AACA,yBAAyB,uEAAe;AACxC,2DAA2D,2BAA2B;AACtF;AACA,gDAAgD,8DAAQ,+DAA+D,2FAAmB;AAC1I;AACA,2CAA2C,SAAS,mDAAmD,cAAc;AACrH;AACA;AACA,SAAS;AACT,sBAAsB,oEAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uEAAe;AACxC;AACA;AACA,iBAAiB,wFAAsB;AACvC,uBAAuB,qEAAsB;AAC7C;AACA,iBAAiB,wFAAsB;AACvC,uBAAuB,qEAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA,6BAA6B,gGAAoB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gFAAwB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sEAAe;AAC/C;AACA;AACA;AACA;AACA,mBAAmB,+EAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,kBAAkB;AACrF,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,oEAAY;AACjE,sBAAsB,oEAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,0DAAO;AAClD,yCAAyC,0DAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gEAAS;AAClC;AACA;AACA;AACA;AACA;AACA,qBAAqB,sEAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,qDAAG;AACrD;AACA;AACA;AACA;AACA;AACA,yDAAyD,wDAAW;AACpE;AACA;AACA,iIAAiI,sEAAc;AAC/I,qKAAqK,sEAAc;AACnL,qIAAqI,sEAAc;AACnJ;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,gBAAgB,iEAAU;AAC1B;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA,gBAAgB,mGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,mGAAuB;AACvC;AACA;AACA,aAAa;AACb;AACA,gBAAgB,mGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,mGAAuB;AACvC;AACA;AACA,aAAa;AACb;AACA,gBAAgB,mGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,mGAAuB;AACvC;AACA;AACA,aAAa;AACb;AACA,gBAAgB,mGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,mGAAuB;AACvC;AACA;AACA,aAAa;AACb;AACA,gBAAgB,mGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,mGAAuB;AACvC;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,gBAAgB,mGAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,gBAAgB,mGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,mGAAuB;AACvC;AACA;AACA,aAAa;AACb;AACA,gBAAgB,mGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,mGAAuB;AACvC;AACA;AACA,aAAa;AACb;AACA,gBAAgB,mGAAuB;AACvC;AACA,aAAa;AACb,iCAAiC,gGAAoB;AACrD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,gBAAgB,mGAAuB;AACvC;AACA;AACA,aAAa;AACb;AACA,gBAAgB,mGAAuB;AACvC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AAC8B;;;;;;;;;;;;;;;;;;;;;;ACxtB6C;AACV;AACH;AACV;AAC6C;AACoD;AAC5D;AACzF;AACA,aAAa;AACb;AACA;AACA,6CAA6C,6DAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kGAAuB;AACvC;AACA,6EAA6E,qBAAqB;AAClG;AACA;AACA;AACA;AACA;AACA,4EAA4E,qBAAqB;AACjG;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iFAAyB;AACrC;AACA;AACA;AACA;AACA;AACA,mCAAmC,gEAAS;AAC5C,qCAAqC,mBAAmB,gEAAgE,sBAAsB;AAC9I,gDAAgD,kFAAkF;AAClI,eAAe,uEAAY;AAC3B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,sEAA0B;AAC/D,gCAAgC,+EAAwB;AACxD;AACA;AACA,iBAAiB;AACjB;AACA;AACA,qCAAqC,uEAA2B;AAChE,gCAAgC,gFAAyB;AACzD;AACA;AACA,iBAAiB;AACjB;AACA;AACA,wCAAwC,uEAA2B;AACnE,gCAAgC,gFAAyB;AACzD;AACA,6CAA6C,sEAA0B;AACvE,gCAAgC,+EAAwB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgC;;;;;;;;;;;;;;;;ACtGoB;AACpD;AACA;AACA,6CAA6C,6DAAW;AACxD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AAC4B;;;;;;;;;;;;;;;;;;ACd4B;AACY;AAC4B;AAChG;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sEAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,0DAAO;AACjD,mCAAmC,0DAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gFAAY;AACnC;AACA;AACA,uBAAuB,uFAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,0HAA0H;AAC1H,mCAAmC,oCAAoC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+B;;;;;;;;;;;;;;;;;;ACxGqB;AACE;AACJ;AAClD;AACA,aAAa;AACb;AACA;AACA,6CAA6C,6DAAW;AACxD;AACA;AACA;AACA;AACA,0FAA0F,OAAO;AACjG;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,+DAAQ;AAC/C,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oDAAG;AACjC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9CuD;AACjB;AACuE;AACgH;AACzL;AACb;AACa;AACS;AACb;AACW;AACS;AAC/B;AACe;AACyB;AAC9B;AACR;AACM;AAC0C;AAC9B;AACR;AAC+B;AACnC;AACE;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,6DAAW;AACvD;AACA;AACA,gDAAgD,6DAAW;AAC3D;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,2BAA2B,mEAAM;AACjC;AACA,aAAa;AACb;AACA;AACA,2BAA2B,uEAAc;AACzC,4BAA4B,+DAAO;AACnC,mCAAmC,4DAAO;AAC1C;AACA,4BAA4B,sEAAU;AACtC,mCAAmC,+DAAU;AAC7C;AACA,4BAA4B,+DAAO,wBAAwB,qDAAG;AAC9D,mCAAmC,+DAAQ;AAC3C;AACA,2CAA2C,6DAAQ;AACnD;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS,kBAAkB,cAAc,eAAe,sFAAsF;AAC3L;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA,mBAAmB,wDAAU;AAC7B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,GAAG;AAC7C;AACA,iCAAiC,wCAAwC;AACzE;AACA;AACA;AACA,mBAAmB,wDAAU;AAC7B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uEAAc;AACzC,qCAAqC,sDAAQ;AAC7C,2BAA2B,+DAAU;AACrC;AACA,0CAA0C,mDAAK;AAC/C,2BAA2B,4DAAO;AAClC;AACA,0CAA0C,sDAAQ;AAClD,2BAA2B,+DAAQ;AACnC;AACA,yBAAyB,2DAAa;AACtC,2BAA2B,oEAAe;AAC1C;AACA;AACA;AACA,2BAA2B,6DAAQ;AACnC;AACA;AACA;AACA,2BAA2B,6DAAQ;AACnC;AACA,0CAA0C,6DAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,wFAAwF,0GAA6B;AACrH,uBAAuB,mEAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8BAA8B;AAC9C;AACA,4BAA4B,0BAA0B;AACtD;AACA,oBAAoB,yEAAkB;AACtC;AACA;AACA;AACA,6DAA6D,GAAG,8BAA8B,sBAAsB,MAAM,6BAA6B;AACvJ;AACA;AACA;AACA;AACA,0BAA0B,iEAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,6EAAc;AACxC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gGAAqB;AAC3C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,sEAAsE,GAAG;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAU;AAC9B,MAAM,qEAAO,IAAI,sEAAkB;AACnC,MAAM,qEAAO,IAAI,4EAAW;AAC5B,MAAM,qEAAO,IAAI,oEAAiB;AAClC;AACA,2BAA2B,iGAAe;AAC1C;AACA;AACA;AACA;AACA;AACA,2CAA2C,mEAAY,GAAG;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uEAAe;AAChC,0BAA0B,iBAAiB,GAAG,mBAAmB;AACjE;AACA,4BAA4B,wEAAY;AACxC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,QAAQ;AACzF;AACA;AACA;AACA;AACA;AACA,aAAa,0EAA0E,qDAAG;AAC1F,aAAa;AACb;AACA;AACA,aAAa,sDAAQ;AACrB,QAAQ,+DAAU;AAClB;AACA,aAAa;AACb;AACA;AACA,aAAa,mDAAK;AAClB,QAAQ,4DAAO;AACf;AACA,aAAa;AACb;AACA;AACA,aAAa,uDAAS;AACtB,QAAQ,gEAAW;AACnB;AACA,aAAa;AACb,aAAa;AACb,aAAa;AACb;AACA;AACA,eAAe,aAAa;AAC5B,wBAAwB,aAAa,IAAI,oBAAoB;AAC7D;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,0BAA0B,+DAAiB;AAC3C,QAAQ,wEAAmB;AAC3B;AACA,aAAa;AACb;AACA;AACA,0BAA0B,+DAAiB;AAC3C,QAAQ,wEAAmB;AAC3B;AACA,aAAa;AACb;AACA;AACA,0BAA0B,8DAAY;AACtC,QAAQ,+DAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkH;;;;;;;;;;;;;;;;;;;;;;;;;ACpaxD;AACF;AAC+B;AACrC;AAC6K;AACpI;AACR;AACuF;AACtH;AACqC;AACzF;AACA,yCAAyC,6DAAW;AACpD;AACA,iBAAiB;AACjB;AACA;AACA,wDAAwD,6FAAsB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,4DAAgB;AAC/D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,oDAAG;AACnE,mBAAmB,gEAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,yDAAyD,4DAAK;AAC9D;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gEAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kGAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,0DAAO;AAC1D;AACA;AACA;AACA,iDAAiD,wEAAiB;AAClE,uDAAuD,sEAAe;AACtE;AACA,8BAA8B,oBAAoB,GAAG,YAAY;AACjE;AACA,mGAAmG,4DAAK;AACxG;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,4BAA4B,kBAAkB;AAC9C,8BAA8B,oBAAoB;AAClD,mCAAmC,qBAAqB;AACxD,iCAAiC,uBAAuB;AACxD,sCAAsC,wBAAwB;AAC9D,yCAAyC,+BAA+B;AACxE,8CAA8C,gCAAgC;AAC9E,iCAAiC,uBAAuB;AACxD,sCAAsC,wBAAwB;AAC9D,qCAAqC,2BAA2B;AAChE,0CAA0C,4BAA4B;AACtE,8BAA8B,oBAAoB;AAClD,mCAAmC,qBAAqB;AACxD,8BAA8B,oBAAoB;AAClD,mCAAmC,qBAAqB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,sEAAe;AAC1E;AACA;AACA;AACA;AACA,+CAA+C,4DAAK;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kGAAuB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gEAAkB;AACrD;AACA;AACA;AACA,wCAAwC,gEAAkB;AAC1D;AACA;AACA,6GAA6G,2BAA2B;AACxI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kGAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,4BAA4B;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,wBAAwB;AAC1F;AACA;AACA,YAAY,kGAAuB;AACnC;AACA;AACA;AACA,YAAY,kGAAuB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sBAAsB;AACtD,uCAAuC,yBAAyB;AAChE,gDAAgD,sCAAsC;AACtF,uEAAuE,yDAAyD;AAChI,wCAAwC,8BAA8B;AACtE,+CAA+C,iCAAiC;AAChF,4CAA4C,kCAAkC;AAC9E;AACA;AACA,iBAAiB;AACjB,iCAAiC,iBAAiB;AAClD,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,gBAAgB,kGAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oDAAG;AACnB,gBAAgB,4DAAK;AACrB;AACA;AACA;AACA;AACA;AACA,6CAA6C,sFAA+B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,4DAAK;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kGAAuB;AACnC;AACA;AACA,YAAY,kGAAuB;AACnC;AACA;AACA;AACA;AACA;AACA,kFAAkF,qEAAc;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,yEAAc;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,oDAAG;AAC7C;AACA,2DAA2D,eAAe;AAC1E;AACA;AACA;AACA;AACA;AACA,qBAAqB,2EAA6B;AAClD,2BAA2B,sFAA+B;AAC1D,qBAAqB,2EAA6B;AAClD,2BAA2B,sFAA+B;AAC1D;AACA;AACA,eAAe,sFAA+B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gEAAkB;AACvC,2BAA2B,2EAAoB;AAC/C,qBAAqB,gEAAkB;AACvC,2BAA2B,2EAAoB;AAC/C;AACA;AACA,eAAe,2EAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wEAA0B;AAC/C,2BAA2B,mFAA4B;AACvD,qBAAqB,wEAA0B;AAC/C,2BAA2B,mFAA4B;AACvD;AACA;AACA,eAAe,mFAA4B;AAC3C;AACA;AACA;AACiC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxoBmD;AACjB;AACX;AACE;AACN;AACI;AACmF;AACjC;AACjD;AACD;AACkC;AAC9B;AACc;AACxB;AAClD;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qDAAG;AAC/B;AACA;AACA;AACA,gCAAgC,qDAAG;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qDAAG;AACnC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,4CAA4C,6DAAW;AACvD;AACA;AACA,8BAA8B,0DAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wEAAU;AACnC,MAAM,qEAAO,IAAI,sEAAkB;AACnC,MAAM,qEAAO,IAAI,mEAAiB;AAClC,MAAM,qEAAO,IAAI,6EAAW;AAC5B;AACA;AACA;AACA,+CAA+C,0DAAO;AACtD;AACA;AACA;AACA,8BAA8B,gGAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,8BAA8B,gGAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iEAAmB;AACxC,qBAAqB,iEAAmB;AACxC,qBAAqB,iEAAmB;AACxC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,+DAA+D,QAAQ,GAAG,IAAI;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+DAAQ;AACpC;AACA;AACA,6EAA6E,kEAAS;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,SAAS,GAAG,SAAS;AACjG;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,mCAAmC,kEAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,mCAAmC,QAAQ,GAAG,IAAI;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,mCAAmC,QAAQ,GAAG,IAAI;AAClD;AACA;AACA;AACA;AACA,sCAAsC,kEAAS;AAC/C,qCAAqC,kEAAS;AAC9C,wCAAwC,kEAAS;AACjD,8CAA8C,kEAAS;AACvD,8CAA8C,kEAAS;AACvD,6CAA6C,kEAAS;AACtD,gDAAgD,kEAAS;AACzD,sDAAsD,kEAAS;AAC/D,qCAAqC,kEAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8DAAK;AACjB;AACA;AACA;AACA;AACA;AACA,mBAAmB,+DAAQ;AAC3B;AACA;AACA,0DAA0D;AAC1D,2EAA2E,iBAAiB;AAC5F,yBAAyB;AACzB,6DAA6D;AAC7D,wEAAwE,iBAAiB;AACzF,yBAAyB;AACzB,6DAA6D;AAC7D,8DAA8D,iBAAiB;AAC/E,yBAAyB;AACzB,mDAAmD,8EAA8E;AACjI;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,4GAAuB;AAC7C,kDAAkD,kBAAkB;AACpE;AACA;AACA,yCAAyC,gBAAgB,0HAA0H,IAAI;AACvL;AACA;AACA;AACA;AACA;AACA,yCAAyC,gBAAgB,wFAAwF,IAAI;AACrJ;AACA;AACA;AACA;AACA;AACA,4BAA4B,2GAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kDAAkD,gCAAgC,gBAAgB;AAClG;AACA;AACA,gCAAgC,iGAAe;AAC+B;;;;;;;;;;;;;;;;;;;;ACxRM;AACpB;AACZ;AACkB;AACV;AAC5D;AACA;AACA,wDAAwD,6DAAW;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,oCAAoC,wEAAU;AAC9C,MAAM,qEAAO,IAAI,qEAAkB;AACnC,MAAM,qEAAO,IAAI,+EAAuB;AACxC;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iDAAiD;AAC9E;AACA;AACA;AACA,oBAAoB,sEAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,oBAAoB;AAC9F;AACA;AAC2C;;;;;;;;;;;;;;;;;;;;;;;;;;AC/E8B;AACrB;AACgB;AACV;AACG;AACX;AACM;AACoC;AACzD;AACiB;AACL;AAC/C;AACA;AACA;AACA;AACA;AACA,4BAA4B,4CAAK;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mEAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,UAAU,WAAW,aAAa;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS,KAAK,SAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,+BAA+B;AACnE;AACA;AACA,oCAAoC,+BAA+B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,UAAU;AACjE;AACA;AACA,mBAAmB,yDAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,6DAAW;AACxD;AACA;AACA,kCAAkC,sEAAe;AACjD;AACA;AACA,oDAAoD,mEAAe,mDAAmD;AACtH;AACA,aAAa,EAAE,wFAAoC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,sDAAsD,mEAAe,mDAAmD,gDAAgD,wFAAoC;AAC5M;AACA,eAAe,yDAAU,uBAAuB,yDAAU;AAC1D;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,wDAAwD,SAAS;AACjE;AACA;AACA,2DAA2D,SAAS;AACpE;AACA,gCAAgC,oDAAG;AACnC,oFAAoF,8DAA8D;AAClJ;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,wDAAwD,SAAS;AACjE;AACA;AACA,4DAA4D,SAAS;AACrE;AACA,gCAAgC,oDAAG;AACnC,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,SAAS;AACjE;AACA,2BAA2B,iEAAU;AACrC;AACA;AACA,gCAAgC,oDAAG;AACnC;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,SAAS;AACjE;AACA;AACA,mEAAmE,SAAS;AAC5E;AACA;AACA;AACA;AACA;AACA,yBAAyB,oDAAG;AAC5B;AACA,qEAAqE,2EAAiB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,oDAAG;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oDAAoD,oDAAG;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,4DAAO,6BAA6B,4DAAO;AAC/E,WAAW,0DAAI;AACf;AACgC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3RoD;AAC1B;AACA;AACF;AACqB;AACf;AACZ;AACsC;AACE;AACA;AACiC;AACvE;AACI;AACU;AACN;AACY;AACZ;AACN;AACK;AACoR;AACxP;AAC7B;AAC1D,+BAA+B,gGAAe;AAC9C,oEAAoE,iEAAU;AAC9E,mCAAmC;AACnC,uCAAuC;AACvC,0CAA0C;AAC1C,+BAA+B;AAC/B,gDAAgD;AAChD,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,0DAAO;AACnE,gEAAgE,0DAAO;AACvE,mEAAmE,0DAAO;AAC1E,yEAAyE,0DAAO;AAChF,+DAA+D,8DAAW;AAC1E,4DAA4D,0DAAO;AACnE,gEAAgE,0DAAO;AACvE;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0FAAmB;AAC/C;AACA;AACA,yEAAyE,GAAG;AAC5E;AACA;AACA;AACA,eAAe,uEAAY;AAC3B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,wBAAwB;AAC/E;AACA,eAAe,qEAAa;AAC5B;AACA;AACA;AACA;AACA,iCAAiC,sCAAsC;AACvE;AACA;AACA,4BAA4B,IAAI,UAAU,+BAA+B;AACzE;AACA;AACA,wBAAwB,IAAI,MAAM,uBAAuB;AACzD,qBAAqB,oDAAG;AACxB;AACA;AACA,mBAAmB,oDAAG;AACtB;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gGAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,GAAG;AACvE;AACA,cAAc,2BAA2B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,SAAS;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,GAAG;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,0BAA0B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oHAAoH,GAAG;AACvH;AACA;AACA,4BAA4B,0FAAmB;AAC/C;AACA;AACA,yEAAyE,GAAG;AAC5E;AACA;AACA;AACA,eAAe,uEAAY;AAC3B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,8BAA8B,+DAAgB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,mCAAmC,iEAAkB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,+DAAgB;AAC7E,8DAA8D,iEAAkB;AAChF,8DAA8D,6DAAc;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,+DAAgB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yDAAY,UAAU;AAC/C;AACA;AACA,qCAAqC,wBAAwB;AAC7D;AACA,qBAAqB,yDAAY;AACjC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,yBAAyB,yDAAY,UAAU;AAC/C;AACA;AACA;AACA,+GAA+G,KAAK;AACpH;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,uBAAuB;AAC7D;AACA,qBAAqB,yDAAY;AACjC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,yBAAyB,yDAAY,UAAU;AAC/C;AACA;AACA,sCAAsC,uBAAuB;AAC7D,qBAAqB,yDAAY;AACjC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+EAAgC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,aAAa;AAC7F;AACA;AACA;AACA;AACA,+EAA+E,aAAa;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uFAAiB;AACnD;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,kBAAkB,sFAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iEAAkB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6DAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oDAAG;AACvC,mCAAmC,+DAAgB,OAAO,uDAAQ,YAAY,uDAAQ;AACtF;AACA,oBAAoB,kEAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,iEAAkB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,+DAAgB;AAC/D;AACA;AACA;AACA;AACA;AACA,iDAAiD,uDAAQ,CAAC,oDAAG,wBAAwB,uDAAQ;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,0DAAW;AACzC;AACA;AACA,8BAA8B,8DAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,eAAe,gEAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,eAAe,gEAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,aAAa;AAC7F;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qEAAsB;AAC/C;AACA;AACA,8BAA8B,iEAAkB;AAChD;AACA;AACA,8BAA8B,0EAA2B;AACzD;AACA;AACA,8BAA8B,+EAAgC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gEAAS;AAC9B;AACA;AACA;AACA,iCAAiC,gEAAQ;AACzC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,yCAAyC,iEAAkB;AAC3D;AACA;AACA;AACA,mBAAmB,gEAAS;AAC5B;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oDAAG;AACjC;AACA;AACA;AACA;AACA;AACA,kBAAkB,YAAY,IAAI,GAAG;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB,iBAAiB,YAAY,IAAI,WAAW;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gEAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wDAAW;AAC3C,qBAAqB;AACrB;AACA;AACA;AACA;AACA,8CAA8C,oDAAG;AACjD,gDAAgD,oDAAG;AACnD;AACA;AACA;AACA,4BAA4B,wEAAU;AACtC,MAAM,qEAAO,IAAI,sEAAkB;AACnC,MAAM,qEAAO,IAAI,oEAAiB;AAClC,MAAM,qEAAO,IAAI,kFAAwB;AACzC,MAAM,qEAAO,IAAI,4EAAqB;AACtC,MAAM,qEAAO,IAAI,sEAAkB;AACnC,MAAM,qEAAO,IAAI,iGAAgC;AACjD,MAAM,qEAAO,IAAI,kEAAgB;AACjC,MAAM,qEAAO,IAAI,gEAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,+FAAoB;AACrD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wEAAU;AACxC,MAAM,qEAAO,IAAI,sEAAkB;AACnC,MAAM,qEAAO,IAAI,oEAAiB;AAClC,MAAM,qEAAO,IAAI,kFAAwB;AACzC,MAAM,qEAAO,IAAI,4EAAqB;AACtC,MAAM,qEAAO,IAAI,sEAAkB;AACnC,MAAM,qEAAO,IAAI,iGAAgC;AACjD,MAAM,qEAAO,IAAI,kEAAgB;AACjC,MAAM,qEAAO,IAAI,gEAAe;AAChC;AAC8H;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzgC1C;AAClC;AACE;AACW;AAC2B;AAC9B;AACc;AACR;AACD;AACV;AACkC;AACzF;AACA;AACA,aAAa;AACb,aAAa;AACb,aAAa;AACb;AACA;AACA;AACA,4CAA4C,6DAAW;AACvD;AACA;AACA;AACA,qCAAqC,gCAAgC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+DAAO;AACjC;AACA;AACA;AACA;AACA;AACA,iDAAiD,WAAW,8DAAK,iBAAiB;AAClF,2BAA2B,+DAAO,sCAAsC,gEAAO;AAC/E;AACA;AACA;AACA;AACA,sCAAsC,6DAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,qBAAqB,wDAAU;AAC/B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8CAA8C;AAC9D;AACA;AACA,wBAAwB,UAAU;AAClC,kFAAkF,oDAAG;AACrF;AACA;AACA;AACA;AACA,oBAAoB,4DAAc;AAClC;AACA,wBAAwB,mGAAuB;AAC/C;AACA;AACA;AACA;AACA,gFAAgF,6BAA6B,KAAK,EAAE;AACpH;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,8CAA8C,wEAAU;AACxD,MAAM,qEAAO,IAAI,qEAAkB;AACnC,MAAM,qEAAO,IAAI,4EAAW;AAC5B;AACA,8BAA8B,gGAAe;AACM;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/FiC;AACzC;AACkC;AAC3B;AACE;AACG;AACC;AACe;AACG;AAChB;AACU;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4DAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oDAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gEAAkB,QAAQ,gEAAkB,UAAU,gEAAkB,cAAc,gEAAkB;AAC3I,+CAA+C,OAAO;AACtD;AACA;AACA,0DAA0D,GAAG,iEAAU,sEAAsE;AAC7I;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+EAAc;AAChD,mCAAmC,iDAAQ;AAC3C;AACA,0CAA0C,GAAG;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,mCAAmC,GAAG,iEAAU,gEAAgE;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,aAAa;AACb,aAAa;AACb,aAAa;AACb;AACA,2BAA2B,4DAAW;AACtC;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,kEAAe,GAAG,qCAAqC;AACrG,yCAAyC,wDAAK;AAC9C,8CAA8C,6DAAW;AACzD;AACA;AACA,gBAAgB,kHAAkH;AAClI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,KAAK;AAC1E;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,oDAAG,6BAA6B,iEAAU;AACjF;AACA;AACA;AACA,+CAA+C,wEAAU;AACzD,OAAO,qEAAO,IAAI,4EAAW;AAC7B,OAAO,qEAAO,IAAI,8EAAsB;AACxC;AACoD;;;;;;;;;;;;;;;;;;AC/SF;AACE;AACqC;AACzF;AACA;AACA,6CAA6C,6DAAW;AACxD;AACA;AACA;AACA,YAAY,kGAAuB;AACnC;AACA;AACA,oDAAoD,oDAAG;AACvD,SAAS;AACT;AACA;AACA;AACA,8BAA8B,oDAAG;AACjC,SAAS;AACT;AACA;AAC0B;;;;;;;;;;;;;;;;;;;;;;ACrByC;AACjB;AACH;AACK;AACM;AACe;AACZ;AAC7D;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,6CAA6C,6DAAW;AACxD;AACA;AACA,0BAA0B,4DAAO;AACjC,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,OAAO,gCAAgC,WAAW;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mEAAU;AAC5C;AACA;AACA;AACA,iBAAiB;AACjB,2BAA2B,qEAAiB;AAC5C;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA,qBAAqB,wDAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,yEAAyE,WAAW;AACpF;AACA,mEAAmE,oDAAG,cAAc,2EAAiB;AACrG;AACA;AAC0C;;;;;;;;;;;;;;;;;;;;;;;;AC7EU;AACM;AACiB;AACO;AACmB;AACtC;AACP;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oFAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAE;AACV;AACA;AACA;AACA;AACA,eAAe,8DAAM;AACrB;AACA;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C,iCAAiC,0BAA0B;AAC3D,mCAAmC,4BAA4B,4DAAO,YAAY;AAClF,mCAAmC,0BAA0B;AAC7D,gCAAgC,yBAAyB;AACzD,iCAAiC,0BAA0B;AAC3D,gCAAgC,uBAAuB;AACvD,yBAAyB,sBAAsB;AAC/C,iCAAiC,8DAA8D;AAC/F,4BAA4B,4BAA4B,uDAAS,MAAM,uDAAS,QAAQ;AACxF,kCAAkC,4BAA4B;AAC9D,oCAAoC,iCAAiC;AACrE,gCAAgC,6BAA6B;AAC7D,qCAAqC,kCAAkC;AACvE,qCAAqC,kCAAkC;AACvE,wCAAwC,qCAAqC;AAC7E,sDAAsD,mDAAmD;AACzG;AACA,2CAA2C,wBAAwB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAE;AACV;AACA;AACA;AACA,QAAQ,0DAAE;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,kBAAkB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,sDAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sDAAQ;AAC7B;AACA;AACA,+BAA+B,mDAAK;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mDAAK;AAC1B;AACA;AACA,kCAAkC,sDAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sDAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iFAAwB;AACzC;AACA,qEAAqE,cAAc;AACnF;AACA;AACA,2BAA2B,gFAAa,yBAAyB,4FAAyB;AAC1F;AACA,yBAAyB,mDAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mDAAK;AAC1B;AACA;AACA;AACA;AACA;AACA,qBAAqB,mDAAK;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0E;;;;;;;;;;;;;;;;;;;;;ACvNxB;AACY;AACjB;AACyC;AACtB;AACoC;AACpG;AACA,+EAA+E,0BAA0B;AACzG;AACA;AACA;AACA;AACA,gCAAgC,kEAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oDAAG;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F,kBAAkB,6EAAsB,aAAa;AACnJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,sFAAsF,2BAA2B;AACjH;AACA;AACA;AACA;AACA;AACA,6FAA6F,2BAA2B;AACxH;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA,0BAA0B,oEAAY;AACtC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,2BAA2B,mBAAmB,kBAAkB;AAC1J;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT,0BAA0B;AAC1B;AACA,0EAA0E,sDAAQ;AAClF,iCAAiC,yBAAyB;AAC1D;AACA;AACA;AACA;AACA,gDAAgD,4DAAK;AACrD;AACA,+CAA+C,gEAAS;AACxD;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,yGAA6B;AAC3G;AACA;AACA,SAAS;AACT;AACA;AAC0C;;;;;;;;;;;;;;;;;;;;;;;;AC9Hc;AACY;AAClB;AACE;AACY;AACb;AACa;AACH;AACA;AAC7D;AACA;AACA,uCAAuC,0DAAO;AAC9C,0CAA0C,0DAAO;AACjD,0CAA0C,0DAAO;AACjD,wCAAwC,0DAAO;AAC/C;AACA;AACA;AACA;AACA,gCAAgC,sEAAe;AAC/C;AACA,6CAA6C,6DAAW;AACxD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,SAAS;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,oDAAG;AACxC,uBAAuB,sEAAe;AACtC,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,oEAAoE,oDAAG;AACvE;AACA;AACA,oBAAoB,oDAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oDAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oDAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oBAAoB,oDAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sEAAwB;AAC7C;AACA;AACA,qBAAqB,sEAAwB;AAC7C;AACA,uCAAuC,mEAAU;AACjD;AACA;AACA;AACA,2BAA2B,4DAAK;AAChC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA,QAAQ,6EAAoB;AAC5B;AACA;AAC4B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/IwD;AAChC;AACI;AACI;AACV;AACwC;AACtC;AACW;AACH;AACD;AACe;AACA;AAChB;AACA;AACE;AACR;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6DAAW;AAC3C,wCAAwC,0DAAO;AAC/C,2CAA2C,0DAAO;AAClD,oDAAoD,0DAAO;AAC3D,kDAAkD,0DAAO;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oDAAG;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,oDAAG;AACpC;AACA;AACA,4CAA4C,6DAAO,2CAA2C,6DAAO;AACrG,uDAAuD,UAAU;AACjE;AACA;AACA;AACA,gDAAgD,wEAAmB,6BAA6B,6DAAW;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,oDAAG;AACpC,gBAAgB,0DAAE,gDAAgD,SAAS;AAC3E,gBAAgB,0DAAE,4CAA4C,QAAQ;AACtE;AACA,qCAAqC,oEAAiB,sCAAsC,6DAAW,kDAAkD,uDAAI,sDAAsD,iEAAS,uDAAuD,6DAAK,wDAAwD,kEAAU;AAC1V;AACA;AACA;AACA;AACA,YAAY,0DAAE,kGAAkG,sBAAsB;AACtI;AACA;AACA,QAAQ,kEAAO;AACf,QAAQ,kEAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,+DAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wEAAU;AACzC,MAAM,qEAAO,IAAI,qEAAkB;AACnC,MAAM,qEAAO,IAAI,6EAAW;AAC5B;AACA,sCAAsC,gGAAe;AACc;;;;;;;;;;;;;;;;;;;;;;;;;;AClJiB;AACrB;AACP;AACQ;AACd;AACwC;AACtC;AACQ;AACJ;AAC0N;AAClR,6BAA6B,gGAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,0DAAY,CAAC,oDAAG;AAC7C;AACA,6BAA6B,8DAAgB,CAAC,oDAAG,mCAAmC,oDAAG;AACvF;AACA,6BAA6B,+DAAiB;AAC9C,oBAAoB,oDAAG;AACvB,oBAAoB,oDAAG;AACvB,oBAAoB,oDAAG;AACvB,oBAAoB,oDAAG;AACvB;AACA;AACA,6BAA6B,kEAAoB,CAAC,oDAAG;AACrD;AACA,6BAA6B,mEAAqB;AAClD;AACA,6BAA6B,oEAAsB,CAAC,oDAAG;AACvD;AACA,6BAA6B,wEAA0B;AACvD,oBAAoB,oDAAG;AACvB,oBAAoB,oDAAG;AACvB;AACA;AACA;AACA,6BAA6B,oEAAsB;AACnD;AACA,6BAA6B,oEAAsB,CAAC,oDAAG,8BAA8B,oDAAG;AACxF;AACA,6BAA6B,gEAAkB;AAC/C;AACA,6BAA6B,mEAAqB,iDAAiD,8DAAgB,CAAC,oDAAG,wBAAwB,oDAAG;AAClJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,2BAA2B,iEAAU;AACrC,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,iBAAiB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,oBAAoB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,0DAAO;AAC7C,2CAA2C,0DAAO;AAClD;AACA,4CAA4C,6DAAW;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,2CAA2C,sEAAe;AAC1D;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qEAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,iCAAiC,sEAAe;AAChD;AACA;AACA;AACA,0DAA0D,yBAAyB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,oDAAoD;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wEAAU;AAChC,MAAM,qEAAO,IAAI,qEAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiD;;;;;;;;;;;;;;;;;;;AC/UwB;AACjB;AACS;AACb;AACpD;AACA;AACA;AACA,kCAAkC,0DAAO;AACzC;AACA;AACA;AACA,6CAA6C,6DAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,+BAA+B;AACpE,eAAe,uEAAY;AAC3B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB,2EAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6B;;;;;;;;;;;;;;;;;AChEuB;AACL;AAC/C;AACA;AACA;AACA;AACA,6CAA6C,6DAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wDAAU;AAC/B;AACA;AACA,SAAS;AACT;AACA;AACoC;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjCgD;AACf;AACN;AACiD;AACrB;AACC;AAClB;AAClB;AACxD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,4CAA4C,aAAa,iEAAU;AACjH;AACA;AACA;AACA;AACA,4DAA4D,4CAA4C,aAAa,iEAAU;AAC/H;AACA;AACA;AACA;AACA,sEAAsE,4CAA4C,aAAa,iEAAU;AACzI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,6FAAsB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,kBAAkB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,4CAA4C,kBAAkB;AAC9D;AACA,2CAA2C,6BAA6B;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,2BAA2B;AACvG;AACA,qFAAqF,iGAA0B;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,wCAAwC,6BAA6B,uDAAuD,MAAM;AAClI;AACA;AACA,4FAA4F,iGAA0B;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qHAA4B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wEAAU;AAClC,MAAM,qEAAO,IAAI,4EAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,0DAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,kBAAkB,sCAAsC,iBAAiB;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,eAAe,YAAY,YAAY;AAChG;AACA;AACA,yDAAyD,eAAe,YAAY,IAAI;AACxF;AACA;AACA;AACA;AACA;AACA,oCAAoC,2EAAmB;AACvD;AACA;AACA;AACA,2DAA2D,gBAAgB;AAC3E;AACA;AACA;AACA;AACA,wBAAwB,wEAAU;AAClC,MAAM,qEAAO,IAAI,4EAAW;AAC5B;AAC6I;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrTzD;AACzC;AACoB;AACM;AACoC;AACd;AACY;AACzB;AAC5B;AACwB;AACtB;AACc;AACiH;AAC7G;AACZ;AACqD;AACC;AACc;AACU;AAC9E;AACqB;AAC0C;AACmE;AAC3E;AAC3C;AACJ;AACN;AACoC;AAC9B;AACI;AACF;AACL;AACiD;AAC9B;AAC3B;AACG;AACoB;AAChB;AACoB;AACd;AACpE;AACA,qBAAqB,iGAAe;AACpC,wHAAwH,iEAAU;AAClI;AACA;AACA;AACA;AACA,qEAAqE,2DAAO;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,8DAAW;AACpF,yEAAyE,8DAAW;AACpF,0EAA0E,8DAAW;AACrF,iDAAiD,0DAAO;AACxD,gDAAgD,0DAAO;AACvD,2CAA2C,0DAAO;AAClD,+CAA+C,0DAAO;AACtD;AACA,qCAAqC,sHAA4B;AACjE,sCAAsC,8FAAsB;AAC5D,iCAAiC,sHAA4B;AAC7D;AACA;AACA;AACA,YAAY,2DAAI;AAChB,mGAAmG,kCAAkC;AACrI,kGAAkG,8BAA8B;AAChI;AACA,8BAA8B,+DAAc;AAC5C,kCAAkC,uEAAkB;AACpD;AACA,4EAA4E,mGAAiB,EAAE,gEAAe,mBAAmB,wEAAmB;AACpJ,+CAA+C,+EAAmB;AAClE;AACA,yFAAyF,uFAA8B;AACvH,aAAa;AACb;AACA,oBAAoB,sHAA4B;AAChD;AACA,iCAAiC,yEAAa;AAC9C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iEAAI;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0EAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,OAAO;AACpE;AACA;AACA;AACA,YAAY,kEAAW;AACvB,YAAY,kFAAyB;AACrC;AACA,aAAa;AACb;AACA;AACA;AACA,sBAAsB,8DAAO;AAC7B;AACA,iEAAiE,qBAAqB,oBAAoB,KAAK;AAC/G;AACA;AACA,0EAA0E,KAAK;AAC/E;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2FAAmB;AACjD,+BAA+B,oDAAG;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6DAAO;AAClC;AACA;AACA;AACA;AACA;AACA,mBAAmB,oDAAG;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,oBAAoB,gFAAiB;AACrC,mBAAmB,iFAA0B;AAC7C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yFAAyF,kBAAkB;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA,wGAAwG,kBAAkB;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,0EAAc,CAAC,oFAAwB;AAChF;AACA,uEAAuE,sCAAsC,aAAa,eAAe,sBAAsB,uBAAuB,GAAG,sFAAsF,yBAAyB,OAAO;AAC/S;AACA,6CAA6C,sEAAe;AAC5D,6CAA6C,2FAA+B;AAC5E;AACA,2DAA2D,mEAAQ;AACnE;AACA;AACA,YAAY,iEAAI,uCAAuC,sCAAsC;AAC7F;AACA,SAAS;AACT,YAAY,iEAAI,sCAAsC,sCAAsC;AAC5F;AACA,SAAS;AACT;AACA;AACA;AACA,6DAA6D,uEAAsB;AACnF,gEAAgE,iEAAgB;AAChF,yDAAyD,iEAAgB;AACzE;AACA,sEAAsE,4DAAa,QAAQ,4DAAa;AACxG,cAAc,4DAAa;AAC3B,+DAA+D,4DAAa,aAAa,4DAAa;AACtG,wEAAwE,sCAAsC;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gGAAoB;AACpD,mDAAmD,2FAAmB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,wCAAwC;AAC/F,qCAAqC,gDAAgD;AACrF,sCAAsC,uDAAuD;AAC7F,+CAA+C,OAAO,0DAAI,gEAAgE;AAC1H,oCAAoC,wEAAwE;AAC5G,0CAA0C,oEAAoE;AAC9G,gCAAgC,OAAO,0DAAI,8EAA8E;AACzH,+BAA+B,OAAO,oDAAG,gFAAgF;AACzH,mCAAmC,gEAAgE;AACnG,yCAAyC,6DAA6D;AACtG,sCAAsC,uBAAuB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,oBAAoB,mGAAuB;AAC3C;AACA,iBAAiB;AACjB,sDAAsD,6FAA6F;AACnJ;AACA;AACA;AACA;AACA;AACA,oDAAoD,yDAAK,QAAQ,yDAAK;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,8EAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA,gBAAgB,uEAAY;AAC5B;AACA,oBAAoB,kEAAO;AAC3B,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,2EAA2E,kBAAkB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,QAAQ,sEAAW;AACnB,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,6DAA6D,qEAAQ;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,6IAA6I;AAC7I,iDAAiD,8DAAO;AACxD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,kBAAkB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,0HAAuC;AACpE;AACA;AACA;AACA,sDAAsD,sFAAsF;AAC5I;AACA;AACA;AACA;AACA,qEAAqE,gCAAgC;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6DAA6D;AAC7E;AACA,8BAA8B,iDAAQ;AACtC;AACA,iGAAiG,2FAA+B;AAChI;AACA,8BAA8B,iDAAQ;AACtC;AACA,uBAAuB,GAAG;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2DAAI;AAC5B;AACA;AACA;AACA;AACA;AACA,wBAAwB,2DAAI;AAC5B;AACA,kFAAkF,UAAU;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,yEAAc;AACrD;AACA;AACA;AACA;AACA,wBAAwB,2DAAI;AAC5B;AACA;AACA;AACA,iBAAiB;AACjB;AACA,wBAAwB,2DAAI;AAC5B;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,8DAAO;AACvF,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,uEAAY;AAC3B;AACA,SAAS;AACT;AACA;AACA,gBAAgB,WAAW;AAC3B,gEAAgE,mBAAmB;AACnF;AACA;AACA;AACA;AACA,wBAAwB,2EAA4B;AACpD;AACA,gBAAgB,iHAAgC;AAChD;AACA;AACA;AACA;AACA,gEAAgE,gBAAgB;AAChF,iBAAiB;AACjB;AACA;AACA,mBAAmB,iEAAS;AAC5B,kDAAkD,6GAAwB,uBAAuB,GAAG,eAAe,KAAK,aAAa;AACrI,0DAA0D,SAAS,EAAE,IAAI;AACzE,6DAA6D,SAAS,EAAE,IAAI;AAC5E,6EAA6E,SAAS,EAAE,IAAI;AAC5F;AACA,+BAA+B,2EAA4B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,gBAAgB;AAC/D,oBAAoB,4BAA4B;AAChD;AACA,4CAA4C,gBAAgB;AAC5D,4BAA4B,2EAA4B;AACxD,gEAAgE,gBAAgB;AAChF,oBAAoB,iHAAgC;AACpD;AACA;AACA,qBAAqB;AACrB;AACA;AACA,+CAA+C,mBAAmB;AAClE;AACA;AACA;AACA,mCAAmC,2EAA4B,iBAAiB,iHAAgC;AAChH;AACA;AACA,mEAAmE,UAAU;AAC7E;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,qCAAqC,gEAAa;AAClD;AACA;AACA;AACA,yBAAyB,4CAA4C;AACrE;AACA;AACA;AACA,oBAAoB,iEAAI,sCAAsC,gBAAgB;AAC9E,uEAAuE,4BAA4B;AACnG,oBAAoB,iEAAI,uCAAuC,gBAAgB;AAC/E;AACA,+FAA+F,uEAAwB;AACvH;AACA;AACA,gEAAgE,gBAAgB;AAChF,oBAAoB,iEAAI,uCAAuC,gBAAgB;AAC/E,uFAAuF,4BAA4B;AACnH;AACA,oCAAoC,2EAA4B;AAChE,iEAAiE,gBAAgB;AACjF,4BAA4B,iHAAgC;AAC5D;AACA;AACA,oBAAoB,iEAAI,wCAAwC,gBAAgB;AAChF;AACA;AACA;AACA,gBAAgB,iEAAI,0CAA0C,gBAAgB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,6FAA6F,6IAA6I;AAC1O;AACA,4BAA4B,uEAAwB,+DAA+D,YAAY,GAAG,YAAY,EAAE;AAChJ;AACA,YAAY,uEAAwB;AACpC;AACA;AACA;AACA;AACA,iCAAiC,wGAAuB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,0GAAyB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,6GAAwB,kBAAkB;AACnH,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA,oBAAoB,oDAAG;AACvB;AACA;AACA;AACA,6BAA6B,gEAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,oDAAG;AACtF,gBAAgB,+BAA+B;AAC/C;AACA;AACA;AACA;AACA;AACA,YAAY,2DAAI;AAChB,6EAA6E,kCAAkC;AAC/G,4EAA4E,8BAA8B;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,oDAAG;AACtF,gBAAgB,+BAA+B;AAC/C;AACA;AACA;AACA;AACA;AACA,YAAY,2DAAI;AAChB,0EAA0E,kCAAkC;AAC5G,yEAAyE,8BAA8B;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,6DAAQ;AAC7B;AACA,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,wEAAU;AAClF,MAAM,qEAAO,IAAI,mGAAqB;AACtC,MAAM,qEAAO;AACb,MAAM,qEAAO,IAAI,sEAAkB;AACnC,MAAM,qEAAO,IAAI,oEAAiB;AAClC,MAAM,qEAAO,IAAI,4EAAqB;AACtC,MAAM,qEAAO,IAAI,4EAAW;AAC5B,MAAM,qEAAO,IAAI,gFAAuB;AACxC,MAAM,qEAAO,IAAI,4EAAsB;AACvC,MAAM,qEAAO,IAAI,4EAAqB;AACtC,MAAM,qEAAO,IAAI,gFAAuB;AACxC,MAAM,qEAAO,KAAK,wFAA2B;AAC7C,MAAM,qEAAO,KAAK,8EAAsB;AACxC,MAAM,qEAAO,KAAK,8EAAsB;AACxC;AACA;AACA;AACA,iCAAiC,sHAA4B;AAC7D;AACA,kCAAkC,8FAAsB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iGAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+DAAS,CAAC,yEAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,8EAA8E;AAC9J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8FAAsB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4G;;;;;;;;;;;;;;;;;;;;;;;;;ACv6B1D;AACE;AACa;AACd;AACO;AACoC;AACzB;AACX;AAC+B;AAClB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,2EAAkB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kFAAY;AACnD;AACA;AACA;AACA;AACA;AACA,sBAAsB,kFAAY;AAClC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA,4BAA4B,mEAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,6DAAW;AACxD;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA,4DAA4D,OAAO;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kGAAuB;AACnC;AACA;AACA;AACA,kCAAkC,6EAAgB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,2BAA2B,4BAA4B,OAAO;AACrI;AACA,SAAS;AACT;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA,yBAAyB,4DAAc;AACvC;AACA;AACA,yBAAyB,4DAAc;AACvC;AACA;AACA,yBAAyB,4DAAc;AACvC;AACA;AACA;AACA;AACA;AACA,8BAA8B,yBAAyB;AACvD;AACA;AACA,SAAS;AACT,eAAe,uEAAY;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAwC;AACxD,iBAAiB;AACjB;AACA;AACA,gEAAgE,oDAAG;AACnE;AACA;AACA,yEAAyE,oDAAG;AAC5E;AACA;AACA,oEAAoE,oDAAG,iCAAiC,4DAAQ;AAChH;AACA;AACA,qEAAqE,oDAAG;AACxE;AACA;AACA,kEAAkE,oDAAG;AACrE;AACA;AACA,kEAAkE,oDAAG,iBAAiB,oDAAG;AACzF;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,oDAAG,iBAAiB,oDAAG;AACpE;AACA;AACA,2EAA2E,oDAAG;AAC9E;AACA;AACA,+DAA+D,oDAAG;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,oDAAG;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4DAAQ;AAC7B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6B;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3RuD;AAChC;AACoH;AACpH;AACM;AACgC;AAC9B;AACQ;AACH;AACH;AACmB;AACvB;AAC1D;AACA;AACA;AACA;AACA,iCAAiC,gEAAa;AAC9C,4CAA4C,6DAAW;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,2EAAc;AACxE;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,kIAAkI,+BAA+B;AACjK;AACA;AACA,iEAAiE,4DAAQ;AACzE;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iEAAiE,8BAA8B;AAC/F;AACA;AACA,gEAAgE,8DAA8D;AAC9H;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,uEAAuE,KAAK,kBAAkB,cAAc;AAC5G;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,0EAA0E,KAAK,kBAAkB,cAAc;AAC/G;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,qEAAQ;AACzC,0BAA0B,6DAAe,wCAAwC,qBAAqB,6DAAO,uDAAuD;AACpK;AACA;AACA;AACA;AACA,oBAAoB,8FAA6B,YAAY,wFAA2B;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,QAAQ;AAC7D;AACA;AACA;AACA;AACA;AACA,oBAAoB,8FAA6B,YAAY,wFAA2B;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6DAAe;AAC1C;AACA;AACA,2BAA2B,oFAAuB;AAClD;AACA,qBAAqB,wFAA2B,mBAAmB,6DAAe;AAClF,qBAAqB,wFAA2B,qBAAqB,6DAAe;AACpF,qBAAqB,wFAA2B,0BAA0B,6DAAe;AACzF,qBAAqB,wFAA2B,yBAAyB,6DAAe;AACxF,qBAAqB,wFAA2B,sBAAsB,6DAAe;AACrF,qBAAqB,wFAA2B,oBAAoB,6DAAe;AACnF,qCAAqC,6DAAe;AACpD;AACA;AACA;AACA,wBAAwB,6DAAe;AACvC;AACA;AACA,kBAAkB,6DAAe;AACjC;AACA;AACA,iBAAiB,wFAA2B,mBAAmB,6DAAe;AAC9E,iBAAiB,wFAA2B,qBAAqB,6DAAe;AAChF,iBAAiB,wFAA2B,0BAA0B,6DAAe;AACrF,iBAAiB,wFAA2B,yBAAyB,6DAAe;AACpF,iBAAiB,wFAA2B,sBAAsB,6DAAe;AACjF,iBAAiB,wFAA2B,oBAAoB,6DAAe;AAC/E,iCAAiC,6DAAe;AAChD;AACA;AACA;AACA,+CAA+C,mDAAmD,8DAAM,GAAG,4EAAoB,qCAAqC;AACpK,eAAe,uEAAY;AAC3B;AACA;AACA,+DAA+D,8DAAM;AACrE;AACA;AACA,4DAA4D,wEAAU;AACtE,MAAM,qEAAO,IAAI,qEAAkB;AACnC,MAAM,qEAAO,IAAI,6EAAsB;AACvC;AACA,qCAAqC,gGAAe;AACa;;;;;;;;;;;;;;;;;;;;;;;;AC3NK;AACK;AACzB;AACE;AACuC;AAC7B;AACV;AACI;AAC4B;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,0DAAO;AACzC,kCAAkC,0DAAO;AACzC,kCAAkC,0DAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2DAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oDAAG;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oDAAG;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oDAAG;AACnC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,2BAA2B,wDAAU;AACrC;AACA;AACA,2BAA2B,wDAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,6DAAW;AACxD;AACA,yCAAyC,0DAAQ,kCAAkC,4DAAU;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,oDAAG;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,oDAAG;AACxE;AACA;AACA;AACA;AACA;AACA,0DAA0D,8DAAK,WAAW,GAAG,0DAAQ,CAAC;AACtF;AACA;AACA;AACA,8CAA8C,0FAAuB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,uCAAuC;AAC7H,eAAe,wDAAU,QAAQ,6CAA6C;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sDAAI,kCAAkC,oDAAG;AACvE,8BAA8B,sDAAI,kCAAkC,oDAAG;AACvE,8BAA8B,sDAAI,kCAAkC,oDAAG;AACvE;AACA,oBAAoB;AACpB,oBAAoB;AACpB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,0DAAO;AAC/C,sCAAsC,0DAAO;AAC7C,sCAAsC,0DAAO;AAC7C,sCAAsC,0DAAO;AAC7C,uCAAuC,+DAAY;AACnD,uCAAuC,+DAAY;AACnD,uCAAuC,+DAAY;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kEAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,2BAA2B,QAAQ,oDAAG,2BAA2B,oDAAG,mBAAmB,KAAK;AACzJ;AACA;AACA,6DAA6D,wBAAwB,oDAAG,qBAAqB;AAC7G;AACA;AACA;AACA,6DAA6D,wBAAwB,oDAAG,qBAAqB;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,2BAA2B,QAAQ,oDAAG,2BAA2B,oDAAG,mBAAmB,KAAK;AACvK;AACA,2EAA2E,wBAAwB,oDAAG,qBAAqB;AAC3H;AACA;AACA,2EAA2E,wBAAwB,oDAAG,qBAAqB;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,2DAAa;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,oBAAoB,QAAQ,EAAE,oEAAe;AAC7C;AACA;AACA,aAAa;AACb;AACA;AACA,iBAAiB;AACjB;AACA;AACyC;;;;;;;;;;;;;;;;;;;ACzQiB;AACC;AAC+B;AAC1F;AACA;AACA,sDAAsD,4DAAO;AAC7D;AACA,4BAA4B,6DAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gGAAe;AACS;;;;;;;;;;;;;;;;AClCiC;AAC1F,kCAAkC,gGAAe;AACd;;;;;;;;;;;;;;;;;ACFe;AACsC;AACxF;AACA;AACA;AACA;AACA;AACA,qCAAqC,2DAAU;AAC/C;AACA;AACA;AACA;AACA,sBAAsB,mEAAkB;AACxC,sBAAsB,mEAAkB;AACxC,sBAAsB,mEAAkB;AACxC,sBAAsB,mEAAkB;AACxC;AACA,kBAAkB,iEAAgB;AAClC;AACA;AACA;AACA;AACA,6BAA6B,aAAa,oDAAG,kCAAkC,oDAAG;AAClF;AACA;AACA,yBAAyB,aAAa,oDAAG,kCAAkC,oDAAG;AAC9E,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AAC8B;;;;;;;;;;;;;;;;;AChDmC;AACb;AACpD;AACA;AACA;AACA,6CAA6C,6DAAW;AACxD;AACA;AACA;AACA;AACA,eAAe,uEAAY;AAC3B;AACA,SAAS;AACT;AACA;AAC+B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACfqE;AAC9B;AACG;AACiB;AACxB;AACE;AACJ;AACF;AACa;AACN;AACnB;AACsB;AACH;AAC8D;AACpC;AACpD;AAC6C;AACkhB;AACvL;AACpU;AAC5E;AACiB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sEAAc;AAC1B;AACA;AACA,qCAAqC,6DAAc;AACnD;AACA,4BAA4B,sEAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAU;AAChC,qCAAqC,iEAAS;AAC9C;AACA;AACA,uBAAuB,6DAAK;AAC5B,gCAAgC,6DAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gEAAO,gDAAgD,gEAAO;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6CAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sEAAe;AAClD;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA,uBAAuB,6DAAK;AAC5B;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sEAAc;AACtC;AACA;AACA;AACA,gBAAgB,sEAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gEAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gEAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gEAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gEAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gEAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA,oDAAoD,iBAAiB;AACrE;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA,sBAAsB,sEAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,oDAAO;AACxC;AACA,+BAA+B,6DAAK;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gEAAQ;AAC5B;AACA;AACA,mBAAmB,6EAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,6DAAK,eAAe,0EAAkB;AAC1G;AACA;AACA,kCAAkC,mEAAW;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gEAAQ;AAC5B;AACA;AACA;AACA,4BAA4B,yEAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,oBAAoB,gEAAQ;AAC5B;AACA;AACA;AACA,4BAA4B,8EAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gEAAQ;AAC5B;AACA;AACA;AACA,wBAAwB,gEAAQ,qBAAqB,6DAAK;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gEAAQ;AAC5B;AACA;AACA;AACA,4BAA4B,gEAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6CAAK;AAClC;AACA;AACA;AACA;AACA,oBAAoB,wEAAS;AAC7B,cAAc,iEAAW;AACzB,cAAc,6DAAK;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,6DAAc;AACtD,yBAAyB,6EAAqB;AAC9C;AACA;AACA,aAAa,uEAAe;AAC5B;AACA;AACA;AACA,mCAAmC,sEAAe;AAClD;AACA;AACA,wBAAwB,8BAA8B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iDAAiD,kCAAkC,0BAA0B,6BAA6B;AAC1I;AACA;AACA,iDAAiD,kCAAkC,0BAA0B,6BAA6B,mDAAmD,qBAAqB;AAClN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,kEAAU;AACjG,4CAA4C,qEAAa;AACzD;AACA;AACA,0BAA0B,gGAAoB;AAC9C,4BAA4B,gGAAoB,wCAAwC,gEAAQ,cAAc,6DAAK;AACnH;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qEAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6CAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,6DAAK;AACzD,6BAA6B,oEAAY;AACzC,yBAAyB,uEAAmB;AAC5C,SAAS;AACT;AACA;AACA;AACA;AACA,0FAA0F,uEAAwB;AAClH,eAAe,oEAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,6DAAK;AACzD,6BAA6B,oEAAY;AACzC;AACA,SAAS;AACT;AACA,wCAAwC,0EAA2B;AACnE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kDAAQ;AAC/C;AACA,mCAAmC,EAAE;AACrC;AACA;AACA;AACA;AACA,sFAAsF,gCAAgC;AACtH,sDAAsD,qEAAa;AACnE,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,qEAAa;AAC1E,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gEAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6DAAK;AACzB;AACA;AACA;AACA,4BAA4B,gEAAQ;AACpC;AACA;AACA;AACA;AACA;AACA,QAAQ,iEAAU;AAClB;AACA,sCAAsC,6DAAK;AAC3C;AACA;AACA;AACA,4BAA4B,gEAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gEAAQ;AAC5B;AACA;AACA;AACA,4BAA4B,gEAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6CAAK;AAClC;AACA;AACA;AACA,aAAa,uEAAe;AAC5B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uEAAe;AAClC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8DAAK,SAAS,uEAAe;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gEAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAa;AAChC;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gEAAQ;AAC5B;AACA;AACA;AACA;AACA,gBAAgB,oDAAO;AACvB;AACA;AACA;AACA,qBAAqB,+DAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO,6DAAK;AACjC;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS,kFAAwB,UAAU,uEAA0B;AACrE,SAAS,kFAAwB,aAAa,uEAA0B;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6DAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,6DAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAmB,8BAA8B,iEAAkB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kEAAmB;AACrC;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sGAAuB;AAC1C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sGAAuB;AAC1C;AACA;AACA;AACA,+BAA+B,mEAAmE;AAClG;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,6DAAK;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sGAAuB;AACtC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6CAAK;AAClC;AACA;AACA;AACA;AACA,oBAAoB,gEAAQ;AAC5B,uEAAuE,oDAAO;AAC9E,gDAAgD,UAAU;AAC1D,0BAA0B,gEAAS;AACnC,yFAAyF,yEAAiB;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,6DAAc;AACvE;AACA,mCAAmC,sEAAe;AAClD;AACA;AACA;AACA;AACA;AACA,sBAAsB,SAAS,6DAAK,6BAA6B,6DAAK,oBAAoB;AAC1F;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+DAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,0EAAkB;AAChE,kDAAkD,yEAAiB;AACnE;AACA,4EAA4E,sEAAc;AAC1F;AACA;AACA;AACA;AACA;AACA,gFAAgF,gEAAQ;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,4DAAa;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oDAAO;AACnB,2BAA2B,6DAAK;AAChC;AACA;AACA;AACA,wBAAwB,6DAAK;AAC7B,yBAAyB,6DAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,gGAAoB;AAClE;AACA,aAAa,qFAA2B,aAAa,0EAA6B;AAClF,aAAa,qFAA2B,YAAY,0EAA6B;AACjF;AACA;AACA;AACA,eAAe,gGAAoB;AACnC;AACA;AACA;AACA;AACA;AACA,oBAAoB,gEAAQ;AAC5B;AACA;AACA;AACA,2BAA2B,6DAAK;AAChC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,sEAAe;AAChE;AACA;AACA;AACA;AACA;AACA,gFAAgF,2BAA2B;AAC3G;AACA,wCAAwC,6DAAK;AAC7C;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,6CAA6C,sEAAe;AAC5D;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mGAAuB;AAC/B;AACA,kBAAkB,6DAAK;AACvB;AACA;AACA;AACA,2BAA2B,6DAAK;AAChC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,sEAAe;AAChE;AACA;AACA;AACA;AACA;AACA,gFAAgF,2BAA2B;AAC3G;AACA,wCAAwC,6DAAK;AAC7C;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,6CAA6C,sEAAe;AAC5D;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,yEAAiB;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA,yCAAyC,sEAAe;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,sEAAe;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6DAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,+EAAqB,aAAa,oEAAuB;AACtE,aAAa,+EAAqB,UAAU,oEAAuB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6CAAK;AAClC;AACA;AACA;AACA,oBAAoB,gEAAQ;AAC5B;AACA;AACA;AACA;AACA,qBAAqB,GAAG,qEAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qEAAa;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6CAAK;AAClC;AACA;AACA;AACA;AACA,sBAAsB,6DAAK;AAC3B;AACA;AACA,wEAAwE,iCAAiC,cAAc,oBAAoB;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,sEAAe;AACzD,yBAAyB;AACzB,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA,+CAA+C,qBAAqB,oBAAoB,iCAAiC,cAAc,oBAAoB;AAC3J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sEAAc;AACnC,sBAAsB,gEAAQ;AAC9B,+DAA+D,gEAAQ;AACvE,+BAA+B,qEAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sEAAc;AAC3C;AACA,oBAAoB,uDAAQ;AAC5B,qCAAqC,gEAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6CAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8DAA8D,oEAAY;AAC/F;AACA;AACA;AACA,6BAA6B;AAC7B,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA,4BAA4B,oEAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oEAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6DAAK;AAC5B,uBAAuB,6DAAK;AAC5B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,sBAAsB,6DAAK;AAC3B,sBAAsB,6DAAK;AAC3B,8EAA8E,iBAAiB;AAC/F;AACA;AACA;AACA;AACA,wBAAwB,yEAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oEAAY;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gEAAQ;AAC7C;AACA,aAAa,uEAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sEAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oEAAW;AACzC;AACA;AACA;AACA;AACA,oBAAoB,gEAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,6DAAK;AACjE;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,6DAAK;AACjE;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yEAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oEAAW;AACzC;AACA;AACA;AACA;AACA,oBAAoB,gEAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yEAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6CAAK;AAClC;AACA;AACA;AACA,oBAAoB,gEAAQ;AAC5B,6BAA6B,oEAAY;AACzC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,2BAA2B,+DAAO;AAClC;AACA;AACA;AACA;AACA,uCAAuC,kDAAQ;AAC/C;AACA,kCAAkC,EAAE;AACpC;AACA;AACA;AACA;AACA,sFAAsF,gCAAgC;AACtH,sDAAsD,qEAAa;AACnE,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,qEAAa;AAC1E,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qDAAG;AACvB;AACA;AACA,iBAAiB,qDAAG;AACpB;AACA,4CAA4C,6DAAK;AACjD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,6BAA6B,qEAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,8DAAW;AACzD;AACA;AACA,eAAe,wEAAgB;AAC/B;AACA;AACA;AACA,kBAAkB,yDAAU;AAC5B;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,gCAAgC,qBAAqB,gDAAgD;AAC5I;AACA;AACA;AACA,iBAAiB,2EAAmB;AACpC,2CAA2C,gCAAgC;AAC3E;AACA;AACA;AACA,SAAS;AACT;AACA,2CAA2C,gCAAgC,wBAAwB,gBAAgB;AACnH;AACA,SAAS;AACT,YAAY,2EAAiB;AAC7B,mBAAmB,4EAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0GAA0G,qDAAG;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,yDAAU;AAC/B;AACA;AACA;AACA;AACA,+FAA+F,qDAAG;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iGAAiG,qDAAG;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mGAAmG,qDAAG;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yGAAyG,qDAAG;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yGAAyG,qDAAG;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,qDAAG;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uHAAuH,qDAAG;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,yDAAU;AAC/B;AACA;AACA;AACA;AACA,qGAAqG,qDAAG;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gHAAgH,qDAAG;AACnH;AACA;AACA,0HAA0H,qDAAG,yDAAyD,qDAAG;AACzL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,qDAAG;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gGAAgG,qDAAG;AACnG;AACA;AACA,6BAA6B,sEAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,kGAAkG,qDAAG;AACrG;AACA;AACA,+GAA+G;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sHAAsH,qDAAG;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wHAAwH,qDAAG;AAC3H;AACA;AACA,yHAAyH,qDAAG;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kHAAkH,qDAAG;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2HAA2H,aAAa;AACxI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F,qDAAG;AACjG;AACA;AACA,iGAAiG,qDAAG;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yGAAyG,qDAAG;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,yDAAU;AAC/B;AACA;AACA;AACA;AACA,yHAAyH,qDAAG;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mIAAmI,qDAAG;AACtI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uGAAuG,qDAAG;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kJAAkJ,2FAAmB,oEAAoE,2FAAmB;AAC5P;AACA;AACA;AACA,kHAAkH,qDAAG;AACrH;AACA;AACA,oHAAoH,qDAAG;AACvH;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oFAAoF,kCAAkC;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAAkG,qDAAG;AACrG;AACA;AACA,0EAA0E,2BAA2B;AACrG;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,uGAAuG,qDAAG;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,yDAAU;AAC/B;AACA;AACA;AACA;AACA,iGAAiG,qDAAG;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F,qDAAG;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gGAAgG,qDAAG;AACnG;AACA;AACA,4GAA4G,qDAAG;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,yDAAU;AAC/B;AACA;AACA;AACA;AACA,2GAA2G,qDAAG;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0GAA0G,qDAAG;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iHAAiH,qDAAG;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iHAAiH,qDAAG;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sHAAsH,gGAAoB;AAC1I;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,2IAA2I,qDAAG;AAC9I;AACA;AACA,mHAAmH;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,4GAA4G,qDAAG;AAC/G;AACA;AACA,oHAAoH,qDAAG;AACvH;AACA;AACA,sHAAsH;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,8DAAe;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B,2BAA2B,iFAAwB;AACnD;AACA,gEAAgE,YAAY;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmC;;;;;;;;;;;;;;;;;;;;;;;ACl8E8B;AACQ;AACN;AACF;AACJ;AACD;AACR;AACsC;AAC1F;AACA;AACA;AACA;AACA;AACA,6CAA6C,6DAAW;AACxD;AACA;AACA,4CAA4C,mEAAM;AAClD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,sDAAsD,QAAQ;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kEAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mFAA4B;AACrD;AACA;AACA;AACA;AACA,8CAA8C,WAAW;AACzD;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,uFAAuF,2EAAiB;AACxG;AACA;AACA,sCAAsC,uEAAgB;AACtD;AACA,wBAAwB,qEAAiB;AACzC;AACA;AACA;AACA;AACA,sDAAsD,IAAI;AAC1D;AACA;AACA,sDAAsD,IAAI,2BAA2B,WAAW;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA,yEAAyE,6BAA6B;AACtG;AACA;AACA;AACA;AACA;AACA,2EAA2E,qEAAc;AACzF;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iBAAiB;AACzD;AACA,eAAe,uEAAY;AAC3B;AACA;AACA,SAAS;AACT;AACA;AACqC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7H+C;AACK;AAChB;AACH;AAC8D;AACrE;AACH;AACK;AACtB;AAC6F;AAC9C;AAChB;AACD;AACrB;AACgB;AACR;AACU;AAC8F;AAC7D;AACd;AACzF;AACA,kCAAkC,iGAAe;AACjD;AACA;AACA;AACA,6BAA6B,sEAAmB;AAChD,uCAAuC,sEAAmB;AAC1D;AACA;AACA;AACA;AACA;AACA,qCAAqC,sEAAmB;AACxD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,0BAA0B,sEAAmB;AAC7C,wCAAwC,oEAAqB;AAC7D;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oEAAqB;AAC3C;AACA;AACA,sBAAsB,wEAAyB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,aAAa;AACb;AACA;AACA;AACA,8CAA8C,0DAAO;AACrD,4CAA4C,0DAAO;AACnD;AACA;AACA;AACA,uCAAuC,6FAAsB;AAC7D;AACA;AACA,6CAA6C,8DAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,wEAAwE;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,0FAAmB,6BAA6B,GAAG,WAAW;AAC5H;AACA;AACA,uCAAuC,0FAAmB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,0FAA0F,sCAAsC;AAChI,6EAA6E,0FAAmB;AAChG,SAAS;AACT,eAAe,uEAAY;AAC3B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,4EAAQ;AACxC;AACA,gDAAgD,qBAAqB;AACrE;AACA;AACA;AACA,yCAAyC,wEAAyB;AAClE,yBAAyB;AACzB;AACA,8CAA8C,oEAAqB;AACnE,yBAAyB;AACzB;AACA;AACA,gDAAgD,qBAAqB,iBAAiB,yBAAyB;AAC/G;AACA;AACA,yDAAyD,6BAA6B;AACtF,SAAS;AACT;AACA;AACA,4FAA4F,gFAAwB,iBAAiB,0FAAmB;AACxJ;AACA;AACA,qCAAqC,4EAAQ;AAC7C,kCAAkC,iCAAiC,oEAAqB,iBAAiB;AACzG,aAAa;AACb,2FAA2F,gFAAwB,mCAAmC,EAAE,0FAAmB;AAC3K;AACA;AACA;AACA,SAAS;AACT,uDAAuD,sFAA8B;AACrF,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD,6DAA6D,6BAA6B,6FAAsB,MAAM;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,qEAAiB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iEAAkB;AAChD;AACA,+EAA+E,2EAAiB;AAChG,iBAAiB;AACjB;AACA;AACA,8BAA8B,iEAAkB;AAChD;AACA,+FAA+F,WAAW,2EAAiB;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,8CAA8C;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iEAAkB,6BAA6B,gBAAgB;AACjF;AACA;AACA,mEAAmE,0EAA0E;AAC7I;AACA,sBAAsB,iEAAkB,kCAAkC,gBAAgB,uBAAuB,WAAW;AAC5H;AACA;AACA;AACA;AACA;AACA,kDAAkD,sBAAsB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iEAAkB;AACjD;AACA;AACA,sBAAsB,iEAAkB,oBAAoB,gBAAgB,aAAa,4EAAc,QAAQ;AAC/G;AACA;AACA;AACA;AACA;AACA,iCAAiC,2EAA4B;AAC7D,gBAAgB,mGAAuB;AACvC;AACA,iEAAiE,0EAA2B;AAC5F,gBAAgB,mGAAuB;AACvC;AACA,kCAAkC,gFAAwB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uFAA+B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6GAA6B;AACxD,6FAA6F,cAAc;AAC3G;AACA,2CAA2C,yDAAyD;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iDAAQ,uBAAuB,EAAE;AACrD;AACA,iFAAiF,mBAAmB,UAAU;AAC9G,2CAA2C,yDAAyD;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0FAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,iDAAiD;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iEAAkB,6BAA6B,gBAAgB;AACjF;AACA,sBAAsB,8DAAQ;AAC9B;AACA;AACA;AACA,8FAA8F,gFAAwB;AACtH;AACA;AACA;AACA,qBAAqB,oBAAoB;AACzC,kEAAkE,6FAAsB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wDAAK,QAAQ,wDAAK,iDAAiD,0FAAmB;AACzH,gCAAgC,wDAAK;AACrC;AACA;AACA,uBAAuB,wDAAK;AAC5B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,wEAAU;AAC/D,OAAO,qEAAO,IAAI,sEAAkB;AACpC,OAAO,qEAAO,IAAI,6EAAW;AAC7B,OAAO,qEAAO,IAAI,8EAAsB;AACxC;AACyD;;;;;;;;;;;;;;;;;;;;;;ACtbL;AACiD;AAChB;AAC3B;AACQ;AACE;AACqB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,6DAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,kBAAkB;AAC7D;AACA;AACA;AACA;AACA;AACA,oBAAoB,+DAAQ;AAC5B;AACA;AACA,kBAAkB,+DAAiB;AACnC,sEAAsE,mDAAK;AAC3E;AACA;AACA;AACA;AACA;AACA,mBAAmB,4DAAO;AAC1B,kBAAkB,gEAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2BAA2B,GAAG,GAAG;AACrE;AACA,6DAA6D,GAAG;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oEAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,sEAAe;AACxD;AACA;AACA;AACA,oDAAoD,GAAG,SAAS,4BAA4B;AAC5F;AACA;AACA,yBAAyB,wEAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA,8BAA8B,uEAAgB;AAC9C;AACA;AACA,gDAAgD,oEAAsB,SAAS,gEAAU,2BAA2B,oEAAsB,WAAW,gEAAU,WAAW,gEAAU;AACpL;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA,gBAAgB,kGAAuB;AACvC;AACA;AACA,aAAa;AACb;AACA,gBAAgB,kGAAuB;AACvC;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4B;;;;;;;;;;;;;;;;;;;;;;;;;ACjLwD;AAChB;AACV;AACR;AACwC;AAChB;AACtB;AACkB;AACV;AAC5D;AACA;AACA;AACA;AACA,qCAAqC,6DAAW;AAChD;AACA,0DAA0D,sEAAgB;AAC1E;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA,mBAAmB,gEAAO,qBAAqB;AAC/C;AACA;AACA;AACA,uBAAuB,oDAAoD;AAC3E;AACA;AACA;AACA,gHAAgH,IAAI;AACpH;AACA,eAAe,gEAAO,4BAA4B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,2BAA2B;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,4BAA4B,OAAO,UAAU,IAAI,UAAU;AAChI;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,mBAAmB,oDAAG;AACtB;AACA;AACA,cAAc,oDAAG,sEAAsE,qBAAqB;AAC5G;AACA;AACA;AACA,+BAA+B,wEAAU;AACzC,MAAM,qEAAO,IAAI,+EAAuB;AACxC,MAAM,qEAAO,IAAI,qEAAkB;AACnC,MAAM,qEAAO,IAAI,4EAAW;AAC5B;AACA,sCAAsC,gGAAe;AACc;;;;;;;;;;;;;;;;;;;;ACpFiB;AACzC;AACkC;AACL;AACF;AACtE,wDAAwD,0EAAU;AAClE;AACA;AACA,kDAAkD,iDAAQ,iDAAiD,iDAAQ,sCAAsC,iDAAQ;AACjK,+CAA+C,MAAM;AACrD;AACA;AACA,uBAAuB,wEAAU;AACjC,OAAO,qEAAO,IAAI,+EAAc;AAChC,OAAO,qEAAO,IAAI,+EAAuB;AACzC;AAC6B;;;;;;;;;;;;;;;;;;;;;;AChBuD;AACe;AAC/C;AACkB;AACV;AACV;AACW;AAC7D,8DAA8D,8EAAqB;AACnF;AACA,yFAAyF,mEAAM;AAC/F,qCAAqC,6DAAW;AAChD;AACA;AACA;AACA,6BAA6B,oDAAG;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wEAAU;AACnC,MAAM,qEAAO,IAAI,qEAAkB;AACnC,MAAM,qEAAO,IAAI,+EAAuB;AACxC;AACA,qBAAqB,8EAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgC;;;;;;;;;;;;;;;;;;;;;;AC9DoD;AAChC;AACsC;AACI;AAClC;AACF;AAC1D,iCAAiC,gGAAe;AAChD;AACA;AACA;AACA;AACA;AACA,4CAA4C,6DAAW;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,gBAAgB;AAC3E;AACA;AACA;AACA,iCAAiC,sEAAe;AAChD;AACA,uBAAuB,uEAAY;AACnC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,mGAAmG,4DAAQ;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,wEAAU;AACpC,MAAM,qEAAO,IAAI,qEAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iEAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACyD;;;;;;;;;;;;;;;;;AC3EyB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT,gCAAgC,mEAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kEAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,gDAAgD;AAC3G;AACA;AACA;AACA;AACA;AACA;AACoD;;;;;;;;;;;;;;;;;;;ACzEgC;AAChC;AACsB;AACe;AACzF;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,6DAAW;AACxD;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kGAAuB;AACnC;AACA;AACA;AACA,6BAA6B,uBAAuB;AACpD;AACA;AACA,gCAAgC,kDAAkD;AAClF;AACA;AACA,wBAAwB,2BAA2B;AACnD,gCAAgC,uDAAuD;AACvF;AACA;AACA,kDAAkD,qBAAqB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,qBAAqB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,0BAA0B,wEAAU;AACpC,MAAM,qEAAO,IAAI,4EAAW;AAC5B;AACiC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/DU;AACe;AACF;AAC0B;AACX;AACD;AACN;AACd;AAC0E;AACzF;AACiB;AACoC;AACsF;AAC7G;AACmC;AAChB;AACjB;AACV;AACC;AACuB;AAC4B;AACS;AACtH;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,4DAAW;AAC3C;AACA,sDAAsD,0DAAO;AAC7D;AACA;AACA,gDAAgD,0DAAO;AACvD;AACA,iDAAiD,0DAAO;AACxD;AACA,wDAAwD,0DAAO;AAC/D;AACA,qCAAqC,4CAAK;AAC1C;AACA;AACA,qDAAqD,8DAAW;AAChE,8DAA8D,8DAAW;AACzE,4DAA4D,8DAAW;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,sDAAsD,SAAS,mBAAmB,8BAA8B;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,IAAI;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wFAAgC;AAC5D;AACA;AACA,gGAAgG,6BAA6B;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,uGAAwB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yDAAU;AAC7B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,wCAAwC,oEAAY;AACpD,SAAS;AACT,eAAe,oDAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,oDAAG;AAChD,eAAe,sEAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,0BAA0B,kEAAU;AACpC;AACA,2EAA2E,qEAAa;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,2BAA2B;AACvF;AACA;AACA,4DAA4D,2BAA2B;AACvF;AACA;AACA;AACA;AACA,2BAA2B,oDAAG;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sEAAe;AACjD;AACA;AACA;AACA,oBAAoB,6EAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4EAAmB;AAC/B;AACA;AACA;AACA,+CAA+C,+BAA+B;AAC9E,kEAAkE,iEAAiE,YAAY,sFAA8B;AAC7K,eAAe,uEAAY;AAC3B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,0GAA6B,CAAC,oEAAY;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,oEAAY;AAChF,eAAe,4DAAQ;AACvB;AACA;AACA,oBAAoB,oDAAG;AACvB;AACA,oDAAoD,UAAU,IAAI,kBAAkB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+EAAkB,CAAC,iDAAQ,0CAA0C,EAAE;AAC7F;AACA;AACA,sBAAsB,gEAAM,4FAA4F;AACxH;AACA;AACA;AACA,iCAAiC,+DAAgB;AACjD,gCAAgC,gEAAM,wEAAwE;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,WAAW,EAAE,kBAAkB;AAC3E;AACA,gDAAgD,WAAW,EAAE,kBAAkB;AAC/E;AACA;AACA;AACA;AACA,iCAAiC,qEAAQ;AACzC,sCAAsC,qEAAQ;AAC9C,yCAAyC,qEAAQ;AACjD;AACA;AACA;AACA,wDAAwD,2EAAc;AACtE,sDAAsD,2EAAc;AACpE,kBAAkB,qEAAI,GAAG,oCAAoC;AAC7D;AACA;AACA,mDAAmD,UAAU,IAAI,kBAAkB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,4DAAW;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,sGAAmB;AAC9G;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,8BAA8B,4DAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,kCAAkC,4DAAQ;AAC1C;AACA;AACA;AACA;AACA,iCAAiC,oEAAY;AAC7C;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,uFAAe;AAC3D;AACA;AACA;AACA,gDAAgD,uHAAqC;AACrF;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,4CAA4C,uHAAqC;AACjF;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uGAAuG,0EAAa;AACpH;AACA,2DAA2D,qEAAI,GAAG,wCAAwC;AAC1G,sBAAsB,+EAAkB,CAAC,iDAAQ;AACjD;AACA;AACA;AACA;AACA,8BAA8B,6DAAO;AACrC;AACA;AACA;AACA,gEAAgE,SAAS;AACzE;AACA,6BAA6B,6EAAqB,0EAA0E,qEAAa,6BAA6B,qEAAa,6CAA6C,kEAAU;AAC1O;AACA;AACA;AACA;AACA;AACA,mCAAmC,oDAAG;AACtC;AACA;AACA;AACA;AACA,oFAAoF,qFAAqF;AACzK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oDAAG;AAC/B;AACA,kEAAkE,KAAK;AACvE;AACA,uCAAuC,iFAAuB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,qEAAW;AACpF;AACA;AACA,gFAAgF,oCAAoC;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oDAAG;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,4BAA4B;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oEAAkB;AAClD,4CAA4C,4DAAU;AACtD;AACA;AACA;AACA,oCAAoC,oEAAkB;AACtD;AACA;AACA;AACA,qBAAqB,4DAAQ;AAC7B;AACA,kBAAkB,kEAAgB,0BAA0B,oEAAY;AACxE;AACA,4CAA4C,4DAAU;AACtD;AACA;AACA;AACA,oCAAoC,oEAAkB;AACtD;AACA;AACA;AACA,2BAA2B,0GAA6B,CAAC,oEAAY;AACrE;AACA,kBAAkB,kEAAgB;AAClC;AACA;AACA;AACA;AACA;AACA,4DAA4D,IAAI;AAChE;AACA;AACqC;;;;;;;;;;;;;;;;;;;;;ACpjBqB;AACR;AACsF;AACtF;AACqF;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,2DAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oDAAG;AACtB;AACA,gDAAgD,yEAAkB;AAClE;AACA,iEAAiE;AACjE;AACA,YAAY,mFAA4B,oCAAoC;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,SAAS;AACzF;AACA;AACA,8BAA8B,0CAA0C;AACxE;AACA,sBAAsB,uEAAgB;AACtC;AACA,6BAA6B,oBAAoB;AACjD,kCAAkC,qBAAqB;AACvD,gCAAgC,gCAAgC;AAChE,iCAAiC,wBAAwB;AACzD,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,yEAAkB;AAC3D;AACA;AACA,8CAA8C,6EAAsB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,4FAAgB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,uCAAuC,qGAAyB;AAChE;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,mFAA4B;AAC3E;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C,gCAAgC,yBAAyB;AACzD,qCAAqC,4BAA4B;AACjE,gCAAgC,uBAAuB;AACvD,mCAAmC,2BAA2B,4DAAO,YAAY;AACjF,iCAAiC,wBAAwB;AACzD,iCAAiC,wBAAwB;AACzD,kCAAkC,4BAA4B;AAC9D;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA,+CAA+C,uBAAuB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,qCAAqC;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,uBAAuB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+FAAuB;AACzD;AACA;AACA,uCAAuC,+FAAuB;AAC9D;AACA;AACA,uCAAuC,+FAAuB;AAC9D;AACA,0CAA0C,iGAAiG;AAC3I;AACA,uCAAuC,+FAAuB;AAC9D;AACA,0CAA0C,iGAAiG;AAC3I;AACA,uCAAuC,+FAAuB;AAC9D;AACA,0CAA0C,mGAAmG;AAC7I;AACA,uCAAuC,+FAAuB;AAC9D,0CAA0C,mGAAmG;AAC7I;AACA,uCAAuC,+FAAuB;AAC9D;AACA;AACA,uCAAuC,+FAAuB;AAC9D;AACA,0CAA0C,mGAAmG;AAC7I;AACA,uCAAuC,+FAAuB;AAC9D;AACA,0CAA0C,mHAAmH;AAC7J;AACA;AACA;AACA,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA,kCAAkC,eAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgD;;;;;;;;;;;;;;;;;;;;AChXa;AACX;AACoD;AACpD;AACkD;AACpG;AACA,yFAAyF,0BAA0B;AACnH;AACA;AACA;AACA;AACA,sDAAsD,+DAAY;AAClE;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA,2BAA2B,oDAAG;AAC9B;AACA;AACA;AACA;AACA;AACA,gEAAgE,wCAAwC,6EAAsB,aAAa;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2DAAa;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,oBAAoB,QAAQ,EAAE,oEAAe;AAC7C;AACA;AACA,sEAAsE,yGAA6B;AACnG;AACA;AACkD;;;;;;;;;;;;;;;;;AC9DM;AACN;AAClD;AACA;AACA;AACA,gDAAgD,0DAAO;AACvD;AACA,kDAAkD,0DAAO;AACzD;AACA;AACA;AACA,uEAAuE,oDAAG;AAC1E;AACA;AACA;AACA;AACA,uEAAuE,oDAAG;AAC1E;AACA;AACA;AACA,uEAAuE,oDAAG;AAC1E;AACA;AACA;AACoC;;;;;;;;;;;;;;;;;;ACxB6B;AACa;AACF;AAC5E;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA,8DAA8D,2DAAa;AAC3E,8BAA8B,uEAAe;AAC7C;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA,yDAAyD,oEAAe,4BAA4B,sEAAwB;AAC5H,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iCAAiC;AACjC;AACA;AACA,iBAAiB;AACjB;AACA,6CAA6C,gCAAgC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,oEAAe;AAC1E;AACA;AACA;AACA;AACA;AACiC;;;;;;;;;;;;;;;;;;;AChFmD;AAC5B;AACkB;AACH;AACvE;AACA;AACA;AACA;AACA,yDAAyD,0DAAO;AAChE,6DAA6D,0DAAO;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,oEAAa;AACrF;AACA;AACA,sEAAsE,oEAAa;AACnF;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,qCAAqC,iEAAU;AAC/C;AACA;AACA;AACA,2BAA2B,wEAAU;AACrC,MAAM,qEAAO,IAAI,4EAAW;AAC5B;AACkC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7CkD;AAC3B;AACgB;AACM;AACvB;AACwB;AACtB;AACR;AACsC;AACd;AACtB;AACoC;AACwG;AAClB;AACvG;AAC6B;AACX;AACW;AACV;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,4DAAW;AAClD,+CAA+C,4DAAW;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,0DAAO;AAC3D;AACA;AACA;AACA,6CAA6C,8DAAW;AACxD,6CAA6C,4DAAU;AACvD;AACA;AACA;AACA;AACA,sBAAsB,oEAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0GAA0G,4CAA4C;AACtJ;AACA;AACA,iCAAiC;AACjC;AACA;AACA,iBAAiB;AACjB;AACA,YAAY,kEAAgB;AAC5B;AACA,uDAAuD,4DAAU;AACjE;AACA;AACA;AACA,aAAa,oEAAkB;AAC/B,kBAAkB,kEAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,0FAAmB;AAChE,kEAAkE,GAAG;AACrE;AACA;AACA;AACA;AACA,qDAAqD,OAAO,gBAAgB,2BAA2B,IAAI,GAAG;AAC9G,yGAAyG,QAAQ,mBAAmB,qBAAqB;AACzJ;AACA,2CAA2C,0DAAO;AAClD,0CAA0C,0DAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,8EAAsB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,0CAA0C,4DAAW;AACrD;AACA,uBAAuB,YAAY;AACnC,iCAAiC,2BAA2B;AAC5D;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA,2DAA2D,8EAAsB;AACjF,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,gBAAgB,mGAAuB;AACvC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iEAAiE,OAAO;AACxE,4FAA4F,gCAAgC;AAC5H;AACA;AACA,aAAa;AACb;AACA,gBAAgB,mGAAuB;AACvC;AACA;AACA;AACA;AACA,iEAAiE,OAAO;AACxE,4FAA4F,2BAA2B;AACvH;AACA;AACA,aAAa;AACb;AACA;AACA,iEAAiE,OAAO;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,iCAAiC,0EAA2B;AAC5D,oBAAoB,mGAAuB;AAC3C;AACA;AACA,aAAa;AACb;AACA;AACA,gBAAgB,mGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,mGAAuB;AACvC,uBAAuB,iFAAY;AACnC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,OAAO,gBAAgB,2BAA2B;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,OAAO,gBAAgB,2BAA2B;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,sEAAe;AACrD;AACA;AACA,wBAAwB,kFAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,oDAAG;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,OAAO;AAChE;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,oDAAG;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,OAAO;AAChE;AACA;AACA;AACA,yDAAyD,OAAO;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,oDAAG;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,oDAAG;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,2EAA4B,SAAS,2EAA4B;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gGAAgB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,mCAAmC;AAC1F;AACA;AACA,mEAAmE,oDAAG;AACtE;AACA;AACA,qCAAqC,kFAA0B,aAAa,yEAA4B;AACxG;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,YAAY;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,8DAA8D,yBAAyB;AACvF;AACA;AACA,kEAAkE,aAAa;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,2BAA2B,wEAAU;AACrC,MAAM,qEAAO,IAAI,4EAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wEAAwE;AACzE,wCAAwC,iEAAU;AAClD,aAAa;AACb,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,uCAAuC,0DAAO;AAC9C;AACA;AACA,iDAAiD,iFAAuB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,0GAA6B;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iEAAkB;AAChD;AACA,uBAAuB,0EAAoB;AAC3C;AACA,mBAAmB,0EAAoB;AACvC;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,0DAA0D,+DAAO;AACjE;AACA,sBAAsB,0GAAuB;AAC7C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB,iEAAkB,uBAAuB,+DAAO;AAChE;AACA,sBAAsB,0GAAuB;AAC7C,+BAA+B,8EAAsB;AACrD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0BAA0B,iCAAiC;AAC3D,yBAAyB,4BAA4B;AACrD,mCAAmC,8BAA8B;AACjE;AACA;AACA;AACA,kCAAkC,0GAAuB;AACzD;AACA,qBAAqB;AACrB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,0GAAuB;AACrD;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,kBAAkB;AAClB,mEAAmE,0GAA6B;AAChG;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gEAAgE;AACjE,oCAAoC,iEAAU;AAC9C,aAAa;AACb,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,uCAAuC,0DAAO;AAC9C;AACA;AACA,iDAAiD,iFAAuB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,kEAAe;AACxD;AACA,YAAY,8DAAO;AACnB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,0BAA0B,GAAG,GAAG;AAC9C;AACkD;;;;;;;;;;;;;;;;;;AC/sBM;AACJ;AACe;AACnE;AACA;AACA;AACA;AACA,4CAA4C,6DAAW;AACvD;AACA;AACA;AACA,8DAA8D,mCAAmC;AACjG;AACA;AACA;AACA;AACA,yGAAyG,WAAW;AACpH;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,sBAAsB,4EAAqB;AAC3C;AACA;AACA,uDAAuD,4EAAqB;AAC5E;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0DAAO;AAC/B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACoC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChDgD;AAChC;AACsC;AAC9B;AAC4B;AACQ;AACN;AACT;AACL;AACN;AACF;AACJ;AACN;AACD;AAC4D;AAC7D;AACY;AACpE,mCAAmC,8EAAqB;AACxD,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sFAAuB;AAC3D;AACA;AACA;AACA;AACA,oCAAoC,sFAAuB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6DAAQ;AAC/B,QAAQ,gEAAG;AACX;AACA;AACA,wCAAwC,sFAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,6DAAW;AACtD,mHAAmH,uEAAgB,4CAA4C;AAC/K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gEAAQ;AACnC,YAAY,gEAAQ;AACpB;AACA;AACA;AACA,kGAAkG,0FAAmB;AACrH;AACA,uBAAuB,0EAAa;AACpC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,gBAAgB,GAAG,qCAAqC;AACtI,+DAA+D,+EAA+E;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,SAAS;AAC7F,sBAAsB,2BAA2B,GAAG,SAAS;AAC7D,+DAA+D,6DAA6D;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+FAA6B,UAAU,yFAA2B;AAC1F;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,cAAc;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uEAAe;AACjD;AACA;AACA;AACA;AACA;AACA,0DAA0D,2DAAO;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wEAAU;AACnC,MAAM,qEAAO,IAAI,qEAAkB;AACnC,MAAM,qEAAO,IAAI,+EAAuB;AACxC,MAAM,qEAAO,IAAI,qFAA0B;AAC3C,MAAM,qEAAO,IAAI,8EAAsB;AACvC,MAAM,qEAAO,IAAI,+EAAc;AAC/B,MAAM,qEAAO,IAAI,4EAAW;AAC5B;AACA,gCAAgC,gGAAe;AACQ;;;;;;;;;;;;;;;;;;;;ACjQU;AACR;AACP;AACuC;AACrC;AACpD;AACA;AACA;AACA,4CAA4C,6DAAW;AACvD;AACA;AACA,QAAQ,kGAAuB;AAC/B;AACA,kDAAkD,GAAG;AACrD;AACA;AACA;AACA,eAAe,uEAAY;AAC3B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0DAA0D,GAAG;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,GAAG;AAC7D;AACA,mCAAmC,+DAAQ,sBAAsB,oDAAG;AACpE;AACA;AACyC;;;;;;;;;;;;;;;;;;;;;ACrCkC;AACb;AACW;AACyB;AACpC;AACa;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+BAA+B;AAC/C,yBAAyB;AACzB,6CAA6C,UAAU,uEAAgB,6CAA6C,gFAAgF,6EAAyB;AAC7N;AACA;AACA;AACA;AACA;AACA,2BAA2B,iFAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0GAA0G,2EAAiB;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2EAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wEAAU;AAC3C,IAAI,oEAAQ;AACZ;AAC2B;;;;;;;;;;;;;;;;;;;AC1EuB;AACE;AACM;AACI;AAC9D;AACA,aAAa;AACb;AACA;AACA;AACA,4CAA4C,6DAAW;AACvD;AACA;AACA,oBAAoB,oDAAG;AACvB;AACA;AACA;AACA;AACA,eAAe,gEAAS;AACxB;AACA;AACA;AACA;AACA;AACA,sDAAsD,uEAAgB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4B;;;;;;;;;;;;;;;;;;;;;;;;;;;AChC6C;AACjB;AACI;AACR;AACF;AAC6E;AAC1D;AACX;AACA;AACI;AACwB;AAC1B;AAC5D;AACA,yCAAyC,6DAAW;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,2EAAiB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,gGAAoB;AAC5D;AACA;AACA,yCAAyC,uBAAuB;AAChE;AACA;AACA,6CAA6C,qBAAqB;AAClE;AACA,+CAA+C,+DAAiB;AAChE,6CAA6C,sCAAsC;AACnF;AACA;AACA;AACA,2DAA2D,2BAA2B,yJAAyJ,2BAA2B;AAC1Q;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,sEAAc;AACzE;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb,oBAAoB,2EAAmB;AACvC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,mCAAmC,2EAAiB;AACpD;AACA;AACA;AACA,oBAAoB,2EAAmB;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wEAA0B;AAC/C,+BAA+B,gEAAU;AACzC;AACA,qBAAqB,wEAA0B;AAC/C,+BAA+B,gEAAU;AACzC;AACA,qBAAqB,wEAA0B;AAC/C,+BAA+B,gEAAU;AACzC;AACA;AACA,gDAAgD,gEAAU,SAAS,gEAAU;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,2EAAiB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,0DAAO;AACpD,kDAAkD,0DAAO;AACzD,oDAAoD,0DAAO;AAC3D,2CAA2C,0DAAO;AAClD,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,OAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,MAAM;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,SAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,MAAM;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gBAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,OAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,aAAa;AACvC;AACA;AACA;AACA;AACA;AACA,0CAA0C,gGAAoB;AAC9D;AACA,2CAA2C,iCAAiC,iKAAiK,iCAAiC;AAC9Q;AACA;AACA;AACA;AACA,0CAA0C,+DAAiB;AAC3D;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,2CAA2C,+DAAiB;AAC5D;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,0BAA0B,eAAe;AACzC;AACA;AACA;AACA,0BAA0B,gBAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kEAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA,gCAAgC,uDAAW;AAC3C,qBAAqB;AACrB;AACA;AACA;AACA;AACA,6CAA6C,oDAAG;AAChD,+CAA+C,oDAAG;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gEAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,0DAAO;AAC1D;AACA,sDAAsD,0DAAO;AAC7D,wDAAwD,0DAAO;AAC/D;AACA;AACA;AACA;AACA,0BAA0B,mBAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,oCAAoC,gGAAoB;AACxD;AACA,iCAAiC,uBAAuB;AACxD;AACA,kCAAkC,+DAAiB;AACnD,qCAAqC,sCAAsC;AAC3E;AACA;AACA;AACA,mDAAmD,iCAAiC,yJAAyJ,iCAAiC;AAC9Q;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,sEAAc;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,eAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,eAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,aAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+EAA+E;AACzG;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mFAAmF;AAC7G;AACA;AACA,0BAA0B,gEAAQ;AAClC;AACA;AACA;AACA;AACA,0BAA0B,gEAAQ;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kBAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,UAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,QAAQ;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gBAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wCAAwC,gEAAU,SAAS;AACzF;AACA;AACA,8BAA8B,6BAA6B,gEAAU,QAAQ;AAC7E;AACA;AACA,8BAA8B,sFAAsF,gEAAU,QAAQ;AACtI;AACA;AACA;AACA;AACA;AACkC;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7kBkD;AACzB;AACT;AACE;AACc;AACwB;AACC;AAC/B;AACU;AAC0B;AACxB;AACE;AACD;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iEAAI;AACZ;AACA,QAAQ,iEAAI;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,uBAAuB,wEAAU;AACjC,MAAM,qEAAO,IAAI,kGAAqB;AACtC,MAAM,qEAAO,IAAI,2EAAqB;AACtC,MAAM,qEAAO,IAAI,kFAAwB;AACzC,MAAM,qEAAO,IAAI,+EAAuB;AACxC,MAAM,qEAAO,IAAI,6EAAW;AAC5B;AACA;AACA,aAAa;AACb,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,yBAAyB,gFAAsB;AAC/C;AACA,sCAAsC,UAAU,MAAM,UAAU,IAAI,UAAU;AAC9E;AACA,wCAAwC,KAAK,GAAG,cAAc,OAAO,cAAc;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY,qBAAqB,UAAU;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,wEAAU;AAClF,MAAM,qEAAO,IAAI,+EAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,6FAAsB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,OAAO,KAAK,uBAAuB;AAC3H,iGAAiG,OAAO,6CAA6C,qBAAqB;AAC1K,oDAAoD,+FAAwB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,6DAAW;AACrE,uDAAuD,6DAAW;AAClE;AACA,0BAA0B,oDAAG;AAC7B;AACA;AACA;AACA;AACA,gEAAgE,sBAAsB;AACtF;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,8BAA8B;AAC/F;AACA;AACA;AACA;AACA;AACA,gFAAgF,8BAA8B;AAC9G;AACA;AACA,0BAA0B,wEAAU;AACpC,MAAM,qEAAO,IAAI,qEAAkB;AACnC;AAC8B;;;;;;;;;;;;;;;;;AC1L4D;AAC1F,6BAA6B,gGAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACXmC;AAClC;AACa;AACD;AACyB;AAC7B;AACN;AACgB;AACH;AACS;AACiB;AAC7B;AACF;AACmD;AACrD;AACC;AAC3D;AACA;AACA,4BAA4B,oDAAG;AAC/B;AACA;AACA,qBAAqB,6DAAO,sBAAsB,6DAAO,SAAS,8DAAO;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oDAAG;AAClB;AACA,aAAa,oDAAG;AAChB;AACA;AACA,aAAa,iEAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oDAAG;AAChB;AACA;AACA,aAAa,iEAAS;AACtB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,aAAa;AACb;AACA;AACA,8BAA8B,sEAAsE;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,oDAAG;AACnE,gEAAgE,oDAAG;AACnE,WAAW,uEAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uEAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uEAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uEAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,8DAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mGAAuB;AAC/B;AACA;AACA;AACA,QAAQ,mGAAuB;AAC/B;AACA;AACA,oBAAoB,iCAAiC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mGAAuB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,0DAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mGAAuB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,qBAAqB;AACrB,eAAe;AACf,kBAAkB;AAClB;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,0DAAO;AACvD;AACA;AACA,mCAAmC,0DAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAS;AACxB;AACA;AACA;AACA,sBAAsB,kEAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,sEAAe;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,gGAAoB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,aAAa;AACb,qBAAqB;AACrB,SAAS;AACT;AACA,oBAAoB,8BAA8B;AAClD;AACA,qBAAqB,+BAA+B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,OAAO;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gGAAoB;AAChC;AACA;AACA,wDAAwD,2DAA2D;AACnH;AACA;AACA,QAAQ,mGAAuB;AAC/B;AACA;AACA;AACA,QAAQ,mGAAuB;AAC/B;AACA,sDAAsD,sEAAe;AACrE,wDAAwD,uCAAuC;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,sDAAsD,+CAA+C;AACrG,4DAA4D,+CAA+C;AAC3G,0DAA0D,+CAA+C;AACzG,sFAAsF,4CAA4C;AAClI,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,gBAAgB;AACxE;AACA;AACA;AACA;AACA;AACA,mDAAmD,sEAAe;AAClE;AACA;AACA,wDAAwD,8BAA8B;AACtF;AACA;AACA,QAAQ,mGAAuB;AAC/B;AACA;AACA;AACA,QAAQ,mGAAuB;AAC/B,oDAAoD,sEAAe;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,cAAc;AACd,wDAAwD,gCAAgC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,sEAAe;AAChE;AACA;AACA;AACA;AACA,wDAAwD,6BAA6B;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,wEAAiB;AACjE;AACA,6CAA6C,wEAAiB;AAC9D;AACA,8CAA8C,wEAAiB;AAC/D,2CAA2C,wEAAiB;AAC5D;AACA;AACA,2CAA2C,0DAAO;AAClD;AACA;AACA;AACA;AACA;AACA,sCAAsC,oDAAG;AACzC,oBAAoB,6DAAO;AAC3B,qBAAqB,IAAI,MAAM,YAAY;AAC3C,yCAAyC,2CAA2C;AACpF,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,gGAAoB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wDAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,YAAY,wDAAK;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,wEAAU;AAC/C,IAAI,oEAAQ;AACZ;AACA,qCAAqC,wEAAU;AAC/C,IAAI,oEAAQ;AACZ;AACA;AACA,aAAa;AACb,aAAa;AACb,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA,gDAAgD,8FAAsB;AACtE,gDAAgD,0DAAO;AACvD,6CAA6C,6DAAW;AACxD,iDAAiD,6DAAW;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oDAAG;AACvB;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAS;AACxB;AACA;AACA;AACA,4BAA4B,sEAAc;AAC1C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+CAA+C;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wEAAU;AACxC,MAAM,qEAAO,IAAI,4EAAW;AAC5B;AAC0C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/yB0C;AACnB;AACb;AACsC;AACJ;AAC1B;AACe;AACD;AACxB;AACoC;AACzB;AAC+G;AAC5K,yBAAyB,gGAAe;AACxC;AACA;AACA;AACA;AACA;AACA,iDAAiD,6DAAW;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,2FAAiB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,OAAO;AAC/E;AACA;AACA;AACA,mDAAmD,gHAA8B;AACjF;AACA,eAAe,uEAAY;AAC3B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,wEAAwE,OAAO;AAC/E;AACA;AACA;AACA;AACA;AACA,eAAe,uEAAY;AAC3B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,8DAA8D,OAAO;AACrE;AACA;AACA;AACA;AACA,qDAAqD,kHAAgC;AACrF;AACA,eAAe,uEAAY;AAC3B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,8DAA8D,OAAO;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uEAAY;AAC3B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,wEAAwE,OAAO;AAC/E;AACA;AACA;AACA,mDAAmD,gHAA8B;AACjF;AACA,eAAe,uEAAY;AAC3B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,wEAAwE,OAAO;AAC/E;AACA;AACA;AACA;AACA;AACA,eAAe,uEAAY;AAC3B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,OAAO;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,OAAO;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2FAAiB,GAAG,iBAAiB;AAC1D;AACA;AACA,SAAS;AACT;AACA;AACA,qBAAqB,2FAAiB,GAAG,iBAAiB;AAC1D;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB,wEAAU;AAC5B,MAAM,qEAAO,IAAI,qEAAkB;AACnC,MAAM,qEAAO,IAAI,oFAAsB;AACvC,MAAM,qEAAO,IAAI,4EAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,+GAA+G,oDAAG;AAClH;AACA;AACA;AACA;AACA,WAAW,oEAAM;AACjB;AACsD;;;;;;;;;;;;;;;;;;;AClMF;AACI;AACkC;AAC1F;AACA;AACA,0CAA0C,0DAAO;AACjD;AACA,6CAA6C,6DAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gGAAe;AACM;;;;;;;;;;;;;;;;;;ACvBqC;AAClC;AACc;AACpE;AACA;AACA;AACA,iCAAiC,sEAAe;AAChD,mBAAmB,0FAAmB;AACtC;AACA,6BAA6B,wDAAK;AAClC,YAAY,wDAAK;AACjB,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4B;;;;;;;;;;;;;;;;;;AC5BwB;AACiB;AACnB;AAClD;AACA,aAAa;AACb;AACA;AACA;AACA,4CAA4C,6DAAW;AACvD;AACA;AACA;AACA,sDAAsD,WAAW,4DAAK,2CAA2C,oDAAG,oCAAoC;AACxJ;AACA;AACA;AACA;AACA;AACA,kDAAkD,uEAAgB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwB;;;;;;;;;;;;;;;;;;AC3BuD;AACG;AAC9B;AACpD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,4CAA4C,6DAAW;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sEAAe;AACjD,0BAA0B,iFAAuB;AACjD;AACA,sGAAsG,WAAW;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sEAAe;AACjD,0BAA0B,iFAAuB;AACjD;AACA,+FAA+F,WAAW;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sEAAe;AACjD,0BAA0B,iFAAuB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,yCAAyC;AACpG,eAAe,uEAAY;AAC3B;AACA;AACA,SAAS;AACT;AACA;AACyB;;;;;;;;;;;;;;;;;;;;;;AClGiF;AACtD;AACT;AACyB;AACR;AACH;AACzD;AACA,aAAa;AACb,aAAa;AACb,iDAAiD,wDAAU;AAC3D,mDAAmD,wDAAU;AAC7D;AACA;AACA;AACA,yEAAyE,gEAAkB;AAC3F;AACA;AACA,iDAAiD,sEAAe;AAChE;AACA;AACA;AACA,4BAA4B,2EAAyB;AACrD;AACA;AACA,6CAA6C,gEAAkB,QAAQ,gEAAkB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,+DAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,sEAAe;AAChE;AACA;AACA;AACA,sDAAsD,oBAAoB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iCAAiC,GAAG,SAAS;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iDAAQ;AACjC;AACA,sBAAsB,GAAG;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qEAAc;AAC1C,8LAA8L,gEAAkB;AAChN;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,gEAAkB;AAC5G,4BAA4B,iDAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,kBAAkB,wDAAU;AAC5B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,6DAAW;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wDAAU;AAC5B;AACA;AACA,aAAa;AACb;AACA;AACA;AACmD;;;;;;;;;;;;;;;;;;;ACzQC;AACI;AACkC;AAC1F;AACA;AACA;AACA,yCAAyC,0DAAO;AAChD;AACA,6CAA6C,6DAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,iCAAiC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+GAA+G,IAAI,YAAY,OAAO,KAAK,MAAM;AACjJ;AACA;AACA;AACA;AACA,0BAA0B,gGAAe;AACE;;;;;;;;;;;;;;;;;;;;;;ACzCyC;AACM;AACpB;AACI;AACE;AAC1B;AAClD,iCAAiC,gGAAe;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oDAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,oDAAG;AAC7D;AACA,+BAA+B,oDAAG;AAClC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oDAAG;AACtB;AACA;AACA;AACA;AACA,eAAe,oDAAG;AAClB;AACA;AACA;AACA;AACA,0BAA0B,wEAAU;AACpC,MAAM,qEAAO,IAAI,+EAAuB;AACxC,MAAM,qEAAO,IAAI,4EAAW;AAC5B,MAAM,qEAAO,IAAI,qFAA0B;AAC3C;AACyD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/D2B;AAClC;AACQ;AACF;AACJ;AAC0E;AACpE;AACoB;AACZ;AACO;AACH;AACV;AACU;AACoB;AAChC;AACU;AACM;AACQ;AACrC;AACwC;AAC5B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gEAAgE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gEAAgE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8DAAgB;AACnC;AACA;AACA,CAAC,kDAAkD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4DAA4D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4DAAc;AACrC;AACA;AACA,uBAAuB,4DAAc;AACrC;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,8DAAgB;AACvD;AACA;AACA,4CAA4C,4DAAc;AAC1D;AACA;AACA,+DAA+D,6DAAe;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uDAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,6BAA6B,gEAAO;AACpC;AACA,gEAAgE,yBAAyB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,oDAAG;AACtE;AACA;AACA;AACA,wBAAwB,uDAAS;AACjC;AACA;AACA;AACA;AACA;AACA,2BAA2B,kDAAI;AAC/B;AACA;AACA;AACA;AACA,2BAA2B,uDAAS;AACpC;AACA,mCAAmC,uDAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,0DAAO;AAC9C,yCAAyC,0DAAO;AAChD,8CAA8C,0DAAO;AACrD,4CAA4C,0DAAO;AACnD,4CAA4C,6DAAW;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wDAAU,UAAU;AAC3C;AACA;AACA,qCAAqC,2BAA2B;AAChE;AACA,mBAAmB,wDAAU;AAC7B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gEAAS,qCAAqC,2EAAiB;AAC5F;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,wBAAwB,4CAA4C,aAAa;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,2EAAiB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qEAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qEAAgB;AAChD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAU;AAC9B,MAAM,qEAAO,IAAI,sEAAkB;AACnC,MAAM,qEAAO,IAAI,gFAAuB;AACxC,MAAM,qEAAO,IAAI,mEAAiB;AAClC,MAAM,qEAAO,IAAI,uFAA2B;AAC5C,MAAM,qEAAO,IAAI,2EAAqB;AACtC,MAAM,qEAAO,IAAI,gFAAuB;AACxC,MAAM,qEAAO,IAAI,6EAAW;AAC5B,MAAM,qEAAO,IAAI,4FAA6B;AAC9C;AACA;AACA;AACA;AACA,gCAAgC,6DAAO;AACvC,oBAAoB,6DAAO;AAC3B;AACA,sBAAsB,2EAAgB;AACtC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sEAAiB;AACzC;AACA;AACA,uDAAuD,4BAA4B;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,OAAO,IAAI,UAAU;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wEAAU;AAChC,MAAM,qEAAO,IAAI,sEAAkB;AACnC,MAAM,qEAAO,IAAI,gFAAuB;AACxC,MAAM,qEAAO,IAAI,mEAAiB;AAClC,MAAM,qEAAO,IAAI,uFAA2B;AAC5C,MAAM,qEAAO,IAAI,2EAAqB;AACtC,MAAM,qEAAO,IAAI,gFAAuB;AACxC,MAAM,qEAAO,IAAI,6EAAW;AAC5B,MAAM,qEAAO,IAAI,4FAA6B;AAC9C;AACA,uBAAuB,iGAAe;AACmD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrqBL;AACM;AAClC;AACmB;AACE;AACP;AACa;AACJ;AACwD;AAC/E;AACN;AACa;AACpB;AAC3C,sDAAsD,kEAAU;AAChE;AACA;AACA;AACA;AACA,kEAAkE,0DAAO;AACzE;AACA,wEAAwE,0DAAO;AAC/E;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,uCAAuC,qDAAG;AAC1C;AACA,wFAAwF,IAAI,wGAA8B,UAAU,kDAAQ;AAC5I;AACA,iCAAiC,EAAE;AACnC;AACA,0BAA0B;AAC1B;AACA;AACA,gBAAgB,uEAAU;AAC1B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0IAA0I,iEAAQ;AAClJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA,gDAAgD,oBAAoB,GAAG,eAAe;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wFAAM;AACvB;AACA;AACA,iBAAiB,wFAAM;AACvB;AACA;AACA;AACA;AACA;AACA,gDAAgD,qFAAa,CAAC,kGAAoB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wEAAU;AAChC,OAAO,qEAAO,IAAI,+EAAuB;AACzC,OAAO,qEAAO,IAAI,+EAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,0DAAO;AACtD;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA,uEAAuE;AACvE,sBAAsB,uFAAS;AAC/B;AACA,0BAA0B,8DAAK;AAC/B;AACA;AACA,0BAA0B,8DAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,uFAAS;AAC9C;AACA;AACA,aAAa;AACb;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gGAAe;AAC4C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7RJ;AAC5B;AACJ;AACsC;AACxC;AACU;AACuC;AACJ;AACpD;AACwB;AACyF;AAC7E;AACnB;AACsC;AACnC;AACN;AACiB;AAClB;AACxD,mCAAmC,gGAAe;AAClD,8BAA8B,iEAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,oDAAoD,0DAAO;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kEAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kEAAU;AAC7B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,yBAAyB,YAAY,kEAAU;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,qCAAqC,0DAAO;AAC5C;AACA,sCAAsC,0DAAO;AAC7C,2CAA2C,0DAAO;AAClD;AACA,qCAAqC,0DAAO;AAC5C;AACA;AACA;AACA;AACA,yFAAyF,SAAS;AAClG;AACA;AACA;AACA;AACA,wFAAwF,SAAS,WAAW,MAAM;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,qBAAqB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iDAAiD,sCAAsC,iCAAiC;AACxH;AACA,SAAS;AACT;AACA,6CAA6C,8BAA8B;AAC3E,SAAS;AACT;AACA;AACA;AACA;AACA,oCAAoC,yCAAyC;AAC7E;AACA;AACA;AACA,0EAA0E,iEAAU;AACpF,2BAA2B;AAC3B,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,wEAAiB;AAC5E;AACA;AACA;AACA;AACA;AACA,0CAA0C,0DAAO;AACjD;AACA,yCAAyC,0DAAO;AAChD;AACA,iDAAiD,0DAAO;AACxD;AACA,qDAAqD,0DAAO;AAC5D;AACA,gDAAgD,0DAAO;AACvD;AACA,wCAAwC,0DAAO;AAC/C;AACA,8CAA8C,0DAAO;AACrD;AACA;AACA,SAAS;AACT;AACA,2CAA2C,0DAAO;AAClD;AACA;AACA,SAAS;AACT;AACA,6CAA6C,6DAAW;AACxD,gCAAgC,qGAAoB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,gBAAgB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,mEAAY;AACzE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,IAAI;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,gCAAgC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,sCAAsC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,oDAAG;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,WAAW,iDAAQ,4CAA4C,GAAG;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA,mCAAmC,sEAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mHAAmH,wCAAwC;AAC3J;AACA;AACA,qGAAqG,0BAA0B;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wDAAY;AAC9B;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,6DAA6D,GAAG;AAChE;AACA;AACA;AACA;AACA,kBAAkB,wDAAY;AAC9B;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,+DAA+D,GAAG;AAClE;AACA;AACA;AACA;AACA,kBAAkB,wDAAY;AAC9B;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,6BAA6B,kFAAuB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sEAAe;AAC5C;AACA;AACA,gCAAgC,wEAAgB;AAChD;AACA;AACA;AACA,8BAA8B,wEAAgB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kFAAuB;AACpD;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,+EAA+E,GAAG;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,kFAAuB;AACjE;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,0BAA0B,4DAAQ;AAClC,2EAA2E,qBAAqB;AAChG;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+HAAsC;AACjE,sCAAsC,2HAAkC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gCAAgC,wEAAU;AAC1C,OAAO,qEAAO,IAAI,kEAAgB;AAClC,OAAO,qEAAO,IAAI,qEAAkB;AACpC;AACA,mDAAmD,iEAAU;AAC7D,uBAAuB;AACvB;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,0DAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,aAAa,4EAA8B,gCAAgC,8BAA8B,SAAS;AACzJ;AACA;AACA,uCAAuC,aAAa,4EAA8B,+BAA+B,8BAA8B,SAAS;AACxJ;AACA;AACA,uCAAuC,aAAa,4EAA8B,gCAAgC,8BAA8B,SAAS;AACzJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS,KAAK,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA,6CAA6C,0DAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qEAAiB;AACtC;AACA;AACA,qBAAqB,qEAAiB;AACtC;AACA;AACA,kCAAkC,wEAAU;AAC5C,OAAO,qEAAO,IAAI,kEAAgB;AAClC,OAAO,qEAAO,IAAI,qEAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kEAAU;AACrB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AAC8G;;;;;;;;;;;;;;;;;;;;;;;;;;ACr8B1B;AACJ;AACc;AACJ;AACtC;AACQ;AACU;AACd;AACN;AAC2B;AAC7E,2CAA2C,gGAAe;AAC1D,oFAAoF,iEAAU;AAC9F;AACA;AACA;AACA;AACA,0DAA0D,0DAAO;AACjE;AACA,uDAAuD,0DAAO;AAC9D;AACA,qDAAqD,0DAAO;AAC5D;AACA,4CAA4C,6DAAW;AACvD,uBAAuB,uEAAY;AACnC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,oDAAG;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,oDAAG;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,wEAAU;AAC9C,MAAM,qEAAO,IAAI,qEAAkB;AACnC,MAAM,qEAAO,IAAI,+EAAuB;AACxC;AACA,+CAA+C,iEAAU;AACzD,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,0CAA0C,sEAAe;AACzD,wEAAwE,0DAAO;AAC/E;AACA,gEAAgE,0DAAO;AACvE;AACA,8DAA8D,0DAAO;AACrE;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,6CAA6C,mBAAmB,yBAAyB,gBAAgB;AACzG;AACA;AACA;AACA;AACA,gCAAgC,yFAA2C;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,sHAAsH;AAC5K;AACA;AACA;AACA,mFAAmF,2FAA2F;AAC9K;AACA;AACA,8DAA8D,iGAAiG;AAC/J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,2GAA2G;AAC7J;AACA;AACA;AACA;AACA;AACA,YAAY,oDAAG;AACf,0BAA0B,oDAAG;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,wDAAwD;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sEAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,iEAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,0DAAO;AACzC;AACA;AACA,+BAA+B,sEAAmB;AAClD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6E;;;;;;;;;;;;;;;;;;;;;;;;;ACrOhB;AACyB;AACtB;AACgD;AACjC;AACkB;AAC/C;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,mCAAmC,uBAAuB;AAC1D;AACA;AACA;AACA,+CAA+C,OAAO,+DAAK,MAAM,4DAAO,WAAW;AACnF;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL,0FAA0F,OAAO;AACjG,gHAAgH,aAAa;AAC7H,uGAAuG,UAAU;AACjH;AACA;AACA;AACA,KAAK;AACL,uFAAuF,MAAM;AAC7F,8FAA8F,OAAO,qEAAc,4BAA4B;AAC/I;AACA;AACA,2BAA2B,8DAAO;AAClC,4BAA4B,8DAAO;AACnC,KAAK;AACL,CAAC;AACD;AACA,mBAAmB,qEAAM;AACzB;AACA;AACA;AACA;AACA,QAAQ,oDAAG;AACX;AACA,qBAAqB,4DAAO;AAC5B;AACA;AACA,yCAAyC,8DAAO,MAAM,IAAI,wFAAkB,WAAW;AACvF;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8EAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,oBAAoB;AAClF;AACA,oBAAoB,iFAAmB;AACvC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,uBAAuB,qGAAsB,MAAM,0EAAgB;AACnE;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,6FAAkB;AAC1D;AACA;AACA;AACA;AACA,uBAAuB,0EAAgB;AACvC;AACA;AACA,yBAAyB,+DAAQ;AACjC,SAAS;AACT;AACA;AACwF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/JJ;AACnB;AACP;AACwC;AACnC;AACe;AAC1B;AAC0C;AACpC;AACR;AACU;AAC8B;AAChB;AACtB;AACI;AACsB;AAClB;AACwD;AACc;AAC7C;AACrB;AAC0B;AACyC;AAC1C;AACzF;AACA;AACA,0BAA0B,iGAAe;AACzC,kDAAkD,iEAAU;AAC5D;AACA;AACA;AACA;AACA;AACA,0DAA0D,0DAAO;AACjE;AACA,kEAAkE,0DAAO;AACzE;AACA;AACA;AACA;AACA,oCAAoC,8DAAW;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,sEAAM;AACtE,sFAAsF,uEAAiB;AACvG;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA,uDAAuD,sEAAM;AAC7D,mCAAmC,uEAAiB,GAAG,0BAA0B;AACjF,qCAAqC,mEAAW;AAChD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,wDAAwD,sEAAM;AAC9D;AACA;AACA;AACA,uBAAuB,sEAAM;AAC7B;AACA;AACA,2DAA2D,4DAAS;AACpE,2DAA2D,4DAAS;AACpE;AACA,SAAS;AACT;AACA;AACA;AACA,mFAAmF,aAAa;AAChG;AACA,iCAAiC,sEAAe;AAChD,gDAAgD,2EAAyB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,wDAAwD,OAAO;AAC/D,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,wDAAwD,+BAA+B;AACvF,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,gBAAgB,mGAAuB;AACvC;AACA,wDAAwD,+BAA+B;AACvF,aAAa;AACb;AACA,gCAAgC,0DAAI;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,6BAA6B,8DAAY;AACzC,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,sEAAM;AAC5E;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,uBAAuB;AACvB;AACA,uBAAuB,uEAAY;AACnC;AACA,uBAAuB,uEAAY;AACnC,wGAAwG,8EAAW;AACnH;AACA;AACA;AACA;AACA;AACA,gCAAgC,2EAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,sEAAM;AAC3D;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA,6CAA6C,oDAAG;AAChD;AACA;AACA;AACA,yBAAyB,gEAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,mBAAmB;AAC9G;AACA;AACA;AACA;AACA,mCAAmC,sEAAM;AACzC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gDAAgD,sEAAM;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gEAAQ;AACtC;AACA;AACA,qBAAqB,aAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oEAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mEAAW;AACjC;AACA;AACA,sDAAsD,2EAAiB,+FAA+F,oEAAY;AAClL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,sEAAM;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,8EAAW,eAAe,wBAAwB;AAClG;AACA;AACA;AACA;AACA;AACA,0BAA0B,iFAAuB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,sEAAM;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kCAAkC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4DAAS;AAC7B;AACA;AACA,oBAAoB,4DAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6DAAc,8CAA8C,kEAAgB;AAC5G,wBAAwB,6FAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,0BAA0B,wDAAK;AAC/B;AACA;AACA;AACA;AACA;AACA,mBAAmB,wEAAU;AAC7B,MAAM,qEAAO,IAAI,sEAAkB;AACnC,MAAM,qEAAO,IAAI,6EAAW;AAC5B,MAAM,qEAAO,IAAI,kEAAgB;AACjC,MAAM,qEAAO,IAAI,wFAA2B;AAC5C;AACA;AACA,6BAA6B,iEAAU;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,0DAAO;AACtD;AACA;AACA,wCAAwC,iFAAuB;AAC/D,iDAAiD,mEAAgB;AACjE;AACA,wCAAwC,0DAAO;AAC/C;AACA,uBAAuB,uEAAY;AACnC;AACA;AACA,SAAS;AACT;AACA;AACA,8BAA8B,QAAQ;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sEAAM;AACjC;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA,wCAAwC,2DAAY;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mEAAY;AACnC;AACA;AACA,mEAAmE,QAAQ;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mEAAW;AAC5C,mBAAmB,mEAAW;AAC9B;AACA,0CAA0C,OAAO,6DAAK;AACtD;AACA;AACA;AACA;AACA,iEAAiE,sEAAM;AACvE;AACA;AACA,yCAAyC,iFAAuB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,2DAAY;AAClE;AACA,oBAAoB,mGAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA,mCAAmC,sEAAM;AACzC,iDAAiD,iDAAiD,sEAAM,+CAA+C;AACvJ,0DAA0D,oEAAY;AACtE,aAAa;AACb;AACA,kEAAkE,sEAAM;AACxE,aAAa;AACb;AACA,kEAAkE,sEAAM;AACxE,aAAa;AACb;AACA,kEAAkE,sEAAM;AACxE,aAAa;AACb;AACA;AACA,kEAAkE,sEAAM;AACxE,aAAa;AACb;AACA;AACA,kEAAkE,sEAAM;AACxE,aAAa;AACb;AACA,kEAAkE,sEAAM;AACxE,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,4DAAQ,mCAAmC,gEAAQ,6BAA6B,sEAAM;AACnJ,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,UAAU;AAC3C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,qBAAqB,MAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8DAAY;AAC1C,wBAAwB,gGAAoB;AAC5C;AACA,uCAAuC,sEAAM;AAC7C;AACA;AACA;AACA;AACA;AACA,8BAA8B,gEAAQ;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sEAAM;AAC5B;AACA;AACA;AACA;AACA;AACA,2BAA2B,IAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kEAAkE;AACpG,iDAAiD,sEAAM;AACvD;AACA,iDAAiD,sEAAM;AACvD;AACA;AACA,SAAS;AACT;AACA,QAAQ,wDAAK;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mEAAY;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gEAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sEAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0BAA0B;AAC1C;AACA,0BAA0B,2CAA2C;AACrE,4BAA4B,6CAA6C;AACzE,4BAA4B,6CAA6C;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,oGAAiC;AACtE;AACA;AACA,mCAAmC,0DAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gEAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,6DAA6D;AACvF,qBAAqB,oFAAwB;AAC7C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,wBAAwB;AAC7E;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,OAAO;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,iCAAiC;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,WAAW;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+DAAO;AAClC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,oCAAoC;AACzG;AACA;AACA;AACA,eAAe,wDAAK;AACpB;AACA,oBAAoB,4DAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,KAAK;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+DAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,iEAAkB;AACvB,KAAK,iEAAkB;AACvB,KAAK,iEAAkB;AACvB;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+F;;;;;;;;;;;;;;;;;ACj9BL;AAC1F;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+FAAoB;AACxC;AACA;AACA;AACiD;;;;;;;;;;;;;;;;;;;;;;ACdG;AAC4B;AACd;AAC+K;AAClI;AAC/G;AACA,aAAa,mBAAmB,oEAAW;AAC3C;AACA;AACA,2EAA2E,8EAAuB;AAClG;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sDAAQ;AACxC,0BAA0B,mDAAK;AAC/B;AACA,qCAAqC,mDAAK;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mDAAK;AAClC;AACA;AACA;AACA;AACA,gCAAgC,mDAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,uDAAW,qBAAqB,uDAAW;AACrE,kBAAkB,uEAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iFAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iFAA0B;AACnD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,iFAA0B;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,OAAO;AACtE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,4BAA4B,iEAAa;AACzC,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,uCAAuC,uDAAS;AAChD,0BAA0B,uEAAe;AACzC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,8EAA8E,uDAAS;AACvF,0BAA0B,uEAAe;AACzC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,4BAA4B,iEAAa;AACzC,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,4BAA4B,iEAAa;AACzC,aAAa;AACb,uCAAuC,2CAA2C;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,sDAAsD,2CAA2C;AACjG;AACA;AACA;AACA;AACA;AACA,6DAA6D,4DAAO;AACpE;AACA,0CAA0C,sDAAQ;AAClD,4BAA4B,qBAAqB,EAAE,+DAAU;AAC7D,gCAAgC,gGAAgG;AAChI;AACA,0CAA0C,mDAAK;AAC/C,8BAA8B,4DAAO;AACrC;AACA;AACA;AACA;AACA,kDAAkD,mDAAK;AACvD,wCAAwC,4DAAO;AAC/C;AACA;AACA,oCAAoC,qBAAqB,EAAE,+DAAU;AACrE,0CAA0C,gGAAgG;AAC1I;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iFAAsB;AAC9C,iFAAiF,sFAA2B;AAC5G;AACA;AACA;AACA,6DAA6D,SAAS;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,kEAAkE,4DAAO,6BAA6B,kEAAoB;AAC1H,aAAa;AACb;AACA,0CAA0C,iEAAU;AACpD,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,qCAAqC,gCAAgC;AACrE;AACA,SAAS;AACT;AACA;AACA,QAAQ,0DAAE;AACV;AACA;AACA;AACA,QAAQ,0DAAE;AACV;AACA;AACA;AACA,QAAQ,0DAAE;AACV;AACA;AACA;AACA,QAAQ,0DAAE;AACV;AACA;AACA;AACA,QAAQ,0DAAE;AACV;AACA;AACA;AACA,iDAAiD,gEAAW;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,uDAAuD,WAAW;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4DAAO;AAC9B;AACA;AACA;AACA,SAAS;AACT;AACA,sEAAsE,gEAAS;AAC/E;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACiF;;;;;;;;;;;;;;;;;;;;;;ACpgBvB;AACF;AACO;AACX;AACc;AACoC;AACpC;AAClE,6BAA6B,iEAAU;AACvC;AACA;AACA;AACA,qDAAqD,0DAAO;AAC5D,mDAAmD,0DAAO;AAC1D,yDAAyD,0DAAO;AAChE,sDAAsD,0DAAO;AAC7D,kDAAkD,0DAAO;AACzD,oDAAoD,0DAAO;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,6DAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iEAAU;AACpC;AACA;AACA;AACA;AACA;AACA,0BAA0B,iEAAU;AACpC;AACA,2EAA2E,4DAAK;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,2BAA2B;AACvF;AACA;AACA,4DAA4D,2BAA2B;AACvF;AACA;AACA;AACA,qBAAqB,2EAAwB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,gEAAS;AACzE;AACA;AACA;AACA,kCAAkC,gEAAQ,0BAA0B,4DAAK;AACzE;AACA;AACA;AACA;AACA;AACA,2BAA2B,8BAA8B,iFAA0B;AACnF,aAAa;AACb;AACA;AACA,yBAAyB,2EAA6B;AACtD,gEAAgE,gEAAS;AACzE;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,kCAAkC,gEAAQ,0BAA0B,4DAAK;AACzE;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iEAAU;AACzC;AACA;AACA,6DAA6D,0CAA0C;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AAC0B;;;;;;;;;;;;;;;;;;;AChI0D;AACrB;AACH;AACJ;AACxD;AACA;AACA,6BAA6B,wDAAU,CAAC,4DAAc;AACtD,kDAAkD,0DAAO;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4DAAc;AACrC;AACA;AACA,uBAAuB,4DAAc;AACrC;AACA;AACA,uBAAuB,4DAAc;AACrC;AACA;AACA,uBAAuB,4DAAc;AACrC;AACA,6BAA6B,wDAAU;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wEAAU;AAC7B,MAAM,qEAAO,IAAI,qEAAkB;AACnC;AAC0B;;;;;;;;;;;;;;;;;;;;;;;ACrCwB;AACe;AACb;AAC8B;AACpB;AACkB;AACQ;AAC/B;AACzD;AACA;AACA;AACA;AACA,6CAA6C,6DAAW;AACxD;AACA;AACA;AACA,2DAA2D,0FAAmB;AAC9E,wEAAwE,oDAAG;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,8CAA8C,oDAAG;AACjD;AACA;AACA,0CAA0C,sEAAe;AACzD;AACA;AACA;AACA,0FAA0F,oDAAoD;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C,kCAAkC,OAAO,GAAG,0BAA0B;AACtE;AACA;AACA;AACA;AACA;AACA,4CAA4C,uDAAS;AACrD,sCAAsC;AACtC;AACA,6BAA6B,oDAAG;AAChC;AACA;AACA;AACA;AACA,2BAA2B,8BAA8B;AACzD;AACA;AACA;AACA,oBAAoB,4DAAc;AAClC,8BAA8B,qEAAgB;AAC9C;AACA,yBAAyB,+DAAQ;AACjC;AACA;AACA,yBAAyB,4DAAc;AACvC;AACA,8BAA8B,qEAAgB;AAC9C;AACA,yBAAyB,+DAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,aAAa;AAChE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,2CAA2C,qBAAqB;AAChE,eAAe,uEAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AAC2B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9JgB;AACkB;AACX;AACa;AACiB;AACxB;AACE;AAC6I;AAC3H;AACV;AACmB;AACd;AACQ;AACO;AACG;AACzF;AACA,QAAQ,+DAAQ;AAChB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,+BAA+B,iEAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,yFAAmB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mDAAmD,kBAAkB;AACrE,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,yCAAyC,uCAAuC;AAChF,uCAAuC,qCAAqC;AAC5E,8BAA8B,mCAAmC;AACjE,yCAAyC,uCAAuC;AAChF;AACA,gBAAgB,mGAAuB;AACvC;AACA,aAAa;AACb;AACA,gBAAgB,mGAAuB;AACvC;AACA,aAAa;AACb,4BAA4B,0BAA0B;AACtD,0CAA0C,wCAAwC;AAClF;AACA;AACA,aAAa;AACb,4BAA4B,0BAA0B;AACtD;AACA,oBAAoB,8EAAgB;AACpC,oBAAoB,mGAAuB;AAC3C;AACA;AACA,aAAa;AACb,0BAA0B,wBAAwB;AAClD;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,6CAA6C,uDAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,6DAAe;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,6DAAe;AACvD;AACA,iCAAiC,oEAAY;AAC7C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,6DAAe;AACvD;AACA,2EAA2E,0DAAc;AACzF;AACA;AACA;AACA,eAAe,oEAAY;AAC3B;AACA;AACA;AACA;AACA,wBAAwB,6DAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6DAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6DAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6DAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6DAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6DAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iEAAU;AACxC,aAAa;AACb,aAAa;AACb,oBAAoB;AACpB,6BAA6B,mGAAmG,wEAAiB;AACjJ,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,0DAAO;AAC/D;AACA,0DAA0D,0DAAO;AACjE;AACA,0DAA0D,0DAAO;AACjE;AACA,2DAA2D,0DAAO;AAClE;AACA,2DAA2D,0DAAO;AAClE;AACA,8DAA8D,0DAAO;AACrE;AACA,qDAAqD,0DAAO;AAC5D;AACA;AACA;AACA;AACA,gDAAgD,kFAAuB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,4CAA4C;AACzF,aAAa;AACb;AACA;AACA;AACA,gCAAgC,wDAAK;AACrC;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,0CAA0C,mBAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,oDAAoD,sEAAc;AAClE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,4DAA4D,aAAa;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,uBAAuB,wEAAiB;AACxC,sBAAsB,wEAAiB;AACvC,uBAAuB,wEAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,mEAAmE,IAAI,uBAAuB;AAClK;AACA;AACA,gEAAgE,uBAAuB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,+BAA+B;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iEAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,SAAS;AACzE;AACA;AACA,kEAAkE,SAAS;AAC3E;AACA;AACA;AACA;AACA,kCAAkC,8DAAM;AACxC;AACA;AACA;AACA;AACA,8DAA8D,kCAAkC;AAChG;AACA;AACA,+DAA+D,iCAAiC;AAChG;AACA;AACA;AACA;AACA;AACA,+DAA+D,wBAAwB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,mEAAqB,WAAW,mEAAqB;AAC7G;AACA;AACA;AACA,SAAS;AACT;AACA,0DAA0D,mEAAqB,WAAW,mEAAqB;AAC/G,SAAS;AACT,8CAA8C,kEAAkE;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,QAAQ,iBAAiB,gCAAgC;AACjH;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kFAAuB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,gEAAQ;AAC9C,kDAAkD,gEAAQ;AAC1D;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gEAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,kFAAuB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gEAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iDAAQ,yBAAyB,GAAG;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4DAAgB;AAC5B,mBAAmB,sEAAc;AACjC;AACA;AACA;AACA;AACA,2BAA2B,gFAAgF;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,6BAA6B,mEAAqB;AACnE;AACA;AACA,aAAa,sDAAQ;AACrB;AACA,6BAA6B,iCAAiC;AAC9D;AACA;AACA;AACA;AACA;AACA,qDAAqD,sEAAe;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wEAAiB,uCAAuC,sEAAwB;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,qDAAqD,uDAAS;AAC9D;AACA,4BAA4B,wBAAwB;AACpD;AACA,sBAAsB,iCAAiC,GAAG,GAAG;AAC7D;AACA;AACA;AACA,4EAA4E,mEAAQ;AACpF;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO,GAAG,QAAQ,GAAG,UAAU;AACvD;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,kFAAkF,uDAAS;AAC3F;AACA,mBAAmB,oDAAG;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,uDAAS;AAC3F;AACA;AACA;AACA;AACA;AACA,YAAY,oDAAG;AACf;AACA;AACA,eAAe,oDAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACt1BwD;AACX;AACjB;AACqB;AAClC;AAC+C;AAChB;AACoB;AAC1C;AACkB;AACV;AACG;AAC/D,8BAA8B,+EAAgB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,8EAAe,UAAU,8EAAe;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,uCAAuC,8EAAe,uCAAuC,8EAAe;AAC5G;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD,iCAAiC,gGAAe;AAChD,8DAA8D,iEAAU;AACxE;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,0CAA0C,0DAAO;AACjD;AACA;AACA;AACA,6CAA6C,6DAAW;AACxD;AACA;AACA,wEAAwE,4BAA4B,4BAA4B,2BAA2B,GAAG,2BAA2B;AACzL;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,kCAAkC;AAC9F;AACA,mBAAmB,yDAAY;AAC/B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF,wBAAwB;AACjH;AACA;AACA;AACA;AACA,yBAAyB;AACzB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F,2EAAiB;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,+BAA+B,uEAAY;AAC3C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,iDAAQ;AAC7C;AACA,yBAAyB;AACzB;AACA;AACA,qCAAqC,iDAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uEAAY;AAC3B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,yHAAyH,yBAAyB;AAClJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,mDAAmD,KAAK,8CAA8C;AAC5L;AACA;AACA;AACA,0BAA0B,wEAAU;AACpC,OAAO,qEAAO,IAAI,sEAAkB;AACpC,OAAO,qEAAO,IAAI,+EAAuB;AACzC,OAAO,qEAAO,IAAI,4EAAW;AAC7B;AAC2E;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClPS;AACZ;AACT;AACe;AACiB;AACxB;AACvC;AACoC;AACf;AACY;AACU;AACd;AACC;AACkD;AAC7C;AACK;AAC8B;AACzB;AACT;AACQ;AAC2D;AACvE;AACiC;AACR;AACxB;AACo3G;AACr7G;AACA;AACA;AACA,gBAAgB,qFAAqF;AACrG,0BAA0B,uDAAU;AACpC,wBAAwB,uDAAU;AAClC,mBAAmB,wDAAW;AAC9B;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yDAAyD;AACzE,mBAAmB,oDAAO;AAC1B;AACA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAU,CAAC,qDAAG;AACjC;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;AACA,4BAA4B,gEAAiB;AAC7C,4BAA4B,gEAAiB;AAC7C,4BAA4B,gEAAiB;AAC7C,4BAA4B,gEAAiB;AAC7C;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACA,mBAAmB,uDAAU;AAC7B;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA,eAAe,gEAAQ,GAAG,+DAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA,iBAAiB,4DAAe;AAChC;AACA,iBAAiB,4DAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4DAAe;AACtC;AACA,uBAAuB,4DAAe;AACtC;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;AACA;AACA;AACA,gBAAgB,gEAAQ,gBAAgB,gEAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,gEAAQ;AACtD;AACA;AACA;AACA;AACA,wBAAwB,yDAAY;AACpC;AACA,mBAAmB,gEAAQ;AAC3B;AACA,iCAAiC,gEAAQ;AACzC;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2EAA8B,KAAK,uDAAU;AAChE;AACA;AACA,CAAC,oEAAoE;AACrE;AACA;AACA;AACA;AACA,iBAAiB,iEAAoB;AACrC,uBAAuB,gFAAc;AACrC,iBAAiB,iEAAoB;AACrC,uBAAuB,gFAAc;AACrC,iBAAiB,iEAAoB;AACrC,uBAAuB,gFAAc;AACrC,iBAAiB,iEAAoB;AACrC,uBAAuB,gFAAc;AACrC;AACA,eAAe,gFAAc;AAC7B;AACA;AACA;AACA;AACA,iBAAiB,gFAAc;AAC/B,uBAAuB,iEAAoB;AAC3C,iBAAiB,gFAAc;AAC/B,uBAAuB,iEAAoB;AAC3C,iBAAiB,gFAAc;AAC/B,uBAAuB,iEAAoB;AAC3C,iBAAiB,gFAAc;AAC/B,uBAAuB,iEAAoB;AAC3C;AACA,uBAAuB,iEAAoB;AAC3C;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA,oDAAoD,yDAAY;AAChE;AACA;AACA,uBAAuB,yDAAY;AACnC,mBAAmB,iFAAU;AAC7B;AACA,eAAe,mFAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC,oBAAoB;AACpB;AACA,iBAAiB,6DAAgB;AACjC,oBAAoB;AACpB;AACA;AACA,oBAAoB;AACpB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,8BAA8B,MAAM;AACpC;AACA,4BAA4B,qDAAG;AAC/B,iCAAiC,wCAAwC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0CAAM,YAAY,0CAAM;AAChC;AACA,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA,+BAA+B,mFAAsB;AACrD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kEAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uEAAc;AAC7B,gBAAgB,qDAAG;AACnB,qCAAqC,0CAA0C;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6DAAgB;AAC3C;AACA;AACA,2CAA2C,qDAAG;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,gGAAgG;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0EAA0E;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sEAAyB;AAC1C;AACA,iBAAiB,sEAAyB;AAC1C;AACA,iBAAiB,sEAAyB;AAC1C;AACA,iBAAiB,sEAAyB;AAC1C;AACA;AACA;AACA;AACA,CAAC,0DAA0D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0DAA0D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uDAAU;AACrC;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,4DAAe;AAC5C,mCAAmC,4DAAW;AAC9C;AACA,0CAA0C,qDAAG;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,uBAAuB,oEAAY,CAAC,4DAAQ;AACrF;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA,mCAAmC,4BAA4B;AAC/D;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4DAAe;AAC1C,4BAA4B,4DAAW;AACvC;AACA;AACA;AACA,4BAA4B,qDAAG;AAC/B;AACA;AACA;AACA;AACA;AACA,wCAAwC,8DAAe,oBAAoB,4DAAa;AACxF;AACA;AACA,wCAAwC,uDAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qDAAG,2BAA2B,qDAAG;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;AACA,iBAAiB,yDAAY;AAC7B,iBAAiB,yDAAY;AAC7B,iBAAiB,yDAAY;AAC7B,iBAAiB,yDAAY;AAC7B,iBAAiB,yDAAY;AAC7B,iBAAiB,yDAAY;AAC7B,iBAAiB,yDAAY;AAC7B,iBAAiB,yDAAY;AAC7B,iBAAiB,yDAAY;AAC7B,iBAAiB,yDAAY;AAC7B,iBAAiB,yDAAY;AAC7B,iBAAiB,yDAAY;AAC7B,iBAAiB,yDAAY;AAC7B,iBAAiB,yDAAY;AAC7B,iBAAiB,yDAAY;AAC7B,iBAAiB,yDAAY;AAC7B,iBAAiB,yDAAY;AAC7B,iBAAiB,yDAAY;AAC7B,iBAAiB,yDAAY;AAC7B,iBAAiB,yDAAY;AAC7B,iBAAiB,yDAAY;AAC7B,iBAAiB,yDAAY;AAC7B,iBAAiB,yDAAY;AAC7B,iBAAiB,yDAAY;AAC7B,iBAAiB,yDAAY;AAC7B,iBAAiB,yDAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yDAAY;AAC3B;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA,iBAAiB,wDAAW;AAC5B;AACA;AACA;AACA;AACA;AACA,4BAA4B,wDAAW;AACvC;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gEAAiB;AAC5C;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6DAAgB;AAC3C,YAAY,uEAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA,2BAA2B,gEAAmB,yDAAyD,qDAAG;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA,mBAAmB,wEAA2B;AAC9C;AACA;AACA,CAAC,8DAA8D;AAC/D;AACA;AACA;AACA,mBAAmB,wEAA2B;AAC9C;AACA;AACA,CAAC,8DAA8D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAU,CAAC,qDAAG;AACjC;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAG;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2DAAY;AAC/B;AACA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oEAAuB;AAC1C;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA;AACA,mCAAmC,8DAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,wEAAyB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,+EAAgC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iEAAoB;AACvC;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gEAAmB;AACtC;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAwB,CAAC,qDAAG;AAC/C;AACA;AACA,CAAC,wDAAwD;AACzD;AACA;AACA;AACA;AACA;AACA,uBAAuB,oEAAuB;AAC9C;AACA,uBAAuB,oEAAuB;AAC9C;AACA;AACA,uBAAuB,oEAAuB;AAC9C;AACA;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA,iBAAiB,gEAAmB;AACpC;AACA;AACA;AACA;AACA;AACA,4BAA4B,gEAAmB;AAC/C;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA,SAAS,iEAAoB;AAC7B,SAAS,iEAAoB;AAC7B,SAAS,iEAAoB;AAC7B,SAAS,iEAAoB;AAC7B,SAAS,iEAAoB;AAC7B,SAAS,iEAAoB;AAC7B,SAAS,iEAAoB;AAC7B,SAAS,iEAAoB;AAC7B,SAAS,iEAAoB;AAC7B,SAAS,iEAAoB;AAC7B,SAAS,iEAAoB;AAC7B,SAAS,iEAAoB;AAC7B,SAAS,iEAAoB;AAC7B,SAAS,iEAAoB;AAC7B,SAAS,iEAAoB;AAC7B,SAAS,iEAAoB;AAC7B,SAAS,iEAAoB;AAC7B,SAAS,iEAAoB;AAC7B,SAAS,iEAAoB;AAC7B,SAAS,iEAAoB;AAC7B,SAAS,iEAAoB;AAC7B,SAAS,iEAAoB;AAC7B,SAAS,iEAAoB;AAC7B,SAAS,iEAAoB;AAC7B,SAAS,iEAAoB;AAC7B,SAAS,iEAAoB;AAC7B,SAAS,iEAAoB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iEAAoB;AACjC,aAAa,iEAAoB;AACjC,aAAa,iEAAoB;AACjC,aAAa,iEAAoB;AACjC,aAAa,iEAAoB;AACjC,aAAa,iEAAoB;AACjC,aAAa,iEAAoB;AACjC,aAAa,iEAAoB;AACjC,aAAa,iEAAoB;AACjC,aAAa,iEAAoB;AACjC,cAAc,iEAAoB;AAClC,cAAc,iEAAoB;AAClC,cAAc,iEAAoB;AAClC,cAAc,iEAAoB;AAClC,cAAc,iEAAoB;AAClC,cAAc,iEAAoB;AAClC,cAAc,iEAAoB;AAClC,cAAc,iEAAoB;AAClC,cAAc,iEAAoB;AAClC,cAAc,iEAAoB;AAClC,cAAc,iEAAoB;AAClC,cAAc,iEAAoB;AAClC,cAAc,iEAAoB;AAClC,cAAc,iEAAoB;AAClC,cAAc,iEAAoB;AAClC,cAAc,iEAAoB;AAClC,cAAc,iEAAoB;AAClC;AACA;AACA,gCAAgC,iEAAoB;AACpD;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA,2BAA2B,6DAAgB;AAC3C;AACA;AACA;AACA;AACA,+BAA+B,6EAAgB;AAC/C;AACA;AACA;AACA;AACA,YAAY,gEAAO;AACnB;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,oCAAoC,4DAAa;AACjD;AACA;AACA;AACA,sDAAsD,oDAAO,OAAO,uDAAU;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6EAAgB;AAC3C;AACA;AACA;AACA,CAAC,oDAAoD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6EAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;AACA,wBAAwB,wDAAW;AACnC;AACA,sBAAsB,6EAAgB;AACtC;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACA,2BAA2B,iEAAoB;AAC/C,yBAAyB,6EAAgB;AACzC;AACA;AACA,YAAY,iEAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,qDAAG,0BAA0B,qDAAG;AAC1F;AACA;AACA;AACA;AACA,2BAA2B,2DAAc;AACzC;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA,uBAAuB,gEAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA,mBAAmB,oDAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,6DAAgB;AACnC;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA;AACA,uBAAuB,qEAAwB;AAC/C;AACA,uBAAuB,qEAAwB;AAC/C;AACA;AACA,uBAAuB,qEAAwB;AAC/C;AACA;AACA;AACA,CAAC,wDAAwD;AACzD;AACA;AACA;AACA;AACA,iBAAiB,yEAA4B;AAC7C;AACA,iBAAiB,yEAA4B;AAC7C;AACA,iBAAiB,yEAA4B;AAC7C;AACA,iBAAiB,yEAA4B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yEAA4B;AACnD;AACA,uBAAuB,yEAA4B;AACnD;AACA,uBAAuB,yEAA4B;AACnD;AACA;AACA,uBAAuB,yEAA4B;AACnD;AACA;AACA;AACA,CAAC,gEAAgE;AACjE;AACA;AACA;AACA,oBAAoB,wDAAW;AAC/B;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wDAAW;AAC9B;AACA;AACA,mBAAmB,wDAAW;AAC9B;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,+DAAkB;AACnC,iBAAiB,+DAAkB;AACnC,iBAAiB,+DAAkB;AACnC;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACA;AACA,qBAAqB,+DAAkB;AACvC,2BAA2B,0EAAkB;AAC7C,qBAAqB,+DAAkB;AACvC,2BAA2B,0EAAkB;AAC7C,qBAAqB,+DAAkB;AACvC,2BAA2B,0EAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,0EAAkB;AACvC,2BAA2B,+DAAkB;AAC7C,qBAAqB,0EAAkB;AACvC,2BAA2B,+DAAkB;AAC7C,qBAAqB,0EAAkB;AACvC,2BAA2B,+DAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,0EAA0B;AAC5F;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA;AACA,+BAA+B,8DAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8DAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8DAAe,CAAC,qDAAG;AACtC;AACA;AACA,CAAC,kCAAkC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACA;AACA,6BAA6B,qDAAG;AAChC;AACA,oGAAoG,oDAAO;AAC3G;AACA;AACA;AACA;AACA,mBAAmB,qDAAG;AACtB;AACA;AACA;AACA;AACA;AACA,CAAC,kDAAkD;AACnD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,4DAAe;AAClC;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;AACA;AACA,qGAAqG,yDAAyD;AAC9J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oEAAoE;AACrE;AACA;AACA;AACA,sBAAsB,mGAA4B;AAClD,mBAAmB,yEAA4B;AAC/C;AACA,2BAA2B,mGAA4B;AACvD;AACA;AACA,2BAA2B,mGAA4B;AACvD,mBAAmB,yEAA4B;AAC/C;AACA;AACA,gDAAgD,MAAM;AACtD;AACA;AACA;AACA,CAAC,gEAAgE;AACjE;AACA;AACA;AACA;AACA,iBAAiB,+DAAkB;AACnC,uBAAuB,iFAAQ;AAC/B,iBAAiB,+DAAkB;AACnC;AACA,uBAAuB,iFAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA,iBAAiB,iFAAQ;AACzB,uBAAuB,+DAAkB;AACzC,iBAAiB,iFAAQ;AACzB;AACA,uBAAuB,+DAAkB;AACzC;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+DAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2DAAc;AACtC,aAAa,qEAAa;AAC1B;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F;AAC3F;AACA;AACA;AACA;AACA;AACA,mBAAmB,+DAAkB;AACrC;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA;AACA,wBAAwB,4DAAQ;AAChC;AACA;AACA;AACA;AACA,mBAAmB,qEAAwB;AAC3C;AACA;AACA,CAAC,wDAAwD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iEAAoB;AACvC;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yEAAiB,iBAAiB,yEAAiB;AACnE;AACA,CAAC;AACD,8EAA8E;AAC9E;AACA;AACA;AACA;AACA,6DAA6D,mCAAmC;AAChG;AACA,0CAA0C,6EAA8B;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA;AACA,6DAA6D,mCAAmC;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gEAAgE;AACjE;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE,+EAA+E;AAC/E;AACA;AACA;AACA;AACA,CAAC,wEAAwE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAwB,CAAC,qDAAG;AAC/C;AACA;AACA,CAAC,wDAAwD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,sEAAsE;AACnH;AACA;AACA;AACA,8BAA8B,qDAAG;AACjC,aAAa;AACb;AACA;AACA;AACA;AACA,4BAA4B,0DAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AACnC;AACA;AACA,wBAAwB,mFAAgB;AACxC,0BAA0B,qFAAkB;AAC5C,CAAC,0BAA0B;AAC3B;AACA;AACA;AACA,uBAAuB,+EAAgB;AACvC;AACA,qBAAqB,sEAAM;AAC3B;AACA,iBAAiB,qDAAG;AACpB;AACA;AACA,mBAAmB,gEAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sEAAM;AACtB;AACA,iBAAiB,qDAAG;AACpB;AACA,wBAAwB,QAAQ;AAChC,2BAA2B,sDAAS;AACpC,aAAa;AACb;AACA,8BAA8B;AAC9B,iCAAiC;AACjC,kCAAkC;AAClC,wCAAwC;AACxC;AACA,kCAAkC;AAClC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,sDAAS;AAC5B;AACA;AACA,CAAC,0BAA0B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,8EAAqB;AAChD;AACA,wBAAwB,sEAAM;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,6DAAS;AACjF;AACA;AACA;AACA,CAAC,kCAAkC;AACnC;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,uBAAuB,gEAAiB,sFAAsF,6DAAc;AAC5I;AACA;AACA,uBAAuB,kEAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA,wDAAwD,kBAAkB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qFAAqF;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4EAAyB;AACjC,QAAQ,4EAAyB;AACjC,QAAQ,4EAAyB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,2DAAY;AACrD,gDAAgD,sEAAM;AACtD;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACA;AACA,uBAAuB,oEAAuB;AAC9C;AACA,uBAAuB,oEAAuB;AAC9C;AACA;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA;AACA,2BAA2B,gEAAmB,yDAAyD,qDAAG;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACA;AACA;AACA,uBAAuB,2EAA4B,KAAK,+DAAgB,YAAY,qDAAG,4BAA4B,oFAAwB;AAC3I;AACA,qBAAqB,uDAAK;AAC1B,uBAAuB,uEAAwB;AAC/C;AACA,mBAAmB,uEAAwB;AAC3C;AACA;AACA;AACA;AACA,qBAAqB,uDAAK;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,iBAAiB,iEAAO;AACxB;AACA;AACA;AACA;AACA,yBAAyB,qDAAG;AAC5B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,eAAe,iEAAO;AACtB,qDAAqD,qDAAG;AACxD,SAAS;AACT;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,mBAAmB,2DAAc;AACjC;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACA,4BAA4B,2EAA8B;AAC1D,4BAA4B,2EAA8B;AAC1D,4BAA4B,2EAA8B;AAC1D;AACA;AACA;AACA;AACA;AACA,iBAAiB,2EAA8B;AAC/C,iBAAiB,2EAA8B;AAC/C,iBAAiB,2EAA8B;AAC/C;AACA;AACA;AACA;AACA,CAAC,oEAAoE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0EAA2B;AACtD;AACA;AACA,2BAA2B,wEAAyB;AACpD;AACA,SAAS;AACT;AACA;AACA,2BAA2B,uEAA0B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,0EAA2B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wEAAyB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4DAA4D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uEAA0B;AAC7C;AACA;AACA,CAAC,4DAA4D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2EAA8B,CAAC,qDAAG;AACrD;AACA;AACA,CAAC,oEAAoE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0FAA6C;AAChE;AACA;AACA,CAAC;AACD,oGAAoG;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kFAAqC;AACxD;AACA;AACA,CAAC;AACD,oFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oEAAoE;AACrE;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA,8BAA8B,qDAAG;AACjC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,uBAAuB,oEAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mEAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,mBAAmB,uEAAwB;AAC3C;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA;AACA,iCAAiC,qDAAG;AACpC,wDAAwD,gEAAiB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mEAAM;AAC5B,mBAAmB,qEAAwB,CAAC,qDAAG;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wDAAwD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uEAA0B;AAC7C;AACA;AACA,CAAC,4DAA4D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sEAAyB;AAC5C;AACA;AACA,CAAC,0DAA0D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mEAAsB,CAAC,qDAAG;AAC7C;AACA;AACA,CAAC,oDAAoD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA,0FAA0F;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4EAA+B,mDAAmD,qDAAqD;AAC1J;AACA;AACA,CAAC,sEAAsE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uEAA0B,CAAC,qDAAG;AACjD;AACA;AACA,CAAC,4DAA4D;AAC7D;AACA;AACA;AACA,yBAAyB,iEAAS;AAClC,cAAc,qDAAG,0BAA0B,OAAO,qDAAG;AACrD,2FAA2F,qDAAG,+BAA+B,qDAAG,+BAA+B,OAAO,qDAAG,oCAAoC,qDAAG;AAChN;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qDAAG;AAC9B;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAG;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mEAAM;AAC5B,oCAAoC,qDAAG;AACvC;AACA;AACA,mBAAmB,wEAA2B;AAC9C;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,CAAC,8DAA8D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oEAAoE;AACrE;AACA;AACA;AACA,4BAA4B,uEAA0B;AACtD;AACA;AACA,iCAAiC,qEAAwB;AACzD;AACA;AACA,iCAAiC,wEAA2B;AAC5D;AACA;AACA,iCAAiC,uEAA0B;AAC3D;AACA;AACA,iCAAiC,uEAAwB;AACzD;AACA;AACA,iCAAiC,4EAA+B;AAChE;AACA;AACA,iCAAiC,uEAA0B;AAC3D;AACA;AACA,iCAAiC,0FAA6C;AAC9E;AACA;AACA,iCAAiC,2EAA8B;AAC/D;AACA;AACA,iCAAiC,kFAAqC;AACtE;AACA;AACA,iCAAiC,sEAAyB;AAC1D;AACA;AACA,iCAAiC,2EAA8B;AAC/D;AACA;AACA,iCAAiC,2EAA8B;AAC/D;AACA;AACA,iCAAiC,mEAAsB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,8BAA8B;AACjF;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA,iBAAiB,kFAAiB,kBAAkB,2DAAc;AAClE,iBAAiB,kFAAiB,kBAAkB,2DAAc;AAClE,iBAAiB,kFAAiB,eAAe,2DAAc;AAC/D,iBAAiB,kFAAiB,gBAAgB,2DAAc;AAChE;AACA;AACA;AACA;AACA;AACA,iBAAiB,2DAAc,kBAAkB,kFAAiB;AAClE,iBAAiB,2DAAc,kBAAkB,kFAAiB;AAClE,iBAAiB,2DAAc,eAAe,kFAAiB;AAC/D,iBAAiB,2DAAc,gBAAgB,kFAAiB;AAChE;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAe,UAAU,qDAAG;AAC/C,4FAA4F,qEAAe;AAC3G,gCAAgC,mEAAM;AACtC;AACA;AACA;AACA;AACA,CAAC,kDAAkD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wEAAwE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0DAA0D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,2CAA2C;AACjH;AACA,oCAAoC;AACpC,qBAAqB;AACrB;AACA;AACA,qCAAqC;AACrC,qBAAqB;AACrB;AACA;AACA,qBAAqB,UAAU,8DAA8D;AAC7F;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,CAAC,4DAA4D;AAC7D;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA,uBAAuB,uEAA0B;AACjD;AACA,uBAAuB,uEAA0B;AACjD;AACA,uBAAuB,uEAA0B;AACjD;AACA,uBAAuB,uEAA0B;AACjD;AACA;AACA;AACA,CAAC,4DAA4D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oEAAoE;AACivE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/tF3uE;AACO;AACjB;AACwB;AAC/B;AACc;AACP;AAC2B;AAC1C;AACU;AAC4B;AAC6B;AACP;AAC3B;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wEAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAe;AACjC;AACA;AACA,kBAAkB,uEAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,mBAAmB,UAAU,GAAG,eAAe;AAC/C;AACA;AACA,0BAA0B,wEAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wEAAU;AACtC;AACA;AACA;AACA;AACA,cAAc,iBAAiB,GAAG,sBAAsB;AACxD,cAAc,iBAAiB,GAAG,uBAAuB,KAAK,eAAe,GAAG,oBAAoB;AACpG;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA,0BAA0B,SAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uEAAe;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAe;AACjC;AACA;AACA,kBAAkB,uEAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,iHAAgC;AAC3F;AACA;AACA,2DAA2D,iHAAgC;AAC3F;AACA,gCAAgC,iHAAgC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACA;AACA;AACA,CAAC,wEAAwE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,wEAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wEAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wCAAwC;AACnE;AACA;AACA,2BAA2B,wDAAwD;AACnF;AACA;AACA,2BAA2B,wDAAwD;AACnF;AACA;AACA,2BAA2B,kCAAkC,+BAA+B,2BAA2B;AACvH;AACA;AACA;AACA;AACA;AACA,+BAA+B,6EAA6E;AAC5G;AACA;AACA;AACA,2BAA2B,kCAAkC,+CAA+C;AAC5G;AACA;AACA,2BAA2B,iEAAiE;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uEAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,iEAAiE;AACxG;AACA;AACA,uCAAuC,gCAAgC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,4DAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wEAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,oCAAoC,wEAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oDAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,wEAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oDAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wEAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAAM;AACrB,eAAe,8DAAM;AACrB;AACA;AACA,eAAe,wEAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,wEAAU;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wEAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD;AACrD;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wEAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wEAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,wEAAU;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wEAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wEAAU;AACzB;AACA;AACA;AACA,aAAa;AACb,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wEAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wEAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wDAAwD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,wEAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uEAAgB,UAAU,mBAAmB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wEAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wEAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wEAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wEAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4DAA4D;AAC7D;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;AACA;AACA;AACA,uBAAuB,wEAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wEAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wEAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wEAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wEAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wEAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4DAA4D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA,cAAc,2FAAmB,kBAAkB,GAAG,GAAG;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gEAAgE;AACjE;AACA;AACA;AACA;AACA;AACA,CAAC,wDAAwD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD;AACrD;AACA;AACA;AACA;AACA;AACA,CAAC,sEAAsE;AACvE;AACA;AACA;AACA;AACA,CAAC,4DAA4D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0DAA0D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sEAAsE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACA;AACA,wBAAwB,oDAAG;AAC3B,kBAAkB,uEAAe;AACjC;AACA;AACA,kBAAkB,uEAAe;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB,wEAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,wEAAU;AACpB;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAe;AACjC;AACA;AACA,kBAAkB,uEAAe;AACjC;AACA;AACA;AACA;AACA;AACA,qBAAqB,wEAAU;AAC/B;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAe;AACjC;AACA;AACA;AACA;AACA,sBAAsB,wEAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,oFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,oGAAoG;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAe;AACjC;AACA;AACA,kBAAkB,uEAAe;AACjC;AACA;AACA,kBAAkB,uEAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA,kBAAkB,uEAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA,aAAa;AACb,aAAa;AACb,aAAa;AACb,aAAa;AACb,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAe;AACjC;AACA;AACA,kBAAkB,uEAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wEAAU;AACtC;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wEAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAe;AACrC;AACA;AACA,sBAAsB,uEAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wEAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACA;AACA;AACA,mCAAmC,kEAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,aAAa;AACb,aAAa;AACb,aAAa;AACb,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kEAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wEAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA,aAAa,+DAAQ;AACrB;AACA;AACA;AACA,uCAAuC,+DAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACA;AACA,6BAA6B,+DAAQ;AACrC,gBAAgB,+DAAQ,iCAAiC,+DAAQ;AACjE,6BAA6B,+DAAQ,iCAAiC,+DAAQ;AAC9E,qKAAqK,+DAAQ;AAC7K;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,+DAAQ;AAC1D;AACA;AACA;AACA,iDAAiD,+DAAQ;AACzD;AACA;AACA;AACA,uDAAuD,+DAAQ,6BAA6B,oDAAG,+DAA+D,+DAAQ;AACtK;AACA,0CAA0C,+DAAQ,gCAAgC,oDAAG,sCAAsC,+DAAQ,+BAA+B,oDAAG;AACrK;AACA;AACA;AACA;AACA,0DAA0D,+DAAQ;AAClE;AACA;AACA;AACA,0DAA0D,oDAAG;AAC7D;AACA;AACA;AACA,sDAAsD,+DAAQ;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,+DAAQ;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oDAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,wEAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4DAA4D;AAC7D;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wEAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wEAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wEAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4DAA4D;AAC7D;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wEAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wEAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kDAAkD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oDAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oDAAG,iBAAiB,oDAAG;AACjD,sBAAsB,uEAAe;AACrC;AACA;AACA;AACA,kBAAkB,uEAAe;AACjC;AACA;AACA,2BAA2B,oDAAG;AAC9B;AACA,iBAAiB,oDAAG;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,kEAAY;AAC9D;AACA;AACA;AACA;AACA,eAAe,wEAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAe;AACjC;AACA;AACA;AACA;AACA,qBAAqB,wEAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wEAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wEAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wEAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wEAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wEAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,wEAAU;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,wEAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kEAAkE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wEAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,wEAAU;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wEAAU;AACjC;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA,CAAC,4DAA4D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA,YAAY,yFAA2B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yFAA2B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yFAA2B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yFAA2B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yFAA2B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yFAA2B;AACvC;AACA;AACA;AACA,qCAAqC,yFAA2B;AAChE,cAAc,oDAAG;AACjB;AACA,QAAQ,+FAA6B;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,wEAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wEAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA,CAAC,sEAAsE;AACvE;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AACnC;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACA,CAAC,gEAAgE;AACjE;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,oEAAa;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,SAAS;AACrE;AACA;AACA,gEAAgE,SAAS;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uEAAe;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4DAA4D;AAC7D;AACA,aAAa,cAAc;AAC3B;AACA;AACA,sBAAsB,wEAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA,CAAC,gEAAgE;AACjE;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;AACA,sBAAsB,uEAAc;AACpC;AACA,uBAAuB,uEAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wEAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAe;AACjC;AACA;AACA,kBAAkB,uEAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uDAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uEAAiB;AAChD;AACA;AACA,sCAAsC,KAAK,uCAAuC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA,+BAA+B,uEAAiB;AAChD,4CAA4C,6FAAgB;AAC5D;AACA;AACA;AACA;AACA;AACA,sDAAsD,UAAU;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA;AACA,CAAC,gEAAgE;AACjE;AACA;AACA;AACA;AACA,CAAC,wEAAwE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4DAA4D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gEAAgE;AACjE;AACA;AACA;AACA;AACA;AACA,CAAC,kEAAkE;AACnE;AACA;AACA;AACA,wBAAwB,+DAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oEAAoE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wEAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wEAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wEAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wEAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,WAAW,sCAAsC,SAAS;AAC5G;AACA;AACA;AACA,0DAA0D,SAAS;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8DAA8D;AAC/D;AACA;AACA;AACA;AACA;AACA,CAAC,kDAAkD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0EAA0E;AAC3E;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,wFAAwF;AACxF;AACA;AACA;AACA;AACA;AACA,CAAC,wDAAwD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,oFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oEAAoE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wDAAwD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACA,CAAC,4DAA4D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AAC2wJ;;;;;;;;;;;;;;;;;;;AC9kHjwJ;AACP;AACR;AACE;AACpD;AACA,aAAa,mCAAmC,4DAAO,OAAO,4DAAO;AACrE;AACA;AACA,6CAA6C,6DAAW;AACxD;AACA;AACA;AACA,iDAAiD,GAAG;AACpD;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA;AACA,eAAe,uEAAY;AAC3B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,yDAAyD,GAAG;AAC5D;AACA,oBAAoB,oDAAG;AACvB;AACA;AACA;AACA;AACA;AACA,qDAAqD,GAAG;AACxD;AACA,sCAAsC,oDAAG;AACzC,uBAAuB,oDAAG;AAC1B,SAAS;AACT;AACA;AAC6B;;;;;;;;;;;;;;;;;AC7C6D;AAC1F,iCAAiC,gGAAe;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyD;;;;;;;;;;;;;;;;;;;;AClBL;AACF;AACe;AACE;AACwB;AAC3F;AACA,aAAa;AACb;AACA,6BAA6B,6FAAsB;AACnD;AACA,6CAA6C,6DAAW;AACxD;AACA;AACA;AACA;AACA,mFAAmF,YAAY;AAC/F;AACA;AACA;AACA;AACA;AACA,eAAe,uEAAY;AAC3B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oDAAG;AACjC;AACA;AACA,YAAY,yEAAiB;AAC7B;AACA;AACA;AACA;AACA,eAAe,oDAAG;AAClB;AACA;AACuB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5C6D;AAChC;AACW;AACN;AACE;AAC+B;AACZ;AAClB;AACY;AACqE;AACnF;AACwD;AAChD;AAClE,2CAA2C,gGAAe;AAC1D,6CAA6C,wHAA+B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,8DAAgB,+BAA+B,wEAA0B;AAC5H;AACA;AACA,wDAAwD,0DAAY,+BAA+B,oEAAsB,+BAA+B,kEAAoB;AAC5K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,uBAAuB,4DAAG;AAC1B,aAAa;AACb;AACA,uBAAuB,wDAAG;AAC1B,aAAa;AACb;AACA;AACA;AACA,2BAA2B,+DAAS;AACpC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+DAAS;AAC5C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS,6EAA6E,wDAAG;AACzF;AACA;AACA,kGAAkG,iEAAU;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sDAAI;AACnC;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,wEAAU;AACrD,MAAM,qEAAO,IAAI,iFAAwB;AACzC,MAAM,qEAAO,IAAI,oEAAiB;AAClC,MAAM,qEAAO,IAAI,uFAA2B;AAC5C,MAAM,qEAAO,IAAI,4EAAqB;AACtC,MAAM,qEAAO,IAAI,qEAAkB;AACnC;AACoF;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzI5B;AACO;AACL;AACD;AACP;AACyD;AACT;AACF;AAC5C;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,0DAAO;AAC/C;AACA,0CAA0C,0DAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gFAAY;AAC3B;AACA;AACA;AACA,yCAAyC,4DAAO,uCAAuC,4DAAO;AAC9F;AACA;AACA;AACA;AACA,4CAA4C,uFAAuB;AACnE;AACA,eAAe,uFAAuB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,+DAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oFAAuB,YAAY,sEAAsE;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,4DAAO;AAC9E,6EAA6E,4DAAO;AACpF;AACA;AACA,0BAA0B,oDAAG;AAC7B;AACA;AACA,aAAa;AACb,iCAAiC,gFAAY,QAAQ,sCAAsC;AAC3F,sBAAsB,WAAW,EAAE,WAAW,EAAE,SAAS;AACzD,SAAS;AACT;AACA,0BAA0B,oDAAG;AAC7B;AACA;AACA,aAAa;AACb,iCAAiC,gFAAY,QAAQ,sCAAsC;AAC3F,sBAAsB,WAAW,EAAE,WAAW,EAAE,SAAS;AACzD,SAAS;AACT;AACA;AACA;AACA;AACA,wBAAwB,mGAAgB,CAAC,+FAAY;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mGAAgB,CAAC,+FAAY;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iEAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,6DAAW;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,UAAU,EAAE,sFAAyB;AACzD;AACA;AACA;AACA;AACA,iCAAiC,aAAa;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,oDAAG;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2H;;;;;;;;;;;;;;;;;AChOjE;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4DAAQ;AAC3B,SAAS;AACT,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AAC8D;;;;;;;;;;;;;;;;;;;;;;;ACpJN;AACO;AACb;AACU;AACJ;AAC6D;AACjE;AACW;AAC/D,kCAAkC,iEAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,0DAAO;AACzD;AACA,0DAA0D,0DAAO;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,oDAAG,kBAAkB,4BAA4B;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,oBAAoB;AAClE;AACA;AACA;AACA;AACA;AACA,wEAAwE,iEAAU;AAClF;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iEAAU;AAC7C;AACA,eAAe,kEAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,6DAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA,wBAAwB,iEAAU;AAClC;AACA;AACA,+CAA+C,wFAAoC;AACnF;AACA,wCAAwC,mEAAe;AACvD;AACA;AACA,4BAA4B,2EAAuB;AACnD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iEAAU;AACtC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA,0CAA0C,uBAAuB;AACjE;AACA,4CAA4C,wFAAoC;AAChF,SAAS;AACT,mBAAmB,wDAAY;AAC/B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0DAA0D,SAAS;AACnE;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgC;;;;;;;;;;;;;;;;;;;;;ACxOwB;AACuB;AACa;AACrC;AACH;AACL;AAC/C,iCAAiC,iEAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,0DAAO;AAClE;AACA,kDAAkD,0DAAO;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,oBAAoB;AACpB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gEAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,6DAAW;AACxD;AACA;AACA;AACA,oDAAoD,SAAS;AAC7D;AACA,4CAA4C,qBAAqB;AACjE,iDAAiD,mEAAe;AAChE;AACA,4CAA4C,wFAAoC;AAChF,SAAS;AACT,mBAAmB,wDAAU;AAC7B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,6DAA6D,SAAS;AACtE;AACA,gBAAgB,sBAAsB;AACtC,gFAAgF;AAChF;AACA;AACA,yDAAyD,OAAO;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+B;;;;;;;;;;;;;;;;;;;;;;;;AClJqD;AAC5B;AACE;AACY;AACpB;AACwC;AAC9B;AACR;AACpD;AACA;AACA,aAAa;AACb,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,6CAA6C,0DAAO;AACpD;AACA;AACA,4CAA4C,6DAAW;AACvD,+CAA+C,qBAAqB;AACpE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oDAAG;AACnC;AACA;AACA,wDAAwD,YAAY;AACpE;AACA;AACA,YAAY,4EAAmB;AAC/B;AACA;AACA,wCAAwC,4DAAO;AAC/C,qDAAqD,mBAAmB;AACxE;AACA;AACA;AACA;AACA,YAAY,4EAAmB;AAC/B;AACA;AACA;AACA,iBAAiB,oDAAG;AACpB;AACA;AACA,oCAAoC,wEAAU;AAC9C,MAAM,qEAAO,IAAI,qEAAkB;AACnC;AACA,yBAAyB,gGAAe;AACC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChF2C;AACH;AACJ;AACJ;AACH;AACY;AACJ;AACpB;AACA;AACuD;AACvD;AACR;AACP;AAC+C;AAChB;AACX;AAC6C;AACxC;AACE;AACV;AACH;AACf;AACiC;AACJ;AACnB;AACS;AACoE;AACvE;AAC1D;AACA,kBAAkB,6DAAM;AACxB;AACA;AACA,oEAAoE,iEAAO;AAC3E;AACA;AACA;AACA;AACA;AACA,gEAAgE,iEAAO,mBAAmB,iEAAO;AACjG;AACA;AACA;AACA;AACA,WAAW,6DAAO;AAClB;AACA;AACA;AACA;AACA;AACA,mCAAmC,+EAAW;AAC9C;AACA;AACA,qBAAqB;AACrB;AACA,gBAAgB,0DAA0D;AAC1E;AACA;AACA;AACA;AACA,kCAAkC,qDAAG;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,8CAA8C;AAC7F;AACA,aAAa;AACb;AACA;AACA,0DAA0D,kBAAkB,QAAQ,KAAK,qDAAG,2BAA2B;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qDAAG;AAC/B;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC,iBAAiB;AACjB;AACA;AACA,wBAAwB,8BAA8B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,qFAAe;AAC5D;AACA;AACA;AACA,0BAA0B,gFAAiB;AAC3C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kEAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,0DAAO;AACnD;AACA,gDAAgD,0DAAO;AACvD;AACA;AACA;AACA;AACA;AACA,4DAA4D,+DAAY;AACxE;AACA;AACA;AACA;AACA,yCAAyC,4DAAO;AAChD,+BAA+B,0DAAO;AACtC,6CAA6C,8DAAW;AACxD,sDAAsD,8DAAW;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,qDAAG;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qDAAG;AAC7B,8BAA8B,QAAQ,4DAAO,iBAAiB,mEAAQ,CAAC,kEAAO;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qDAAG;AACvB,kEAAkE,gDAAgD,8EAAmB,mBAAmB;AACxJ;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B,8EAAmB,4BAA4B;AAC/F;AACA,wBAAwB,gCAAgC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,UAAU;AAC5C,kDAAkD,iEAAU,UAAU,kDAAQ;AAC9E;AACA,iCAAiC,EAAE,uCAAuC,EAAE;AAC5E;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAG;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uEAAY;AACjC;AACA,wBAAwB,YAAY,GAAG,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,gBAAgB,4BAA4B;AAC5C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,iEAAiE,2EAAiB;AAClF,qFAAqF,kBAAkB;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,6FAAqB,gBAAgB,6FAAqB;AAC5G;AACA;AACA;AACA,SAAS;AACT;AACA,wCAAwC,uBAAuB,2EAAiB;AAChF,sFAAsF,kBAAkB;AACxG;AACA;AACA;AACA,wCAAwC,6FAAqB,yBAAyB,6FAAqB;AAC3G,YAAY,6FAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,uBAAuB,2EAAiB;AACpF,yFAAyF,kBAAkB;AAC3G;AACA;AACA;AACA,4CAA4C,2EAAiB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qHAAqH,6FAAqB;AAC1I,4HAA4H,6FAAqB;AACjJ;AACA;AACA;AACA;AACA;AACA,2DAA2D,mEAAW;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,oMAAoM,qDAAG;AACvM;AACA;AACA,4DAA4D,2EAAiB;AAC7E,8FAA8F,kBAAkB;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,mEAAW;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yHAAyH,6FAAqB;AAC9I,gIAAgI,6FAAqB;AACrJ;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,mCAAmC,sEAAe;AAClD,uDAAuD,0DAAO;AAC9D,+GAA+G,aAAa;AAC5H,qCAAqC,sEAAmB;AACxD;AACA;AACA;AACA,oBAAoB,iFAAa;AACjC,2CAA2C,0FAAkB;AAC7D,6CAA6C,oDAAK;AAClD;AACA;AACA;AACA;AACA;AACA,4CAA4C,oDAAK;AACjD;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,2CAA2C,4FAAoB;AAC/D;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,qEAAqE,2EAAiB;AACtF;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,wBAAwB,qDAAG;AAC3B;AACA,+BAA+B,oEAAM;AACrC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,2KAA2K;AAC3K;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,2EAAiB;AAC1F,2FAA2F,kBAAkB;AAC7G;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,wDAAwD,mEAAW;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,yBAAyB;AACzE;AACA;AACA,gBAAgB,iFAAa;AAC7B;AACA;AACA;AACA;AACA,iCAAiC,qEAAa,oCAAoC,oDAAK;AACvF;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,4BAA4B,qEAAa,oCAAoC,oDAAK;AAClF;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,kDAAkD,sDAAsD;AACxG;AACA;AACA;AACA;AACA;AACA,sDAAsD,eAAe;AACrE,eAAe,qDAAG;AAClB;AACA;AACA,sDAAsD,cAAc;AACpE,eAAe,qDAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,OAAO;AAC3F;AACA;AACA;AACA;AACA;AACA,eAAe,uEAAY;AAC3B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,yDAAyD,qDAAG;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,mBAAmB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,qDAAG;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,mBAAmB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA,yDAAyD,qDAAG;AAC5D;AACA;AACA;AACA,qEAAqE,yBAAyB;AAC9F;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,OAAO;AAC3F;AACA;AACA;AACA;AACA;AACA,eAAe,uEAAY;AAC3B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,qDAAG;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,qDAAG,gBAAgB,cAAc;AACzE;AACA;AACA,sBAAsB,wEAAU;AAChC,OAAO,qEAAO,IAAI,sEAAkB;AACpC,OAAO,qEAAO,IAAI,gFAAuB;AACzC,OAAO,qEAAO,IAAI,8EAAsB;AACxC,OAAO,qEAAO,IAAI,6EAAW;AAC7B,OAAO,qEAAO,IAAI,qFAAsB;AACxC;AACA,6BAA6B,iGAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qDAAG;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AAC+C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtwB4D;AAChD;AACT;AACE;AAC0B;AACY;AACY;AACN;AAC1B;AACgC;AACvB;AACmB;AACd;AAC1B;AACK;AACwB;AACtB;AACN;AAC3D;AACA;AACA;AACA,wCAAwC,4EAAW;AACnD,wCAAwC,sEAAkB;AAC1D,uDAAuD,6DAAW;AAClE,QAAQ,iFAAyB;AACjC;AACA,yBAAyB,sFAA8B;AACvD;AACA,SAAS;AACT;AACA;AACA,wCAAwC,4EAAW;AACnD,wCAAwC,sEAAkB;AAC1D,8CAA8C,kFAAwB;AACtE,gDAAgD,oEAAiB;AACjE,2DAA2D,6DAAW;AACtE,uDAAuD,6DAAW;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,mBAAmB;AAClE;AACA;AACA,+CAA+C,oDAAG;AAClD;AACA;AACA,8BAA8B,sBAAsB,IAAI,oBAAoB,EAAE,kBAAkB;AAChG,yCAAyC,2DAA2D;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,qBAAqB;AACzE,aAAa;AACb,SAAS;AACT,QAAQ,iFAAyB;AACjC;AACA,8BAA8B,sFAA8B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,kCAAkC,mFAAW;AAC7C;AACA,+BAA+B,kGAAiB,IAAI,4GAA8B;AAClF,qBAAqB,+EAAuB,IAAI,qDAAqD;AACrG,qBAAqB,sEAAkB,QAAQ,qEAAiB;AAChE,qBAAqB,qFAAsB,QAAQ,oFAAqB;AACxE,qBAAqB,oEAAU;AAC/B,qBAAqB,4EAAW,QAAQ,0FAAc,CAAC,qEAAiB;AACxE,qBAAqB,+EAAc,QAAQ,0FAAc,CAAC,2EAAoB;AAC9E,mCAAmC,wGAAoB;AACvD,YAAY,kEAAW;AACvB;AACA;AACA,gFAAgF,4EAAW;AAC3F,QAAQ,iEAAI;AACZ;AACA,6DAA6D,qBAAqB;AAClF;AACA;AACA;AACA;AACA;AACA,sFAAsF,kFAAwB;AAC9G;AACA,YAAY,kEAAW;AACvB;AACA;AACA;AACA;AACA,uEAAuE,6DAAW;AAClF,eAAe,oDAAG;AAClB;AACA;AACA,uEAAuE,6DAAW;AAClF,mGAAmG,oDAAG,eAAe,oDAAG;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oDAAG;AACvC,SAAS;AACT,uCAAuC,oDAAG;AAC1C;AACA;AACA,2FAA2F,oDAAG;AAC9F;AACA,yDAAyD,oDAAG;AAC5D,iDAAiD,oDAAG;AACpD,oDAAoD,oDAAG;AACvD,6DAA6D,oDAAG;AAChE,8BAA8B,oDAAG;AACjC,gCAAgC,oDAAG;AACnC;AACA;AACA;AACA;AAC2C;;;;;;;;;;;;;;;;AC1J8C;AACT;AACiB;AAC1B;AACvE,+FAAiB,CAAC,wFAAwB,EAAE,gFAAuB;AACnE,+FAAiB,CAAC,kFAAsB,EAAE,iFAAqB;;;;;;;;;;;;;;;;;;;ACLqB;AACG;AACT;AACV;AACpE,oEAAoE,+FAA+B;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wEAAU;AACtC,MAAM,qEAAO,IAAI,4EAAkB;AACnC,MAAM,qEAAO,IAAI,sFAAuB;AACxC;AACmC;;;;;;;;;;;;;;;;;;;;;;;AChB+C;AACK;AACrC;AAC0B;AACf;AACL;AACe;AACR;AAC/D,uCAAuC,oFAAkB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,sDAAsD;AACpI;AACA;AACA;AACA;AACA,sCAAsC,+FAA+B;AACrE;AACA;AACA,gCAAgC,qEAAgB;AAChD;AACA;AACA,YAAY,iEAAW;AACvB,8CAA8C,gFAAuB;AACrE;AACA,6DAA6D,0FAAiC;AAC9F,4GAA4G,mDAAmD;AAC/J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wCAAwC;AACvE;AACA;AACA,oEAAoE,YAAY;AAChF;AACA,2BAA2B,oDAAG;AAC9B;AACA;AACA,mEAAmE,YAAY;AAC/E;AACA;AACA;AACA;AACA;AACA,6BAA6B,yBAAyB;AACtD,8BAA8B,OAAO,kBAAkB,UAAU;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,aAAa,UAAU,YAAY;AAC/F;AACA;AACA,sDAAsD,YAAY;AAClE;AACA,6BAA6B,yBAAyB,EAAE,wCAAwC,SAAS,OAAO,EAAE,4CAA4C,WAAW,OAAO;AAChL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,yDAAyD,QAAQ;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,YAAY;AACnF;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,YAAY;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8DAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACmC;;;;;;;;;;;;;ACrHe;AAClD,aAAa,+DAAM;AACnB;;;;;;;;;;;;;;;;;;;;;;;;;ACF0D;AACF;AACyD;AAC9C;AACqB;AAChC;AACG;AACb;AACR;AACY;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,oDAAG;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,oDAAG;AACvD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,+BAA+B,kBAAkB,IAAI,WAAW,KAAK,kCAAkC;AACvG,gDAAgD,gCAAgC;AAChF;AACA;AACA;AACA,8BAA8B,MAAM,KAAK,gBAAgB,8DAAQ,0BAA0B;AAC3F;AACA;AACA;AACA;AACA;AACA,wDAAwD,oDAAG;AAC3D;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,6FAAY;AAChD;AACA,wDAAwD,MAAM,8DAAQ,yCAAyC;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8BAA8B,0DAAO;AACrC;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA,wBAAwB,4DAAQ;AAChC,gBAAgB,qGAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yGAAmB;AAC7C,sBAAsB,oBAAoB;AAC1C,SAAS;AACT,sBAAsB,yGAAmB;AACzC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,iEAAI;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iEAAI;AACpB,0CAA0C,2EAAiB;AAC3D;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACkB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjQ+D;AACzC;AACkE;AACpC;AAC0B;AACK;AACzC;AACP;AACyC;AACpC;AACJ;AACO;AAC+C;AAC5G;AACA;AACA;AACA,eAAe,iDAAQ;AACvB;AACA,CAAC;AACD;AACA;AACA;AACA,eAAe,iDAAQ;AACvB;AACA,CAAC;AACD;AACA;AACA;AACA,eAAe,iDAAQ;AACvB;AACA;AACA,CAAC;AACD;AACA;AACA,eAAe,iDAAQ;AACvB;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,eAAe,iDAAQ;AACvB;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,0DAAO;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAAQ;AACR,4GAA4G,iEAAU;AACtH,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,UAAU;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6HAA6H,+BAA+B;AAC5J;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,UAAU;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,aAAa,KAAK,gEAAM;AAC3E;AACA;AACA;AACA;AACA;AACA,iDAAiD,wEAAU;AAC3D,OAAO,qEAAO,IAAI,0GAAqB;AACvC,OAAO,qEAAO,IAAI,qGAAwB;AAC1C;AACA,gGAAgG,iEAAU;AAC1G,aAAa;AACb;AACA;AACA;AACA,6BAA6B,mEAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,+DAAS;AACtB;AACA;AACA;AACA;AACA;AACA,4BAA4B,2EAAQ,IAAI,+FAAY;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,iDAAQ;AACzD,qBAAqB;AACrB;AACA,6CAA6C,iDAAQ;AACrD;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,6CAA6C,iDAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,2CAA2C,wEAAU;AACrD,OAAO,qEAAO,IAAI,sGAAmB;AACrC;AACA;AACA,0EAA0E,iEAAU;AACpF,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,4BAA4B,2EAAQ,IAAI,+FAAY;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qGAAqG,iDAAQ;AAC7G,qCAAqC,iDAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,4DAA4D;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wEAAU;AAC1C,OAAO,qEAAO,IAAI,kHAAwB;AAC1C,OAAO,qEAAO,IAAI,0GAAqB;AACvC;AAC8T;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3QtR;AACqB;AACd;AAC2B;AACmB;AACvB;AACN;AACT;AACwC;AACvC;AACD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAQ;AAC3B,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oDAAG;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,4DAAO;AACpF;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oDAAG,qCAAqC,oDAAG,uCAAuC,oDAAG,uCAAuC,oDAAG;AAC1I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0DAA0D;AAC3D,kCAAkC,iEAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oDAAG;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iEAAQ;AAChB,2DAA2D,iDAAQ;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ,iEAAQ;AAChB,kFAAkF,iDAAQ;AAC1F,6DAA6D,gDAAgD;AAC7G;AACA,SAAS;AACT;AACA;AACA,uBAAuB,iEAAU;AACjC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA,gEAAgE,wCAAwC;AACxG,oEAAoE,wCAAwC;AAC5G;AACA;AACA;AACA,0DAA0D,wCAAwC,sCAAsC,wCAAwC;AAChL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA,iEAAiE,wCAAwC;AACzG,qEAAqE,wCAAwC;AAC7G;AACA;AACA;AACA,2DAA2D,wCAAwC,uCAAuC,wCAAwC;AAClL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,kGAAqB;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sEAAe;AAC9B;AACA;AACA;AACA;AACA,qDAAqD,aAAa;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uEAAY;AAC3B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,2EAAQ;AACR;AACA;AACA;AACA;AACA;AACA,yBAAyB,oDAAG;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,qEAAQ,aAAa,qEAAQ;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qEAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gFAAkB;AAC7B;AACA;AACA,kBAAkB,oFAAsB;AACxC;AACA;AACA;AACA;AACA;AACgzB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACja3vB;AACb;AACkC;AACd;AACU;AACjB;AACG;AACmB;AAC3E;AACA,yBAAyB,iDAAQ;AACjC,wBAAwB,oFAAY,sBAAsB,6DAAO,WAAW,iDAAQ;AACpF;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,iEAAU;AACnD;AACA;AACA,oDAAoD,0DAAO;AAC3D;AACA,sDAAsD,0DAAO;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oJAAoJ,sBAAsB;AAC1K,+BAA+B,6DAAQ;AACvC;AACA;AACA;AACA;AACA,mCAAmC,sCAAsC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,sCAAsC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iEAAU;AACtC;AACA;AACA,wDAAwD,0DAAO;AAC/D;AACA,0DAA0D,0DAAO;AACjE;AACA,2DAA2D,0DAAO;AAClE;AACA,oEAAoE,0DAAO;AAC3E;AACA;AACA;AACA,2CAA2C,uDAAM;AACjD;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA,yBAAyB,sBAAsB;AAC/C;AACA;AACA;AACA;AACA;AACA,6CAA6C,sBAAsB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,2CAA2C;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uEAAY;AAC3B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iCAAiC,uEAAY;AAC7C;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iDAAQ,yBAAyB,EAAE;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAAQ;AACR;AACA;AACA;AACA;AACA,CAAC,kDAAkD;AACnD;AACA;AACA;AACA;AACA;AACA,CAAC,4DAA4D;AAC7D;AACA;AACA;AACA;AACA,QAAQ,8DAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iDAAQ,gCAAgC,EAAE;AAC1D;AACA;AACA;AACA;AACA;AACA;AAC0P;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtSnK;AACtB;AACN;AACiB;AACjB;AACe;AACX;AACK;AACJ;AACqB;AAC1C;AACoB;AACA;AACF;AACS;AACL;AACqB;AACY;AACP;AACd;AACmB;AACxB;AACiB;AACA;AACc;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA,QAAQ,iEAAS;AACjB;AACA,QAAQ,6EAAgB;AACxB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,wCAAwC,0DAAO;AAC/C;AACA;AACA;AACA,gCAAgC,sEAAoB;AACpD,uCAAuC,2FAAyC;AAChF;AACA;AACA;AACA;AACA,2DAA2D,mBAAmB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAAkG,sFAAc;AAChH;AACA;AACA,wBAAwB;AACxB;AACA;AACA,eAAe,uEAAY;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gDAAgD,mBAAmB;AACnE;AACA;AACA,mEAAmE,mBAAmB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uEAAY;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,eAAe,uEAAY;AAC3B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,oBAAoB;AAChF;AACA,gCAAgC;AAChC;AACA;AACA;AACA,eAAe,oEAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,eAAe,8DAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,sFAAc;AAC7F;AACA;AACA,sBAAsB,8DAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,GAAG;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,GAAG;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,GAAG;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uEAAY;AAC3B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,yBAAyB,8DAAQ;AACjC;AACA;AACA;AACA;AACA,uBAAuB,2DAA2D;AAClF;AACA,2BAA2B,wFAAwF;AACnH;AACA;AACA,SAAS;AACT,sFAAsF,0BAA0B;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,qBAAqB,wEAAU;AAC/B,MAAM,qEAAO,IAAI,kGAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,iBAAiB;AACjB,qBAAqB;AACrB,wBAAwB;AACxB,wBAAwB;AACxB,iCAAiC;AACjC,0CAA0C;AAC1C,iCAAiC;AACjC,sBAAsB;AACtB,qBAAqB;AACrB,0BAA0B;AAC1B,sBAAsB;AACtB,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,aAAa;AACb;AACA;AACA;AACA;AACA,wBAAwB,wFAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8DAAO;AAC/B;AACA;AACA;AACA,4DAA4D,4BAA4B,EAAE,2EAAiB;AAC3G;AACA;AACA;AACA,6BAA6B,4EAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0EAAgB;AACtC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,kDAAkD,wEAAU;AAC5D,MAAM,qEAAO,IAAI,gGAAe;AAChC,MAAM,qEAAO,IAAI,yFAAe;AAChC,MAAM,qEAAO,IAAI,6EAAW;AAC5B,MAAM,qEAAO,IAAI,yFAAe;AAChC;AACA;AACA,cAAc,gCAAgC,GAAG,iBAAiB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,2FAAmB;AACrD;AACA,WAAW,mEAAM;AACjB;AAC+J;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrYjH;AACuC;AACrF,qCAAqC,oFAAa;AAClD;AACA;AACA,GAAG,+BAA+B,iDAAQ;AAC1C;AACA;AACA;AACA;AACA,uDAAuD,oFAAa;AACpE;AACA;AACA,GAAG,gCAAgC,iDAAQ;AAC3C;AACA,6DAA6D,oFAAa;AAC1E;AACA;AACA,GAAG,gCAAgC,iDAAQ;AAC3C;AACA,yCAAyC,oFAAa;AACtD;AACA;AACA,GAAG,gCAAgC,iDAAQ;AAC3C;AACA,sCAAsC,oFAAa;AACnD;AACA;AACA,GAAG,gCAAgC,iDAAQ;AAC3C;AACA,gDAAgD,oFAAa;AAC7D;AACA;AACA,GAAG,gCAAgC,iDAAQ;AAC3C;AACA,gCAAgC,oFAAa,0BAA0B,gCAAgC,iDAAQ,yCAAyC;AACxJ,+BAA+B,oFAAa,yBAAyB,gCAAgC,iDAAQ,uCAAuC;AACpJ,+BAA+B,oFAAa,qBAAqB,+BAA+B,iDAAQ,qCAAqC;AAC7I,oCAAoC,oFAAa,yBAAyB,+BAA+B,iDAAQ,0CAA0C;AAC3J,yCAAyC,oFAAa,6BAA6B,gCAAgC,iDAAQ,6DAA6D;AACxL,2CAA2C,oFAAa,8BAA8B,gCAAgC,iDAAQ,+CAA+C;AAC7K,4CAA4C,oFAAa,+BAA+B,gCAAgC,iDAAQ,gDAAgD;AAChL,qCAAqC,oFAAa,yBAAyB,gCAAgC,iDAAQ,mEAAmE;AACtL,uCAAuC,oFAAa,oBAAoB,gCAAgC,iDAAQ,oEAAoE;AACpL,oCAAoC,oFAAa,2BAA2B,gCAAgC,iDAAQ;AACpH;AACA;AACA,IAAI;AACJ,yDAAyD,oFAAa;AACtE;AACA;AACA,GAAG,gCAAgC,iDAAQ;AAC3C;AACA,8CAA8C,oFAAa;AAC3D;AACA;AACA,GAAG,gCAAgC,iDAAQ;AAC3C;AACA;AACA;AACA;AACA,gDAAgD,oFAAa;AAC7D,4CAA4C,oFAAa;AACzD,qCAAqC,oFAAa;AAClD,qCAAqC,oFAAa,+BAA+B,gCAAgC,iDAAQ,oEAAoE;AAC7L,2DAA2D,oFAAa;AACxE;AACA;AACA,GAAG,gCAAgC,iDAAQ;AAC3C;AACA,yDAAyD,oFAAa;AACtE;AACA;AACA,GAAG,gCAAgC,iDAAQ;AAC3C;AACA;AACA;AACA;AACA,4CAA4C,oFAAa;AAC0qB;;;;;;;;;;;;;;;;;;;;;;AC/E9qB;AACW;AAChE;AACA;AACA;AACA,2CAA2C,oDAAG;AAC9C;AACA,yEAAyE,+DAAK;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,oFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA,CAAC,wDAAwD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0DAA0D;AAC3D;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AAC6G;;;;;;;;;;;;;;;;;;AC9CvF;AACA;AACb;AAC9C;AACA;AACA;AACA;AACA,+BAA+B,0DAAO;AACtC,8BAA8B,0DAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAAkG,iBAAiB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iDAAQ,uBAAuB,GAAG,SAAS,EAAE;AAChF;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8DAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,8DAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrJqB;AACP;AACuC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oFAAa,2BAA2B,+BAA+B,iDAAQ,uEAAuE;AACxL,gDAAgD,oFAAa;AAC7D;AACA;AACA,MAAM,+BAA+B,iDAAQ;AAC7C;AACA;AACA;AACA;AACA,mCAAmC,oFAAa,6BAA6B,+BAA+B,iDAAQ;AACpH;AACA;AACA,IAAI;AACJ;AACA,gCAAgC,oFAAa;AAC7C;AACA;AACA,MAAM,+BAA+B,iDAAQ;AAC7C;AACA;AACA;AACA;AACA,oCAAoC,oFAAa,yBAAyB,gCAAgC,iDAAQ;AAClH;AACA;AACA,IAAI;AACJ,qCAAqC,oFAAa,yBAAyB,gCAAgC,iDAAQ,gDAAgD;AACnK,qCAAqC,oFAAa,yBAAyB,gCAAgC,iDAAQ,oEAAoE;AACvL,iDAAiD,oFAAa;AAC9D;AACA;AACA,MAAM,gCAAgC,iDAAQ;AAC9C;AACA,4CAA4C,oFAAa;AACzD;AACA;AACA,MAAM,gCAAgC,iDAAQ;AAC9C;AACA;AACA;AACA;AACA,2CAA2C,oFAAa,+BAA+B,gCAAgC,iDAAQ,sEAAsE;AACrM,iDAAiD,oFAAa;AAC9D;AACA;AACA,MAAM,gCAAgC,iDAAQ;AAC9C;AACA,+CAA+C,oFAAa;AAC5D;AACA;AACA,MAAM,gCAAgC,iDAAQ;AAC9C;AACA,yCAAyC,oFAAa,6BAA6B,gCAAgC,iDAAQ,oEAAoE;AAC/L,2CAA2C,oFAAa;AACxD;AACA;AACA,MAAM,gCAAgC,iDAAQ;AAC9C;AACA;AACA;AACA;AACA,gDAAgD,oFAAa;AAC7D;AACA;AACA,MAAM,gCAAgC,iDAAQ;AAC9C;AACA,2CAA2C,oFAAa;AACxD;AACA;AACA,MAAM,+BAA+B,iDAAQ;AAC7C;AACA;AACA;AACA;AACA,mDAAmD,oFAAa;AAChE;AACA;AACA,MAAM,gCAAgC,iDAAQ;AAC9C;AACA;AACA;AACA;AACA,8CAA8C,oFAAa;AAC3D;AACA;AACA,MAAM,gCAAgC,iDAAQ;AAC9C;AACA;AACA;AACA;AACA,wDAAwD,oFAAa;AACrE;AACA;AACA,MAAM,gCAAgC,iDAAQ;AAC9C;AACA;AACA;AACA;AACA,uCAAuC,oFAAa,+BAA+B,+BAA+B,iDAAQ;AAC1H;AACA;AACA,IAAI;AACJ,uCAAuC,oFAAa,+BAA+B,gCAAgC,iDAAQ;AAC3H;AACA;AACA,IAAI;AACJ,4CAA4C,oFAAa;AACzD;AACA;AACA,MAAM,+BAA+B,iDAAQ;AAC7C;AACA;AACA;AACA;AACA,qDAAqD,oFAAa;AAClE;AACA;AACA,MAAM,gCAAgC,iDAAQ;AAC9C;AACA,4CAA4C,oFAAa;AACzD;AACA;AACA,MAAM,gCAAgC,iDAAQ;AAC9C;AACA,qDAAqD,oFAAa;AAClE;AACA;AACA,MAAM,gCAAgC,iDAAQ;AAC9C;AACA,gDAAgD,oFAAa;AAC7D;AACA;AACA,MAAM,gCAAgC,iDAAQ;AAC9C;AACA,gDAAgD,oFAAa;AAC7D;AACA;AACA,MAAM,+BAA+B,iDAAQ;AAC7C;AACA;AACA;AACA;AACA,iDAAiD,oFAAa;AAC9D;AACA;AACA,MAAM,gCAAgC,iDAAQ;AAC9C;AACA,mDAAmD,oFAAa;AAChE;AACA;AACA,MAAM,gCAAgC,iDAAQ;AAC9C;AACA,2CAA2C,oFAAa,+BAA+B,gCAAgC,iDAAQ,sEAAsE;AACrM,+CAA+C,oFAAa;AAC5D;AACA;AACA,MAAM,gCAAgC,iDAAQ;AAC9C;AACA,oDAAoD,oFAAa;AACjE;AACA;AACA,MAAM,gCAAgC,iDAAQ;AAC9C;AACA,gDAAgD,oFAAa;AAC7D;AACA;AACA,MAAM,gCAAgC,iDAAQ;AAC9C;AACA,mDAAmD,oFAAa;AAChE;AACA;AACA,MAAM,gCAAgC,iDAAQ;AAC9C;AACA,yCAAyC,oFAAa,8BAA8B,gCAAgC,iDAAQ,oDAAoD;AAChL,2CAA2C,oFAAa;AACxD;AACA;AACA,MAAM,gCAAgC,iDAAQ;AAC9C;AACA,iDAAiD,oFAAa;AAC9D;AACA;AACA,MAAM,gCAAgC,iDAAQ;AAC9C;AACA;AACA;AACA;AACA,4DAA4D,oFAAa;AACzE;AACA;AACA,MAAM,+BAA+B,iDAAQ;AAC7C;AACA;AACA;AACA;AACA,8CAA8C,oFAAa;AAC3D;AACA;AACA,MAAM,gCAAgC,iDAAQ;AAC9C;AACA,2DAA2D,oFAAa;AACxE;AACA;AACA,MAAM,gCAAgC,iDAAQ;AAC9C;AACA;AACA;AACA;AACA,gDAAgD,oFAAa;AAC7D;AACA;AACA,MAAM,gCAAgC,iDAAQ;AAC9C;AACA,0DAA0D,oFAAa;AACvE;AACA;AACA,MAAM,gCAAgC,iDAAQ;AAC9C;AACA,8DAA8D,oFAAa;AAC3E;AACA;AACA,MAAM,gCAAgC,iDAAQ;AAC9C;AACA;AACA;AACA;AACA,0DAA0D,oFAAa;AACvE;AACA;AACA,MAAM,gCAAgC,iDAAQ;AAC9C;AACA;AACA;AACA;AACA,oDAAoD,oFAAa;AACjE;AACA;AACA,MAAM,gCAAgC,iDAAQ;AAC9C;AACA;AACA;AACA;AACA,kDAAkD,oFAAa;AAC/D;AACA;AACA,MAAM,gCAAgC,iDAAQ;AAC9C;AACA;AACA;AACA;AACA,sDAAsD,oFAAa;AACnE;AACA;AACA,MAAM,gCAAgC,iDAAQ;AAC9C;AACA,4CAA4C,oFAAa;AACzD;AACA;AACA,MAAM,gCAAgC,iDAAQ;AAC9C;AACA,sCAAsC,oFAAa,2BAA2B,+BAA+B,iDAAQ,0EAA0E;AAC/L,qCAAqC,oFAAa,0BAA0B,+BAA+B,iDAAQ,yEAAyE;AAC5L,2CAA2C,oFAAa,gCAAgC,8BAA8B,iDAAQ;AAC9H;AACA;AACA,IAAI;AACJ,qCAAqC,oFAAa,0BAA0B,+BAA+B,iDAAQ,yEAAyE;AAC5L,yCAAyC,oFAAa,8BAA8B,+BAA+B,iDAAQ;AAC3H;AACA;AACA,IAAI;AACJ,4CAA4C,oFAAa;AACzD;AACA;AACA,MAAM,+BAA+B,iDAAQ;AAC7C;AACA;AACA;AACA;AACA,gDAAgD,oFAAa;AAC7D;AACA;AACA,MAAM,gCAAgC,iDAAQ;AAC9C;AACA,0CAA0C,oFAAa,8BAA8B,gCAAgC,iDAAQ,wDAAwD;AACrL,2CAA2C,oFAAa,+BAA+B,gCAAgC,iDAAQ,+DAA+D;AAC9L,qDAAqD,oFAAa;AAClE;AACA;AACA,MAAM,gCAAgC,iDAAQ;AAC9C;AACA,8CAA8C,oFAAa;AAC3D;AACA;AACA,MAAM,gCAAgC,iDAAQ;AAC9C;AACA,6DAA6D,oFAAa;AAC1E;AACA;AACA,MAAM,gCAAgC,iDAAQ;AAC9C;AACA;AACA;AACA;AACA,6EAA6E,oFAAa;AAC1F;AACA;AACA,MAAM,gCAAgC,iDAAQ;AAC9C;AACA,iDAAiD,iDAAQ;AACzD;AACA,6BAA6B,EAAE;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,wFAAwF;AACxF;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA;AACA,kCAAkC,OAAO,oDAAG,iCAAiC,oDAAG,0BAA0B;AAC1G;AACA;AACA,KAAK;AACL;AACA,CAAC,kDAAkD;AAC82E;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjX31E;AACjB;AACQ;AACE;AACF;AACG;AACY;AACf;AAC7D,2BAA2B,IAAI,IAAI;AACnC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yEAAgB,2BAA2B,yEAAgB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,aAAa;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,EAAE;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,uEAAuE;AACjF,UAAU;AACV;AACA;AACA;AACA;AACA,wBAAwB,gEAAQ;AAChC;AACA,4FAA4F,2EAAiB;AAC7G;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA,0BAA0B,+DAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oDAAG;AAC5B;AACA;AACA,oBAAoB,gEAAU;AAC9B,2BAA2B,oDAAG;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oDAAG;AACrB;AACA,6BAA6B,4DAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kEAAS;AACzB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,gBAAgB,kEAAS;AACzB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,8DAA8D;AACzJ;AACA;AACA;AACA;AACA,wEAAwE,4DAAO;AAC/E,2CAA2C,4DAA4D;AACvG;AACA;AACA;AACA;AACA;AACA;AAC0S;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpS7O;AACyB;AACvB;AACP;AACK;AACpB;AACuB;AACqB;AACiD;AACtI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;AACA;AACA,IAAI,uDAAK;AACT,IAAI,uDAAK;AACT;AACA;AACA,IAAI,uDAAK;AACT;AACA;AACA,IAAI,uDAAK;AACT,IAAI,uDAAK;AACT;AACA;AACA;AACA;AACA;AACA,IAAI,uDAAK;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gEAAgE;AACjE;AACA;AACA;AACA;AACA;AACA,CAAC,wDAAwD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0DAA0D;AAC3D;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA,iCAAiC,4DAAO;AACxC;AACA,eAAe,yGAAmB;AAClC;AACA;AACA;AACA,eAAe,sGAAgB;AAC/B;AACA;AACA,CAAC,kDAAkD;AACnD;AACA;AACA,qBAAqB,4DAAO;AAC5B;AACA,eAAe,8FAAQ;AACvB;AACA;AACA;AACA,eAAe,2FAAK;AACpB;AACA;AACA;AACA;AACA,oBAAoB,4DAAO;AAC3B,2BAA2B,eAAe,GAAG,oBAAoB,4DAAO,6BAA6B;AACrG,SAAS;AACT;AACA;AACA;AACA,2BAA2B,4DAAO;AAClC;AACA;AACA,oCAAoC,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,GAAG;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,4DAAO;AACzC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,yDAAyD,gBAAgB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,wBAAwB;AAChE;AACA;AACA,CAAC,0BAA0B;AAC3B,kCAAkC,+DAAS;AAC3C;AACA;AACA;AACA;AACA;AACA,qBAAqB,2DAAO;AAC5B,SAAS;AACT;AACA;AACA,sCAAsC,8DAAQ;AAC9C;AACA,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kCAAkC,2DAAO,oCAAoC;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8BAA8B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,oFAAa;AAC3D,mDAAmD,oFAAa;AAChE;AACA;AACA;AACA;AACA,CAAC,wDAAwD;AACzD;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA,4CAA4C,uEAAiB;AAC7D,+CAA+C,uEAAiB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,kBAAkB,0CAA0C,EAAE,aAAa,GAAG,yBAAyB;AACvG;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4DAAQ,gCAAgC,4DAAQ;AACzE;AACA;AACA,aAAa;AACb;AACA,sCAAsC,wBAAwB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,4DAAQ;AACnB;AACypB;;;;;;;;;;;;;;;AC9YzpB;AACA;AACA;AACA;AACA;AACA,CAAC,0DAA0D;AACxB;;;;;;;;;;;;;;;ACNnC;AAC4B;;;;;;;;;;;;;;;;;;;ACDsC;AACF;AAC+D;AAC7C;AAClF,8BAA8B,iEAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+DAAK;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,8HAA0B;AAC5D;AACA;AACA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,8HAA0B;AAChE;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,mCAAmC,iFAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iFAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AAC2B;;;;;;;;;;;;;;;;;;;ACzEiD;AACZ;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,eAAe;AAC/C;AACA;AACA,qBAAqB,8EAAe,wDAAwD,+DAAK;AACjG;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AAC6F;;;;;;;;;;;;;;;;;;;;;ACvC/C;AACc;AACG;AACgC;AACT;AAC3B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mCAAmC,iDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+DAAQ;AACjC;AACA,qCAAqC,iDAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+DAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,kEAAS,uBAAuB;AAC3E,+BAA+B,qFAAc;AAC7C;AACA;AACA;AACA,CAAC,sCAAsC;AACvC,gCAAgC,iGAAkB;AAClD;AACA;AACA;AACA;AACA,0CAA0C,UAAU;AACpD;AACA;AACA,KAAK;AACL;AACA,uBAAuB,iDAAQ;AAC/B;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,4CAA4C,0DAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kEAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACkC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClKuB;AACG;AACI;AACD;AACsB;AAChB;AACrE;AACA,kCAAkC,oFAAa,yBAAyB,iDAAQ;AAChF,yBAAyB,kDAAS;AAClC;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA,gCAAgC,QAAQ,gBAAgB;AACxD,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACA;AACA;AACA,CAAC,kDAAkD;AACnD;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AACnC;AACA;AACA;AACA,YAAY,+DAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA,wBAAwB;AACxB,wBAAwB;AACxB,0BAA0B;AAC1B,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,+DAAQ;AACzB;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA,4BAA4B;AAC5B,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+DAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa,GAAG,qBAAqB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oCAAoC,GAAG,SAAS,GAAG,cAAc,OAAO,SAAS,GAAG,cAAc;AACtI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,gGAAgG,mEAAQ;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gGAAgG,mEAAQ;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mCAAmC,GAAG,oCAAoC,GAAG,SAAS,GAAG,cAAc;AACxH,iBAAiB,mCAAmC,GAAG,SAAS,GAAG,cAAc;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS,GAAG,cAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACA;AACA,CAAC,0CAA0C;AAC3C;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,CAAC,kDAAkD;AACnD;AACA;AACA;AACA,2BAA2B,8EAAsB;AACjD;AACA,yBAAyB,kEAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kEAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,iDAAQ;AACrD;AACA,+DAA+D,EAAE,uCAAuC,EAAE;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACoX;;;;;;;;;;;;;;;AChtB7Z;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sBAAsB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uCAAuC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACkB;;;;;;;;;;;;;;;;;;;;;;;;;ACnIuE;AAC9B;AACO;AACF;AACO;AAClC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,iCAAiC,iEAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,mEAAgB;AACrE,kDAAkD,0DAAO;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kEAAmB;AAC3C;AACA;AACA;AACA,wBAAwB,kEAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8CAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,gBAAgB,mEAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,uBAAuB,8CAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;AACA;AACA,gCAAgC,8CAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe,yBAAyB,+DAAgB;AAC5E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,aAAa;AACjD;AACA;AACA,wBAAwB,+DAAgB;AACxC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,YAAY,+DAAgB,oCAAoC;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB,0DAA0D;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,8CAAM;AAC9C,gBAAgB,iEAAU;AAC1B;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0DAAO;AACnC;AACA;AACA;AACA;AACA;AACA,wDAAwD,0DAAO;AAC/D;AACA,mFAAmF,0BAA0B;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iEAAU;AACtB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB,iEAAiE;AACzG;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,8CAAM;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,GAAG;AACjE;AACA;AACA;AACA;AACA,mCAAmC,GAAG;AACtC;AACA;AACA;AACA;AACA,mCAAmC,GAAG,wBAAwB,MAAM,+DAA+D,MAAM;AACzI;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA,gCAAgC,YAAY;AAC5C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,6BAA6B,cAAc;AAC3C,SAAS;AACT;AACA;AACA,iCAAiC,YAAY;AAC7C;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AAC6H;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5dxE;AACiB;AACN;AAC3B;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,eAAe,+DAAK;AACpB,wCAAwC,oDAAG;AAC3C,KAAK;AACL,CAAC,sCAAsC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,oDAAoD,oDAAG;AACvD,mCAAmC,qEAAQ;AAC3C,KAAK;AACL,CAAC,wDAAwD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC,8CAA8C;AAC/C,wCAAwC,kBAAkB,EAAE,OAAO;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,oDAAG;AAC5D,kCAAkC,+DAAK;AACvC;AACA;AACA;AACA,KAAK;AACL,CAAC,8BAA8B;AAC/B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,sBAAsB,8CAAM;AAC5B;AACA;AACA,KAAK;AACL,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,+DAAK;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,CAAC,0CAA0C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC,wCAAwC;AACzC;AACA;AACA,oCAAoC,sBAAsB;AAC1D;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,oDAAG;AAC3C,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC,sCAAsC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,qEAAQ,oCAAoC,qEAAQ,6BAA6B,+DAAK;AACvI;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACA;AACA;AACA;AACA,CAAC,oDAAoD;AACrD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB,0CAA0C,oDAAG;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,8CAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,qBAAqB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,8CAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACue;;;;;;;;;;;;;;;;;;;;;AC3c1a;AACR;AACrD;AACA,wDAAwD,wBAAwB;AAChF,oDAAoD,wBAAwB;AAC5E;AACA,4BAA4B,4DAAO,6BAA6B,4DAAO;AACvE;AACA;AACA,yFAAyF,4DAAO;AAChG,qBAAqB,oDAAG;AACxB,oBAAoB,4DAAO;AAC3B;AACA;AACA,SAAS;AACT;AACA,aAAa,oDAAG;AAChB,gBAAgB,4DAAO;AACvB,sBAAsB,gBAAgB,GAAG,oCAAoC,GAAG,6BAA6B;AAC7G;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,yCAAyC,EAAE;AAC3C;AACyH;;;;;;;;;;;;;;;ACtCzH;AACyC;;;;;;;;;;;;;;;;;ACD4B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC,4BAA4B,oEAAgB;AAC5C;AACA;AACA;AACA;AACA;AACuC;;;;;;;;;;;;;;;;;;;;;;;;ACpCqD;AACnC;AACgC;AAC1B;AACuB;AACb;AAC3B;AAC2B;AACP;AAClE;AACA,aAAa,uBAAuB;AACpC,aAAa,4BAA4B,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,YAAY,+DAAS;AACrB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,uCAAuC,wDAAwD;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kEAAS;AAChC,YAAY,+DAAS;AACrB;AACA;AACA,iBAAiB,iEAAW;AAC5B;AACA;AACA,iBAAiB,6DAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+DAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,+DAAQ;AACzB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qEAAY;AAC3B;AACA;AACA;AACA;AACA;AACA,6CAA6C,+DAAQ;AACrD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iFAAiF,gBAAgB;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4EAAoB;AAC3C;AACA,wBAAwB,oEAAa;AACrC;AACA,gBAAgB,iDAAQ,kBAAkB,GAAG;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4EAAoB;AAC/C;AACA;AACA,wBAAwB,oEAAa,eAAe,iDAAQ;AAC5D;AACA,2BAA2B,EAAE,qCAAqC,EAAE;AACpE;AACA,gBAAgB,8DAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oEAAa,eAAe,iDAAQ;AAChE;AACA,+BAA+B,GAAG,sCAAsC,EAAE;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oEAAa,eAAe,iDAAQ;AAChE;AACA,+BAA+B,GAAG;AAClC;AACA;AACA;AACA,wBAAwB,oEAAa;AACrC;AACA,gBAAgB,iDAAQ,kBAAkB,GAAG;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,+DAAS;AAC7D,4BAA4B,+DAAQ;AACpC;AACA;AACA;AACA;AACA;AACA,4BAA4B,oEAAa,CAAC,mEAAY,MAAM,iDAAQ;AACpE;AACA,+BAA+B,GAAG;AAClC;AACA;AACA;AACA;AACA;AACA,wBAAwB,wEAAiB;AACzC,oCAAoC,oEAAa,CAAC,mEAAY,SAAS,iDAAQ;AAC/E;AACA,uCAAuC,GAAG,sCAAsC,EAAE;AAClF;AACA;AACA;AACA;AACA,wBAAwB,+DAAQ;AAChC,oCAAoC,oEAAa,CAAC,mEAAY,SAAS,iDAAQ;AAC/E;AACA,uCAAuC,GAAG,8BAA8B,EAAE;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oEAAa,CAAC,mEAAY,SAAS,iDAAQ;AACvE;AACA,+BAA+B,GAAG;AAClC;AACA;AACA;AACA,2CAA2C,mEAAY;AACvD;AACA,2CAA2C,mEAAY;AACvD;AACA;AACA;AACA;AACA,oCAAoC,oEAAa,CAAC,mEAAY,yBAAyB,iDAAQ;AAC/F;AACA,uCAAuC,GAAG,2CAA2C,GAAG;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oEAAa,CAAC,mEAAY,yBAAyB,iDAAQ;AACvF;AACA,+BAA+B,GAAG;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,4EAAoB,0BAA0B,mEAAY;AACzF;AACA,0DAA0D,4EAAoB,0BAA0B,mEAAY,UAAU,4DAAG;AACjI;AACA;AACA,+BAA+B,4EAAoB,CAAC,8DAAQ,0BAA0B,mEAAY;AAClG;AACA;AACA;AACA;AACA,oCAAoC,oEAAa,CAAC,mEAAY,WAAW,iDAAQ;AACjF;AACA,uCAAuC,GAAG;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oEAAa,CAAC,mEAAY,aAAa,iDAAQ;AACnF;AACA,uCAAuC,GAAG;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oEAAa,CAAC,mEAAY,eAAe,iDAAQ;AACrF;AACA,uCAAuC,GAAG;AAC1C;AACA;AACA;AACA;AACA,2CAA2C,mEAAY;AACvD;AACA,oDAAoD,mEAAY;AAChE;AACA,+BAA+B,8DAAQ,sBAAsB,mEAAY;AACzE;AACA;AACA,mCAAmC,8DAAQ,0BAA0B,mEAAY,6BAA6B,mEAAY;AAC1H;AACA,2CAA2C,mEAAY;AACvD;AACA,0CAA0C,6DAAO,aAAa,mEAAY;AAC1E;AACA,+CAA+C,8DAAQ,0BAA0B,mEAAY;AAC7F;AACA;AACA;AACA;AACA;AACA,+BAA+B,6DAAO,aAAa,mEAAY;AAC/D;AACA,+BAA+B,6DAAO,aAAa,mEAAY;AAC/D;AACA,+BAA+B,8DAAQ,aAAa,mEAAY;AAChE;AACA,2CAA2C,8DAAQ,aAAa,mEAAY;AAC5E,wEAAwE,6DAAO;AAC/E;AACA;AACA,+BAA+B,8DAAQ,CAAC,6DAAO,aAAa,mEAAY;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qDAAG;AAClC;AACA;AACA,sDAAsD,SAAS,GAAG,SAAS;AAC3E,uDAAuD,mEAAY;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oEAAa,eAAe,iDAAQ;AAC5D;AACA,2BAA2B,GAAG;AAC9B;AACA;AACA;AACA;AACA;AACA;AAC2C;;;;;;;;;;;;;;;;;;;;;;;;AC5We;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA,WAAW,gEAAa,uBAAuB,gEAAa;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkL;;;;;;;;;;;;;;;;ACpDrF;AAC7F,+BAA+B,gGAAe;AACd;;;;;;;;;;;;;;;;;;;;;;;;;;ACFwB;AACK;AACL;AACQ;AAClB;AACoC;AACc;AACpB;AAC5E;AACA,iCAAiC,2EAAQ,IAAI,+FAAU;AACvD;AACA,OAAO,oFAA8B;AACrC;AACA;AACA;AACA,mCAAmC,iDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4DAA4D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4DAAO;AACf,QAAQ,4DAAO;AACf,QAAQ,4DAAO;AACf,QAAQ,4DAAO;AACf;AACA;AACA;AACA;AACA,+EAA+E,uDAAK;AACpF,oCAAoC,gBAAgB,GAAG,cAAc,IAAI,mEAAQ;AACjF,WAAW,2DAAK;AAChB;AACuG;;;;;;;;;;;;;;;;;;;AC5D9C;AACzD;AACA;AACA;AACA;AACA;AACA,sCAAsC,sEAAa;AACnD;AACwE;;;;;;;;;;;;;;;;;;;;;;;;ACRmE;AAChF;AACH;AACwB;AACR;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,0DAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,6FAAsB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yBAAyB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,4BAA4B,6FAAsB;AAClD;AACA;AACA;AACA;AACA,6BAA6B,0FAAmB,yCAAyC,0FAAmB;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,iEAAU;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2EAAoB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,eAAe;AAClE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uEAAY;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uDAAK;AAC9B,yBAAyB,uDAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6FAAsB;AACpD;AACA;AAC6K;;;;;;;;;;;;;;;;;;AC7ShH;AAC7D;AACA;AACA;AACA;AACA,CAAC,wBAAwB;AACzB;AACA,mBAAmB,4DAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChCC;AACJ;AAC8E;AACZ;AACoB;AAC3I;AACA,sBAAsB,0FAAmB;AACzC;AACA;AACA;AACA,eAAe,YAAY;AAC3B,yBAAyB,oDAAG;AAC5B;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sHAAwB;AACtD;AACA;AACA;AACA;AACA;AACA,8DAA8D,WAAW,YAAY,gBAAgB;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,6FAAsB;AAC/D,yCAAyC,6FAAsB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sHAAwB;AAC5D,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uCAAuC;AACvD,kCAAkC,6FAAsB;AACxD,oCAAoC,6FAAsB;AAC1D,wBAAwB,gCAAgC;AACxD;AACA;AACA;AACA;AACA;AACA,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0FAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,sHAAwB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,6FAAsB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2BAA2B,6BAA6B,SAAS,6DAA6D,mDAAmD,UAAU,SAAS,0JAA0J,2BAA2B;AACnZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,IAAI,sHAAqB,8FAA8F;AAC7I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+GAAc;AAC7B;AACA;AACA,0BAA0B,0FAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,wDAAK;AAC5C,2CAA2C,wDAAK;AAChD,qCAAqC,wDAAK;AAC1C,qCAAqC,wDAAK;AAC1C,2CAA2C,wDAAK;AAChD,0BAA0B,wDAAK;AAC/B;AACA;AACA,wCAAwC;AACxC,wCAAwC;AACxC,8CAA8C;AAC9C,0CAA0C;AAC1C,qBAAqB;AACrB,iDAAiD;AACjD,4BAA4B;AAC5B,+DAA+D;AAC/D,iCAAiC;AACjC;AACA;AACA,wBAAwB;AACxB,2BAA2B;AAC3B;AACwQ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvP1N;AACwB;AACT;AACyD;AACrB;AACrB;AACwC;AAC5B;AAC+B;AACpB;AACnG,0BAA0B,2EAAQ,IAAI,gGAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB,gEAAU;AAC5B;AACA;AACA,kBAAkB,gEAAU;AAC5B;AACA;AACA,kBAAkB,gEAAU;AAC5B;AACA;AACA;AACA;AACA,8BAA8B,6FAAsB;AACpD,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,iDAAQ;AAClB;AACA;AACA;AACA,UAAU,iDAAQ;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA,mCAAmC,iDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,2BAA2B,iDAAQ;AACnC;AACA,SAAS;AACT;AACA,2BAA2B,iDAAQ;AACnC;AACA,SAAS;AACT;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2FAAoB;AAClD,qBAAqB;AACrB;AACA;AACA;AACA,8CAA8C,iDAAQ;AACtD,qBAAqB;AACrB;AACA,SAAS;AACT;AACA;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA,mCAAmC,iDAAQ;AAC3C;AACA,iBAAiB;AACjB;AACA,mCAAmC,iDAAQ;AAC3C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA,2BAA2B,iDAAQ;AACnC,SAAS;AACT;AACA;AACA,kCAAkC,iDAAQ;AAC1C,SAAS;AACT;AACA,mCAAmC,iDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kGAAe;AACvD,8DAA8D,kGAAe;AAC7E;AACA,SAAS;AACT;AACA,mCAAmC,iDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAQ;AAC1B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA,4CAA4C,aAAa;AACzD,qBAAqB;AACrB;AACA;AACA,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA,2CAA2C,YAAY;AACvD,qBAAqB;AACrB;AACA;AACA,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA,gDAAgD,OAAO;AACvD,qBAAqB;AACrB;AACA;AACA,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA,+DAA+D,OAAO;AACtE,qBAAqB;AACrB;AACA;AACA,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA,mDAAmD,cAAc;AACjE,qBAAqB;AACrB;AACA;AACA,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA,4CAA4C,WAAW;AACvD,qBAAqB;AACrB;AACA;AACA,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA,8CAA8C,SAAS;AACvD,qBAAqB;AACrB;AACA;AACA,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA,+CAA+C,SAAS;AACxD,qBAAqB;AACrB;AACA;AACA,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA,0CAA0C,SAAS;AACnD,qBAAqB;AACrB;AACA;AACA,wCAAwC,SAAS;AACjD,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,gDAAgD,WAAW;AAC3D,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,4CAA4C,OAAO;AACnD,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,yDAAyD,4BAA4B;AACrF,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA,4CAA4C,cAAc;AAC1D,qBAAqB;AACrB;AACA;AACA,mDAAmD,aAAa;AAChE,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,2DAA2D,aAAa;AACxE,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,+CAA+C,gBAAgB;AAC/D,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C,qBAAqB;AACrB;AACA;AACA,mDAAmD,gBAAgB;AACnE,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qDAAqD,SAAS;AAC9D,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,iDAAQ;AAC/C,qBAAqB;AACrB;AACA;AACA,uCAAuC,iDAAQ;AAC/C,qBAAqB;AACrB;AACA;AACA,uCAAuC,iDAAQ;AAC/C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,2BAA2B,iDAAQ;AACnC;AACA,8FAA8F,UAAU,GAAG,KAAK;AAChH;AACA;AACA;AACA;AACA;AACA,yBAAyB,qHAA4B;AACrD;AACA,SAAS;AACT;AACA,2BAA2B,iDAAQ;AACnC;AACA,gHAAgH,UAAU,GAAG,KAAK;AAClI;AACA;AACA;AACA;AACA;AACA,yBAAyB,qHAA4B;AACrD;AACA,SAAS;AACT;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iDAAQ;AAC3C;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,mCAAmC,iDAAQ;AAC3C;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,mCAAmC,iDAAQ;AAC3C;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,mCAAmC,iDAAQ;AAC3C;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,mCAAmC,iDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA,mCAAmC,iDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA,0BAA0B,0BAA0B,cAAc,UAAU,mBAAmB,EAAE,KAAK;AACtG,0BAA0B,wBAAwB,kCAAkC,EAAE,KAAK;AAC3F;AACA;AACA;AACA;AACA,mDAAmD,iDAAQ;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,iDAAQ;AAC1C;AACA;AACA;AACA,kCAAkC,iDAAQ;AAC1C;AACA;AACA;AACA,kCAAkC,iDAAQ;AAC1C;AACA,yBAAyB;AACzB;AACA;AACA,mDAAmD,iDAAQ;AAC3D;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,mCAAmC,iDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,QAAQ,cAAc,UAAU,mBAAmB,EAAE,KAAK;AACpF;AACA;AACA;AACA,mDAAmD,iDAAQ;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,iDAAQ;AAC1C;AACA;AACA;AACA,kCAAkC,iDAAQ;AAC1C;AACA;AACA;AACA,kCAAkC,iDAAQ;AAC1C;AACA,yBAAyB;AACzB;AACA,2CAA2C,iDAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,mDAAmD,iDAAQ;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA,kBAAkB,QAAQ,QAAQ,SAAS,KAAK;AAChD;AACA;AACA;AACA,mCAAmC,iDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,mCAAmC,iDAAQ;AAC3C;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,mCAAmC,iDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,2BAA2B,iDAAQ;AACnC,SAAS;AACT;AACA;AACA,2BAA2B,iDAAQ;AACnC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mCAAmC,iDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sHAAwB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAAQ;AACR,8BAA8B,2EAAQ;AACtC;AACA,8BAA8B,uFAAe;AAC7C;AACA;AACA,2BAA2B,iDAAQ;AACnC;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,kGAAe;AAChE,0EAA0E,kGAAe;AACzF;AACA,qBAAqB;AACrB;AACA;AACA;AACA,CAAC;AACiI;;;;;;;;;;;;;;;;;ACtwBzC;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qEAAiB;AAC3C;AACA;AAC4C;;;;;;;;;;;;;;;;;;ACrE5C;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8G;;;;;;;;;;;;;;;;;;;;;;;;;;ACtB1C;AACP;AACwC;AACR;AAClC;AACwB;AACT;AACN;AAC+C;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,4DAAQ;AACzC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iEAAU;AACpC,aAAa;AACb,aAAa;AACb;AACA;AACA;AACA,gEAAgE,0DAAO;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gEAAe,QAAQ,SAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,mEAAgB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gEAAQ;AACvC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6EAAqB;AACpC;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA,4DAA4D,eAAe;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C;AACA,2BAA2B,6EAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C;AACA,2BAA2B,6EAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6EAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,6EAAqB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,gFAA2B,QAAQ,GAAG,OAAO;AACrH;AACA;AACA;AACA;AACA,kDAAkD,iFAAuB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,gFAA2B;AAC5E;AACA;AACA;AACA;AACA,gEAAgE,gFAA2B;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gEAAmB;AAC5C;AACA;AACA,+BAA+B,2EAAiB;AAChD;AACA;AACA;AACA,kCAAkC,gEAAQ;AAC1C;AACA;AACA;AACA;AACA,6BAA6B,wDAAW;AACxC,iCAAiC,sEAAe;AAChD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,uEAAuE,gFAA2B,QAAQ,GAAG,WAAW;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,4DAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,uBAAuB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,uBAAuB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iBAAiB;AACrD;AACA;AACA,mCAAmC,8EAA6B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD,kCAAkC,4DAAQ;AAC1C;AACA;AACA,kCAAkC,8EAA6B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA,mCAAmC,4DAAQ;AAC3C,wCAAwC;AACxC;AACA;AACA,wCAAwC;AACxC;AACA,wCAAwC,8EAA6B;AACrE,4BAA4B,gCAAgC;AAC5D,wCAAwC,iBAAiB,4DAAQ;AACjE;AACA;AACA,wCAAwC,iBAAiB,4DAAQ;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4DAAQ;AACnC,yBAAyB,4DAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4DAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,4DAAQ;AACxC;AACA;AACA,gCAAgC,8EAA6B;AAC7D,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4DAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4DAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA,qBAAqB,8EAA6B;AAClD;AACA;AACA,4CAA4C,sFAA8B;AAC1E;AACA;AACA;AACA,wBAAwB,4DAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmF;;;;;;;;;;;;;;;;;;;;;;;;;AC5wBnB;AACX;AAC6B;AACS;AACQ;AAChC;AACI;AACgB;AACf;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mBAAmB,EAAE,2EAAoB;AACrD,oDAAoD,iBAAiB;AACrE,qIAAqI;AACrI;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,8BAA8B,mEAAQ,CAAC,oDAAG;AAC1C,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iFAAuB;AACrD;AACA;AACA;AACA,0DAA0D,kBAAkB,+DAA+D,uBAAuB;AAClK,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,aAAa,2EAAmB;AAChC,YAAY,yEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA,sCAAsC,uBAAuB;AAC7D;AACA;AACA;AACA,8CAA8C,kGAAqB;AACnE,uCAAuC,4EAAc;AACrD,6DAA6D,wEAAY;AACzE,4DAA4D,0FAAiB,CAAC,oDAAG;AACjF;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,aAAa,2EAAmB;AAChC;AACA;AACA;AACA,KAAK;AACL;AACwE;;;;;;;;;;;;;;;AC3FxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kBAAkB;AAClB;AACA,SAAS;AACT;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mBAAmB,KAAK,YAAY;AACnE,+CAA+C,gCAAgC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,kEAAkE,gBAAgB;AAClF;AACA,SAAS;AACT;AACA,6DAA6D,gBAAgB;AAC7E;AACA,SAAS;AACT;AACA;AACA;AACwB;;;;;;;;;;;;;;;;;;;;;;;AC5FiE;AAC5B;AACA;AACO;AACpE;AACA,qCAAqC,kBAAkB;AACvD;AACA;AACA,wBAAwB,4DAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oEAAY;AAClC;AACA;AACA;AACA;AACA;AACA,8BAA8B,iCAAiC;AAC/D;AACA;AACA;AACA;AACA;AACA,wBAAwB,EAAE,EAAE,EAAE,GAAG,oEAAY,CAAC,4DAAQ,0CAA0C;AAChG,2BAA2B,QAAQ,4DAAO,+BAA+B;AACzE;AACA;AACA,4BAA4B,4DAAO;AACnC;AACA;AACA,sBAAsB,oEAAY;AAClC,2BAA2B,iCAAiC;AAC5D;AACA;AACA,wBAAwB,oEAAY,CAAC,4DAAQ,0CAA0C;AACvF,2BAA2B,QAAQ,4DAAO,mCAAmC;AAC7E;AACA;AACA;AACA,gCAAgC,4DAAW;AAC3C;AACA;AACA,2BAA2B,4DAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjEzC;AACiB;AACS;AACrF;AACA;AACA;AACA;AACA;AACA,gCAAgC,oFAAa;AAC7C,yCAAyC,oFAAa;AACtD,mDAAmD,oFAAa;AAChE,0CAA0C,oFAAa;AACvD,qDAAqD,oFAAa;AAClE,yCAAyC,oFAAa;AACtD;AACA;AACA;AACA;AACA;AACA,CAAC,0DAA0D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,0DAAO;AAClD;AACA,yCAAyC,0DAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAAQ;AACR,4CAA4C,oFAAa;AAC+Q;;;;;;;;;;;;;;;;ACpD3O;AAC7F,uBAAuB,gGAAe;AACd;;;;;;;;;;;;;;;;ACFqE;AAC7F,8BAA8B,gGAAe;AACd;;;;;;;;;;;;;;;;;;;;;;;;ACF4C;AACO;AACT;AACjB;AACQ;AACC;AACyE;AACzD;AACF;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,2DAAK;AAC5D;AACA;AACA;AACA,6DAA6D,2DAAK;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,2BAA2B;AAC5D;AACA;AACA;AACA;AACA;AACA,uCAAuC,8DAAQ;AAC/C;AACA;AACA;AACA,+CAA+C,uCAAuC;AACtF,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,mCAAmC,4EAAc;AACjD,aAAa;AACb,SAAS;AACT;AACA;AACA,mCAAmC,iFAAuB;AAC1D;AACA,iDAAiD,wFAA8B;AAC/E;AACA;AACA,kDAAkD,kEAA0B;AAC5E;AACA;AACA,+BAA+B,gFAAiB;AAChD;AACA,sCAAsC,uDAAe;AACrD;AACA,4CAA4C,mFAAmF;AAC/H,SAAS;AACT;AACA;AACA;AACA,yBAAyB,gEAAS;AAClC;AACA;AACA,kCAAkC,gEAAS;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,uDAAK;AAC9C;AACA,2CAA2C,8DAAQ;AACnD,mDAAmD,+DAA+D;AAClH;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sEAA0B;AACnD;AACA;AACA,sBAAsB,sEAA0B;AAChD,SAAS;AACT;AACA;AACA;AACA,8BAA8B,sEAA0B;AACxD,iBAAiB;AACjB;AACA,yBAAyB,gEAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,eAAe;AACzC;AACA,+BAA+B,8DAAQ;AACvC,uCAAuC,kEAAkE;AACzG;AACA;AACA,+BAA+B,8DAAQ;AACvC,8BAA8B,6DAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,yBAAyB,4BAA4B;AACrD;AACA;AACA;AACA,+BAA+B,wDAAY;AAC3C,gDAAgD,OAAO;AACvD;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iFAAuB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mEAAQ;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AAC6B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/S0D;AAChB;AACN;AACA;AACH;AACD;AACA;AAC4B;AACc;AACQ;AACjC;AACzB;AACuC;AAC9C;AAC6D;AAC9B;AACwB;AACd;AACe;AACZ;AAClB;AACT;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD,kEAAkE,uFAAiB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA,sEAAsE,kBAAkB;AACxF;AACA,SAAS;AACT,kEAAkE,uFAAiB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gEAAQ;AACxC;AACA,oEAAoE,gEAAmB;AACvF;AACA;AACA,qBAAqB;AACrB;AACA,gHAAgH,gEAAmB;AACnI;AACA;AACA;AACA;AACA;AACA,uCAAuC,4DAAW;AAClD;AACA;AACA;AACA,gCAAgC,4DAAO;AACvC;AACA;AACA,mCAAmC,yEAAc;AACjD;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA,gCAAgC,8DAAQ;AACxC,gBAAgB,uEAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA,oBAAoB,mFAA0B;AAC9C;AACA;AACA;AACA,qBAAqB,mFAA0B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,gGAAsB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gEAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iEAAS,8BAA8B,4DAAO;AACrE;AACA;AACA,SAAS;AACT,uBAAuB,oEAAO;AAC9B;AACA,sBAAsB,8DAAK;AAC3B,sBAAsB,8DAAK;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wDAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA,YAAY,gEAAU;AACtB;AACA,0EAA0E,4DAAO;AACjF;AACA,mEAAmE,kBAAkB;AACrF,qBAAqB;AACrB;AACA;AACA,gCAAgC,qDAAG,MAAM,+DAAS;AAClD,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,qCAAqC,uDAAK;AAC1C;AACA,wDAAwD,oBAAoB;AAC5E,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,+EAAsB,cAAc;AACpH;AACA;AACA;AACA,kBAAkB;AAClB,aAAa,WAAW,6DAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,kDAAkD,kDAAQ,0CAA0C,EAAE;AACtG;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B,GAAG,YAAY;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,sDAAsD,2FAAiB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qDAAG;AAC7B;AACA;AACA,4DAA4D,qDAAG;AAC/D;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,4FAA4F,kEAAO;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,qBAAqB;AACvF;AACA;AACA,qCAAqC;AACrC,wDAAwD;AACxD;AACA,2BAA2B,qDAAG,iBAAiB,mEAAQ;AACvD;AACA;AACA;AACA;AACA,cAAc;AACd,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wEAAU;AAC5B,OAAO,qEAAO,IAAI,2GAAqB;AACvC,OAAO,qEAAO,IAAI,sGAAwB;AAC1C,OAAO,qEAAO,IAAI,gGAAoB;AACtC,OAAO,qEAAO,IAAI,6EAAW;AAC7B,OAAO,qEAAO,IAAI,8EAAY;AAC9B,OAAO,qEAAO,IAAI,qGAAmB;AACrC;AACA;AACA,iDAAiD,EAAE;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,kBAAkB,cAAc;AACzE;AACA;AACA;AACA,cAAc,oEAAc;AAC5B;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gEAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uEAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uEAAY;AACpD;AACA,8CAA8C,kBAAkB;AAChE;AACA;AACA,8CAA8C,kBAAkB,GAAG,QAAQ;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACoF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrhBlB;AACH;AACO;AACD;AACN;AACJ;AACa;AACJ;AACN;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kEAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,8BAA8B,qEAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8DAAK,cAAc,kEAAS;AAC9C,kBAAkB,8DAAK,cAAc,kEAAS;AAC9C;AACA;AACA;AACA,qCAAqC,2DAAK;AAC1C;AACA;AACA;AACA,yCAAyC,2DAAK;AAC9C;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAe;AACnC,oCAAoC,8DAAQ;AAC5C,mDAAmD,2DAAK;AACxD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2EAAmB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,gDAAgD;AAChD;AACA,SAAS;AACT;AACA,kEAAkE;AAClE;AACA,2EAA2E,2DAAK;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,2DAAK;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iEAAU;AAC1B;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,KAAK;AACL;AACA;AACA;AACA;AACA;AACsb;;;;;;;;;;;;;;;;ACtTzV;AAC7F,yBAAyB,gGAAe;AACd;;;;;;;;;;;;;;;;;;;;;;;ACF4C;AACJ;AACa;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,SAAS;AACpG;AACA,qCAAqC,gEAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,2CAA2C,2EAAmC;AAC9E,+CAA+C,2EAAmC;AAClF;AACA;AACA;AACA;AACA,yBAAyB,+DAAO;AAChC,+BAA+B,+DAAO;AACtC;AACA,qBAAqB;AACrB,SAAS;AACT,qBAAqB,kEAAkB;AACvC;AACA;AACA,qBAAqB,oEAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gEAAQ;AAC3B,wEAAwE,gCAAgC;AACxG;AACA,0CAA0C,yCAAyC,KAAK,iBAAiB;AACzG;AACA;AACA;AACA;AACA;AACA,yBAAyB,gEAAQ,CAAC,+DAAO;AACzC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gEAAQ;AAC3B,0EAA0E,gCAAgC;AAC1G;AACA,0CAA0C,yCAAyC,KAAK,iBAAiB;AACzG;AACA;AACA;AACA;AACA;AACA,yBAAyB,gEAAQ,CAAC,+DAAO;AACzC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsL;;;;;;;;;;;;;;;;;;AChJtL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA;AACA;AACA,CAAC,sEAAsE;AACmC;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzB5C;AACoB;AACT;AACZ;AACF;AAC2B;AACL;AAC5B;AACiI;AAC7H;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,iFAAuB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,kEAAkB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,kEAAkB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,+BAA+B,4EAAc;AAC7C;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kEAAkB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kEAAkB;AACvC;AACA;AACA,+BAA+B,gFAAiB;AAChD;AACA,sCAAsC,uDAAe;AACrD,4CAA4C,8CAA8C;AAC1F,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,4DAAO;AACxE,oBAAoB,+DAAmB;AACvC,sDAAsD,kEAAO;AAC7D,qBAAqB;AACrB;AACA,uCAAuC,uEAAY;AACnD;AACA,6FAA6F,8DAAQ;AACrG,wBAAwB,iEAAU;AAClC;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,kEAA0B;AAC3E,yDAAyD,2EAAmC;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sEAA0B;AACnD;AACA;AACA,sBAAsB,sEAA0B;AAChD,SAAS;AACT;AACA;AACA;AACA,8BAA8B,sEAA0B;AACxD,iBAAiB;AACjB;AACA,yBAAyB,gEAAoB;AAC7C;AACA,sBAAsB,oDAAG;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,kEAAO;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kEAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2E;;;;;;;;;;;;;AC7SD;;;;;;;SCA1E;SACA;;SAEA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;;SAEA;SACA;;SAEA;SACA;SACA;;SAEA;SACA;;;;;UCzBA;UACA;UACA;UACA;UACA,+BAA+B,wCAAwC;UACvE;UACA;UACA;UACA;UACA,iBAAiB,qBAAqB;UACtC;UACA;UACA,kBAAkB,qBAAqB;UACvC;UACA;UACA,KAAK;UACL;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;;;;UC3BA;UACA;UACA;UACA;UACA,yCAAyC,wCAAwC;UACjF;UACA;UACA;;;;;UCPA;;;;;UCAA;UACA;UACA;UACA,uDAAuD,iBAAiB;UACxE;UACA,gDAAgD,aAAa;UAC7D;;;;;UCNA;;UAEA;UACA;UACA;UACA;UACA;UACA;;UAEA;;UAEA;;UAEA;;UAEA;;UAEA;;UAEA;;;;;SEnBA;SACA;SACA;SACA;SACA","sources":["webpack://immt-editor/./node_modules/marked/lib/marked.esm.js","webpack://immt-editor/./node_modules/vscode/_virtual/semver.js","webpack://immt-editor/./node_modules/vscode/_virtual/semver2.js","webpack://immt-editor/./node_modules/vscode/external/tslib/tslib.es6.js","webpack://immt-editor/./node_modules/vscode/external/vscode-semver/semver.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/base/common/actions.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/base/common/comparers.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/base/common/dataTransfer.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/base/common/date.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/base/common/decorators.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/base/common/errorMessage.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/base/common/filters.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/base/common/glob.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/base/common/htmlContent.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/base/common/iconLabels.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/base/common/idGenerator.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/base/common/json.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/base/common/jsonSchema.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/base/common/labels.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/base/common/marshalling.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/base/common/mime.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/base/common/naturalLanguage/korean.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/base/common/numbers.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/base/common/performance.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/base/common/prefixTree.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/base/common/severity.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/base/common/ternarySearchTree.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/base/common/themables.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/base/common/uriIpc.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/base/common/uuid.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/editor/common/config/editorOptions.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/editor/common/core/stringBuilder.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/editor/common/core/textChange.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/editor/common/core/textModelDefaults.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/editor/common/languageSelector.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/editor/common/languages/languageConfiguration.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/editor/common/services/semanticTokensDto.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/editor/common/services/treeViewsDnd.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/configuration/common/configuration.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/configuration/common/configuration.service.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/configuration/common/configurationModels.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/configuration/common/configurationRegistry.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/contextkey/common/contextkey.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/contextkey/common/contextkey.service.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/contextkey/common/scanner.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/extensionManagement/common/extensionManagement.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/extensionManagement/common/extensionManagementUtil.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/extensionManagement/common/implicitActivationEvents.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/extensions/common/extensionValidator.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/extensions/common/extensions.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/extensions/common/extensionsApiProposals.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/files/common/files.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/files/common/watcher.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/instantiation/common/descriptors.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/instantiation/common/extensions.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/instantiation/common/graph.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/instantiation/common/instantiation.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/instantiation/common/instantiationService.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/instantiation/common/serviceCollection.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/jsonschemas/common/jsonContributionRegistry.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/log/common/log.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/log/common/log.service.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/log/common/logService.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/markers/common/markers.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/notification/common/notification.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/product/common/productService.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/product/common/productService.service.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/progress/common/progress.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/progress/common/progress.service.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/registry/common/platform.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/remote/common/remoteAuthorityResolver.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/remote/common/remoteHosts.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/request/common/request.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/request/common/request.service.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/storage/common/storage.service.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/telemetry/common/telemetry.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/telemetry/common/telemetryUtils.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/terminal/common/environmentVariableShared.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/terminal/common/terminalDataBuffering.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/theme/common/iconRegistry.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/tunnel/common/tunnel.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/uriIdentity/common/uriIdentity.service.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/userDataProfile/common/userDataProfile.service.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/workspace/common/editSessions.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/workspace/common/workspace.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/platform/workspace/common/workspace.service.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/cache.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHost.api.impl.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHost.common.services.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHost.protocol.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostAiRelatedInformation.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostApiCommands.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostApiDeprecationService.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostAuthentication.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostBulkEdits.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostChatAgents2.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostChatVariables.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostClipboard.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostCodeInsets.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostCodeMapper.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostCommands.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostComments.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostConfiguration.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostConsoleForwarder.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostCustomEditors.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostDebugService.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostDecorations.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostDiagnostics.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostDialogs.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostDocumentContentProviders.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostDocumentData.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostDocumentSaveParticipant.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostDocuments.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostDocumentsAndEditors.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostEditorTabs.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostEmbedding.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostEmbeddingVector.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostExtensionActivator.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostExtensionService.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostFileSystem.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostFileSystemConsumer.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostFileSystemEventService.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostFileSystemInfo.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostInitDataService.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostInteractive.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostLabelService.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostLanguageFeatures.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostLanguageModelTools.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostLanguageModels.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostLanguages.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostLocalizationService.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostLogService.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostLoggerService.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostManagedSockets.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostMemento.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostMessageService.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostNotebook.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostNotebookDocument.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostNotebookDocumentSaveParticipant.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostNotebookDocuments.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostNotebookEditor.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostNotebookEditors.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostNotebookKernels.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostNotebookRenderers.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostOutput.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostProfileContentHandler.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostProgress.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostQuickDiff.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostQuickOpen.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostRequireInterceptor.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostRpcService.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostSCM.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostSearch.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostSecretState.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostSecrets.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostShare.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostSpeech.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostStatusBar.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostStorage.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostStoragePaths.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostTask.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostTelemetry.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostTerminalService.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostTerminalShellIntegration.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostTestItem.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostTesting.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostTestingPrivateApi.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostTextEditor.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostTextEditors.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostTheming.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostTimeline.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostTreeViews.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostTunnelService.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostTypeConverters.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostTypes.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostUriOpener.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostUriTransformerService.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostUrls.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostVariableResolverService.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostWebview.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostWebviewMessaging.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostWebviewPanels.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostWebviewView.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostWindow.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extHostWorkspace.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/common/extensionHostMain.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/worker/extHost.worker.services.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/worker/extHostConsoleForwarder.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/worker/extHostExtensionService.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/worker/extensionHostWorker.esm.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/api/worker/extensionHostWorker.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/common/configuration.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/common/editor.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/common/views.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/contrib/chat/common/chatAgents.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/contrib/chat/common/chatContextKeys.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/contrib/chat/common/chatService.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/contrib/debug/common/abstractDebugAdapter.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/contrib/debug/common/debug.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/contrib/debug/common/debugUtils.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/contrib/notebook/common/notebookCommon.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/contrib/notebook/common/notebookExecutionService.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/contrib/notebook/common/notebookKernelService.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/contrib/search/common/cellSearchModel.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/contrib/search/common/searchNotebookHelpers.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/contrib/tasks/common/taskDefinitionRegistry.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/contrib/tasks/common/tasks.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/contrib/testing/common/testId.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/contrib/testing/common/testItemCollection.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/contrib/testing/common/testTypes.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/contrib/webview/common/webview.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/services/authentication/common/authentication.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/services/configurationResolver/common/configurationResolver.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/services/configurationResolver/common/variableResolver.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/services/editor/common/editorGroupsService.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/services/editor/common/editorGroupsService.service.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/services/editor/common/editorResolverService.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/services/editor/common/editorService.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/services/extensions/common/extensionDescriptionRegistry.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/services/extensions/common/extensionHostProtocol.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/services/extensions/common/extensions.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/services/extensions/common/extensionsRegistry.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/services/extensions/common/lazyPromise.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/services/extensions/common/proxyIdentifier.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/services/extensions/common/rpcProtocol.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/services/extensions/common/workspaceContains.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/services/extensions/worker/polyfillNestedWorker.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/services/notebook/common/notebookDocumentService.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/services/output/common/output.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/services/path/common/pathService.service.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/services/remote/common/remoteAgentService.service.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/services/search/common/fileSearchManager.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/services/search/common/queryBuilder.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/services/search/common/search.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/services/search/common/search.service.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/services/search/common/searchExtConversionTypes.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/services/search/common/searchExtTypes.js","webpack://immt-editor/./node_modules/vscode/vscode/src/vs/workbench/services/search/common/textSearchManager.js","webpack://immt-editor/./node_modules/vscode/workers/extensionHost.worker.js","webpack://immt-editor/webpack/bootstrap","webpack://immt-editor/webpack/runtime/chunk loaded","webpack://immt-editor/webpack/runtime/define property getters","webpack://immt-editor/webpack/runtime/hasOwnProperty shorthand","webpack://immt-editor/webpack/runtime/make namespace object","webpack://immt-editor/webpack/runtime/import chunk loading","webpack://immt-editor/webpack/before-startup","webpack://immt-editor/webpack/startup","webpack://immt-editor/webpack/after-startup"],"sourcesContent":["/**\n * marked v14.0.0 - a markdown parser\n * Copyright (c) 2011-2024, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */\n\n/**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */\n\n/**\n * Gets the original marked default options.\n */\nfunction _getDefaults() {\n    return {\n        async: false,\n        breaks: false,\n        extensions: null,\n        gfm: true,\n        hooks: null,\n        pedantic: false,\n        renderer: null,\n        silent: false,\n        tokenizer: null,\n        walkTokens: null,\n    };\n}\nlet _defaults = _getDefaults();\nfunction changeDefaults(newDefaults) {\n    _defaults = newDefaults;\n}\n\n/**\n * Helpers\n */\nconst escapeTest = /[&<>\"']/;\nconst escapeReplace = new RegExp(escapeTest.source, 'g');\nconst escapeTestNoEncode = /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/;\nconst escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, 'g');\nconst escapeReplacements = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;',\n};\nconst getEscapeReplacement = (ch) => escapeReplacements[ch];\nfunction escape$1(html, encode) {\n    if (encode) {\n        if (escapeTest.test(html)) {\n            return html.replace(escapeReplace, getEscapeReplacement);\n        }\n    }\n    else {\n        if (escapeTestNoEncode.test(html)) {\n            return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n        }\n    }\n    return html;\n}\nconst caret = /(^|[^\\[])\\^/g;\nfunction edit(regex, opt) {\n    let source = typeof regex === 'string' ? regex : regex.source;\n    opt = opt || '';\n    const obj = {\n        replace: (name, val) => {\n            let valSource = typeof val === 'string' ? val : val.source;\n            valSource = valSource.replace(caret, '$1');\n            source = source.replace(name, valSource);\n            return obj;\n        },\n        getRegex: () => {\n            return new RegExp(source, opt);\n        },\n    };\n    return obj;\n}\nfunction cleanUrl(href) {\n    try {\n        href = encodeURI(href).replace(/%25/g, '%');\n    }\n    catch {\n        return null;\n    }\n    return href;\n}\nconst noopTest = { exec: () => null };\nfunction splitCells(tableRow, count) {\n    // ensure that every cell-delimiting pipe has a space\n    // before it to distinguish it from an escaped pipe\n    const row = tableRow.replace(/\\|/g, (match, offset, str) => {\n        let escaped = false;\n        let curr = offset;\n        while (--curr >= 0 && str[curr] === '\\\\')\n            escaped = !escaped;\n        if (escaped) {\n            // odd number of slashes means | is escaped\n            // so we leave it alone\n            return '|';\n        }\n        else {\n            // add space before unescaped |\n            return ' |';\n        }\n    }), cells = row.split(/ \\|/);\n    let i = 0;\n    // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n    if (!cells[0].trim()) {\n        cells.shift();\n    }\n    if (cells.length > 0 && !cells[cells.length - 1].trim()) {\n        cells.pop();\n    }\n    if (count) {\n        if (cells.length > count) {\n            cells.splice(count);\n        }\n        else {\n            while (cells.length < count)\n                cells.push('');\n        }\n    }\n    for (; i < cells.length; i++) {\n        // leading or trailing whitespace is ignored per the gfm spec\n        cells[i] = cells[i].trim().replace(/\\\\\\|/g, '|');\n    }\n    return cells;\n}\n/**\n * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n * /c*$/ is vulnerable to REDOS.\n *\n * @param str\n * @param c\n * @param invert Remove suffix of non-c chars instead. Default falsey.\n */\nfunction rtrim(str, c, invert) {\n    const l = str.length;\n    if (l === 0) {\n        return '';\n    }\n    // Length of suffix matching the invert condition.\n    let suffLen = 0;\n    // Step left until we fail to match the invert condition.\n    while (suffLen < l) {\n        const currChar = str.charAt(l - suffLen - 1);\n        if (currChar === c && !invert) {\n            suffLen++;\n        }\n        else if (currChar !== c && invert) {\n            suffLen++;\n        }\n        else {\n            break;\n        }\n    }\n    return str.slice(0, l - suffLen);\n}\nfunction findClosingBracket(str, b) {\n    if (str.indexOf(b[1]) === -1) {\n        return -1;\n    }\n    let level = 0;\n    for (let i = 0; i < str.length; i++) {\n        if (str[i] === '\\\\') {\n            i++;\n        }\n        else if (str[i] === b[0]) {\n            level++;\n        }\n        else if (str[i] === b[1]) {\n            level--;\n            if (level < 0) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}\n\nfunction outputLink(cap, link, raw, lexer) {\n    const href = link.href;\n    const title = link.title ? escape$1(link.title) : null;\n    const text = cap[1].replace(/\\\\([\\[\\]])/g, '$1');\n    if (cap[0].charAt(0) !== '!') {\n        lexer.state.inLink = true;\n        const token = {\n            type: 'link',\n            raw,\n            href,\n            title,\n            text,\n            tokens: lexer.inlineTokens(text),\n        };\n        lexer.state.inLink = false;\n        return token;\n    }\n    return {\n        type: 'image',\n        raw,\n        href,\n        title,\n        text: escape$1(text),\n    };\n}\nfunction indentCodeCompensation(raw, text) {\n    const matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n    if (matchIndentToCode === null) {\n        return text;\n    }\n    const indentToCode = matchIndentToCode[1];\n    return text\n        .split('\\n')\n        .map(node => {\n        const matchIndentInNode = node.match(/^\\s+/);\n        if (matchIndentInNode === null) {\n            return node;\n        }\n        const [indentInNode] = matchIndentInNode;\n        if (indentInNode.length >= indentToCode.length) {\n            return node.slice(indentToCode.length);\n        }\n        return node;\n    })\n        .join('\\n');\n}\n/**\n * Tokenizer\n */\nclass _Tokenizer {\n    options;\n    rules; // set by the lexer\n    lexer; // set by the lexer\n    constructor(options) {\n        this.options = options || _defaults;\n    }\n    space(src) {\n        const cap = this.rules.block.newline.exec(src);\n        if (cap && cap[0].length > 0) {\n            return {\n                type: 'space',\n                raw: cap[0],\n            };\n        }\n    }\n    code(src) {\n        const cap = this.rules.block.code.exec(src);\n        if (cap) {\n            const text = cap[0].replace(/^ {1,4}/gm, '');\n            return {\n                type: 'code',\n                raw: cap[0],\n                codeBlockStyle: 'indented',\n                text: !this.options.pedantic\n                    ? rtrim(text, '\\n')\n                    : text,\n            };\n        }\n    }\n    fences(src) {\n        const cap = this.rules.block.fences.exec(src);\n        if (cap) {\n            const raw = cap[0];\n            const text = indentCodeCompensation(raw, cap[3] || '');\n            return {\n                type: 'code',\n                raw,\n                lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, '$1') : cap[2],\n                text,\n            };\n        }\n    }\n    heading(src) {\n        const cap = this.rules.block.heading.exec(src);\n        if (cap) {\n            let text = cap[2].trim();\n            // remove trailing #s\n            if (/#$/.test(text)) {\n                const trimmed = rtrim(text, '#');\n                if (this.options.pedantic) {\n                    text = trimmed.trim();\n                }\n                else if (!trimmed || / $/.test(trimmed)) {\n                    // CommonMark requires space before trailing #s\n                    text = trimmed.trim();\n                }\n            }\n            return {\n                type: 'heading',\n                raw: cap[0],\n                depth: cap[1].length,\n                text,\n                tokens: this.lexer.inline(text),\n            };\n        }\n    }\n    hr(src) {\n        const cap = this.rules.block.hr.exec(src);\n        if (cap) {\n            return {\n                type: 'hr',\n                raw: rtrim(cap[0], '\\n'),\n            };\n        }\n    }\n    blockquote(src) {\n        const cap = this.rules.block.blockquote.exec(src);\n        if (cap) {\n            let lines = rtrim(cap[0], '\\n').split('\\n');\n            let raw = '';\n            let text = '';\n            const tokens = [];\n            while (lines.length > 0) {\n                let inBlockquote = false;\n                const currentLines = [];\n                let i;\n                for (i = 0; i < lines.length; i++) {\n                    // get lines up to a continuation\n                    if (/^ {0,3}>/.test(lines[i])) {\n                        currentLines.push(lines[i]);\n                        inBlockquote = true;\n                    }\n                    else if (!inBlockquote) {\n                        currentLines.push(lines[i]);\n                    }\n                    else {\n                        break;\n                    }\n                }\n                lines = lines.slice(i);\n                const currentRaw = currentLines.join('\\n');\n                const currentText = currentRaw\n                    // precede setext continuation with 4 spaces so it isn't a setext\n                    .replace(/\\n {0,3}((?:=+|-+) *)(?=\\n|$)/g, '\\n    $1')\n                    .replace(/^ {0,3}>[ \\t]?/gm, '');\n                raw = raw ? `${raw}\\n${currentRaw}` : currentRaw;\n                text = text ? `${text}\\n${currentText}` : currentText;\n                // parse blockquote lines as top level tokens\n                // merge paragraphs if this is a continuation\n                const top = this.lexer.state.top;\n                this.lexer.state.top = true;\n                this.lexer.blockTokens(currentText, tokens, true);\n                this.lexer.state.top = top;\n                // if there is no continuation then we are done\n                if (lines.length === 0) {\n                    break;\n                }\n                const lastToken = tokens[tokens.length - 1];\n                if (lastToken?.type === 'code') {\n                    // blockquote continuation cannot be preceded by a code block\n                    break;\n                }\n                else if (lastToken?.type === 'blockquote') {\n                    // include continuation in nested blockquote\n                    const oldToken = lastToken;\n                    const newText = oldToken.raw + '\\n' + lines.join('\\n');\n                    const newToken = this.blockquote(newText);\n                    tokens[tokens.length - 1] = newToken;\n                    raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;\n                    text = text.substring(0, text.length - oldToken.text.length) + newToken.text;\n                    break;\n                }\n                else if (lastToken?.type === 'list') {\n                    // include continuation in nested list\n                    const oldToken = lastToken;\n                    const newText = oldToken.raw + '\\n' + lines.join('\\n');\n                    const newToken = this.list(newText);\n                    tokens[tokens.length - 1] = newToken;\n                    raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;\n                    text = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;\n                    lines = newText.substring(tokens[tokens.length - 1].raw.length).split('\\n');\n                    continue;\n                }\n            }\n            return {\n                type: 'blockquote',\n                raw,\n                tokens,\n                text,\n            };\n        }\n    }\n    list(src) {\n        let cap = this.rules.block.list.exec(src);\n        if (cap) {\n            let bull = cap[1].trim();\n            const isordered = bull.length > 1;\n            const list = {\n                type: 'list',\n                raw: '',\n                ordered: isordered,\n                start: isordered ? +bull.slice(0, -1) : '',\n                loose: false,\n                items: [],\n            };\n            bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n            if (this.options.pedantic) {\n                bull = isordered ? bull : '[*+-]';\n            }\n            // Get next list item\n            const itemRegex = new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`);\n            let endsWithBlankLine = false;\n            // Check if current bullet point can start a new List Item\n            while (src) {\n                let endEarly = false;\n                let raw = '';\n                let itemContents = '';\n                if (!(cap = itemRegex.exec(src))) {\n                    break;\n                }\n                if (this.rules.block.hr.test(src)) { // End list if bullet was actually HR (possibly move into itemRegex?)\n                    break;\n                }\n                raw = cap[0];\n                src = src.substring(raw.length);\n                let line = cap[2].split('\\n', 1)[0].replace(/^\\t+/, (t) => ' '.repeat(3 * t.length));\n                let nextLine = src.split('\\n', 1)[0];\n                let blankLine = !line.trim();\n                let indent = 0;\n                if (this.options.pedantic) {\n                    indent = 2;\n                    itemContents = line.trimStart();\n                }\n                else if (blankLine) {\n                    indent = cap[1].length + 1;\n                }\n                else {\n                    indent = cap[2].search(/[^ ]/); // Find first non-space char\n                    indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n                    itemContents = line.slice(indent);\n                    indent += cap[1].length;\n                }\n                if (blankLine && /^ *$/.test(nextLine)) { // Items begin with at most one blank line\n                    raw += nextLine + '\\n';\n                    src = src.substring(nextLine.length + 1);\n                    endEarly = true;\n                }\n                if (!endEarly) {\n                    const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`);\n                    const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`);\n                    const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`);\n                    const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);\n                    // Check if following lines should be included in List Item\n                    while (src) {\n                        const rawLine = src.split('\\n', 1)[0];\n                        nextLine = rawLine;\n                        // Re-align to follow commonmark nesting rules\n                        if (this.options.pedantic) {\n                            nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ');\n                        }\n                        // End list item if found code fences\n                        if (fencesBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new heading\n                        if (headingBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new bullet\n                        if (nextBulletRegex.test(nextLine)) {\n                            break;\n                        }\n                        // Horizontal rule found\n                        if (hrRegex.test(src)) {\n                            break;\n                        }\n                        if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) { // Dedent if possible\n                            itemContents += '\\n' + nextLine.slice(indent);\n                        }\n                        else {\n                            // not enough indentation\n                            if (blankLine) {\n                                break;\n                            }\n                            // paragraph continuation unless last line was a different block level element\n                            if (line.search(/[^ ]/) >= 4) { // indented code block\n                                break;\n                            }\n                            if (fencesBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (headingBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (hrRegex.test(line)) {\n                                break;\n                            }\n                            itemContents += '\\n' + nextLine;\n                        }\n                        if (!blankLine && !nextLine.trim()) { // Check if current line is blank\n                            blankLine = true;\n                        }\n                        raw += rawLine + '\\n';\n                        src = src.substring(rawLine.length + 1);\n                        line = nextLine.slice(indent);\n                    }\n                }\n                if (!list.loose) {\n                    // If the previous item ended with a blank line, the list is loose\n                    if (endsWithBlankLine) {\n                        list.loose = true;\n                    }\n                    else if (/\\n *\\n *$/.test(raw)) {\n                        endsWithBlankLine = true;\n                    }\n                }\n                let istask = null;\n                let ischecked;\n                // Check for task list items\n                if (this.options.gfm) {\n                    istask = /^\\[[ xX]\\] /.exec(itemContents);\n                    if (istask) {\n                        ischecked = istask[0] !== '[ ] ';\n                        itemContents = itemContents.replace(/^\\[[ xX]\\] +/, '');\n                    }\n                }\n                list.items.push({\n                    type: 'list_item',\n                    raw,\n                    task: !!istask,\n                    checked: ischecked,\n                    loose: false,\n                    text: itemContents,\n                    tokens: [],\n                });\n                list.raw += raw;\n            }\n            // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n            list.items[list.items.length - 1].raw = list.items[list.items.length - 1].raw.trimEnd();\n            list.items[list.items.length - 1].text = list.items[list.items.length - 1].text.trimEnd();\n            list.raw = list.raw.trimEnd();\n            // Item child tokens handled here at end because we needed to have the final item to trim it first\n            for (let i = 0; i < list.items.length; i++) {\n                this.lexer.state.top = false;\n                list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n                if (!list.loose) {\n                    // Check if list should be loose\n                    const spacers = list.items[i].tokens.filter(t => t.type === 'space');\n                    const hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => /\\n.*\\n/.test(t.raw));\n                    list.loose = hasMultipleLineBreaks;\n                }\n            }\n            // Set all items to loose if list is loose\n            if (list.loose) {\n                for (let i = 0; i < list.items.length; i++) {\n                    list.items[i].loose = true;\n                }\n            }\n            return list;\n        }\n    }\n    html(src) {\n        const cap = this.rules.block.html.exec(src);\n        if (cap) {\n            const token = {\n                type: 'html',\n                block: true,\n                raw: cap[0],\n                pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',\n                text: cap[0],\n            };\n            return token;\n        }\n    }\n    def(src) {\n        const cap = this.rules.block.def.exec(src);\n        if (cap) {\n            const tag = cap[1].toLowerCase().replace(/\\s+/g, ' ');\n            const href = cap[2] ? cap[2].replace(/^<(.*)>$/, '$1').replace(this.rules.inline.anyPunctuation, '$1') : '';\n            const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, '$1') : cap[3];\n            return {\n                type: 'def',\n                tag,\n                raw: cap[0],\n                href,\n                title,\n            };\n        }\n    }\n    table(src) {\n        const cap = this.rules.block.table.exec(src);\n        if (!cap) {\n            return;\n        }\n        if (!/[:|]/.test(cap[2])) {\n            // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading\n            return;\n        }\n        const headers = splitCells(cap[1]);\n        const aligns = cap[2].replace(/^\\||\\| *$/g, '').split('|');\n        const rows = cap[3] && cap[3].trim() ? cap[3].replace(/\\n[ \\t]*$/, '').split('\\n') : [];\n        const item = {\n            type: 'table',\n            raw: cap[0],\n            header: [],\n            align: [],\n            rows: [],\n        };\n        if (headers.length !== aligns.length) {\n            // header and align columns must be equal, rows can be different.\n            return;\n        }\n        for (const align of aligns) {\n            if (/^ *-+: *$/.test(align)) {\n                item.align.push('right');\n            }\n            else if (/^ *:-+: *$/.test(align)) {\n                item.align.push('center');\n            }\n            else if (/^ *:-+ *$/.test(align)) {\n                item.align.push('left');\n            }\n            else {\n                item.align.push(null);\n            }\n        }\n        for (let i = 0; i < headers.length; i++) {\n            item.header.push({\n                text: headers[i],\n                tokens: this.lexer.inline(headers[i]),\n                header: true,\n                align: item.align[i],\n            });\n        }\n        for (const row of rows) {\n            item.rows.push(splitCells(row, item.header.length).map((cell, i) => {\n                return {\n                    text: cell,\n                    tokens: this.lexer.inline(cell),\n                    header: false,\n                    align: item.align[i],\n                };\n            }));\n        }\n        return item;\n    }\n    lheading(src) {\n        const cap = this.rules.block.lheading.exec(src);\n        if (cap) {\n            return {\n                type: 'heading',\n                raw: cap[0],\n                depth: cap[2].charAt(0) === '=' ? 1 : 2,\n                text: cap[1],\n                tokens: this.lexer.inline(cap[1]),\n            };\n        }\n    }\n    paragraph(src) {\n        const cap = this.rules.block.paragraph.exec(src);\n        if (cap) {\n            const text = cap[1].charAt(cap[1].length - 1) === '\\n'\n                ? cap[1].slice(0, -1)\n                : cap[1];\n            return {\n                type: 'paragraph',\n                raw: cap[0],\n                text,\n                tokens: this.lexer.inline(text),\n            };\n        }\n    }\n    text(src) {\n        const cap = this.rules.block.text.exec(src);\n        if (cap) {\n            return {\n                type: 'text',\n                raw: cap[0],\n                text: cap[0],\n                tokens: this.lexer.inline(cap[0]),\n            };\n        }\n    }\n    escape(src) {\n        const cap = this.rules.inline.escape.exec(src);\n        if (cap) {\n            return {\n                type: 'escape',\n                raw: cap[0],\n                text: escape$1(cap[1]),\n            };\n        }\n    }\n    tag(src) {\n        const cap = this.rules.inline.tag.exec(src);\n        if (cap) {\n            if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {\n                this.lexer.state.inLink = true;\n            }\n            else if (this.lexer.state.inLink && /^<\\/a>/i.test(cap[0])) {\n                this.lexer.state.inLink = false;\n            }\n            if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n                this.lexer.state.inRawBlock = true;\n            }\n            else if (this.lexer.state.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n                this.lexer.state.inRawBlock = false;\n            }\n            return {\n                type: 'html',\n                raw: cap[0],\n                inLink: this.lexer.state.inLink,\n                inRawBlock: this.lexer.state.inRawBlock,\n                block: false,\n                text: cap[0],\n            };\n        }\n    }\n    link(src) {\n        const cap = this.rules.inline.link.exec(src);\n        if (cap) {\n            const trimmedUrl = cap[2].trim();\n            if (!this.options.pedantic && /^</.test(trimmedUrl)) {\n                // commonmark requires matching angle brackets\n                if (!(/>$/.test(trimmedUrl))) {\n                    return;\n                }\n                // ending angle bracket cannot be escaped\n                const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\\\');\n                if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n                    return;\n                }\n            }\n            else {\n                // find closing parenthesis\n                const lastParenIndex = findClosingBracket(cap[2], '()');\n                if (lastParenIndex > -1) {\n                    const start = cap[0].indexOf('!') === 0 ? 5 : 4;\n                    const linkLen = start + cap[1].length + lastParenIndex;\n                    cap[2] = cap[2].substring(0, lastParenIndex);\n                    cap[0] = cap[0].substring(0, linkLen).trim();\n                    cap[3] = '';\n                }\n            }\n            let href = cap[2];\n            let title = '';\n            if (this.options.pedantic) {\n                // split pedantic href and title\n                const link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n                if (link) {\n                    href = link[1];\n                    title = link[3];\n                }\n            }\n            else {\n                title = cap[3] ? cap[3].slice(1, -1) : '';\n            }\n            href = href.trim();\n            if (/^</.test(href)) {\n                if (this.options.pedantic && !(/>$/.test(trimmedUrl))) {\n                    // pedantic allows starting angle bracket without ending angle bracket\n                    href = href.slice(1);\n                }\n                else {\n                    href = href.slice(1, -1);\n                }\n            }\n            return outputLink(cap, {\n                href: href ? href.replace(this.rules.inline.anyPunctuation, '$1') : href,\n                title: title ? title.replace(this.rules.inline.anyPunctuation, '$1') : title,\n            }, cap[0], this.lexer);\n        }\n    }\n    reflink(src, links) {\n        let cap;\n        if ((cap = this.rules.inline.reflink.exec(src))\n            || (cap = this.rules.inline.nolink.exec(src))) {\n            const linkString = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n            const link = links[linkString.toLowerCase()];\n            if (!link) {\n                const text = cap[0].charAt(0);\n                return {\n                    type: 'text',\n                    raw: text,\n                    text,\n                };\n            }\n            return outputLink(cap, link, cap[0], this.lexer);\n        }\n    }\n    emStrong(src, maskedSrc, prevChar = '') {\n        let match = this.rules.inline.emStrongLDelim.exec(src);\n        if (!match)\n            return;\n        // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n        if (match[3] && prevChar.match(/[\\p{L}\\p{N}]/u))\n            return;\n        const nextChar = match[1] || match[2] || '';\n        if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n            // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)\n            const lLength = [...match[0]].length - 1;\n            let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n            const endReg = match[0][0] === '*' ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;\n            endReg.lastIndex = 0;\n            // Clip maskedSrc to same section of string as src (move to lexer?)\n            maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n            while ((match = endReg.exec(maskedSrc)) != null) {\n                rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n                if (!rDelim)\n                    continue; // skip single * in __abc*abc__\n                rLength = [...rDelim].length;\n                if (match[3] || match[4]) { // found another Left Delim\n                    delimTotal += rLength;\n                    continue;\n                }\n                else if (match[5] || match[6]) { // either Left or Right Delim\n                    if (lLength % 3 && !((lLength + rLength) % 3)) {\n                        midDelimTotal += rLength;\n                        continue; // CommonMark Emphasis Rules 9-10\n                    }\n                }\n                delimTotal -= rLength;\n                if (delimTotal > 0)\n                    continue; // Haven't found enough closing delimiters\n                // Remove extra characters. *a*** -> *a*\n                rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n                // char length can be >1 for unicode characters;\n                const lastCharLength = [...match[0]][0].length;\n                const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);\n                // Create `em` if smallest delimiter has odd char count. *a***\n                if (Math.min(lLength, rLength) % 2) {\n                    const text = raw.slice(1, -1);\n                    return {\n                        type: 'em',\n                        raw,\n                        text,\n                        tokens: this.lexer.inlineTokens(text),\n                    };\n                }\n                // Create 'strong' if smallest delimiter has even char count. **a***\n                const text = raw.slice(2, -2);\n                return {\n                    type: 'strong',\n                    raw,\n                    text,\n                    tokens: this.lexer.inlineTokens(text),\n                };\n            }\n        }\n    }\n    codespan(src) {\n        const cap = this.rules.inline.code.exec(src);\n        if (cap) {\n            let text = cap[2].replace(/\\n/g, ' ');\n            const hasNonSpaceChars = /[^ ]/.test(text);\n            const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);\n            if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n                text = text.substring(1, text.length - 1);\n            }\n            text = escape$1(text, true);\n            return {\n                type: 'codespan',\n                raw: cap[0],\n                text,\n            };\n        }\n    }\n    br(src) {\n        const cap = this.rules.inline.br.exec(src);\n        if (cap) {\n            return {\n                type: 'br',\n                raw: cap[0],\n            };\n        }\n    }\n    del(src) {\n        const cap = this.rules.inline.del.exec(src);\n        if (cap) {\n            return {\n                type: 'del',\n                raw: cap[0],\n                text: cap[2],\n                tokens: this.lexer.inlineTokens(cap[2]),\n            };\n        }\n    }\n    autolink(src) {\n        const cap = this.rules.inline.autolink.exec(src);\n        if (cap) {\n            let text, href;\n            if (cap[2] === '@') {\n                text = escape$1(cap[1]);\n                href = 'mailto:' + text;\n            }\n            else {\n                text = escape$1(cap[1]);\n                href = text;\n            }\n            return {\n                type: 'link',\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: 'text',\n                        raw: text,\n                        text,\n                    },\n                ],\n            };\n        }\n    }\n    url(src) {\n        let cap;\n        if (cap = this.rules.inline.url.exec(src)) {\n            let text, href;\n            if (cap[2] === '@') {\n                text = escape$1(cap[0]);\n                href = 'mailto:' + text;\n            }\n            else {\n                // do extended autolink path validation\n                let prevCapZero;\n                do {\n                    prevCapZero = cap[0];\n                    cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? '';\n                } while (prevCapZero !== cap[0]);\n                text = escape$1(cap[0]);\n                if (cap[1] === 'www.') {\n                    href = 'http://' + cap[0];\n                }\n                else {\n                    href = cap[0];\n                }\n            }\n            return {\n                type: 'link',\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: 'text',\n                        raw: text,\n                        text,\n                    },\n                ],\n            };\n        }\n    }\n    inlineText(src) {\n        const cap = this.rules.inline.text.exec(src);\n        if (cap) {\n            let text;\n            if (this.lexer.state.inRawBlock) {\n                text = cap[0];\n            }\n            else {\n                text = escape$1(cap[0]);\n            }\n            return {\n                type: 'text',\n                raw: cap[0],\n                text,\n            };\n        }\n    }\n}\n\n/**\n * Block-Level Grammar\n */\nconst newline = /^(?: *(?:\\n|$))+/;\nconst blockCode = /^( {4}[^\\n]+(?:\\n(?: *(?:\\n|$))*)?)+/;\nconst fences = /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/;\nconst hr = /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/;\nconst heading = /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/;\nconst bullet = /(?:[*+-]|\\d{1,9}[.)])/;\nconst lheading = edit(/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\\n(?!\\s*?\\n|bull |blockCode|fences|blockquote|heading|html))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/)\n    .replace(/bull/g, bullet) // lists can interrupt\n    .replace(/blockCode/g, / {4}/) // indented code blocks can interrupt\n    .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n    .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n    .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n    .replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n    .getRegex();\nconst _paragraph = /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/;\nconst blockText = /^[^\\n]+/;\nconst _blockLabel = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\nconst def = edit(/^ {0,3}\\[(label)\\]: *(?:\\n *)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n *)?| *\\n *)(title))? *(?:\\n+|$)/)\n    .replace('label', _blockLabel)\n    .replace('title', /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/)\n    .getRegex();\nconst list = edit(/^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/)\n    .replace(/bull/g, bullet)\n    .getRegex();\nconst _tag = 'address|article|aside|base|basefont|blockquote|body|caption'\n    + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'\n    + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'\n    + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'\n    + '|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title'\n    + '|tr|track|ul';\nconst _comment = /<!--(?:-?>|[\\s\\S]*?(?:-->|$))/;\nconst html = edit('^ {0,3}(?:' // optional indentation\n    + '<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n    + '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n    + '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n    + '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n    + '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n    + '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (6)\n    + '|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (7) open tag\n    + '|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (7) closing tag\n    + ')', 'i')\n    .replace('comment', _comment)\n    .replace('tag', _tag)\n    .replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/)\n    .getRegex();\nconst paragraph = edit(_paragraph)\n    .replace('hr', hr)\n    .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n    .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n    .replace('|table', '')\n    .replace('blockquote', ' {0,3}>')\n    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n    .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n    .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n    .getRegex();\nconst blockquote = edit(/^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/)\n    .replace('paragraph', paragraph)\n    .getRegex();\n/**\n * Normal Block Grammar\n */\nconst blockNormal = {\n    blockquote,\n    code: blockCode,\n    def,\n    fences,\n    heading,\n    hr,\n    html,\n    lheading,\n    list,\n    newline,\n    paragraph,\n    table: noopTest,\n    text: blockText,\n};\n/**\n * GFM Block Grammar\n */\nconst gfmTable = edit('^ *([^\\\\n ].*)\\\\n' // Header\n    + ' {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)' // Align\n    + '(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)') // Cells\n    .replace('hr', hr)\n    .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n    .replace('blockquote', ' {0,3}>')\n    .replace('code', ' {4}[^\\\\n]')\n    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n    .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n    .replace('tag', _tag) // tables can be interrupted by type (6) html blocks\n    .getRegex();\nconst blockGfm = {\n    ...blockNormal,\n    table: gfmTable,\n    paragraph: edit(_paragraph)\n        .replace('hr', hr)\n        .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n        .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n        .replace('table', gfmTable) // interrupt paragraphs with table\n        .replace('blockquote', ' {0,3}>')\n        .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n        .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n        .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n        .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n        .getRegex(),\n};\n/**\n * Pedantic grammar (original John Gruber's loose markdown specification)\n */\nconst blockPedantic = {\n    ...blockNormal,\n    html: edit('^ *(?:comment *(?:\\\\n|\\\\s*$)'\n        + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n        + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))')\n        .replace('comment', _comment)\n        .replace(/tag/g, '(?!(?:'\n        + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'\n        + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'\n        + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b')\n        .getRegex(),\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n    heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n    fences: noopTest, // fences not supported\n    lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n    paragraph: edit(_paragraph)\n        .replace('hr', hr)\n        .replace('heading', ' *#{1,6} *[^\\n]')\n        .replace('lheading', lheading)\n        .replace('|table', '')\n        .replace('blockquote', ' {0,3}>')\n        .replace('|fences', '')\n        .replace('|list', '')\n        .replace('|html', '')\n        .replace('|tag', '')\n        .getRegex(),\n};\n/**\n * Inline-Level Grammar\n */\nconst escape = /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/;\nconst inlineCode = /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/;\nconst br = /^( {2,}|\\\\)\\n(?!\\s*$)/;\nconst inlineText = /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/;\n// list of unicode punctuation marks, plus any missing characters from CommonMark spec\nconst _punctuation = '\\\\p{P}\\\\p{S}';\nconst punctuation = edit(/^((?![*_])[\\spunctuation])/, 'u')\n    .replace(/punctuation/g, _punctuation).getRegex();\n// sequences em should skip over [title](link), `code`, <html>\nconst blockSkip = /\\[[^[\\]]*?\\]\\([^\\(\\)]*?\\)|`[^`]*?`|<[^<>]*?>/g;\nconst emStrongLDelim = edit(/^(?:\\*+(?:((?!\\*)[punct])|[^\\s*]))|^_+(?:((?!_)[punct])|([^\\s_]))/, 'u')\n    .replace(/punct/g, _punctuation)\n    .getRegex();\nconst emStrongRDelimAst = edit('^[^_*]*?__[^_*]*?\\\\*[^_*]*?(?=__)' // Skip orphan inside strong\n    + '|[^*]+(?=[^*])' // Consume to delim\n    + '|(?!\\\\*)[punct](\\\\*+)(?=[\\\\s]|$)' // (1) #*** can only be a Right Delimiter\n    + '|[^punct\\\\s](\\\\*+)(?!\\\\*)(?=[punct\\\\s]|$)' // (2) a***#, a*** can only be a Right Delimiter\n    + '|(?!\\\\*)[punct\\\\s](\\\\*+)(?=[^punct\\\\s])' // (3) #***a, ***a can only be Left Delimiter\n    + '|[\\\\s](\\\\*+)(?!\\\\*)(?=[punct])' // (4) ***# can only be Left Delimiter\n    + '|(?!\\\\*)[punct](\\\\*+)(?!\\\\*)(?=[punct])' // (5) #***# can be either Left or Right Delimiter\n    + '|[^punct\\\\s](\\\\*+)(?=[^punct\\\\s])', 'gu') // (6) a***a can be either Left or Right Delimiter\n    .replace(/punct/g, _punctuation)\n    .getRegex();\n// (6) Not allowed for _\nconst emStrongRDelimUnd = edit('^[^_*]*?\\\\*\\\\*[^_*]*?_[^_*]*?(?=\\\\*\\\\*)' // Skip orphan inside strong\n    + '|[^_]+(?=[^_])' // Consume to delim\n    + '|(?!_)[punct](_+)(?=[\\\\s]|$)' // (1) #___ can only be a Right Delimiter\n    + '|[^punct\\\\s](_+)(?!_)(?=[punct\\\\s]|$)' // (2) a___#, a___ can only be a Right Delimiter\n    + '|(?!_)[punct\\\\s](_+)(?=[^punct\\\\s])' // (3) #___a, ___a can only be Left Delimiter\n    + '|[\\\\s](_+)(?!_)(?=[punct])' // (4) ___# can only be Left Delimiter\n    + '|(?!_)[punct](_+)(?!_)(?=[punct])', 'gu') // (5) #___# can be either Left or Right Delimiter\n    .replace(/punct/g, _punctuation)\n    .getRegex();\nconst anyPunctuation = edit(/\\\\([punct])/, 'gu')\n    .replace(/punct/g, _punctuation)\n    .getRegex();\nconst autolink = edit(/^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/)\n    .replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)\n    .replace('email', /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/)\n    .getRegex();\nconst _inlineComment = edit(_comment).replace('(?:-->|$)', '-->').getRegex();\nconst tag = edit('^comment'\n    + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n    + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n    + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n    + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n    + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>') // CDATA section\n    .replace('comment', _inlineComment)\n    .replace('attribute', /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/)\n    .getRegex();\nconst _inlineLabel = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\nconst link = edit(/^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/)\n    .replace('label', _inlineLabel)\n    .replace('href', /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/)\n    .replace('title', /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/)\n    .getRegex();\nconst reflink = edit(/^!?\\[(label)\\]\\[(ref)\\]/)\n    .replace('label', _inlineLabel)\n    .replace('ref', _blockLabel)\n    .getRegex();\nconst nolink = edit(/^!?\\[(ref)\\](?:\\[\\])?/)\n    .replace('ref', _blockLabel)\n    .getRegex();\nconst reflinkSearch = edit('reflink|nolink(?!\\\\()', 'g')\n    .replace('reflink', reflink)\n    .replace('nolink', nolink)\n    .getRegex();\n/**\n * Normal Inline Grammar\n */\nconst inlineNormal = {\n    _backpedal: noopTest, // only used for GFM url\n    anyPunctuation,\n    autolink,\n    blockSkip,\n    br,\n    code: inlineCode,\n    del: noopTest,\n    emStrongLDelim,\n    emStrongRDelimAst,\n    emStrongRDelimUnd,\n    escape,\n    link,\n    nolink,\n    punctuation,\n    reflink,\n    reflinkSearch,\n    tag,\n    text: inlineText,\n    url: noopTest,\n};\n/**\n * Pedantic Inline Grammar\n */\nconst inlinePedantic = {\n    ...inlineNormal,\n    link: edit(/^!?\\[(label)\\]\\((.*?)\\)/)\n        .replace('label', _inlineLabel)\n        .getRegex(),\n    reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/)\n        .replace('label', _inlineLabel)\n        .getRegex(),\n};\n/**\n * GFM Inline Grammar\n */\nconst inlineGfm = {\n    ...inlineNormal,\n    escape: edit(escape).replace('])', '~|])').getRegex(),\n    url: edit(/^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/, 'i')\n        .replace('email', /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/)\n        .getRegex(),\n    _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n    del: /^(~~?)(?=[^\\s~])([\\s\\S]*?[^\\s~])\\1(?=[^~]|$)/,\n    text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/,\n};\n/**\n * GFM + Line Breaks Inline Grammar\n */\nconst inlineBreaks = {\n    ...inlineGfm,\n    br: edit(br).replace('{2,}', '*').getRegex(),\n    text: edit(inlineGfm.text)\n        .replace('\\\\b_', '\\\\b_| {2,}\\\\n')\n        .replace(/\\{2,\\}/g, '*')\n        .getRegex(),\n};\n/**\n * exports\n */\nconst block = {\n    normal: blockNormal,\n    gfm: blockGfm,\n    pedantic: blockPedantic,\n};\nconst inline = {\n    normal: inlineNormal,\n    gfm: inlineGfm,\n    breaks: inlineBreaks,\n    pedantic: inlinePedantic,\n};\n\n/**\n * Block Lexer\n */\nclass _Lexer {\n    tokens;\n    options;\n    state;\n    tokenizer;\n    inlineQueue;\n    constructor(options) {\n        // TokenList cannot be created in one go\n        this.tokens = [];\n        this.tokens.links = Object.create(null);\n        this.options = options || _defaults;\n        this.options.tokenizer = this.options.tokenizer || new _Tokenizer();\n        this.tokenizer = this.options.tokenizer;\n        this.tokenizer.options = this.options;\n        this.tokenizer.lexer = this;\n        this.inlineQueue = [];\n        this.state = {\n            inLink: false,\n            inRawBlock: false,\n            top: true,\n        };\n        const rules = {\n            block: block.normal,\n            inline: inline.normal,\n        };\n        if (this.options.pedantic) {\n            rules.block = block.pedantic;\n            rules.inline = inline.pedantic;\n        }\n        else if (this.options.gfm) {\n            rules.block = block.gfm;\n            if (this.options.breaks) {\n                rules.inline = inline.breaks;\n            }\n            else {\n                rules.inline = inline.gfm;\n            }\n        }\n        this.tokenizer.rules = rules;\n    }\n    /**\n     * Expose Rules\n     */\n    static get rules() {\n        return {\n            block,\n            inline,\n        };\n    }\n    /**\n     * Static Lex Method\n     */\n    static lex(src, options) {\n        const lexer = new _Lexer(options);\n        return lexer.lex(src);\n    }\n    /**\n     * Static Lex Inline Method\n     */\n    static lexInline(src, options) {\n        const lexer = new _Lexer(options);\n        return lexer.inlineTokens(src);\n    }\n    /**\n     * Preprocessing\n     */\n    lex(src) {\n        src = src\n            .replace(/\\r\\n|\\r/g, '\\n');\n        this.blockTokens(src, this.tokens);\n        for (let i = 0; i < this.inlineQueue.length; i++) {\n            const next = this.inlineQueue[i];\n            this.inlineTokens(next.src, next.tokens);\n        }\n        this.inlineQueue = [];\n        return this.tokens;\n    }\n    blockTokens(src, tokens = [], lastParagraphClipped = false) {\n        if (this.options.pedantic) {\n            src = src.replace(/\\t/g, '    ').replace(/^ +$/gm, '');\n        }\n        else {\n            src = src.replace(/^( *)(\\t+)/gm, (_, leading, tabs) => {\n                return leading + '    '.repeat(tabs.length);\n            });\n        }\n        let token;\n        let lastToken;\n        let cutSrc;\n        while (src) {\n            if (this.options.extensions\n                && this.options.extensions.block\n                && this.options.extensions.block.some((extTokenizer) => {\n                    if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n                        src = src.substring(token.raw.length);\n                        tokens.push(token);\n                        return true;\n                    }\n                    return false;\n                })) {\n                continue;\n            }\n            // newline\n            if (token = this.tokenizer.space(src)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.length === 1 && tokens.length > 0) {\n                    // if there's a single \\n as a spacer, it's terminating the last line,\n                    // so move it there so that we don't get unnecessary paragraph tags\n                    tokens[tokens.length - 1].raw += '\\n';\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.code(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                // An indented code block cannot interrupt a paragraph.\n                if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.text;\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // fences\n            if (token = this.tokenizer.fences(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // heading\n            if (token = this.tokenizer.heading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // hr\n            if (token = this.tokenizer.hr(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // blockquote\n            if (token = this.tokenizer.blockquote(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // list\n            if (token = this.tokenizer.list(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // html\n            if (token = this.tokenizer.html(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // def\n            if (token = this.tokenizer.def(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.raw;\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                }\n                else if (!this.tokens.links[token.tag]) {\n                    this.tokens.links[token.tag] = {\n                        href: token.href,\n                        title: token.title,\n                    };\n                }\n                continue;\n            }\n            // table (gfm)\n            if (token = this.tokenizer.table(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // lheading\n            if (token = this.tokenizer.lheading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // top-level paragraph\n            // prevent paragraph consuming extensions by clipping 'src' to extension start\n            cutSrc = src;\n            if (this.options.extensions && this.options.extensions.startBlock) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startBlock.forEach((getStartIndex) => {\n                    tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n                    if (typeof tempStart === 'number' && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n                lastToken = tokens[tokens.length - 1];\n                if (lastParagraphClipped && lastToken?.type === 'paragraph') {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                lastParagraphClipped = (cutSrc.length !== src.length);\n                src = src.substring(token.raw.length);\n                continue;\n            }\n            // text\n            if (token = this.tokenizer.text(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && lastToken.type === 'text') {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                }\n                else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        this.state.top = true;\n        return tokens;\n    }\n    inline(src, tokens = []) {\n        this.inlineQueue.push({ src, tokens });\n        return tokens;\n    }\n    /**\n     * Lexing/Compiling\n     */\n    inlineTokens(src, tokens = []) {\n        let token, lastToken, cutSrc;\n        // String with links masked to avoid interference with em and strong\n        let maskedSrc = src;\n        let match;\n        let keepPrevChar, prevChar;\n        // Mask out reflinks\n        if (this.tokens.links) {\n            const links = Object.keys(this.tokens.links);\n            if (links.length > 0) {\n                while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n                    if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n                        maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n                    }\n                }\n            }\n        }\n        // Mask out other blocks\n        while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n            maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n        }\n        // Mask out escaped characters\n        while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {\n            maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n        }\n        while (src) {\n            if (!keepPrevChar) {\n                prevChar = '';\n            }\n            keepPrevChar = false;\n            // extensions\n            if (this.options.extensions\n                && this.options.extensions.inline\n                && this.options.extensions.inline.some((extTokenizer) => {\n                    if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n                        src = src.substring(token.raw.length);\n                        tokens.push(token);\n                        return true;\n                    }\n                    return false;\n                })) {\n                continue;\n            }\n            // escape\n            if (token = this.tokenizer.escape(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // tag\n            if (token = this.tokenizer.tag(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // link\n            if (token = this.tokenizer.link(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // reflink, nolink\n            if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // em & strong\n            if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.codespan(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // br\n            if (token = this.tokenizer.br(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // del (gfm)\n            if (token = this.tokenizer.del(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // autolink\n            if (token = this.tokenizer.autolink(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // url (gfm)\n            if (!this.state.inLink && (token = this.tokenizer.url(src))) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // text\n            // prevent inlineText consuming extensions by clipping 'src' to extension start\n            cutSrc = src;\n            if (this.options.extensions && this.options.extensions.startInline) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startInline.forEach((getStartIndex) => {\n                    tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n                    if (typeof tempStart === 'number' && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (token = this.tokenizer.inlineText(cutSrc)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.slice(-1) !== '_') { // Track prevChar before string of ____ started\n                    prevChar = token.raw.slice(-1);\n                }\n                keepPrevChar = true;\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && lastToken.type === 'text') {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                }\n                else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        return tokens;\n    }\n}\n\n/**\n * Renderer\n */\nclass _Renderer {\n    options;\n    parser; // set by the parser\n    constructor(options) {\n        this.options = options || _defaults;\n    }\n    space(token) {\n        return '';\n    }\n    code({ text, lang, escaped }) {\n        const langString = (lang || '').match(/^\\S*/)?.[0];\n        const code = text.replace(/\\n$/, '') + '\\n';\n        if (!langString) {\n            return '<pre><code>'\n                + (escaped ? code : escape$1(code, true))\n                + '</code></pre>\\n';\n        }\n        return '<pre><code class=\"language-'\n            + escape$1(langString)\n            + '\">'\n            + (escaped ? code : escape$1(code, true))\n            + '</code></pre>\\n';\n    }\n    blockquote({ tokens }) {\n        const body = this.parser.parse(tokens);\n        return `<blockquote>\\n${body}</blockquote>\\n`;\n    }\n    html({ text }) {\n        return text;\n    }\n    heading({ tokens, depth }) {\n        return `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>\\n`;\n    }\n    hr(token) {\n        return '<hr>\\n';\n    }\n    list(token) {\n        const ordered = token.ordered;\n        const start = token.start;\n        let body = '';\n        for (let j = 0; j < token.items.length; j++) {\n            const item = token.items[j];\n            body += this.listitem(item);\n        }\n        const type = ordered ? 'ol' : 'ul';\n        const startAttr = (ordered && start !== 1) ? (' start=\"' + start + '\"') : '';\n        return '<' + type + startAttr + '>\\n' + body + '</' + type + '>\\n';\n    }\n    listitem(item) {\n        let itemBody = '';\n        if (item.task) {\n            const checkbox = this.checkbox({ checked: !!item.checked });\n            if (item.loose) {\n                if (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') {\n                    item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n                    if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {\n                        item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;\n                    }\n                }\n                else {\n                    item.tokens.unshift({\n                        type: 'text',\n                        raw: checkbox + ' ',\n                        text: checkbox + ' ',\n                    });\n                }\n            }\n            else {\n                itemBody += checkbox + ' ';\n            }\n        }\n        itemBody += this.parser.parse(item.tokens, !!item.loose);\n        return `<li>${itemBody}</li>\\n`;\n    }\n    checkbox({ checked }) {\n        return '<input '\n            + (checked ? 'checked=\"\" ' : '')\n            + 'disabled=\"\" type=\"checkbox\">';\n    }\n    paragraph({ tokens }) {\n        return `<p>${this.parser.parseInline(tokens)}</p>\\n`;\n    }\n    table(token) {\n        let header = '';\n        // header\n        let cell = '';\n        for (let j = 0; j < token.header.length; j++) {\n            cell += this.tablecell(token.header[j]);\n        }\n        header += this.tablerow({ text: cell });\n        let body = '';\n        for (let j = 0; j < token.rows.length; j++) {\n            const row = token.rows[j];\n            cell = '';\n            for (let k = 0; k < row.length; k++) {\n                cell += this.tablecell(row[k]);\n            }\n            body += this.tablerow({ text: cell });\n        }\n        if (body)\n            body = `<tbody>${body}</tbody>`;\n        return '<table>\\n'\n            + '<thead>\\n'\n            + header\n            + '</thead>\\n'\n            + body\n            + '</table>\\n';\n    }\n    tablerow({ text }) {\n        return `<tr>\\n${text}</tr>\\n`;\n    }\n    tablecell(token) {\n        const content = this.parser.parseInline(token.tokens);\n        const type = token.header ? 'th' : 'td';\n        const tag = token.align\n            ? `<${type} align=\"${token.align}\">`\n            : `<${type}>`;\n        return tag + content + `</${type}>\\n`;\n    }\n    /**\n     * span level renderer\n     */\n    strong({ tokens }) {\n        return `<strong>${this.parser.parseInline(tokens)}</strong>`;\n    }\n    em({ tokens }) {\n        return `<em>${this.parser.parseInline(tokens)}</em>`;\n    }\n    codespan({ text }) {\n        return `<code>${text}</code>`;\n    }\n    br(token) {\n        return '<br>';\n    }\n    del({ tokens }) {\n        return `<del>${this.parser.parseInline(tokens)}</del>`;\n    }\n    link({ href, title, tokens }) {\n        const text = this.parser.parseInline(tokens);\n        const cleanHref = cleanUrl(href);\n        if (cleanHref === null) {\n            return text;\n        }\n        href = cleanHref;\n        let out = '<a href=\"' + href + '\"';\n        if (title) {\n            out += ' title=\"' + title + '\"';\n        }\n        out += '>' + text + '</a>';\n        return out;\n    }\n    image({ href, title, text }) {\n        const cleanHref = cleanUrl(href);\n        if (cleanHref === null) {\n            return text;\n        }\n        href = cleanHref;\n        let out = `<img src=\"${href}\" alt=\"${text}\"`;\n        if (title) {\n            out += ` title=\"${title}\"`;\n        }\n        out += '>';\n        return out;\n    }\n    text(token) {\n        return 'tokens' in token && token.tokens ? this.parser.parseInline(token.tokens) : token.text;\n    }\n}\n\n/**\n * TextRenderer\n * returns only the textual part of the token\n */\nclass _TextRenderer {\n    // no need for block level renderers\n    strong({ text }) {\n        return text;\n    }\n    em({ text }) {\n        return text;\n    }\n    codespan({ text }) {\n        return text;\n    }\n    del({ text }) {\n        return text;\n    }\n    html({ text }) {\n        return text;\n    }\n    text({ text }) {\n        return text;\n    }\n    link({ text }) {\n        return '' + text;\n    }\n    image({ text }) {\n        return '' + text;\n    }\n    br() {\n        return '';\n    }\n}\n\n/**\n * Parsing & Compiling\n */\nclass _Parser {\n    options;\n    renderer;\n    textRenderer;\n    constructor(options) {\n        this.options = options || _defaults;\n        this.options.renderer = this.options.renderer || new _Renderer();\n        this.renderer = this.options.renderer;\n        this.renderer.options = this.options;\n        this.renderer.parser = this;\n        this.textRenderer = new _TextRenderer();\n    }\n    /**\n     * Static Parse Method\n     */\n    static parse(tokens, options) {\n        const parser = new _Parser(options);\n        return parser.parse(tokens);\n    }\n    /**\n     * Static Parse Inline Method\n     */\n    static parseInline(tokens, options) {\n        const parser = new _Parser(options);\n        return parser.parseInline(tokens);\n    }\n    /**\n     * Parse Loop\n     */\n    parse(tokens, top = true) {\n        let out = '';\n        for (let i = 0; i < tokens.length; i++) {\n            const anyToken = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[anyToken.type]) {\n                const genericToken = anyToken;\n                const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);\n                if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(genericToken.type)) {\n                    out += ret || '';\n                    continue;\n                }\n            }\n            const token = anyToken;\n            switch (token.type) {\n                case 'space': {\n                    out += this.renderer.space(token);\n                    continue;\n                }\n                case 'hr': {\n                    out += this.renderer.hr(token);\n                    continue;\n                }\n                case 'heading': {\n                    out += this.renderer.heading(token);\n                    continue;\n                }\n                case 'code': {\n                    out += this.renderer.code(token);\n                    continue;\n                }\n                case 'table': {\n                    out += this.renderer.table(token);\n                    continue;\n                }\n                case 'blockquote': {\n                    out += this.renderer.blockquote(token);\n                    continue;\n                }\n                case 'list': {\n                    out += this.renderer.list(token);\n                    continue;\n                }\n                case 'html': {\n                    out += this.renderer.html(token);\n                    continue;\n                }\n                case 'paragraph': {\n                    out += this.renderer.paragraph(token);\n                    continue;\n                }\n                case 'text': {\n                    let textToken = token;\n                    let body = this.renderer.text(textToken);\n                    while (i + 1 < tokens.length && tokens[i + 1].type === 'text') {\n                        textToken = tokens[++i];\n                        body += '\\n' + this.renderer.text(textToken);\n                    }\n                    if (top) {\n                        out += this.renderer.paragraph({\n                            type: 'paragraph',\n                            raw: body,\n                            text: body,\n                            tokens: [{ type: 'text', raw: body, text: body }],\n                        });\n                    }\n                    else {\n                        out += body;\n                    }\n                    continue;\n                }\n                default: {\n                    const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        return '';\n                    }\n                    else {\n                        throw new Error(errMsg);\n                    }\n                }\n            }\n        }\n        return out;\n    }\n    /**\n     * Parse Inline Tokens\n     */\n    parseInline(tokens, renderer) {\n        renderer = renderer || this.renderer;\n        let out = '';\n        for (let i = 0; i < tokens.length; i++) {\n            const anyToken = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[anyToken.type]) {\n                const ret = this.options.extensions.renderers[anyToken.type].call({ parser: this }, anyToken);\n                if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(anyToken.type)) {\n                    out += ret || '';\n                    continue;\n                }\n            }\n            const token = anyToken;\n            switch (token.type) {\n                case 'escape': {\n                    out += renderer.text(token);\n                    break;\n                }\n                case 'html': {\n                    out += renderer.html(token);\n                    break;\n                }\n                case 'link': {\n                    out += renderer.link(token);\n                    break;\n                }\n                case 'image': {\n                    out += renderer.image(token);\n                    break;\n                }\n                case 'strong': {\n                    out += renderer.strong(token);\n                    break;\n                }\n                case 'em': {\n                    out += renderer.em(token);\n                    break;\n                }\n                case 'codespan': {\n                    out += renderer.codespan(token);\n                    break;\n                }\n                case 'br': {\n                    out += renderer.br(token);\n                    break;\n                }\n                case 'del': {\n                    out += renderer.del(token);\n                    break;\n                }\n                case 'text': {\n                    out += renderer.text(token);\n                    break;\n                }\n                default: {\n                    const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        return '';\n                    }\n                    else {\n                        throw new Error(errMsg);\n                    }\n                }\n            }\n        }\n        return out;\n    }\n}\n\nclass _Hooks {\n    options;\n    constructor(options) {\n        this.options = options || _defaults;\n    }\n    static passThroughHooks = new Set([\n        'preprocess',\n        'postprocess',\n        'processAllTokens',\n    ]);\n    /**\n     * Process markdown before marked\n     */\n    preprocess(markdown) {\n        return markdown;\n    }\n    /**\n     * Process HTML after marked is finished\n     */\n    postprocess(html) {\n        return html;\n    }\n    /**\n     * Process all tokens before walk tokens\n     */\n    processAllTokens(tokens) {\n        return tokens;\n    }\n}\n\nclass Marked {\n    defaults = _getDefaults();\n    options = this.setOptions;\n    parse = this.parseMarkdown(_Lexer.lex, _Parser.parse);\n    parseInline = this.parseMarkdown(_Lexer.lexInline, _Parser.parseInline);\n    Parser = _Parser;\n    Renderer = _Renderer;\n    TextRenderer = _TextRenderer;\n    Lexer = _Lexer;\n    Tokenizer = _Tokenizer;\n    Hooks = _Hooks;\n    constructor(...args) {\n        this.use(...args);\n    }\n    /**\n     * Run callback for every token\n     */\n    walkTokens(tokens, callback) {\n        let values = [];\n        for (const token of tokens) {\n            values = values.concat(callback.call(this, token));\n            switch (token.type) {\n                case 'table': {\n                    const tableToken = token;\n                    for (const cell of tableToken.header) {\n                        values = values.concat(this.walkTokens(cell.tokens, callback));\n                    }\n                    for (const row of tableToken.rows) {\n                        for (const cell of row) {\n                            values = values.concat(this.walkTokens(cell.tokens, callback));\n                        }\n                    }\n                    break;\n                }\n                case 'list': {\n                    const listToken = token;\n                    values = values.concat(this.walkTokens(listToken.items, callback));\n                    break;\n                }\n                default: {\n                    const genericToken = token;\n                    if (this.defaults.extensions?.childTokens?.[genericToken.type]) {\n                        this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {\n                            const tokens = genericToken[childTokens].flat(Infinity);\n                            values = values.concat(this.walkTokens(tokens, callback));\n                        });\n                    }\n                    else if (genericToken.tokens) {\n                        values = values.concat(this.walkTokens(genericToken.tokens, callback));\n                    }\n                }\n            }\n        }\n        return values;\n    }\n    use(...args) {\n        const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };\n        args.forEach((pack) => {\n            // copy options to new object\n            const opts = { ...pack };\n            // set async to true if it was set to true before\n            opts.async = this.defaults.async || opts.async || false;\n            // ==-- Parse \"addon\" extensions --== //\n            if (pack.extensions) {\n                pack.extensions.forEach((ext) => {\n                    if (!ext.name) {\n                        throw new Error('extension name required');\n                    }\n                    if ('renderer' in ext) { // Renderer extensions\n                        const prevRenderer = extensions.renderers[ext.name];\n                        if (prevRenderer) {\n                            // Replace extension with func to run new extension but fall back if false\n                            extensions.renderers[ext.name] = function (...args) {\n                                let ret = ext.renderer.apply(this, args);\n                                if (ret === false) {\n                                    ret = prevRenderer.apply(this, args);\n                                }\n                                return ret;\n                            };\n                        }\n                        else {\n                            extensions.renderers[ext.name] = ext.renderer;\n                        }\n                    }\n                    if ('tokenizer' in ext) { // Tokenizer Extensions\n                        if (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) {\n                            throw new Error(\"extension level must be 'block' or 'inline'\");\n                        }\n                        const extLevel = extensions[ext.level];\n                        if (extLevel) {\n                            extLevel.unshift(ext.tokenizer);\n                        }\n                        else {\n                            extensions[ext.level] = [ext.tokenizer];\n                        }\n                        if (ext.start) { // Function to check for start of token\n                            if (ext.level === 'block') {\n                                if (extensions.startBlock) {\n                                    extensions.startBlock.push(ext.start);\n                                }\n                                else {\n                                    extensions.startBlock = [ext.start];\n                                }\n                            }\n                            else if (ext.level === 'inline') {\n                                if (extensions.startInline) {\n                                    extensions.startInline.push(ext.start);\n                                }\n                                else {\n                                    extensions.startInline = [ext.start];\n                                }\n                            }\n                        }\n                    }\n                    if ('childTokens' in ext && ext.childTokens) { // Child tokens to be visited by walkTokens\n                        extensions.childTokens[ext.name] = ext.childTokens;\n                    }\n                });\n                opts.extensions = extensions;\n            }\n            // ==-- Parse \"overwrite\" extensions --== //\n            if (pack.renderer) {\n                const renderer = this.defaults.renderer || new _Renderer(this.defaults);\n                for (const prop in pack.renderer) {\n                    if (!(prop in renderer)) {\n                        throw new Error(`renderer '${prop}' does not exist`);\n                    }\n                    if (['options', 'parser'].includes(prop)) {\n                        // ignore options property\n                        continue;\n                    }\n                    const rendererProp = prop;\n                    const rendererFunc = pack.renderer[rendererProp];\n                    const prevRenderer = renderer[rendererProp];\n                    // Replace renderer with func to run extension, but fall back if false\n                    renderer[rendererProp] = (...args) => {\n                        let ret = rendererFunc.apply(renderer, args);\n                        if (ret === false) {\n                            ret = prevRenderer.apply(renderer, args);\n                        }\n                        return ret || '';\n                    };\n                }\n                opts.renderer = renderer;\n            }\n            if (pack.tokenizer) {\n                const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);\n                for (const prop in pack.tokenizer) {\n                    if (!(prop in tokenizer)) {\n                        throw new Error(`tokenizer '${prop}' does not exist`);\n                    }\n                    if (['options', 'rules', 'lexer'].includes(prop)) {\n                        // ignore options, rules, and lexer properties\n                        continue;\n                    }\n                    const tokenizerProp = prop;\n                    const tokenizerFunc = pack.tokenizer[tokenizerProp];\n                    const prevTokenizer = tokenizer[tokenizerProp];\n                    // Replace tokenizer with func to run extension, but fall back if false\n                    // @ts-expect-error cannot type tokenizer function dynamically\n                    tokenizer[tokenizerProp] = (...args) => {\n                        let ret = tokenizerFunc.apply(tokenizer, args);\n                        if (ret === false) {\n                            ret = prevTokenizer.apply(tokenizer, args);\n                        }\n                        return ret;\n                    };\n                }\n                opts.tokenizer = tokenizer;\n            }\n            // ==-- Parse Hooks extensions --== //\n            if (pack.hooks) {\n                const hooks = this.defaults.hooks || new _Hooks();\n                for (const prop in pack.hooks) {\n                    if (!(prop in hooks)) {\n                        throw new Error(`hook '${prop}' does not exist`);\n                    }\n                    if (prop === 'options') {\n                        // ignore options property\n                        continue;\n                    }\n                    const hooksProp = prop;\n                    const hooksFunc = pack.hooks[hooksProp];\n                    const prevHook = hooks[hooksProp];\n                    if (_Hooks.passThroughHooks.has(prop)) {\n                        // @ts-expect-error cannot type hook function dynamically\n                        hooks[hooksProp] = (arg) => {\n                            if (this.defaults.async) {\n                                return Promise.resolve(hooksFunc.call(hooks, arg)).then(ret => {\n                                    return prevHook.call(hooks, ret);\n                                });\n                            }\n                            const ret = hooksFunc.call(hooks, arg);\n                            return prevHook.call(hooks, ret);\n                        };\n                    }\n                    else {\n                        // @ts-expect-error cannot type hook function dynamically\n                        hooks[hooksProp] = (...args) => {\n                            let ret = hooksFunc.apply(hooks, args);\n                            if (ret === false) {\n                                ret = prevHook.apply(hooks, args);\n                            }\n                            return ret;\n                        };\n                    }\n                }\n                opts.hooks = hooks;\n            }\n            // ==-- Parse WalkTokens extensions --== //\n            if (pack.walkTokens) {\n                const walkTokens = this.defaults.walkTokens;\n                const packWalktokens = pack.walkTokens;\n                opts.walkTokens = function (token) {\n                    let values = [];\n                    values.push(packWalktokens.call(this, token));\n                    if (walkTokens) {\n                        values = values.concat(walkTokens.call(this, token));\n                    }\n                    return values;\n                };\n            }\n            this.defaults = { ...this.defaults, ...opts };\n        });\n        return this;\n    }\n    setOptions(opt) {\n        this.defaults = { ...this.defaults, ...opt };\n        return this;\n    }\n    lexer(src, options) {\n        return _Lexer.lex(src, options ?? this.defaults);\n    }\n    parser(tokens, options) {\n        return _Parser.parse(tokens, options ?? this.defaults);\n    }\n    parseMarkdown(lexer, parser) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const parse = (src, options) => {\n            const origOpt = { ...options };\n            const opt = { ...this.defaults, ...origOpt };\n            const throwError = this.onError(!!opt.silent, !!opt.async);\n            // throw error if an extension set async to true but parse was called with async: false\n            if (this.defaults.async === true && origOpt.async === false) {\n                return throwError(new Error('marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.'));\n            }\n            // throw error in case of non string input\n            if (typeof src === 'undefined' || src === null) {\n                return throwError(new Error('marked(): input parameter is undefined or null'));\n            }\n            if (typeof src !== 'string') {\n                return throwError(new Error('marked(): input parameter is of type '\n                    + Object.prototype.toString.call(src) + ', string expected'));\n            }\n            if (opt.hooks) {\n                opt.hooks.options = opt;\n            }\n            if (opt.async) {\n                return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src)\n                    .then(src => lexer(src, opt))\n                    .then(tokens => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens)\n                    .then(tokens => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens)\n                    .then(tokens => parser(tokens, opt))\n                    .then(html => opt.hooks ? opt.hooks.postprocess(html) : html)\n                    .catch(throwError);\n            }\n            try {\n                if (opt.hooks) {\n                    src = opt.hooks.preprocess(src);\n                }\n                let tokens = lexer(src, opt);\n                if (opt.hooks) {\n                    tokens = opt.hooks.processAllTokens(tokens);\n                }\n                if (opt.walkTokens) {\n                    this.walkTokens(tokens, opt.walkTokens);\n                }\n                let html = parser(tokens, opt);\n                if (opt.hooks) {\n                    html = opt.hooks.postprocess(html);\n                }\n                return html;\n            }\n            catch (e) {\n                return throwError(e);\n            }\n        };\n        return parse;\n    }\n    onError(silent, async) {\n        return (e) => {\n            e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n            if (silent) {\n                const msg = '<p>An error occurred:</p><pre>'\n                    + escape$1(e.message + '', true)\n                    + '</pre>';\n                if (async) {\n                    return Promise.resolve(msg);\n                }\n                return msg;\n            }\n            if (async) {\n                return Promise.reject(e);\n            }\n            throw e;\n        };\n    }\n}\n\nconst markedInstance = new Marked();\nfunction marked(src, opt) {\n    return markedInstance.parse(src, opt);\n}\n/**\n * Sets the default options.\n *\n * @param options Hash of options\n */\nmarked.options =\n    marked.setOptions = function (options) {\n        markedInstance.setOptions(options);\n        marked.defaults = markedInstance.defaults;\n        changeDefaults(marked.defaults);\n        return marked;\n    };\n/**\n * Gets the original marked default options.\n */\nmarked.getDefaults = _getDefaults;\nmarked.defaults = _defaults;\n/**\n * Use Extension\n */\nmarked.use = function (...args) {\n    markedInstance.use(...args);\n    marked.defaults = markedInstance.defaults;\n    changeDefaults(marked.defaults);\n    return marked;\n};\n/**\n * Run callback for every token\n */\nmarked.walkTokens = function (tokens, callback) {\n    return markedInstance.walkTokens(tokens, callback);\n};\n/**\n * Compiles markdown to HTML without enclosing `p` tag.\n *\n * @param src String of markdown source to be compiled\n * @param options Hash of options\n * @return String of compiled HTML\n */\nmarked.parseInline = markedInstance.parseInline;\n/**\n * Expose\n */\nmarked.Parser = _Parser;\nmarked.parser = _Parser.parse;\nmarked.Renderer = _Renderer;\nmarked.TextRenderer = _TextRenderer;\nmarked.Lexer = _Lexer;\nmarked.lexer = _Lexer.lex;\nmarked.Tokenizer = _Tokenizer;\nmarked.Hooks = _Hooks;\nmarked.parse = marked;\nconst options = marked.options;\nconst setOptions = marked.setOptions;\nconst use = marked.use;\nconst walkTokens = marked.walkTokens;\nconst parseInline = marked.parseInline;\nconst parse = marked;\nconst parser = _Parser.parse;\nconst lexer = _Lexer.lex;\n\nexport { _Hooks as Hooks, _Lexer as Lexer, Marked, _Parser as Parser, _Renderer as Renderer, _TextRenderer as TextRenderer, _Tokenizer as Tokenizer, _defaults as defaults, _getDefaults as getDefaults, lexer, marked, options, parse, parseInline, parser, setOptions, use, walkTokens };\n//# sourceMappingURL=marked.esm.js.map\n","import { __require as requireSemver } from '../external/vscode-semver/semver.js';\nvar semverExports = requireSemver();\nexport { semverExports };\n","var semver = {exports: {}};\nexport { semver as __module };\n","function __decorate(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\nfunction __param(paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n}\nexport { __decorate, __param };\n","import { __module as semver } from '../../_virtual/semver2.js';\nvar hasRequiredSemver;\nfunction requireSemver () {\n\tif (hasRequiredSemver) return semver.exports;\n\thasRequiredSemver = 1;\n\t(function (module, exports) {\n\t\texports = module.exports = SemVer;\n\t\t var debug;\n\t\t if (typeof process === 'object' &&\n\t\t     process.env &&\n\t\t     process.env.NODE_DEBUG &&\n\t\t     /\\bsemver\\b/i.test(process.env.NODE_DEBUG))\n\t\t   debug = function() {\n\t\t     var args = Array.prototype.slice.call(arguments, 0);\n\t\t     args.unshift('SEMVER');\n\t\t     console.log.apply(console, args);\n\t\t     };\n\t\t else\n\t\t   debug = function() {};\n\t\texports.SEMVER_SPEC_VERSION = '2.0.0';\n\t\tvar MAX_LENGTH = 256;\n\t\tvar MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n\t\tvar MAX_SAFE_COMPONENT_LENGTH = 16;\n\t\tvar re = exports.re = [];\n\t\tvar src = exports.src = [];\n\t\tvar R = 0;\n\t\tvar NUMERICIDENTIFIER = R++;\n\t\tsrc[NUMERICIDENTIFIER] = '0|[1-9]\\\\d*';\n\t\tvar NUMERICIDENTIFIERLOOSE = R++;\n\t\tsrc[NUMERICIDENTIFIERLOOSE] = '[0-9]+';\n\t\tvar NONNUMERICIDENTIFIER = R++;\n\t\tsrc[NONNUMERICIDENTIFIER] = '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*';\n\t\tvar MAINVERSION = R++;\n\t\tsrc[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n\t\t                   '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n\t\t                   '(' + src[NUMERICIDENTIFIER] + ')';\n\t\tvar MAINVERSIONLOOSE = R++;\n\t\tsrc[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n\t\t                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n\t\t                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')';\n\t\tvar PRERELEASEIDENTIFIER = R++;\n\t\tsrc[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +\n\t\t                            '|' + src[NONNUMERICIDENTIFIER] + ')';\n\t\tvar PRERELEASEIDENTIFIERLOOSE = R++;\n\t\tsrc[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +\n\t\t                                 '|' + src[NONNUMERICIDENTIFIER] + ')';\n\t\tvar PRERELEASE = R++;\n\t\tsrc[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +\n\t\t                  '(?:\\\\.' + src[PRERELEASEIDENTIFIER] + ')*))';\n\t\tvar PRERELEASELOOSE = R++;\n\t\tsrc[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +\n\t\t                       '(?:\\\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';\n\t\tvar BUILDIDENTIFIER = R++;\n\t\tsrc[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';\n\t\tvar BUILD = R++;\n\t\tsrc[BUILD] = '(?:\\\\+(' + src[BUILDIDENTIFIER] +\n\t\t             '(?:\\\\.' + src[BUILDIDENTIFIER] + ')*))';\n\t\tvar FULL = R++;\n\t\tvar FULLPLAIN = 'v?' + src[MAINVERSION] +\n\t\t                src[PRERELEASE] + '?' +\n\t\t                src[BUILD] + '?';\n\t\tsrc[FULL] = '^' + FULLPLAIN + '$';\n\t\tvar LOOSEPLAIN = '[v=\\\\s]*' + src[MAINVERSIONLOOSE] +\n\t\t                 src[PRERELEASELOOSE] + '?' +\n\t\t                 src[BUILD] + '?';\n\t\tvar LOOSE = R++;\n\t\tsrc[LOOSE] = '^' + LOOSEPLAIN + '$';\n\t\tvar GTLT = R++;\n\t\tsrc[GTLT] = '((?:<|>)?=?)';\n\t\tvar XRANGEIDENTIFIERLOOSE = R++;\n\t\tsrc[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\\\*';\n\t\tvar XRANGEIDENTIFIER = R++;\n\t\tsrc[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\\\*';\n\t\tvar XRANGEPLAIN = R++;\n\t\tsrc[XRANGEPLAIN] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIER] + ')' +\n\t\t                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n\t\t                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n\t\t                   '(?:' + src[PRERELEASE] + ')?' +\n\t\t                   src[BUILD] + '?' +\n\t\t                   ')?)?';\n\t\tvar XRANGEPLAINLOOSE = R++;\n\t\tsrc[XRANGEPLAINLOOSE] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n\t\t                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n\t\t                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n\t\t                        '(?:' + src[PRERELEASELOOSE] + ')?' +\n\t\t                        src[BUILD] + '?' +\n\t\t                        ')?)?';\n\t\tvar XRANGE = R++;\n\t\tsrc[XRANGE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAIN] + '$';\n\t\tvar XRANGELOOSE = R++;\n\t\tsrc[XRANGELOOSE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAINLOOSE] + '$';\n\t\tvar COERCE = R++;\n\t\tsrc[COERCE] = '(?:^|[^\\\\d])' +\n\t\t              '(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +\n\t\t              '(?:\\\\.(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +\n\t\t              '(?:\\\\.(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +\n\t\t              '(?:$|[^\\\\d])';\n\t\tvar LONETILDE = R++;\n\t\tsrc[LONETILDE] = '(?:~>?)';\n\t\tvar TILDETRIM = R++;\n\t\tsrc[TILDETRIM] = '(\\\\s*)' + src[LONETILDE] + '\\\\s+';\n\t\tre[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');\n\t\tvar tildeTrimReplace = '$1~';\n\t\tvar TILDE = R++;\n\t\tsrc[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';\n\t\tvar TILDELOOSE = R++;\n\t\tsrc[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';\n\t\tvar LONECARET = R++;\n\t\tsrc[LONECARET] = '(?:\\\\^)';\n\t\tvar CARETTRIM = R++;\n\t\tsrc[CARETTRIM] = '(\\\\s*)' + src[LONECARET] + '\\\\s+';\n\t\tre[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');\n\t\tvar caretTrimReplace = '$1^';\n\t\tvar CARET = R++;\n\t\tsrc[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';\n\t\tvar CARETLOOSE = R++;\n\t\tsrc[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';\n\t\tvar COMPARATORLOOSE = R++;\n\t\tsrc[COMPARATORLOOSE] = '^' + src[GTLT] + '\\\\s*(' + LOOSEPLAIN + ')$|^$';\n\t\tvar COMPARATOR = R++;\n\t\tsrc[COMPARATOR] = '^' + src[GTLT] + '\\\\s*(' + FULLPLAIN + ')$|^$';\n\t\tvar COMPARATORTRIM = R++;\n\t\tsrc[COMPARATORTRIM] = '(\\\\s*)' + src[GTLT] +\n\t\t                      '\\\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';\n\t\tre[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');\n\t\tvar comparatorTrimReplace = '$1$2$3';\n\t\tvar HYPHENRANGE = R++;\n\t\tsrc[HYPHENRANGE] = '^\\\\s*(' + src[XRANGEPLAIN] + ')' +\n\t\t                   '\\\\s+-\\\\s+' +\n\t\t                   '(' + src[XRANGEPLAIN] + ')' +\n\t\t                   '\\\\s*$';\n\t\tvar HYPHENRANGELOOSE = R++;\n\t\tsrc[HYPHENRANGELOOSE] = '^\\\\s*(' + src[XRANGEPLAINLOOSE] + ')' +\n\t\t                        '\\\\s+-\\\\s+' +\n\t\t                        '(' + src[XRANGEPLAINLOOSE] + ')' +\n\t\t                        '\\\\s*$';\n\t\tvar STAR = R++;\n\t\tsrc[STAR] = '(<|>)?=?\\\\s*\\\\*';\n\t\tfor (var i = 0; i < R; i++) {\n\t\t  debug(i, src[i]);\n\t\t  if (!re[i])\n\t\t    re[i] = new RegExp(src[i]);\n\t\t}\n\t\texports.parse = parse;\n\t\tfunction parse(version, loose) {\n\t\t  if (version instanceof SemVer)\n\t\t    return version;\n\t\t  if (typeof version !== 'string')\n\t\t    return null;\n\t\t  if (version.length > MAX_LENGTH)\n\t\t    return null;\n\t\t  var r = loose ? re[LOOSE] : re[FULL];\n\t\t  if (!r.test(version))\n\t\t    return null;\n\t\t  try {\n\t\t    return new SemVer(version, loose);\n\t\t  } catch (er) {\n\t\t    return null;\n\t\t  }\n\t\t}\n\t\texports.valid = valid;\n\t\tfunction valid(version, loose) {\n\t\t  var v = parse(version, loose);\n\t\t  return v ? v.version : null;\n\t\t}\n\t\texports.clean = clean;\n\t\tfunction clean(version, loose) {\n\t\t  var s = parse(version.trim().replace(/^[=v]+/, ''), loose);\n\t\t  return s ? s.version : null;\n\t\t}\n\t\texports.SemVer = SemVer;\n\t\tfunction SemVer(version, loose) {\n\t\t  if (version instanceof SemVer) {\n\t\t    if (version.loose === loose)\n\t\t      return version;\n\t\t    else\n\t\t      version = version.version;\n\t\t  } else if (typeof version !== 'string') {\n\t\t    throw new TypeError('Invalid Version: ' + version);\n\t\t  }\n\t\t  if (version.length > MAX_LENGTH)\n\t\t    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')\n\t\t  if (!(this instanceof SemVer))\n\t\t    return new SemVer(version, loose);\n\t\t  debug('SemVer', version, loose);\n\t\t  this.loose = loose;\n\t\t  var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);\n\t\t  if (!m)\n\t\t    throw new TypeError('Invalid Version: ' + version);\n\t\t  this.raw = version;\n\t\t  this.major = +m[1];\n\t\t  this.minor = +m[2];\n\t\t  this.patch = +m[3];\n\t\t  if (this.major > MAX_SAFE_INTEGER || this.major < 0)\n\t\t    throw new TypeError('Invalid major version')\n\t\t  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)\n\t\t    throw new TypeError('Invalid minor version')\n\t\t  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)\n\t\t    throw new TypeError('Invalid patch version')\n\t\t  if (!m[4])\n\t\t    this.prerelease = [];\n\t\t  else\n\t\t    this.prerelease = m[4].split('.').map(function(id) {\n\t\t      if (/^[0-9]+$/.test(id)) {\n\t\t        var num = +id;\n\t\t        if (num >= 0 && num < MAX_SAFE_INTEGER)\n\t\t          return num;\n\t\t      }\n\t\t      return id;\n\t\t    });\n\t\t  this.build = m[5] ? m[5].split('.') : [];\n\t\t  this.format();\n\t\t}\n\t\tSemVer.prototype.format = function() {\n\t\t  this.version = this.major + '.' + this.minor + '.' + this.patch;\n\t\t  if (this.prerelease.length)\n\t\t    this.version += '-' + this.prerelease.join('.');\n\t\t  return this.version;\n\t\t};\n\t\tSemVer.prototype.toString = function() {\n\t\t  return this.version;\n\t\t};\n\t\tSemVer.prototype.compare = function(other) {\n\t\t  debug('SemVer.compare', this.version, this.loose, other);\n\t\t  if (!(other instanceof SemVer))\n\t\t    other = new SemVer(other, this.loose);\n\t\t  return this.compareMain(other) || this.comparePre(other);\n\t\t};\n\t\tSemVer.prototype.compareMain = function(other) {\n\t\t  if (!(other instanceof SemVer))\n\t\t    other = new SemVer(other, this.loose);\n\t\t  return compareIdentifiers(this.major, other.major) ||\n\t\t         compareIdentifiers(this.minor, other.minor) ||\n\t\t         compareIdentifiers(this.patch, other.patch);\n\t\t};\n\t\tSemVer.prototype.comparePre = function(other) {\n\t\t  if (!(other instanceof SemVer))\n\t\t    other = new SemVer(other, this.loose);\n\t\t  if (this.prerelease.length && !other.prerelease.length)\n\t\t    return -1;\n\t\t  else if (!this.prerelease.length && other.prerelease.length)\n\t\t    return 1;\n\t\t  else if (!this.prerelease.length && !other.prerelease.length)\n\t\t    return 0;\n\t\t  var i = 0;\n\t\t  do {\n\t\t    var a = this.prerelease[i];\n\t\t    var b = other.prerelease[i];\n\t\t    debug('prerelease compare', i, a, b);\n\t\t    if (a === undefined && b === undefined)\n\t\t      return 0;\n\t\t    else if (b === undefined)\n\t\t      return 1;\n\t\t    else if (a === undefined)\n\t\t      return -1;\n\t\t    else if (a === b)\n\t\t      continue;\n\t\t    else\n\t\t      return compareIdentifiers(a, b);\n\t\t  } while (++i);\n\t\t};\n\t\tSemVer.prototype.inc = function(release, identifier) {\n\t\t  switch (release) {\n\t\t    case 'premajor':\n\t\t      this.prerelease.length = 0;\n\t\t      this.patch = 0;\n\t\t      this.minor = 0;\n\t\t      this.major++;\n\t\t      this.inc('pre', identifier);\n\t\t      break;\n\t\t    case 'preminor':\n\t\t      this.prerelease.length = 0;\n\t\t      this.patch = 0;\n\t\t      this.minor++;\n\t\t      this.inc('pre', identifier);\n\t\t      break;\n\t\t    case 'prepatch':\n\t\t      this.prerelease.length = 0;\n\t\t      this.inc('patch', identifier);\n\t\t      this.inc('pre', identifier);\n\t\t      break;\n\t\t    case 'prerelease':\n\t\t      if (this.prerelease.length === 0)\n\t\t        this.inc('patch', identifier);\n\t\t      this.inc('pre', identifier);\n\t\t      break;\n\t\t    case 'major':\n\t\t      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0)\n\t\t        this.major++;\n\t\t      this.minor = 0;\n\t\t      this.patch = 0;\n\t\t      this.prerelease = [];\n\t\t      break;\n\t\t    case 'minor':\n\t\t      if (this.patch !== 0 || this.prerelease.length === 0)\n\t\t        this.minor++;\n\t\t      this.patch = 0;\n\t\t      this.prerelease = [];\n\t\t      break;\n\t\t    case 'patch':\n\t\t      if (this.prerelease.length === 0)\n\t\t        this.patch++;\n\t\t      this.prerelease = [];\n\t\t      break;\n\t\t    case 'pre':\n\t\t      if (this.prerelease.length === 0)\n\t\t        this.prerelease = [0];\n\t\t      else {\n\t\t        var i = this.prerelease.length;\n\t\t        while (--i >= 0) {\n\t\t          if (typeof this.prerelease[i] === 'number') {\n\t\t            this.prerelease[i]++;\n\t\t            i = -2;\n\t\t          }\n\t\t        }\n\t\t        if (i === -1)\n\t\t          this.prerelease.push(0);\n\t\t      }\n\t\t      if (identifier) {\n\t\t        if (this.prerelease[0] === identifier) {\n\t\t          if (isNaN(this.prerelease[1]))\n\t\t            this.prerelease = [identifier, 0];\n\t\t        } else\n\t\t          this.prerelease = [identifier, 0];\n\t\t      }\n\t\t      break;\n\t\t    default:\n\t\t      throw new Error('invalid increment argument: ' + release);\n\t\t  }\n\t\t  this.format();\n\t\t  this.raw = this.version;\n\t\t  return this;\n\t\t};\n\t\texports.inc = inc;\n\t\tfunction inc(version, release, loose, identifier) {\n\t\t  if (typeof(loose) === 'string') {\n\t\t    identifier = loose;\n\t\t    loose = undefined;\n\t\t  }\n\t\t  try {\n\t\t    return new SemVer(version, loose).inc(release, identifier).version;\n\t\t  } catch (er) {\n\t\t    return null;\n\t\t  }\n\t\t}\n\t\texports.diff = diff;\n\t\tfunction diff(version1, version2) {\n\t\t  if (eq(version1, version2)) {\n\t\t    return null;\n\t\t  } else {\n\t\t    var v1 = parse(version1);\n\t\t    var v2 = parse(version2);\n\t\t    if (v1.prerelease.length || v2.prerelease.length) {\n\t\t      for (var key in v1) {\n\t\t        if (key === 'major' || key === 'minor' || key === 'patch') {\n\t\t          if (v1[key] !== v2[key]) {\n\t\t            return 'pre'+key;\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t      return 'prerelease';\n\t\t    }\n\t\t    for (var key in v1) {\n\t\t      if (key === 'major' || key === 'minor' || key === 'patch') {\n\t\t        if (v1[key] !== v2[key]) {\n\t\t          return key;\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t}\n\t\texports.compareIdentifiers = compareIdentifiers;\n\t\tvar numeric = /^[0-9]+$/;\n\t\tfunction compareIdentifiers(a, b) {\n\t\t  var anum = numeric.test(a);\n\t\t  var bnum = numeric.test(b);\n\t\t  if (anum && bnum) {\n\t\t    a = +a;\n\t\t    b = +b;\n\t\t  }\n\t\t  return (anum && !bnum) ? -1 :\n\t\t         (bnum && !anum) ? 1 :\n\t\t         a < b ? -1 :\n\t\t         a > b ? 1 :\n\t\t         0;\n\t\t}\n\t\texports.rcompareIdentifiers = rcompareIdentifiers;\n\t\tfunction rcompareIdentifiers(a, b) {\n\t\t  return compareIdentifiers(b, a);\n\t\t}\n\t\texports.major = major;\n\t\tfunction major(a, loose) {\n\t\t  return new SemVer(a, loose).major;\n\t\t}\n\t\texports.minor = minor;\n\t\tfunction minor(a, loose) {\n\t\t  return new SemVer(a, loose).minor;\n\t\t}\n\t\texports.patch = patch;\n\t\tfunction patch(a, loose) {\n\t\t  return new SemVer(a, loose).patch;\n\t\t}\n\t\texports.compare = compare;\n\t\tfunction compare(a, b, loose) {\n\t\t  return new SemVer(a, loose).compare(new SemVer(b, loose));\n\t\t}\n\t\texports.compareLoose = compareLoose;\n\t\tfunction compareLoose(a, b) {\n\t\t  return compare(a, b, true);\n\t\t}\n\t\texports.rcompare = rcompare;\n\t\tfunction rcompare(a, b, loose) {\n\t\t  return compare(b, a, loose);\n\t\t}\n\t\texports.sort = sort;\n\t\tfunction sort(list, loose) {\n\t\t  return list.sort(function(a, b) {\n\t\t    return exports.compare(a, b, loose);\n\t\t  });\n\t\t}\n\t\texports.rsort = rsort;\n\t\tfunction rsort(list, loose) {\n\t\t  return list.sort(function(a, b) {\n\t\t    return exports.rcompare(a, b, loose);\n\t\t  });\n\t\t}\n\t\texports.gt = gt;\n\t\tfunction gt(a, b, loose) {\n\t\t  return compare(a, b, loose) > 0;\n\t\t}\n\t\texports.lt = lt;\n\t\tfunction lt(a, b, loose) {\n\t\t  return compare(a, b, loose) < 0;\n\t\t}\n\t\texports.eq = eq;\n\t\tfunction eq(a, b, loose) {\n\t\t  return compare(a, b, loose) === 0;\n\t\t}\n\t\texports.neq = neq;\n\t\tfunction neq(a, b, loose) {\n\t\t  return compare(a, b, loose) !== 0;\n\t\t}\n\t\texports.gte = gte;\n\t\tfunction gte(a, b, loose) {\n\t\t  return compare(a, b, loose) >= 0;\n\t\t}\n\t\texports.lte = lte;\n\t\tfunction lte(a, b, loose) {\n\t\t  return compare(a, b, loose) <= 0;\n\t\t}\n\t\texports.cmp = cmp;\n\t\tfunction cmp(a, op, b, loose) {\n\t\t  var ret;\n\t\t  switch (op) {\n\t\t    case '===':\n\t\t      if (typeof a === 'object') a = a.version;\n\t\t      if (typeof b === 'object') b = b.version;\n\t\t      ret = a === b;\n\t\t      break;\n\t\t    case '!==':\n\t\t      if (typeof a === 'object') a = a.version;\n\t\t      if (typeof b === 'object') b = b.version;\n\t\t      ret = a !== b;\n\t\t      break;\n\t\t    case '': case '=': case '==': ret = eq(a, b, loose); break;\n\t\t    case '!=': ret = neq(a, b, loose); break;\n\t\t    case '>': ret = gt(a, b, loose); break;\n\t\t    case '>=': ret = gte(a, b, loose); break;\n\t\t    case '<': ret = lt(a, b, loose); break;\n\t\t    case '<=': ret = lte(a, b, loose); break;\n\t\t    default: throw new TypeError('Invalid operator: ' + op);\n\t\t  }\n\t\t  return ret;\n\t\t}\n\t\texports.Comparator = Comparator;\n\t\tfunction Comparator(comp, loose) {\n\t\t  if (comp instanceof Comparator) {\n\t\t    if (comp.loose === loose)\n\t\t      return comp;\n\t\t    else\n\t\t      comp = comp.value;\n\t\t  }\n\t\t  if (!(this instanceof Comparator))\n\t\t    return new Comparator(comp, loose);\n\t\t  debug('comparator', comp, loose);\n\t\t  this.loose = loose;\n\t\t  this.parse(comp);\n\t\t  if (this.semver === ANY)\n\t\t    this.value = '';\n\t\t  else\n\t\t    this.value = this.operator + this.semver.version;\n\t\t  debug('comp', this);\n\t\t}\n\t\tvar ANY = {};\n\t\tComparator.prototype.parse = function(comp) {\n\t\t  var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];\n\t\t  var m = comp.match(r);\n\t\t  if (!m)\n\t\t    throw new TypeError('Invalid comparator: ' + comp);\n\t\t  this.operator = m[1];\n\t\t  if (this.operator === '=')\n\t\t    this.operator = '';\n\t\t  if (!m[2])\n\t\t    this.semver = ANY;\n\t\t  else\n\t\t    this.semver = new SemVer(m[2], this.loose);\n\t\t};\n\t\tComparator.prototype.toString = function() {\n\t\t  return this.value;\n\t\t};\n\t\tComparator.prototype.test = function(version) {\n\t\t  debug('Comparator.test', version, this.loose);\n\t\t  if (this.semver === ANY)\n\t\t    return true;\n\t\t  if (typeof version === 'string')\n\t\t    version = new SemVer(version, this.loose);\n\t\t  return cmp(version, this.operator, this.semver, this.loose);\n\t\t};\n\t\tComparator.prototype.intersects = function(comp, loose) {\n\t\t  if (!(comp instanceof Comparator)) {\n\t\t    throw new TypeError('a Comparator is required');\n\t\t  }\n\t\t  var rangeTmp;\n\t\t  if (this.operator === '') {\n\t\t    rangeTmp = new Range(comp.value, loose);\n\t\t    return satisfies(this.value, rangeTmp, loose);\n\t\t  } else if (comp.operator === '') {\n\t\t    rangeTmp = new Range(this.value, loose);\n\t\t    return satisfies(comp.semver, rangeTmp, loose);\n\t\t  }\n\t\t  var sameDirectionIncreasing =\n\t\t    (this.operator === '>=' || this.operator === '>') &&\n\t\t    (comp.operator === '>=' || comp.operator === '>');\n\t\t  var sameDirectionDecreasing =\n\t\t    (this.operator === '<=' || this.operator === '<') &&\n\t\t    (comp.operator === '<=' || comp.operator === '<');\n\t\t  var sameSemVer = this.semver.version === comp.semver.version;\n\t\t  var differentDirectionsInclusive =\n\t\t    (this.operator === '>=' || this.operator === '<=') &&\n\t\t    (comp.operator === '>=' || comp.operator === '<=');\n\t\t  var oppositeDirectionsLessThan =\n\t\t    cmp(this.semver, '<', comp.semver, loose) &&\n\t\t    ((this.operator === '>=' || this.operator === '>') &&\n\t\t    (comp.operator === '<=' || comp.operator === '<'));\n\t\t  var oppositeDirectionsGreaterThan =\n\t\t    cmp(this.semver, '>', comp.semver, loose) &&\n\t\t    ((this.operator === '<=' || this.operator === '<') &&\n\t\t    (comp.operator === '>=' || comp.operator === '>'));\n\t\t  return sameDirectionIncreasing || sameDirectionDecreasing ||\n\t\t    (sameSemVer && differentDirectionsInclusive) ||\n\t\t    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;\n\t\t};\n\t\texports.Range = Range;\n\t\tfunction Range(range, loose) {\n\t\t  if (range instanceof Range) {\n\t\t    if (range.loose === loose) {\n\t\t      return range;\n\t\t    } else {\n\t\t      return new Range(range.raw, loose);\n\t\t    }\n\t\t  }\n\t\t  if (range instanceof Comparator) {\n\t\t    return new Range(range.value, loose);\n\t\t  }\n\t\t  if (!(this instanceof Range))\n\t\t    return new Range(range, loose);\n\t\t  this.loose = loose;\n\t\t  this.raw = range;\n\t\t  this.set = range.split(/\\s*\\|\\|\\s*/).map(function(range) {\n\t\t    return this.parseRange(range.trim());\n\t\t  }, this).filter(function(c) {\n\t\t    return c.length;\n\t\t  });\n\t\t  if (!this.set.length) {\n\t\t    throw new TypeError('Invalid SemVer Range: ' + range);\n\t\t  }\n\t\t  this.format();\n\t\t}\n\t\tRange.prototype.format = function() {\n\t\t  this.range = this.set.map(function(comps) {\n\t\t    return comps.join(' ').trim();\n\t\t  }).join('||').trim();\n\t\t  return this.range;\n\t\t};\n\t\tRange.prototype.toString = function() {\n\t\t  return this.range;\n\t\t};\n\t\tRange.prototype.parseRange = function(range) {\n\t\t  var loose = this.loose;\n\t\t  range = range.trim();\n\t\t  debug('range', range, loose);\n\t\t  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];\n\t\t  range = range.replace(hr, hyphenReplace);\n\t\t  debug('hyphen replace', range);\n\t\t  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);\n\t\t  debug('comparator trim', range, re[COMPARATORTRIM]);\n\t\t  range = range.replace(re[TILDETRIM], tildeTrimReplace);\n\t\t  range = range.replace(re[CARETTRIM], caretTrimReplace);\n\t\t  range = range.split(/\\s+/).join(' ');\n\t\t  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];\n\t\t  var set = range.split(' ').map(function(comp) {\n\t\t    return parseComparator(comp, loose);\n\t\t  }).join(' ').split(/\\s+/);\n\t\t  if (this.loose) {\n\t\t    set = set.filter(function(comp) {\n\t\t      return !!comp.match(compRe);\n\t\t    });\n\t\t  }\n\t\t  set = set.map(function(comp) {\n\t\t    return new Comparator(comp, loose);\n\t\t  });\n\t\t  return set;\n\t\t};\n\t\tRange.prototype.intersects = function(range, loose) {\n\t\t  if (!(range instanceof Range)) {\n\t\t    throw new TypeError('a Range is required');\n\t\t  }\n\t\t  return this.set.some(function(thisComparators) {\n\t\t    return thisComparators.every(function(thisComparator) {\n\t\t      return range.set.some(function(rangeComparators) {\n\t\t        return rangeComparators.every(function(rangeComparator) {\n\t\t          return thisComparator.intersects(rangeComparator, loose);\n\t\t        });\n\t\t      });\n\t\t    });\n\t\t  });\n\t\t};\n\t\texports.toComparators = toComparators;\n\t\tfunction toComparators(range, loose) {\n\t\t  return new Range(range, loose).set.map(function(comp) {\n\t\t    return comp.map(function(c) {\n\t\t      return c.value;\n\t\t    }).join(' ').trim().split(' ');\n\t\t  });\n\t\t}\n\t\tfunction parseComparator(comp, loose) {\n\t\t  debug('comp', comp);\n\t\t  comp = replaceCarets(comp, loose);\n\t\t  debug('caret', comp);\n\t\t  comp = replaceTildes(comp, loose);\n\t\t  debug('tildes', comp);\n\t\t  comp = replaceXRanges(comp, loose);\n\t\t  debug('xrange', comp);\n\t\t  comp = replaceStars(comp, loose);\n\t\t  debug('stars', comp);\n\t\t  return comp;\n\t\t}\n\t\tfunction isX(id) {\n\t\t  return !id || id.toLowerCase() === 'x' || id === '*';\n\t\t}\n\t\tfunction replaceTildes(comp, loose) {\n\t\t  return comp.trim().split(/\\s+/).map(function(comp) {\n\t\t    return replaceTilde(comp, loose);\n\t\t  }).join(' ');\n\t\t}\n\t\tfunction replaceTilde(comp, loose) {\n\t\t  var r = loose ? re[TILDELOOSE] : re[TILDE];\n\t\t  return comp.replace(r, function(_, M, m, p, pr) {\n\t\t    debug('tilde', comp, _, M, m, p, pr);\n\t\t    var ret;\n\t\t    if (isX(M))\n\t\t      ret = '';\n\t\t    else if (isX(m))\n\t\t      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n\t\t    else if (isX(p))\n\t\t      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n\t\t    else if (pr) {\n\t\t      debug('replaceTilde pr', pr);\n\t\t      if (pr.charAt(0) !== '-')\n\t\t        pr = '-' + pr;\n\t\t      ret = '>=' + M + '.' + m + '.' + p + pr +\n\t\t            ' <' + M + '.' + (+m + 1) + '.0';\n\t\t    } else\n\t\t      ret = '>=' + M + '.' + m + '.' + p +\n\t\t            ' <' + M + '.' + (+m + 1) + '.0';\n\t\t    debug('tilde return', ret);\n\t\t    return ret;\n\t\t  });\n\t\t}\n\t\tfunction replaceCarets(comp, loose) {\n\t\t  return comp.trim().split(/\\s+/).map(function(comp) {\n\t\t    return replaceCaret(comp, loose);\n\t\t  }).join(' ');\n\t\t}\n\t\tfunction replaceCaret(comp, loose) {\n\t\t  debug('caret', comp, loose);\n\t\t  var r = loose ? re[CARETLOOSE] : re[CARET];\n\t\t  return comp.replace(r, function(_, M, m, p, pr) {\n\t\t    debug('caret', comp, _, M, m, p, pr);\n\t\t    var ret;\n\t\t    if (isX(M))\n\t\t      ret = '';\n\t\t    else if (isX(m))\n\t\t      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n\t\t    else if (isX(p)) {\n\t\t      if (M === '0')\n\t\t        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n\t\t      else\n\t\t        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';\n\t\t    } else if (pr) {\n\t\t      debug('replaceCaret pr', pr);\n\t\t      if (pr.charAt(0) !== '-')\n\t\t        pr = '-' + pr;\n\t\t      if (M === '0') {\n\t\t        if (m === '0')\n\t\t          ret = '>=' + M + '.' + m + '.' + p + pr +\n\t\t                ' <' + M + '.' + m + '.' + (+p + 1);\n\t\t        else\n\t\t          ret = '>=' + M + '.' + m + '.' + p + pr +\n\t\t                ' <' + M + '.' + (+m + 1) + '.0';\n\t\t      } else\n\t\t        ret = '>=' + M + '.' + m + '.' + p + pr +\n\t\t              ' <' + (+M + 1) + '.0.0';\n\t\t    } else {\n\t\t      debug('no pr');\n\t\t      if (M === '0') {\n\t\t        if (m === '0')\n\t\t          ret = '>=' + M + '.' + m + '.' + p +\n\t\t                ' <' + M + '.' + m + '.' + (+p + 1);\n\t\t        else\n\t\t          ret = '>=' + M + '.' + m + '.' + p +\n\t\t                ' <' + M + '.' + (+m + 1) + '.0';\n\t\t      } else\n\t\t        ret = '>=' + M + '.' + m + '.' + p +\n\t\t              ' <' + (+M + 1) + '.0.0';\n\t\t    }\n\t\t    debug('caret return', ret);\n\t\t    return ret;\n\t\t  });\n\t\t}\n\t\tfunction replaceXRanges(comp, loose) {\n\t\t  debug('replaceXRanges', comp, loose);\n\t\t  return comp.split(/\\s+/).map(function(comp) {\n\t\t    return replaceXRange(comp, loose);\n\t\t  }).join(' ');\n\t\t}\n\t\tfunction replaceXRange(comp, loose) {\n\t\t  comp = comp.trim();\n\t\t  var r = loose ? re[XRANGELOOSE] : re[XRANGE];\n\t\t  return comp.replace(r, function(ret, gtlt, M, m, p, pr) {\n\t\t    debug('xRange', comp, ret, gtlt, M, m, p, pr);\n\t\t    var xM = isX(M);\n\t\t    var xm = xM || isX(m);\n\t\t    var xp = xm || isX(p);\n\t\t    var anyX = xp;\n\t\t    if (gtlt === '=' && anyX)\n\t\t      gtlt = '';\n\t\t    if (xM) {\n\t\t      if (gtlt === '>' || gtlt === '<') {\n\t\t        ret = '<0.0.0';\n\t\t      } else {\n\t\t        ret = '*';\n\t\t      }\n\t\t    } else if (gtlt && anyX) {\n\t\t      if (xm)\n\t\t        m = 0;\n\t\t      if (xp)\n\t\t        p = 0;\n\t\t      if (gtlt === '>') {\n\t\t        gtlt = '>=';\n\t\t        if (xm) {\n\t\t          M = +M + 1;\n\t\t          m = 0;\n\t\t          p = 0;\n\t\t        } else if (xp) {\n\t\t          m = +m + 1;\n\t\t          p = 0;\n\t\t        }\n\t\t      } else if (gtlt === '<=') {\n\t\t        gtlt = '<';\n\t\t        if (xm)\n\t\t          M = +M + 1;\n\t\t        else\n\t\t          m = +m + 1;\n\t\t      }\n\t\t      ret = gtlt + M + '.' + m + '.' + p;\n\t\t    } else if (xm) {\n\t\t      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n\t\t    } else if (xp) {\n\t\t      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n\t\t    }\n\t\t    debug('xRange return', ret);\n\t\t    return ret;\n\t\t  });\n\t\t}\n\t\tfunction replaceStars(comp, loose) {\n\t\t  debug('replaceStars', comp, loose);\n\t\t  return comp.trim().replace(re[STAR], '');\n\t\t}\n\t\tfunction hyphenReplace($0,\n\t\t                       from, fM, fm, fp, fpr, fb,\n\t\t                       to, tM, tm, tp, tpr, tb) {\n\t\t  if (isX(fM))\n\t\t    from = '';\n\t\t  else if (isX(fm))\n\t\t    from = '>=' + fM + '.0.0';\n\t\t  else if (isX(fp))\n\t\t    from = '>=' + fM + '.' + fm + '.0';\n\t\t  else\n\t\t    from = '>=' + from;\n\t\t  if (isX(tM))\n\t\t    to = '';\n\t\t  else if (isX(tm))\n\t\t    to = '<' + (+tM + 1) + '.0.0';\n\t\t  else if (isX(tp))\n\t\t    to = '<' + tM + '.' + (+tm + 1) + '.0';\n\t\t  else if (tpr)\n\t\t    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;\n\t\t  else\n\t\t    to = '<=' + to;\n\t\t  return (from + ' ' + to).trim();\n\t\t}\n\t\tRange.prototype.test = function(version) {\n\t\t  if (!version)\n\t\t    return false;\n\t\t  if (typeof version === 'string')\n\t\t    version = new SemVer(version, this.loose);\n\t\t  for (var i = 0; i < this.set.length; i++) {\n\t\t    if (testSet(this.set[i], version))\n\t\t      return true;\n\t\t  }\n\t\t  return false;\n\t\t};\n\t\tfunction testSet(set, version) {\n\t\t  for (var i = 0; i < set.length; i++) {\n\t\t    if (!set[i].test(version))\n\t\t      return false;\n\t\t  }\n\t\t  if (version.prerelease.length) {\n\t\t    for (var i = 0; i < set.length; i++) {\n\t\t      debug(set[i].semver);\n\t\t      if (set[i].semver === ANY)\n\t\t        continue;\n\t\t      if (set[i].semver.prerelease.length > 0) {\n\t\t        var allowed = set[i].semver;\n\t\t        if (allowed.major === version.major &&\n\t\t            allowed.minor === version.minor &&\n\t\t            allowed.patch === version.patch)\n\t\t          return true;\n\t\t      }\n\t\t    }\n\t\t    return false;\n\t\t  }\n\t\t  return true;\n\t\t}\n\t\texports.satisfies = satisfies;\n\t\tfunction satisfies(version, range, loose) {\n\t\t  try {\n\t\t    range = new Range(range, loose);\n\t\t  } catch (er) {\n\t\t    return false;\n\t\t  }\n\t\t  return range.test(version);\n\t\t}\n\t\texports.maxSatisfying = maxSatisfying;\n\t\tfunction maxSatisfying(versions, range, loose) {\n\t\t  var max = null;\n\t\t  var maxSV = null;\n\t\t  try {\n\t\t    var rangeObj = new Range(range, loose);\n\t\t  } catch (er) {\n\t\t    return null;\n\t\t  }\n\t\t  versions.forEach(function (v) {\n\t\t    if (rangeObj.test(v)) {\n\t\t      if (!max || maxSV.compare(v) === -1) {\n\t\t        max = v;\n\t\t        maxSV = new SemVer(max, loose);\n\t\t      }\n\t\t    }\n\t\t  });\n\t\t  return max;\n\t\t}\n\t\texports.minSatisfying = minSatisfying;\n\t\tfunction minSatisfying(versions, range, loose) {\n\t\t  var min = null;\n\t\t  var minSV = null;\n\t\t  try {\n\t\t    var rangeObj = new Range(range, loose);\n\t\t  } catch (er) {\n\t\t    return null;\n\t\t  }\n\t\t  versions.forEach(function (v) {\n\t\t    if (rangeObj.test(v)) {\n\t\t      if (!min || minSV.compare(v) === 1) {\n\t\t        min = v;\n\t\t        minSV = new SemVer(min, loose);\n\t\t      }\n\t\t    }\n\t\t  });\n\t\t  return min;\n\t\t}\n\t\texports.validRange = validRange;\n\t\tfunction validRange(range, loose) {\n\t\t  try {\n\t\t    return new Range(range, loose).range || '*';\n\t\t  } catch (er) {\n\t\t    return null;\n\t\t  }\n\t\t}\n\t\texports.ltr = ltr;\n\t\tfunction ltr(version, range, loose) {\n\t\t  return outside(version, range, '<', loose);\n\t\t}\n\t\texports.gtr = gtr;\n\t\tfunction gtr(version, range, loose) {\n\t\t  return outside(version, range, '>', loose);\n\t\t}\n\t\texports.outside = outside;\n\t\tfunction outside(version, range, hilo, loose) {\n\t\t  version = new SemVer(version, loose);\n\t\t  range = new Range(range, loose);\n\t\t  var gtfn, ltefn, ltfn, comp, ecomp;\n\t\t  switch (hilo) {\n\t\t    case '>':\n\t\t      gtfn = gt;\n\t\t      ltefn = lte;\n\t\t      ltfn = lt;\n\t\t      comp = '>';\n\t\t      ecomp = '>=';\n\t\t      break;\n\t\t    case '<':\n\t\t      gtfn = lt;\n\t\t      ltefn = gte;\n\t\t      ltfn = gt;\n\t\t      comp = '<';\n\t\t      ecomp = '<=';\n\t\t      break;\n\t\t    default:\n\t\t      throw new TypeError('Must provide a hilo val of \"<\" or \">\"');\n\t\t  }\n\t\t  if (satisfies(version, range, loose)) {\n\t\t    return false;\n\t\t  }\n\t\t  for (var i = 0; i < range.set.length; ++i) {\n\t\t    var comparators = range.set[i];\n\t\t    var high = null;\n\t\t    var low = null;\n\t\t    comparators.forEach(function(comparator) {\n\t\t      if (comparator.semver === ANY) {\n\t\t        comparator = new Comparator('>=0.0.0');\n\t\t      }\n\t\t      high = high || comparator;\n\t\t      low = low || comparator;\n\t\t      if (gtfn(comparator.semver, high.semver, loose)) {\n\t\t        high = comparator;\n\t\t      } else if (ltfn(comparator.semver, low.semver, loose)) {\n\t\t        low = comparator;\n\t\t      }\n\t\t    });\n\t\t    if (high.operator === comp || high.operator === ecomp) {\n\t\t      return false;\n\t\t    }\n\t\t    if ((!low.operator || low.operator === comp) &&\n\t\t        ltefn(version, low.semver)) {\n\t\t      return false;\n\t\t    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n\t\t      return false;\n\t\t    }\n\t\t  }\n\t\t  return true;\n\t\t}\n\t\texports.prerelease = prerelease;\n\t\tfunction prerelease(version, loose) {\n\t\t  var parsed = parse(version, loose);\n\t\t  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null;\n\t\t}\n\t\texports.intersects = intersects;\n\t\tfunction intersects(r1, r2, loose) {\n\t\t  r1 = new Range(r1, loose);\n\t\t  r2 = new Range(r2, loose);\n\t\t  return r1.intersects(r2)\n\t\t}\n\t\texports.coerce = coerce;\n\t\tfunction coerce(version) {\n\t\t  if (version instanceof SemVer)\n\t\t    return version;\n\t\t  if (typeof version !== 'string')\n\t\t    return null;\n\t\t  var match = version.match(re[COERCE]);\n\t\t  if (match == null)\n\t\t    return null;\n\t\t  return parse((match[1] || '0') + '.' + (match[2] || '0') + '.' + (match[3] || '0'));\n\t\t}\n\t} (semver, semver.exports));\n\treturn semver.exports;\n}\nexport { requireSemver as __require };\n","import { Emitter } from './event.js';\nimport { Disposable } from './lifecycle.js';\nimport { localize } from '../../nls.js';\nclass Action extends Disposable {\n    constructor(id, label = '', cssClass = '', enabled = true, actionCallback) {\n        super();\n        this._onDidChange = this._register(( (new Emitter())));\n        this.onDidChange = this._onDidChange.event;\n        this._enabled = true;\n        this._id = id;\n        this._label = label;\n        this._cssClass = cssClass;\n        this._enabled = enabled;\n        this._actionCallback = actionCallback;\n    }\n    get id() {\n        return this._id;\n    }\n    get label() {\n        return this._label;\n    }\n    set label(value) {\n        this._setLabel(value);\n    }\n    _setLabel(value) {\n        if (this._label !== value) {\n            this._label = value;\n            this._onDidChange.fire({ label: value });\n        }\n    }\n    get tooltip() {\n        return this._tooltip || '';\n    }\n    set tooltip(value) {\n        this._setTooltip(value);\n    }\n    _setTooltip(value) {\n        if (this._tooltip !== value) {\n            this._tooltip = value;\n            this._onDidChange.fire({ tooltip: value });\n        }\n    }\n    get class() {\n        return this._cssClass;\n    }\n    set class(value) {\n        this._setClass(value);\n    }\n    _setClass(value) {\n        if (this._cssClass !== value) {\n            this._cssClass = value;\n            this._onDidChange.fire({ class: value });\n        }\n    }\n    get enabled() {\n        return this._enabled;\n    }\n    set enabled(value) {\n        this._setEnabled(value);\n    }\n    _setEnabled(value) {\n        if (this._enabled !== value) {\n            this._enabled = value;\n            this._onDidChange.fire({ enabled: value });\n        }\n    }\n    get checked() {\n        return this._checked;\n    }\n    set checked(value) {\n        this._setChecked(value);\n    }\n    _setChecked(value) {\n        if (this._checked !== value) {\n            this._checked = value;\n            this._onDidChange.fire({ checked: value });\n        }\n    }\n    async run(event, data) {\n        if (this._actionCallback) {\n            await this._actionCallback(event);\n        }\n    }\n}\nclass ActionRunner extends Disposable {\n    constructor() {\n        super(...arguments);\n        this._onWillRun = this._register(( (new Emitter())));\n        this.onWillRun = this._onWillRun.event;\n        this._onDidRun = this._register(( (new Emitter())));\n        this.onDidRun = this._onDidRun.event;\n    }\n    async run(action, context) {\n        if (!action.enabled) {\n            return;\n        }\n        this._onWillRun.fire({ action });\n        let error = undefined;\n        try {\n            await this.runAction(action, context);\n        }\n        catch (e) {\n            error = e;\n        }\n        this._onDidRun.fire({ action, error });\n    }\n    async runAction(action, context) {\n        await action.run(context);\n    }\n}\nclass Separator {\n    constructor() {\n        this.id = Separator.ID;\n        this.label = '';\n        this.tooltip = '';\n        this.class = 'separator';\n        this.enabled = false;\n        this.checked = false;\n    }\n    static join(...actionLists) {\n        let out = [];\n        for (const list of actionLists) {\n            if (!list.length) ;\n            else if (out.length) {\n                out = [...out, ( (new Separator())), ...list];\n            }\n            else {\n                out = list;\n            }\n        }\n        return out;\n    }\n    static { this.ID = 'vs.actions.separator'; }\n    async run() { }\n}\nclass SubmenuAction {\n    get actions() { return this._actions; }\n    constructor(id, label, actions, cssClass) {\n        this.tooltip = '';\n        this.enabled = true;\n        this.checked = undefined;\n        this.id = id;\n        this.label = label;\n        this.class = cssClass;\n        this._actions = actions;\n    }\n    async run() { }\n}\nclass EmptySubmenuAction extends Action {\n    static { this.ID = 'vs.actions.empty'; }\n    constructor() {\n        super(EmptySubmenuAction.ID, ( localize(1599, '(empty)')), undefined, false);\n    }\n}\nfunction toAction(props) {\n    return {\n        id: props.id,\n        label: props.label,\n        tooltip: props.tooltip ?? props.label,\n        class: props.class,\n        enabled: props.enabled ?? true,\n        checked: props.checked,\n        run: async (...args) => props.run(...args),\n    };\n}\nexport { Action, ActionRunner, EmptySubmenuAction, Separator, SubmenuAction, toAction };\n","import { Lazy } from './lazy.js';\nimport { sep } from './path.js';\nconst intlFileNameCollatorBaseNumeric = ( new Lazy(() => {\n    const collator = new Intl.Collator(undefined, { numeric: true, sensitivity: 'base' });\n    return {\n        collator,\n        collatorIsNumeric: collator.resolvedOptions().numeric\n    };\n}));\nconst intlFileNameCollatorNumeric = ( new Lazy(() => {\n    const collator = new Intl.Collator(undefined, { numeric: true });\n    return {\n        collator\n    };\n}));\nconst intlFileNameCollatorNumericCaseInsensitive = ( new Lazy(() => {\n    const collator = new Intl.Collator(undefined, { numeric: true, sensitivity: 'accent' });\n    return {\n        collator\n    };\n}));\nfunction compareFileNames(one, other, caseSensitive = false) {\n    const a = one || '';\n    const b = other || '';\n    const result = intlFileNameCollatorBaseNumeric.value.collator.compare(a, b);\n    if (intlFileNameCollatorBaseNumeric.value.collatorIsNumeric && result === 0 && a !== b) {\n        return a < b ? -1 : 1;\n    }\n    return result;\n}\nfunction compareFileNamesDefault(one, other) {\n    const collatorNumeric = intlFileNameCollatorNumeric.value.collator;\n    one = one || '';\n    other = other || '';\n    return compareAndDisambiguateByLength(collatorNumeric, one, other);\n}\nfunction compareFileNamesUpper(one, other) {\n    const collatorNumeric = intlFileNameCollatorNumeric.value.collator;\n    one = one || '';\n    other = other || '';\n    return compareCaseUpperFirst(one, other) || compareAndDisambiguateByLength(collatorNumeric, one, other);\n}\nfunction compareFileNamesLower(one, other) {\n    const collatorNumeric = intlFileNameCollatorNumeric.value.collator;\n    one = one || '';\n    other = other || '';\n    return compareCaseLowerFirst(one, other) || compareAndDisambiguateByLength(collatorNumeric, one, other);\n}\nfunction compareFileNamesUnicode(one, other) {\n    one = one || '';\n    other = other || '';\n    if (one === other) {\n        return 0;\n    }\n    return one < other ? -1 : 1;\n}\nfunction compareFileExtensions(one, other) {\n    const [oneName, oneExtension] = extractNameAndExtension(one);\n    const [otherName, otherExtension] = extractNameAndExtension(other);\n    let result = intlFileNameCollatorBaseNumeric.value.collator.compare(oneExtension, otherExtension);\n    if (result === 0) {\n        if (intlFileNameCollatorBaseNumeric.value.collatorIsNumeric && oneExtension !== otherExtension) {\n            return oneExtension < otherExtension ? -1 : 1;\n        }\n        result = intlFileNameCollatorBaseNumeric.value.collator.compare(oneName, otherName);\n        if (intlFileNameCollatorBaseNumeric.value.collatorIsNumeric && result === 0 && oneName !== otherName) {\n            return oneName < otherName ? -1 : 1;\n        }\n    }\n    return result;\n}\nfunction compareFileExtensionsDefault(one, other) {\n    one = one || '';\n    other = other || '';\n    const oneExtension = extractExtension(one);\n    const otherExtension = extractExtension(other);\n    const collatorNumeric = intlFileNameCollatorNumeric.value.collator;\n    const collatorNumericCaseInsensitive = intlFileNameCollatorNumericCaseInsensitive.value.collator;\n    return compareAndDisambiguateByLength(collatorNumericCaseInsensitive, oneExtension, otherExtension) ||\n        compareAndDisambiguateByLength(collatorNumeric, one, other);\n}\nfunction compareFileExtensionsUpper(one, other) {\n    one = one || '';\n    other = other || '';\n    const oneExtension = extractExtension(one);\n    const otherExtension = extractExtension(other);\n    const collatorNumeric = intlFileNameCollatorNumeric.value.collator;\n    const collatorNumericCaseInsensitive = intlFileNameCollatorNumericCaseInsensitive.value.collator;\n    return compareAndDisambiguateByLength(collatorNumericCaseInsensitive, oneExtension, otherExtension) ||\n        compareCaseUpperFirst(one, other) ||\n        compareAndDisambiguateByLength(collatorNumeric, one, other);\n}\nfunction compareFileExtensionsLower(one, other) {\n    one = one || '';\n    other = other || '';\n    const oneExtension = extractExtension(one);\n    const otherExtension = extractExtension(other);\n    const collatorNumeric = intlFileNameCollatorNumeric.value.collator;\n    const collatorNumericCaseInsensitive = intlFileNameCollatorNumericCaseInsensitive.value.collator;\n    return compareAndDisambiguateByLength(collatorNumericCaseInsensitive, oneExtension, otherExtension) ||\n        compareCaseLowerFirst(one, other) ||\n        compareAndDisambiguateByLength(collatorNumeric, one, other);\n}\nfunction compareFileExtensionsUnicode(one, other) {\n    one = one || '';\n    other = other || '';\n    const oneExtension = extractExtension(one).toLowerCase();\n    const otherExtension = extractExtension(other).toLowerCase();\n    if (oneExtension !== otherExtension) {\n        return oneExtension < otherExtension ? -1 : 1;\n    }\n    if (one !== other) {\n        return one < other ? -1 : 1;\n    }\n    return 0;\n}\nconst FileNameMatch = /^(.*?)(\\.([^.]*))?$/;\nfunction extractNameAndExtension(str, dotfilesAsNames = false) {\n    const match = str ? FileNameMatch.exec(str) : [];\n    let result = [(match && match[1]) || '', (match && match[3]) || ''];\n    if (dotfilesAsNames && (!result[0] && result[1] || result[0] && result[0].charAt(0) === '.')) {\n        result = [result[0] + '.' + result[1], ''];\n    }\n    return result;\n}\nfunction extractExtension(str) {\n    const match = str ? FileNameMatch.exec(str) : [];\n    return (match && match[1] && match[1].charAt(0) !== '.' && match[3]) || '';\n}\nfunction compareAndDisambiguateByLength(collator, one, other) {\n    const result = collator.compare(one, other);\n    if (result !== 0) {\n        return result;\n    }\n    if (one.length !== other.length) {\n        return one.length < other.length ? -1 : 1;\n    }\n    return 0;\n}\nfunction startsWithLower(string) {\n    const character = string.charAt(0);\n    return (character.toLocaleUpperCase() !== character) ? true : false;\n}\nfunction startsWithUpper(string) {\n    const character = string.charAt(0);\n    return (character.toLocaleLowerCase() !== character) ? true : false;\n}\nfunction compareCaseLowerFirst(one, other) {\n    if (startsWithLower(one) && startsWithUpper(other)) {\n        return -1;\n    }\n    return (startsWithUpper(one) && startsWithLower(other)) ? 1 : 0;\n}\nfunction compareCaseUpperFirst(one, other) {\n    if (startsWithUpper(one) && startsWithLower(other)) {\n        return -1;\n    }\n    return (startsWithLower(one) && startsWithUpper(other)) ? 1 : 0;\n}\nfunction comparePathComponents(one, other, caseSensitive = false) {\n    if (!caseSensitive) {\n        one = one && one.toLowerCase();\n        other = other && other.toLowerCase();\n    }\n    if (one === other) {\n        return 0;\n    }\n    return one < other ? -1 : 1;\n}\nfunction comparePaths(one, other, caseSensitive = false) {\n    const oneParts = one.split(sep);\n    const otherParts = other.split(sep);\n    const lastOne = oneParts.length - 1;\n    const lastOther = otherParts.length - 1;\n    let endOne, endOther;\n    for (let i = 0;; i++) {\n        endOne = lastOne === i;\n        endOther = lastOther === i;\n        if (endOne && endOther) {\n            return compareFileNames(oneParts[i], otherParts[i], caseSensitive);\n        }\n        else if (endOne) {\n            return -1;\n        }\n        else if (endOther) {\n            return 1;\n        }\n        const result = comparePathComponents(oneParts[i], otherParts[i], caseSensitive);\n        if (result !== 0) {\n            return result;\n        }\n    }\n}\nfunction compareAnything(one, other, lookFor) {\n    const elementAName = one.toLowerCase();\n    const elementBName = other.toLowerCase();\n    const prefixCompare = compareByPrefix(one, other, lookFor);\n    if (prefixCompare) {\n        return prefixCompare;\n    }\n    const elementASuffixMatch = elementAName.endsWith(lookFor);\n    const elementBSuffixMatch = elementBName.endsWith(lookFor);\n    if (elementASuffixMatch !== elementBSuffixMatch) {\n        return elementASuffixMatch ? -1 : 1;\n    }\n    const r = compareFileNames(elementAName, elementBName);\n    if (r !== 0) {\n        return r;\n    }\n    return elementAName.localeCompare(elementBName);\n}\nfunction compareByPrefix(one, other, lookFor) {\n    const elementAName = one.toLowerCase();\n    const elementBName = other.toLowerCase();\n    const elementAPrefixMatch = elementAName.startsWith(lookFor);\n    const elementBPrefixMatch = elementBName.startsWith(lookFor);\n    if (elementAPrefixMatch !== elementBPrefixMatch) {\n        return elementAPrefixMatch ? -1 : 1;\n    }\n    else if (elementAPrefixMatch && elementBPrefixMatch) {\n        if (elementAName.length < elementBName.length) {\n            return -1;\n        }\n        if (elementAName.length > elementBName.length) {\n            return 1;\n        }\n    }\n    return 0;\n}\nexport { compareAnything, compareByPrefix, compareFileExtensions, compareFileExtensionsDefault, compareFileExtensionsLower, compareFileExtensionsUnicode, compareFileExtensionsUpper, compareFileNames, compareFileNamesDefault, compareFileNamesLower, compareFileNamesUnicode, compareFileNamesUpper, comparePaths };\n","import { distinct } from './arrays.js';\nimport { Iterable } from './iterator.js';\nimport { generateUuid } from './uuid.js';\nfunction createStringDataTransferItem(stringOrPromise) {\n    return {\n        asString: async () => stringOrPromise,\n        asFile: () => undefined,\n        value: typeof stringOrPromise === 'string' ? stringOrPromise : undefined,\n    };\n}\nfunction createFileDataTransferItem(fileName, uri, data) {\n    const file = { id: generateUuid(), name: fileName, uri, data };\n    return {\n        asString: async () => '',\n        asFile: () => file,\n        value: undefined,\n    };\n}\nclass VSDataTransfer {\n    constructor() {\n        this._entries = ( new Map());\n    }\n    get size() {\n        let size = 0;\n        for (const _ of this._entries) {\n            size++;\n        }\n        return size;\n    }\n    has(mimeType) {\n        return ( this._entries.has(this.toKey(mimeType)));\n    }\n    matches(pattern) {\n        const mimes = [...( this._entries.keys())];\n        if (( Iterable.some(this, ([_, item]) => item.asFile()))) {\n            mimes.push('files');\n        }\n        return matchesMimeType_normalized(normalizeMimeType(pattern), mimes);\n    }\n    get(mimeType) {\n        return this._entries.get(this.toKey(mimeType))?.[0];\n    }\n    append(mimeType, value) {\n        const existing = this._entries.get(mimeType);\n        if (existing) {\n            existing.push(value);\n        }\n        else {\n            this._entries.set(this.toKey(mimeType), [value]);\n        }\n    }\n    replace(mimeType, value) {\n        this._entries.set(this.toKey(mimeType), [value]);\n    }\n    delete(mimeType) {\n        this._entries.delete(this.toKey(mimeType));\n    }\n    *[Symbol.iterator]() {\n        for (const [mine, items] of this._entries) {\n            for (const item of items) {\n                yield [mine, item];\n            }\n        }\n    }\n    toKey(mimeType) {\n        return normalizeMimeType(mimeType);\n    }\n}\nfunction normalizeMimeType(mimeType) {\n    return mimeType.toLowerCase();\n}\nfunction matchesMimeType(pattern, mimeTypes) {\n    return matchesMimeType_normalized(normalizeMimeType(pattern), ( mimeTypes.map(normalizeMimeType)));\n}\nfunction matchesMimeType_normalized(normalizedPattern, normalizedMimeTypes) {\n    if (normalizedPattern === '*/*') {\n        return normalizedMimeTypes.length > 0;\n    }\n    if (normalizedMimeTypes.includes(normalizedPattern)) {\n        return true;\n    }\n    const wildcard = normalizedPattern.match(/^([a-z]+)\\/([a-z]+|\\*)$/i);\n    if (!wildcard) {\n        return false;\n    }\n    const [_, type, subtype] = wildcard;\n    if (subtype === '*') {\n        return ( normalizedMimeTypes.some(mime => mime.startsWith(type + '/')));\n    }\n    return false;\n}\nconst UriList = ( Object.freeze({\n    create: (entries) => {\n        return distinct(( entries.map(x => ( x.toString())))).join('\\r\\n');\n    },\n    split: (str) => {\n        return str.split('\\r\\n');\n    },\n    parse: (str) => {\n        return UriList.split(str).filter(value => !value.startsWith('#'));\n    }\n}));\nexport { UriList, VSDataTransfer, createFileDataTransferItem, createStringDataTransferItem, matchesMimeType };\n","import { localize } from '../../nls.js';\nconst minute = 60;\nconst hour = minute * 60;\nconst day = hour * 24;\nconst week = day * 7;\nconst month = day * 30;\nconst year = day * 365;\nfunction fromNow(date, appendAgoLabel, useFullTimeWords, disallowNow) {\n    if (typeof date !== 'number') {\n        date = date.getTime();\n    }\n    const seconds = Math.round((( (new Date())).getTime() - date) / 1000);\n    if (seconds < -30) {\n        return ( localize(\n            715,\n            'in {0}',\n            fromNow(( (new Date())).getTime() + seconds * 1000, false)\n        ));\n    }\n    if (!disallowNow && seconds < 30) {\n        return ( localize(716, 'now'));\n    }\n    let value;\n    if (seconds < minute) {\n        value = seconds;\n        if (appendAgoLabel) {\n            if (value === 1) {\n                return useFullTimeWords\n                    ? ( localize(717, '{0} second ago', value))\n                    : ( localize(718, '{0} sec ago', value));\n            }\n            else {\n                return useFullTimeWords\n                    ? ( localize(719, '{0} seconds ago', value))\n                    : ( localize(720, '{0} secs ago', value));\n            }\n        }\n        else {\n            if (value === 1) {\n                return useFullTimeWords\n                    ? ( localize(721, '{0} second', value))\n                    : ( localize(722, '{0} sec', value));\n            }\n            else {\n                return useFullTimeWords\n                    ? ( localize(723, '{0} seconds', value))\n                    : ( localize(724, '{0} secs', value));\n            }\n        }\n    }\n    if (seconds < hour) {\n        value = Math.floor(seconds / minute);\n        if (appendAgoLabel) {\n            if (value === 1) {\n                return useFullTimeWords\n                    ? ( localize(725, '{0} minute ago', value))\n                    : ( localize(726, '{0} min ago', value));\n            }\n            else {\n                return useFullTimeWords\n                    ? ( localize(727, '{0} minutes ago', value))\n                    : ( localize(728, '{0} mins ago', value));\n            }\n        }\n        else {\n            if (value === 1) {\n                return useFullTimeWords\n                    ? ( localize(729, '{0} minute', value))\n                    : ( localize(730, '{0} min', value));\n            }\n            else {\n                return useFullTimeWords\n                    ? ( localize(731, '{0} minutes', value))\n                    : ( localize(732, '{0} mins', value));\n            }\n        }\n    }\n    if (seconds < day) {\n        value = Math.floor(seconds / hour);\n        if (appendAgoLabel) {\n            if (value === 1) {\n                return useFullTimeWords\n                    ? ( localize(733, '{0} hour ago', value))\n                    : ( localize(734, '{0} hr ago', value));\n            }\n            else {\n                return useFullTimeWords\n                    ? ( localize(735, '{0} hours ago', value))\n                    : ( localize(736, '{0} hrs ago', value));\n            }\n        }\n        else {\n            if (value === 1) {\n                return useFullTimeWords\n                    ? ( localize(737, '{0} hour', value))\n                    : ( localize(738, '{0} hr', value));\n            }\n            else {\n                return useFullTimeWords\n                    ? ( localize(739, '{0} hours', value))\n                    : ( localize(740, '{0} hrs', value));\n            }\n        }\n    }\n    if (seconds < week) {\n        value = Math.floor(seconds / day);\n        if (appendAgoLabel) {\n            return value === 1\n                ? ( localize(741, '{0} day ago', value))\n                : ( localize(742, '{0} days ago', value));\n        }\n        else {\n            return value === 1\n                ? ( localize(743, '{0} day', value))\n                : ( localize(744, '{0} days', value));\n        }\n    }\n    if (seconds < month) {\n        value = Math.floor(seconds / week);\n        if (appendAgoLabel) {\n            if (value === 1) {\n                return useFullTimeWords\n                    ? ( localize(745, '{0} week ago', value))\n                    : ( localize(746, '{0} wk ago', value));\n            }\n            else {\n                return useFullTimeWords\n                    ? ( localize(747, '{0} weeks ago', value))\n                    : ( localize(748, '{0} wks ago', value));\n            }\n        }\n        else {\n            if (value === 1) {\n                return useFullTimeWords\n                    ? ( localize(749, '{0} week', value))\n                    : ( localize(750, '{0} wk', value));\n            }\n            else {\n                return useFullTimeWords\n                    ? ( localize(751, '{0} weeks', value))\n                    : ( localize(752, '{0} wks', value));\n            }\n        }\n    }\n    if (seconds < year) {\n        value = Math.floor(seconds / month);\n        if (appendAgoLabel) {\n            if (value === 1) {\n                return useFullTimeWords\n                    ? ( localize(753, '{0} month ago', value))\n                    : ( localize(754, '{0} mo ago', value));\n            }\n            else {\n                return useFullTimeWords\n                    ? ( localize(755, '{0} months ago', value))\n                    : ( localize(756, '{0} mos ago', value));\n            }\n        }\n        else {\n            if (value === 1) {\n                return useFullTimeWords\n                    ? ( localize(757, '{0} month', value))\n                    : ( localize(758, '{0} mo', value));\n            }\n            else {\n                return useFullTimeWords\n                    ? ( localize(759, '{0} months', value))\n                    : ( localize(760, '{0} mos', value));\n            }\n        }\n    }\n    value = Math.floor(seconds / year);\n    if (appendAgoLabel) {\n        if (value === 1) {\n            return useFullTimeWords\n                ? ( localize(761, '{0} year ago', value))\n                : ( localize(762, '{0} yr ago', value));\n        }\n        else {\n            return useFullTimeWords\n                ? ( localize(763, '{0} years ago', value))\n                : ( localize(764, '{0} yrs ago', value));\n        }\n    }\n    else {\n        if (value === 1) {\n            return useFullTimeWords\n                ? ( localize(765, '{0} year', value))\n                : ( localize(766, '{0} yr', value));\n        }\n        else {\n            return useFullTimeWords\n                ? ( localize(767, '{0} years', value))\n                : ( localize(768, '{0} yrs', value));\n        }\n    }\n}\nfunction fromNowByDay(date, appendAgoLabel, useFullTimeWords) {\n    if (typeof date !== 'number') {\n        date = date.getTime();\n    }\n    const todayMidnightTime = ( (new Date()));\n    todayMidnightTime.setHours(0, 0, 0, 0);\n    const yesterdayMidnightTime = ( (new Date(todayMidnightTime.getTime())));\n    yesterdayMidnightTime.setDate(yesterdayMidnightTime.getDate() - 1);\n    if (date > todayMidnightTime.getTime()) {\n        return ( localize(769, 'Today'));\n    }\n    if (date > yesterdayMidnightTime.getTime()) {\n        return ( localize(770, 'Yesterday'));\n    }\n    return fromNow(date, appendAgoLabel, useFullTimeWords);\n}\nfunction getDurationString(ms, useFullTimeWords) {\n    const seconds = Math.abs(ms / 1000);\n    if (seconds < 1) {\n        return ( localize(772, '{0}ms', ms));\n    }\n    if (seconds < minute) {\n        return ( localize(774, '{0}s', Math.round(ms) / 1000));\n    }\n    if (seconds < hour) {\n        return ( localize(776, '{0} mins', Math.round(ms / (1000 * minute))));\n    }\n    if (seconds < day) {\n        return ( localize(778, '{0} hrs', Math.round(ms / (1000 * hour))));\n    }\n    return ( localize(779, '{0} days', Math.round(ms / (1000 * day))));\n}\nfunction toLocalISOString(date) {\n    return date.getFullYear() +\n        '-' + String(date.getMonth() + 1).padStart(2, '0') +\n        '-' + String(date.getDate()).padStart(2, '0') +\n        'T' + String(date.getHours()).padStart(2, '0') +\n        ':' + String(date.getMinutes()).padStart(2, '0') +\n        ':' + String(date.getSeconds()).padStart(2, '0') +\n        '.' + (date.getMilliseconds() / 1000).toFixed(3).slice(2, 5) +\n        'Z';\n}\nexport { fromNow, fromNowByDay, getDurationString, toLocalISOString };\n","function createDecorator(mapFn) {\n    return (target, key, descriptor) => {\n        let fnKey = null;\n        let fn = null;\n        if (typeof descriptor.value === 'function') {\n            fnKey = 'value';\n            fn = descriptor.value;\n        }\n        else if (typeof descriptor.get === 'function') {\n            fnKey = 'get';\n            fn = descriptor.get;\n        }\n        if (!fn) {\n            throw ( new Error('not supported'));\n        }\n        descriptor[fnKey] = mapFn(fn, key);\n    };\n}\nfunction memoize(_target, key, descriptor) {\n    let fnKey = null;\n    let fn = null;\n    if (typeof descriptor.value === 'function') {\n        fnKey = 'value';\n        fn = descriptor.value;\n        if (fn.length !== 0) {\n            console.warn('Memoize should only be used in functions with zero parameters');\n        }\n    }\n    else if (typeof descriptor.get === 'function') {\n        fnKey = 'get';\n        fn = descriptor.get;\n    }\n    if (!fn) {\n        throw ( new Error('not supported'));\n    }\n    const memoizeKey = `$memoize$${key}`;\n    descriptor[fnKey] = function (...args) {\n        if (!this.hasOwnProperty(memoizeKey)) {\n            Object.defineProperty(this, memoizeKey, {\n                configurable: false,\n                enumerable: false,\n                writable: false,\n                value: fn.apply(this, args)\n            });\n        }\n        return this[memoizeKey];\n    };\n}\nfunction debounce(delay, reducer, initialValueProvider) {\n    return ( createDecorator((fn, key) => {\n        const timerKey = `$debounce$${key}`;\n        const resultKey = `$debounce$result$${key}`;\n        return function (...args) {\n            if (!this[resultKey]) {\n                this[resultKey] = undefined;\n            }\n            clearTimeout(this[timerKey]);\n            this[timerKey] = setTimeout(() => {\n                fn.apply(this, args);\n                this[resultKey] = undefined;\n            }, delay);\n        };\n    }));\n}\nfunction throttle(delay, reducer, initialValueProvider) {\n    return ( createDecorator((fn, key) => {\n        const timerKey = `$throttle$timer$${key}`;\n        const resultKey = `$throttle$result$${key}`;\n        const lastRunKey = `$throttle$lastRun$${key}`;\n        const pendingKey = `$throttle$pending$${key}`;\n        return function (...args) {\n            if (!this[resultKey]) {\n                this[resultKey] = initialValueProvider ? initialValueProvider() : undefined;\n            }\n            if (this[lastRunKey] === null || this[lastRunKey] === undefined) {\n                this[lastRunKey] = -Number.MAX_VALUE;\n            }\n            if (reducer) {\n                this[resultKey] = reducer(this[resultKey], ...args);\n            }\n            if (this[pendingKey]) {\n                return;\n            }\n            const nextTime = this[lastRunKey] + delay;\n            if (nextTime <= Date.now()) {\n                this[lastRunKey] = Date.now();\n                fn.apply(this, [this[resultKey]]);\n                this[resultKey] = initialValueProvider ? initialValueProvider() : undefined;\n            }\n            else {\n                this[pendingKey] = true;\n                this[timerKey] = setTimeout(() => {\n                    this[pendingKey] = false;\n                    this[lastRunKey] = Date.now();\n                    fn.apply(this, [this[resultKey]]);\n                    this[resultKey] = initialValueProvider ? initialValueProvider() : undefined;\n                }, nextTime - Date.now());\n            }\n        };\n    }));\n}\nexport { debounce, memoize, throttle };\n","import { coalesce } from './arrays.js';\nimport { isString } from './types.js';\nimport { localize } from '../../nls.js';\nfunction exceptionToErrorMessage(exception, verbose) {\n    if (verbose && (exception.stack || exception.stacktrace)) {\n        return ( localize(\n            580,\n            \"{0}: {1}\",\n            detectSystemErrorMessage(exception),\n            stackToString(exception.stack) || stackToString(exception.stacktrace)\n        ));\n    }\n    return detectSystemErrorMessage(exception);\n}\nfunction stackToString(stack) {\n    if (Array.isArray(stack)) {\n        return stack.join('\\n');\n    }\n    return stack;\n}\nfunction detectSystemErrorMessage(exception) {\n    if (exception.code === 'ERR_UNC_HOST_NOT_ALLOWED') {\n        return `${exception.message}. Please update the 'security.allowedUNCHosts' setting if you want to allow this host.`;\n    }\n    if (typeof exception.code === 'string' && typeof exception.errno === 'number' && typeof exception.syscall === 'string') {\n        return ( localize(581, \"A system error occurred ({0})\", exception.message));\n    }\n    return exception.message || ( localize(582, \"An unknown error occurred. Please consult the log for more details.\"));\n}\nfunction toErrorMessage(error = null, verbose = false) {\n    if (!error) {\n        return ( localize(582, \"An unknown error occurred. Please consult the log for more details.\"));\n    }\n    if (Array.isArray(error)) {\n        const errors = coalesce(error);\n        const msg = toErrorMessage(errors[0], verbose);\n        if (errors.length > 1) {\n            return ( localize(583, \"{0} ({1} errors in total)\", msg, errors.length));\n        }\n        return msg;\n    }\n    if (isString(error)) {\n        return error;\n    }\n    if (error.detail) {\n        const detail = error.detail;\n        if (detail.error) {\n            return exceptionToErrorMessage(detail.error, verbose);\n        }\n        if (detail.exception) {\n            return exceptionToErrorMessage(detail.exception, verbose);\n        }\n    }\n    if (error.stack) {\n        return exceptionToErrorMessage(error, verbose);\n    }\n    if (error.message) {\n        return error.message;\n    }\n    return ( localize(582, \"An unknown error occurred. Please consult the log for more details.\"));\n}\nfunction isErrorWithActions(obj) {\n    const candidate = obj;\n    return candidate instanceof Error && Array.isArray(candidate.actions);\n}\nfunction createErrorWithActions(messageOrError, actions) {\n    let error;\n    if (typeof messageOrError === 'string') {\n        error = ( (new Error(messageOrError)));\n    }\n    else {\n        error = messageOrError;\n    }\n    error.actions = actions;\n    return error;\n}\nexport { createErrorWithActions, isErrorWithActions, toErrorMessage };\n","import { LRUCache } from './map.js';\nimport { getKoreanAltChars } from './naturalLanguage/korean.js';\nimport { startsWithIgnoreCase, convertSimple2RegExpPattern, isEmojiImprecise } from './strings.js';\nfunction or(...filter) {\n    return function (word, wordToMatchAgainst) {\n        for (let i = 0, len = filter.length; i < len; i++) {\n            const match = filter[i](word, wordToMatchAgainst);\n            if (match) {\n                return match;\n            }\n        }\n        return null;\n    };\n}\n_matchesPrefix.bind(undefined, false);\nconst matchesPrefix = _matchesPrefix.bind(undefined, true);\nfunction _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {\n    if (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {\n        return null;\n    }\n    let matches;\n    if (ignoreCase) {\n        matches = startsWithIgnoreCase(wordToMatchAgainst, word);\n    }\n    else {\n        matches = wordToMatchAgainst.indexOf(word) === 0;\n    }\n    if (!matches) {\n        return null;\n    }\n    return word.length > 0 ? [{ start: 0, end: word.length }] : [];\n}\nfunction matchesContiguousSubString(word, wordToMatchAgainst) {\n    const index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());\n    if (index === -1) {\n        return null;\n    }\n    return [{ start: index, end: index + word.length }];\n}\nfunction matchesSubString(word, wordToMatchAgainst) {\n    return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);\n}\nfunction _matchesSubString(word, wordToMatchAgainst, i, j) {\n    if (i === word.length) {\n        return [];\n    }\n    else if (j === wordToMatchAgainst.length) {\n        return null;\n    }\n    else {\n        if (word[i] === wordToMatchAgainst[j]) {\n            let result = null;\n            if (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {\n                return join({ start: j, end: j + 1 }, result);\n            }\n            return null;\n        }\n        return _matchesSubString(word, wordToMatchAgainst, i, j + 1);\n    }\n}\nfunction isLower(code) {\n    return 97  <= code && code <= 122 ;\n}\nfunction isUpper(code) {\n    return 65  <= code && code <= 90 ;\n}\nfunction isNumber(code) {\n    return 48  <= code && code <= 57 ;\n}\nfunction isWhitespace(code) {\n    return (code === 32\n        || code === 9\n        || code === 10  || code === 13) ;\n}\nconst wordSeparators = ( new Set());\n'()[]{}<>`\\'\"-/;:,.?!'\n    .split('')\n    .forEach(s => wordSeparators.add(s.charCodeAt(0)));\nfunction isWordSeparator(code) {\n    return isWhitespace(code) || ( wordSeparators.has(code));\n}\nfunction charactersMatch(codeA, codeB) {\n    return (codeA === codeB) || (isWordSeparator(codeA) && isWordSeparator(codeB));\n}\nconst alternateCharsCache = ( new Map());\nfunction getAlternateCodes(code) {\n    if (( alternateCharsCache.has(code))) {\n        return alternateCharsCache.get(code);\n    }\n    let result;\n    const codes = getKoreanAltChars(code);\n    if (codes) {\n        result = codes;\n    }\n    alternateCharsCache.set(code, result);\n    return result;\n}\nfunction isAlphanumeric(code) {\n    return isLower(code) || isUpper(code) || isNumber(code);\n}\nfunction join(head, tail) {\n    if (tail.length === 0) {\n        tail = [head];\n    }\n    else if (head.end === tail[0].start) {\n        tail[0].start = head.start;\n    }\n    else {\n        tail.unshift(head);\n    }\n    return tail;\n}\nfunction nextAnchor(camelCaseWord, start) {\n    for (let i = start; i < camelCaseWord.length; i++) {\n        const c = camelCaseWord.charCodeAt(i);\n        if (isUpper(c) || isNumber(c) || (i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1)))) {\n            return i;\n        }\n    }\n    return camelCaseWord.length;\n}\nfunction _matchesCamelCase(word, camelCaseWord, i, j) {\n    if (i === word.length) {\n        return [];\n    }\n    else if (j === camelCaseWord.length) {\n        return null;\n    }\n    else if (word[i] !== camelCaseWord[j].toLowerCase()) {\n        return null;\n    }\n    else {\n        let result = null;\n        let nextUpperIndex = j + 1;\n        result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);\n        while (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {\n            result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);\n            nextUpperIndex++;\n        }\n        return result === null ? null : join({ start: j, end: j + 1 }, result);\n    }\n}\nfunction analyzeCamelCaseWord(word) {\n    let upper = 0, lower = 0, alpha = 0, numeric = 0, code = 0;\n    for (let i = 0; i < word.length; i++) {\n        code = word.charCodeAt(i);\n        if (isUpper(code)) {\n            upper++;\n        }\n        if (isLower(code)) {\n            lower++;\n        }\n        if (isAlphanumeric(code)) {\n            alpha++;\n        }\n        if (isNumber(code)) {\n            numeric++;\n        }\n    }\n    const upperPercent = upper / word.length;\n    const lowerPercent = lower / word.length;\n    const alphaPercent = alpha / word.length;\n    const numericPercent = numeric / word.length;\n    return { upperPercent, lowerPercent, alphaPercent, numericPercent };\n}\nfunction isUpperCaseWord(analysis) {\n    const { upperPercent, lowerPercent } = analysis;\n    return lowerPercent === 0 && upperPercent > 0.6;\n}\nfunction isCamelCaseWord(analysis) {\n    const { upperPercent, lowerPercent, alphaPercent, numericPercent } = analysis;\n    return lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;\n}\nfunction isCamelCasePattern(word) {\n    let upper = 0, lower = 0, code = 0, whitespace = 0;\n    for (let i = 0; i < word.length; i++) {\n        code = word.charCodeAt(i);\n        if (isUpper(code)) {\n            upper++;\n        }\n        if (isLower(code)) {\n            lower++;\n        }\n        if (isWhitespace(code)) {\n            whitespace++;\n        }\n    }\n    if ((upper === 0 || lower === 0) && whitespace === 0) {\n        return word.length <= 30;\n    }\n    else {\n        return upper <= 5;\n    }\n}\nfunction matchesCamelCase(word, camelCaseWord) {\n    if (!camelCaseWord) {\n        return null;\n    }\n    camelCaseWord = camelCaseWord.trim();\n    if (camelCaseWord.length === 0) {\n        return null;\n    }\n    if (!isCamelCasePattern(word)) {\n        return null;\n    }\n    if (camelCaseWord.length > 60) {\n        camelCaseWord = camelCaseWord.substring(0, 60);\n    }\n    const analysis = analyzeCamelCaseWord(camelCaseWord);\n    if (!isCamelCaseWord(analysis)) {\n        if (!isUpperCaseWord(analysis)) {\n            return null;\n        }\n        camelCaseWord = camelCaseWord.toLowerCase();\n    }\n    let result = null;\n    let i = 0;\n    word = word.toLowerCase();\n    while (i < camelCaseWord.length && (result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null) {\n        i = nextAnchor(camelCaseWord, i + 1);\n    }\n    return result;\n}\nfunction matchesWords(word, target, contiguous = false) {\n    if (!target || target.length === 0) {\n        return null;\n    }\n    let result = null;\n    let targetIndex = 0;\n    word = word.toLowerCase();\n    target = target.toLowerCase();\n    while (targetIndex < target.length) {\n        result = _matchesWords(word, target, 0, targetIndex, contiguous);\n        if (result !== null) {\n            break;\n        }\n        targetIndex = nextWord(target, targetIndex + 1);\n    }\n    return result;\n}\nfunction _matchesWords(word, target, wordIndex, targetIndex, contiguous) {\n    let targetIndexOffset = 0;\n    if (wordIndex === word.length) {\n        return [];\n    }\n    else if (targetIndex === target.length) {\n        return null;\n    }\n    else if (!charactersMatch(word.charCodeAt(wordIndex), target.charCodeAt(targetIndex))) {\n        const altChars = getAlternateCodes(word.charCodeAt(wordIndex));\n        if (!altChars) {\n            return null;\n        }\n        for (let k = 0; k < altChars.length; k++) {\n            if (!charactersMatch(altChars[k], target.charCodeAt(targetIndex + k))) {\n                return null;\n            }\n        }\n        targetIndexOffset += altChars.length - 1;\n    }\n    let result = null;\n    let nextWordIndex = targetIndex + targetIndexOffset + 1;\n    result = _matchesWords(word, target, wordIndex + 1, nextWordIndex, contiguous);\n    if (!contiguous) {\n        while (!result && (nextWordIndex = nextWord(target, nextWordIndex)) < target.length) {\n            result = _matchesWords(word, target, wordIndex + 1, nextWordIndex, contiguous);\n            nextWordIndex++;\n        }\n    }\n    if (!result) {\n        return null;\n    }\n    if (word.charCodeAt(wordIndex) !== target.charCodeAt(targetIndex)) {\n        const altChars = getAlternateCodes(word.charCodeAt(wordIndex));\n        if (!altChars) {\n            return result;\n        }\n        for (let k = 0; k < altChars.length; k++) {\n            if (altChars[k] !== target.charCodeAt(targetIndex + k)) {\n                return result;\n            }\n        }\n    }\n    return join({ start: targetIndex, end: targetIndex + targetIndexOffset + 1 }, result);\n}\nfunction nextWord(word, start) {\n    for (let i = start; i < word.length; i++) {\n        if (isWordSeparator(word.charCodeAt(i)) ||\n            (i > 0 && isWordSeparator(word.charCodeAt(i - 1)))) {\n            return i;\n        }\n    }\n    return word.length;\n}\nconst fuzzyContiguousFilter = or(matchesPrefix, matchesCamelCase, matchesContiguousSubString);\nconst fuzzySeparateFilter = or(matchesPrefix, matchesCamelCase, matchesSubString);\nconst fuzzyRegExpCache = ( new LRUCache(10000));\nfunction matchesFuzzy(word, wordToMatchAgainst, enableSeparateSubstringMatching = false) {\n    if (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {\n        return null;\n    }\n    let regexp = fuzzyRegExpCache.get(word);\n    if (!regexp) {\n        regexp = ( new RegExp(convertSimple2RegExpPattern(word), 'i'));\n        fuzzyRegExpCache.set(word, regexp);\n    }\n    const match = regexp.exec(wordToMatchAgainst);\n    if (match) {\n        return [{ start: match.index, end: match.index + match[0].length }];\n    }\n    return enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);\n}\nfunction matchesFuzzy2(pattern, word) {\n    const score = fuzzyScore(pattern, pattern.toLowerCase(), 0, word, word.toLowerCase(), 0, { firstMatchCanBeWeak: true, boostFullMatch: true });\n    return score ? createMatches(score) : null;\n}\nfunction anyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos) {\n    const max = Math.min(13, pattern.length);\n    for (; patternPos < max; patternPos++) {\n        const result = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, { firstMatchCanBeWeak: true, boostFullMatch: true });\n        if (result) {\n            return result;\n        }\n    }\n    return [0, wordPos];\n}\nfunction createMatches(score) {\n    if (typeof score === 'undefined') {\n        return [];\n    }\n    const res = [];\n    const wordPos = score[1];\n    for (let i = score.length - 1; i > 1; i--) {\n        const pos = score[i] + wordPos;\n        const last = res[res.length - 1];\n        if (last && last.end === pos) {\n            last.end = pos + 1;\n        }\n        else {\n            res.push({ start: pos, end: pos + 1 });\n        }\n    }\n    return res;\n}\nconst _maxLen = 128;\nfunction initTable() {\n    const table = [];\n    const row = [];\n    for (let i = 0; i <= _maxLen; i++) {\n        row[i] = 0;\n    }\n    for (let i = 0; i <= _maxLen; i++) {\n        table.push(row.slice(0));\n    }\n    return table;\n}\nfunction initArr(maxLen) {\n    const row = [];\n    for (let i = 0; i <= maxLen; i++) {\n        row[i] = 0;\n    }\n    return row;\n}\nconst _minWordMatchPos = initArr(2 * _maxLen);\nconst _maxWordMatchPos = initArr(2 * _maxLen);\nconst _diag = initTable();\nconst _table = initTable();\nconst _arrows = initTable();\nfunction isSeparatorAtPos(value, index) {\n    if (index < 0 || index >= value.length) {\n        return false;\n    }\n    const code = value.codePointAt(index);\n    switch (code) {\n        case 95 :\n        case 45 :\n        case 46 :\n        case 32 :\n        case 47 :\n        case 92 :\n        case 39 :\n        case 34 :\n        case 58 :\n        case 36 :\n        case 60 :\n        case 62 :\n        case 40 :\n        case 41 :\n        case 91 :\n        case 93 :\n        case 123 :\n        case 125 :\n            return true;\n        case undefined:\n            return false;\n        default:\n            if (isEmojiImprecise(code)) {\n                return true;\n            }\n            return false;\n    }\n}\nfunction isWhitespaceAtPos(value, index) {\n    if (index < 0 || index >= value.length) {\n        return false;\n    }\n    const code = value.charCodeAt(index);\n    switch (code) {\n        case 32 :\n        case 9 :\n            return true;\n        default:\n            return false;\n    }\n}\nfunction isUpperCaseAtPos(pos, word, wordLow) {\n    return word[pos] !== wordLow[pos];\n}\nfunction isPatternInWord(patternLow, patternPos, patternLen, wordLow, wordPos, wordLen, fillMinWordPosArr = false) {\n    while (patternPos < patternLen && wordPos < wordLen) {\n        if (patternLow[patternPos] === wordLow[wordPos]) {\n            if (fillMinWordPosArr) {\n                _minWordMatchPos[patternPos] = wordPos;\n            }\n            patternPos += 1;\n        }\n        wordPos += 1;\n    }\n    return patternPos === patternLen;\n}\nvar FuzzyScore;\n( (function(FuzzyScore) {\n    FuzzyScore.Default = ([-100, 0]);\n    function isDefault(score) {\n        return !score || (score.length === 2 && score[0] === -100 && score[1] === 0);\n    }\n    FuzzyScore.isDefault = isDefault;\n})(FuzzyScore || (FuzzyScore = {})));\nclass FuzzyScoreOptions {\n    static { this.default = { boostFullMatch: true, firstMatchCanBeWeak: false }; }\n    constructor(firstMatchCanBeWeak, boostFullMatch) {\n        this.firstMatchCanBeWeak = firstMatchCanBeWeak;\n        this.boostFullMatch = boostFullMatch;\n    }\n}\nfunction fuzzyScore(pattern, patternLow, patternStart, word, wordLow, wordStart, options = FuzzyScoreOptions.default) {\n    const patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;\n    const wordLen = word.length > _maxLen ? _maxLen : word.length;\n    if (patternStart >= patternLen || wordStart >= wordLen || (patternLen - patternStart) > (wordLen - wordStart)) {\n        return undefined;\n    }\n    if (!isPatternInWord(patternLow, patternStart, patternLen, wordLow, wordStart, wordLen, true)) {\n        return undefined;\n    }\n    _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow);\n    let row = 1;\n    let column = 1;\n    let patternPos = patternStart;\n    let wordPos = wordStart;\n    const hasStrongFirstMatch = [false];\n    for (row = 1, patternPos = patternStart; patternPos < patternLen; row++, patternPos++) {\n        const minWordMatchPos = _minWordMatchPos[patternPos];\n        const maxWordMatchPos = _maxWordMatchPos[patternPos];\n        const nextMaxWordMatchPos = (patternPos + 1 < patternLen ? _maxWordMatchPos[patternPos + 1] : wordLen);\n        for (column = minWordMatchPos - wordStart + 1, wordPos = minWordMatchPos; wordPos < nextMaxWordMatchPos; column++, wordPos++) {\n            let score = Number.MIN_SAFE_INTEGER;\n            let canComeDiag = false;\n            if (wordPos <= maxWordMatchPos) {\n                score = _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, _diag[row - 1][column - 1] === 0, hasStrongFirstMatch);\n            }\n            let diagScore = 0;\n            if (score !== Number.MAX_SAFE_INTEGER) {\n                canComeDiag = true;\n                diagScore = score + _table[row - 1][column - 1];\n            }\n            const canComeLeft = wordPos > minWordMatchPos;\n            const leftScore = canComeLeft ? _table[row][column - 1] + (_diag[row][column - 1] > 0 ? -5 : 0) : 0;\n            const canComeLeftLeft = wordPos > minWordMatchPos + 1 && _diag[row][column - 1] > 0;\n            const leftLeftScore = canComeLeftLeft ? _table[row][column - 2] + (_diag[row][column - 2] > 0 ? -5 : 0) : 0;\n            if (canComeLeftLeft && (!canComeLeft || leftLeftScore >= leftScore) && (!canComeDiag || leftLeftScore >= diagScore)) {\n                _table[row][column] = leftLeftScore;\n                _arrows[row][column] = 3 ;\n                _diag[row][column] = 0;\n            }\n            else if (canComeLeft && (!canComeDiag || leftScore >= diagScore)) {\n                _table[row][column] = leftScore;\n                _arrows[row][column] = 2 ;\n                _diag[row][column] = 0;\n            }\n            else if (canComeDiag) {\n                _table[row][column] = diagScore;\n                _arrows[row][column] = 1 ;\n                _diag[row][column] = _diag[row - 1][column - 1] + 1;\n            }\n            else {\n                throw ( new Error(`not possible`));\n            }\n        }\n    }\n    if (!hasStrongFirstMatch[0] && !options.firstMatchCanBeWeak) {\n        return undefined;\n    }\n    row--;\n    column--;\n    const result = [_table[row][column], wordStart];\n    let backwardsDiagLength = 0;\n    let maxMatchColumn = 0;\n    while (row >= 1) {\n        let diagColumn = column;\n        do {\n            const arrow = _arrows[row][diagColumn];\n            if (arrow === 3 ) {\n                diagColumn = diagColumn - 2;\n            }\n            else if (arrow === 2 ) {\n                diagColumn = diagColumn - 1;\n            }\n            else {\n                break;\n            }\n        } while (diagColumn >= 1);\n        if (backwardsDiagLength > 1\n            && patternLow[patternStart + row - 1] === wordLow[wordStart + column - 1]\n            && !isUpperCaseAtPos(diagColumn + wordStart - 1, word, wordLow)\n            && backwardsDiagLength + 1 > _diag[row][diagColumn]\n        ) {\n            diagColumn = column;\n        }\n        if (diagColumn === column) {\n            backwardsDiagLength++;\n        }\n        else {\n            backwardsDiagLength = 1;\n        }\n        if (!maxMatchColumn) {\n            maxMatchColumn = diagColumn;\n        }\n        row--;\n        column = diagColumn - 1;\n        result.push(column);\n    }\n    if (wordLen - wordStart === patternLen && options.boostFullMatch) {\n        result[0] += 2;\n    }\n    const skippedCharsCount = maxMatchColumn - patternLen;\n    result[0] -= skippedCharsCount;\n    return result;\n}\nfunction _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow) {\n    let patternPos = patternLen - 1;\n    let wordPos = wordLen - 1;\n    while (patternPos >= patternStart && wordPos >= wordStart) {\n        if (patternLow[patternPos] === wordLow[wordPos]) {\n            _maxWordMatchPos[patternPos] = wordPos;\n            patternPos--;\n        }\n        wordPos--;\n    }\n}\nfunction _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, newMatchStart, outFirstMatchStrong) {\n    if (patternLow[patternPos] !== wordLow[wordPos]) {\n        return Number.MIN_SAFE_INTEGER;\n    }\n    let score = 1;\n    let isGapLocation = false;\n    if (wordPos === (patternPos - patternStart)) {\n        score = pattern[patternPos] === word[wordPos] ? 7 : 5;\n    }\n    else if (isUpperCaseAtPos(wordPos, word, wordLow) && (wordPos === 0 || !isUpperCaseAtPos(wordPos - 1, word, wordLow))) {\n        score = pattern[patternPos] === word[wordPos] ? 7 : 5;\n        isGapLocation = true;\n    }\n    else if (isSeparatorAtPos(wordLow, wordPos) && (wordPos === 0 || !isSeparatorAtPos(wordLow, wordPos - 1))) {\n        score = 5;\n    }\n    else if (isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1)) {\n        score = 5;\n        isGapLocation = true;\n    }\n    if (score > 1 && patternPos === patternStart) {\n        outFirstMatchStrong[0] = true;\n    }\n    if (!isGapLocation) {\n        isGapLocation = isUpperCaseAtPos(wordPos, word, wordLow) || isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1);\n    }\n    if (patternPos === patternStart) {\n        if (wordPos > wordStart) {\n            score -= isGapLocation ? 3 : 5;\n        }\n    }\n    else {\n        if (newMatchStart) {\n            score += isGapLocation ? 2 : 0;\n        }\n        else {\n            score += isGapLocation ? 0 : 1;\n        }\n    }\n    if (wordPos + 1 === wordLen) {\n        score -= isGapLocation ? 3 : 5;\n    }\n    return score;\n}\nfunction fuzzyScoreGracefulAggressive(pattern, lowPattern, patternPos, word, lowWord, wordPos, options) {\n    return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, true, options);\n}\nfunction fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, aggressive, options) {\n    let top = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, options);\n    if (top && !aggressive) {\n        return top;\n    }\n    if (pattern.length >= 3) {\n        const tries = Math.min(7, pattern.length - 1);\n        for (let movingPatternPos = patternPos + 1; movingPatternPos < tries; movingPatternPos++) {\n            const newPattern = nextTypoPermutation(pattern, movingPatternPos);\n            if (newPattern) {\n                const candidate = fuzzyScore(newPattern, newPattern.toLowerCase(), patternPos, word, lowWord, wordPos, options);\n                if (candidate) {\n                    candidate[0] -= 3;\n                    if (!top || candidate[0] > top[0]) {\n                        top = candidate;\n                    }\n                }\n            }\n        }\n    }\n    return top;\n}\nfunction nextTypoPermutation(pattern, patternPos) {\n    if (patternPos + 1 >= pattern.length) {\n        return undefined;\n    }\n    const swap1 = pattern[patternPos];\n    const swap2 = pattern[patternPos + 1];\n    if (swap1 === swap2) {\n        return undefined;\n    }\n    return pattern.slice(0, patternPos)\n        + swap2\n        + swap1\n        + pattern.slice(patternPos + 2);\n}\nexport { FuzzyScore, FuzzyScoreOptions, anyScore, createMatches, fuzzyScore, fuzzyScoreGracefulAggressive, isPatternInWord, isUpper, matchesCamelCase, matchesContiguousSubString, matchesFuzzy, matchesFuzzy2, matchesPrefix, matchesSubString, matchesWords, or };\n","import './arrays.js';\nimport { isThenable } from './async.js';\nimport { isEqualOrParent } from './extpath.js';\nimport { LRUCache } from './map.js';\nimport { sep, basename, extname, posix } from './path.js';\nimport { isLinux } from './platform.js';\nimport { escapeRegExpCharacters, ltrim } from './strings.js';\nfunction getEmptyExpression() {\n    return Object.create(null);\n}\nconst GLOBSTAR = '**';\nconst GLOB_SPLIT = '/';\nconst PATH_REGEX = '[/\\\\\\\\]';\nconst NO_PATH_REGEX = '[^/\\\\\\\\]';\nconst ALL_FORWARD_SLASHES = /\\//g;\nfunction starsToRegExp(starCount, isLastPattern) {\n    switch (starCount) {\n        case 0:\n            return '';\n        case 1:\n            return `${NO_PATH_REGEX}*?`;\n        default:\n            return `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}${isLastPattern ? `|${PATH_REGEX}${NO_PATH_REGEX}+` : ''})*?`;\n    }\n}\nfunction splitGlobAware(pattern, splitChar) {\n    if (!pattern) {\n        return [];\n    }\n    const segments = [];\n    let inBraces = false;\n    let inBrackets = false;\n    let curVal = '';\n    for (const char of pattern) {\n        switch (char) {\n            case splitChar:\n                if (!inBraces && !inBrackets) {\n                    segments.push(curVal);\n                    curVal = '';\n                    continue;\n                }\n                break;\n            case '{':\n                inBraces = true;\n                break;\n            case '}':\n                inBraces = false;\n                break;\n            case '[':\n                inBrackets = true;\n                break;\n            case ']':\n                inBrackets = false;\n                break;\n        }\n        curVal += char;\n    }\n    if (curVal) {\n        segments.push(curVal);\n    }\n    return segments;\n}\nfunction parseRegExp(pattern) {\n    if (!pattern) {\n        return '';\n    }\n    let regEx = '';\n    const segments = splitGlobAware(pattern, GLOB_SPLIT);\n    if (segments.every(segment => segment === GLOBSTAR)) {\n        regEx = '.*';\n    }\n    else {\n        let previousSegmentWasGlobStar = false;\n        segments.forEach((segment, index) => {\n            if (segment === GLOBSTAR) {\n                if (previousSegmentWasGlobStar) {\n                    return;\n                }\n                regEx += starsToRegExp(2, index === segments.length - 1);\n            }\n            else {\n                let inBraces = false;\n                let braceVal = '';\n                let inBrackets = false;\n                let bracketVal = '';\n                for (const char of segment) {\n                    if (char !== '}' && inBraces) {\n                        braceVal += char;\n                        continue;\n                    }\n                    if (inBrackets && (char !== ']' || !bracketVal) ) {\n                        let res;\n                        if (char === '-') {\n                            res = char;\n                        }\n                        else if ((char === '^' || char === '!') && !bracketVal) {\n                            res = '^';\n                        }\n                        else if (char === GLOB_SPLIT) {\n                            res = '';\n                        }\n                        else {\n                            res = escapeRegExpCharacters(char);\n                        }\n                        bracketVal += res;\n                        continue;\n                    }\n                    switch (char) {\n                        case '{':\n                            inBraces = true;\n                            continue;\n                        case '[':\n                            inBrackets = true;\n                            continue;\n                        case '}': {\n                            const choices = splitGlobAware(braceVal, ',');\n                            const braceRegExp = `(?:${( choices.map(choice => parseRegExp(choice))).join('|')})`;\n                            regEx += braceRegExp;\n                            inBraces = false;\n                            braceVal = '';\n                            break;\n                        }\n                        case ']': {\n                            regEx += ('[' + bracketVal + ']');\n                            inBrackets = false;\n                            bracketVal = '';\n                            break;\n                        }\n                        case '?':\n                            regEx += NO_PATH_REGEX;\n                            continue;\n                        case '*':\n                            regEx += starsToRegExp(1);\n                            continue;\n                        default:\n                            regEx += escapeRegExpCharacters(char);\n                    }\n                }\n                if (index < segments.length - 1 &&\n                    ((\n                segments[index + 1] !== GLOBSTAR || index + 2 < segments.length)\n                    )) {\n                    regEx += PATH_REGEX;\n                }\n            }\n            previousSegmentWasGlobStar = (segment === GLOBSTAR);\n        });\n    }\n    return regEx;\n}\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/;\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/;\nconst T3 = /^{\\*\\*\\/\\*?[\\w\\.-]+\\/?(,\\*\\*\\/\\*?[\\w\\.-]+\\/?)*}$/;\nconst T3_2 = /^{\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/;\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/;\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/;\nconst CACHE = ( new LRUCache(10000));\nconst FALSE = function () {\n    return false;\n};\nconst NULL = function () {\n    return null;\n};\nfunction parsePattern(arg1, options) {\n    if (!arg1) {\n        return NULL;\n    }\n    let pattern;\n    if (typeof arg1 !== 'string') {\n        pattern = arg1.pattern;\n    }\n    else {\n        pattern = arg1;\n    }\n    pattern = pattern.trim();\n    const patternKey = `${pattern}_${!!options.trimForExclusions}`;\n    let parsedPattern = CACHE.get(patternKey);\n    if (parsedPattern) {\n        return wrapRelativePattern(parsedPattern, arg1);\n    }\n    let match;\n    if (T1.test(pattern)) {\n        parsedPattern = trivia1(pattern.substr(4), pattern);\n    }\n    else if (match = T2.exec(trimForExclusions(pattern, options))) {\n        parsedPattern = trivia2(match[1], pattern);\n    }\n    else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) {\n        parsedPattern = trivia3(pattern, options);\n    }\n    else if (match = T4.exec(trimForExclusions(pattern, options))) {\n        parsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n    }\n    else if (match = T5.exec(trimForExclusions(pattern, options))) {\n        parsedPattern = trivia4and5(match[1], pattern, false);\n    }\n    else {\n        parsedPattern = toRegExp(pattern);\n    }\n    CACHE.set(patternKey, parsedPattern);\n    return wrapRelativePattern(parsedPattern, arg1);\n}\nfunction wrapRelativePattern(parsedPattern, arg2) {\n    if (typeof arg2 === 'string') {\n        return parsedPattern;\n    }\n    const wrappedPattern = function (path, basename) {\n        if (!isEqualOrParent(path, arg2.base, !isLinux)) {\n            return null;\n        }\n        return parsedPattern(ltrim(path.substr(arg2.base.length), sep), basename);\n    };\n    wrappedPattern.allBasenames = parsedPattern.allBasenames;\n    wrappedPattern.allPaths = parsedPattern.allPaths;\n    wrappedPattern.basenames = parsedPattern.basenames;\n    wrappedPattern.patterns = parsedPattern.patterns;\n    return wrappedPattern;\n}\nfunction trimForExclusions(pattern, options) {\n    return options.trimForExclusions && pattern.endsWith('/**') ? pattern.substr(0, pattern.length - 2) : pattern;\n}\nfunction trivia1(base, pattern) {\n    return function (path, basename) {\n        return typeof path === 'string' && path.endsWith(base) ? pattern : null;\n    };\n}\nfunction trivia2(base, pattern) {\n    const slashBase = `/${base}`;\n    const backslashBase = `\\\\${base}`;\n    const parsedPattern = function (path, basename) {\n        if (typeof path !== 'string') {\n            return null;\n        }\n        if (basename) {\n            return basename === base ? pattern : null;\n        }\n        return path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? pattern : null;\n    };\n    const basenames = [base];\n    parsedPattern.basenames = basenames;\n    parsedPattern.patterns = [pattern];\n    parsedPattern.allBasenames = basenames;\n    return parsedPattern;\n}\nfunction trivia3(pattern, options) {\n    const parsedPatterns = aggregateBasenameMatches(( pattern.slice(1, -1)\n        .split(',')\n        .map(pattern => parsePattern(pattern, options)))\n        .filter(pattern => pattern !== NULL), pattern);\n    const patternsLength = parsedPatterns.length;\n    if (!patternsLength) {\n        return NULL;\n    }\n    if (patternsLength === 1) {\n        return parsedPatterns[0];\n    }\n    const parsedPattern = function (path, basename) {\n        for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n            if (parsedPatterns[i](path, basename)) {\n                return pattern;\n            }\n        }\n        return null;\n    };\n    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n    if (withBasenames) {\n        parsedPattern.allBasenames = withBasenames.allBasenames;\n    }\n    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n    if (allPaths.length) {\n        parsedPattern.allPaths = allPaths;\n    }\n    return parsedPattern;\n}\nfunction trivia4and5(targetPath, pattern, matchPathEnds) {\n    const usingPosixSep = sep === posix.sep;\n    const nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, sep);\n    const nativePathEnd = sep + nativePath;\n    const targetPathEnd = posix.sep + targetPath;\n    let parsedPattern;\n    if (matchPathEnds) {\n        parsedPattern = function (path, basename) {\n            return typeof path === 'string' && ((path === nativePath || path.endsWith(nativePathEnd)) || !usingPosixSep && (path === targetPath || path.endsWith(targetPathEnd))) ? pattern : null;\n        };\n    }\n    else {\n        parsedPattern = function (path, basename) {\n            return typeof path === 'string' && (path === nativePath || (!usingPosixSep && path === targetPath)) ? pattern : null;\n        };\n    }\n    parsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + targetPath];\n    return parsedPattern;\n}\nfunction toRegExp(pattern) {\n    try {\n        const regExp = ( new RegExp(`^${parseRegExp(pattern)}$`));\n        return function (path) {\n            regExp.lastIndex = 0;\n            return typeof path === 'string' && regExp.test(path) ? pattern : null;\n        };\n    }\n    catch (error) {\n        return NULL;\n    }\n}\nfunction match(arg1, path, hasSibling) {\n    if (!arg1 || typeof path !== 'string') {\n        return false;\n    }\n    return parse(arg1)(path, undefined, hasSibling);\n}\nfunction parse(arg1, options = {}) {\n    if (!arg1) {\n        return FALSE;\n    }\n    if (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n        const parsedPattern = parsePattern(arg1, options);\n        if (parsedPattern === NULL) {\n            return FALSE;\n        }\n        const resultPattern = function (path, basename) {\n            return !!parsedPattern(path, basename);\n        };\n        if (parsedPattern.allBasenames) {\n            resultPattern.allBasenames = parsedPattern.allBasenames;\n        }\n        if (parsedPattern.allPaths) {\n            resultPattern.allPaths = parsedPattern.allPaths;\n        }\n        return resultPattern;\n    }\n    return parsedExpression(arg1, options);\n}\nfunction isRelativePattern(obj) {\n    const rp = obj;\n    if (!rp) {\n        return false;\n    }\n    return typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\nfunction parsedExpression(expression, options) {\n    const parsedPatterns = aggregateBasenameMatches(( Object.getOwnPropertyNames(expression)\n        .map(pattern => parseExpressionPattern(pattern, expression[pattern], options)))\n        .filter(pattern => pattern !== NULL));\n    const patternsLength = parsedPatterns.length;\n    if (!patternsLength) {\n        return NULL;\n    }\n    if (!( parsedPatterns.some(parsedPattern => !!parsedPattern.requiresSiblings))) {\n        if (patternsLength === 1) {\n            return parsedPatterns[0];\n        }\n        const resultExpression = function (path, basename) {\n            let resultPromises = undefined;\n            for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n                const result = parsedPatterns[i](path, basename);\n                if (typeof result === 'string') {\n                    return result;\n                }\n                if (isThenable(result)) {\n                    if (!resultPromises) {\n                        resultPromises = [];\n                    }\n                    resultPromises.push(result);\n                }\n            }\n            if (resultPromises) {\n                return (async () => {\n                    for (const resultPromise of resultPromises) {\n                        const result = await resultPromise;\n                        if (typeof result === 'string') {\n                            return result;\n                        }\n                    }\n                    return null;\n                })();\n            }\n            return null;\n        };\n        const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n        if (withBasenames) {\n            resultExpression.allBasenames = withBasenames.allBasenames;\n        }\n        const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n        if (allPaths.length) {\n            resultExpression.allPaths = allPaths;\n        }\n        return resultExpression;\n    }\n    const resultExpression = function (path, base, hasSibling) {\n        let name = undefined;\n        let resultPromises = undefined;\n        for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n            const parsedPattern = parsedPatterns[i];\n            if (parsedPattern.requiresSiblings && hasSibling) {\n                if (!base) {\n                    base = basename(path);\n                }\n                if (!name) {\n                    name = base.substr(0, base.length - extname(path).length);\n                }\n            }\n            const result = parsedPattern(path, base, name, hasSibling);\n            if (typeof result === 'string') {\n                return result;\n            }\n            if (isThenable(result)) {\n                if (!resultPromises) {\n                    resultPromises = [];\n                }\n                resultPromises.push(result);\n            }\n        }\n        if (resultPromises) {\n            return (async () => {\n                for (const resultPromise of resultPromises) {\n                    const result = await resultPromise;\n                    if (typeof result === 'string') {\n                        return result;\n                    }\n                }\n                return null;\n            })();\n        }\n        return null;\n    };\n    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n    if (withBasenames) {\n        resultExpression.allBasenames = withBasenames.allBasenames;\n    }\n    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n    if (allPaths.length) {\n        resultExpression.allPaths = allPaths;\n    }\n    return resultExpression;\n}\nfunction parseExpressionPattern(pattern, value, options) {\n    if (value === false) {\n        return NULL;\n    }\n    const parsedPattern = parsePattern(pattern, options);\n    if (parsedPattern === NULL) {\n        return NULL;\n    }\n    if (typeof value === 'boolean') {\n        return parsedPattern;\n    }\n    if (value) {\n        const when = value.when;\n        if (typeof when === 'string') {\n            const result = (path, basename, name, hasSibling) => {\n                if (!hasSibling || !parsedPattern(path, basename)) {\n                    return null;\n                }\n                const clausePattern = when.replace('$(basename)', () => name);\n                const matched = hasSibling(clausePattern);\n                return isThenable(matched) ?\n                    matched.then(match => match ? pattern : null) :\n                    matched ? pattern : null;\n            };\n            result.requiresSiblings = true;\n            return result;\n        }\n    }\n    return parsedPattern;\n}\nfunction aggregateBasenameMatches(parsedPatterns, result) {\n    const basenamePatterns = parsedPatterns.filter(parsedPattern => !!parsedPattern.basenames);\n    if (basenamePatterns.length < 2) {\n        return parsedPatterns;\n    }\n    const basenames = basenamePatterns.reduce((all, current) => {\n        const basenames = current.basenames;\n        return basenames ? all.concat(basenames) : all;\n    }, []);\n    let patterns;\n    if (result) {\n        patterns = [];\n        for (let i = 0, n = basenames.length; i < n; i++) {\n            patterns.push(result);\n        }\n    }\n    else {\n        patterns = basenamePatterns.reduce((all, current) => {\n            const patterns = current.patterns;\n            return patterns ? all.concat(patterns) : all;\n        }, []);\n    }\n    const aggregate = function (path, basename) {\n        if (typeof path !== 'string') {\n            return null;\n        }\n        if (!basename) {\n            let i;\n            for (i = path.length; i > 0; i--) {\n                const ch = path.charCodeAt(i - 1);\n                if (ch === 47  || ch === 92 ) {\n                    break;\n                }\n            }\n            basename = path.substr(i);\n        }\n        const index = basenames.indexOf(basename);\n        return index !== -1 ? patterns[index] : null;\n    };\n    aggregate.basenames = basenames;\n    aggregate.patterns = patterns;\n    aggregate.allBasenames = basenames;\n    const aggregatedPatterns = parsedPatterns.filter(parsedPattern => !parsedPattern.basenames);\n    aggregatedPatterns.push(aggregate);\n    return aggregatedPatterns;\n}\nexport { GLOBSTAR, GLOB_SPLIT, getEmptyExpression, isRelativePattern, match, parse, splitGlobAware };\n","import { illegalArgument } from './errors.js';\nimport { escapeIcons } from './iconLabels.js';\nimport { isEqual } from './resources.js';\nimport { escapeRegExpCharacters } from './strings.js';\nimport { URI } from './uri.js';\nclass MarkdownString {\n    constructor(value = '', isTrustedOrOptions = false) {\n        this.value = value;\n        if (typeof this.value !== 'string') {\n            throw illegalArgument('value');\n        }\n        if (typeof isTrustedOrOptions === 'boolean') {\n            this.isTrusted = isTrustedOrOptions;\n            this.supportThemeIcons = false;\n            this.supportHtml = false;\n        }\n        else {\n            this.isTrusted = isTrustedOrOptions.isTrusted ?? undefined;\n            this.supportThemeIcons = isTrustedOrOptions.supportThemeIcons ?? false;\n            this.supportHtml = isTrustedOrOptions.supportHtml ?? false;\n        }\n    }\n    appendText(value, newlineStyle = 0 ) {\n        this.value += escapeMarkdownSyntaxTokens(this.supportThemeIcons ? escapeIcons(value) : value)\n            .replace(/([ \\t]+)/g, (_match, g1) => '&nbsp;'.repeat(g1.length))\n            .replace(/\\>/gm, '\\\\>')\n            .replace(/\\n/g, newlineStyle === 1  ? '\\\\\\n' : '\\n\\n');\n        return this;\n    }\n    appendMarkdown(value) {\n        this.value += value;\n        return this;\n    }\n    appendCodeblock(langId, code) {\n        this.value += `\\n${appendEscapedMarkdownCodeBlockFence(code, langId)}\\n`;\n        return this;\n    }\n    appendLink(target, label, title) {\n        this.value += '[';\n        this.value += this._escape(label, ']');\n        this.value += '](';\n        this.value += this._escape(String(target), ')');\n        if (title) {\n            this.value += ` \"${this._escape(this._escape(title, '\"'), ')')}\"`;\n        }\n        this.value += ')';\n        return this;\n    }\n    _escape(value, ch) {\n        const r = ( new RegExp(escapeRegExpCharacters(ch), 'g'));\n        return value.replace(r, (match, offset) => {\n            if (value.charAt(offset - 1) !== '\\\\') {\n                return `\\\\${match}`;\n            }\n            else {\n                return match;\n            }\n        });\n    }\n}\nfunction isEmptyMarkdownString(oneOrMany) {\n    if (isMarkdownString(oneOrMany)) {\n        return !oneOrMany.value;\n    }\n    else if (Array.isArray(oneOrMany)) {\n        return oneOrMany.every(isEmptyMarkdownString);\n    }\n    else {\n        return true;\n    }\n}\nfunction isMarkdownString(thing) {\n    if (thing instanceof MarkdownString) {\n        return true;\n    }\n    else if (thing && typeof thing === 'object') {\n        return typeof thing.value === 'string'\n            && (typeof thing.isTrusted === 'boolean' || typeof thing.isTrusted === 'object' || thing.isTrusted === undefined)\n            && (typeof thing.supportThemeIcons === 'boolean' || thing.supportThemeIcons === undefined);\n    }\n    return false;\n}\nfunction markdownStringEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    else if (!a || !b) {\n        return false;\n    }\n    else {\n        return a.value === b.value\n            && a.isTrusted === b.isTrusted\n            && a.supportThemeIcons === b.supportThemeIcons\n            && a.supportHtml === b.supportHtml\n            && (a.baseUri === b.baseUri || !!a.baseUri && !!b.baseUri && isEqual(( URI.from(a.baseUri)), ( URI.from(b.baseUri))));\n    }\n}\nfunction escapeMarkdownSyntaxTokens(text) {\n    return text.replace(/[\\\\`*_{}[\\]()#+\\-!~]/g, '\\\\$&');\n}\nfunction appendEscapedMarkdownCodeBlockFence(code, langId) {\n    const longestFenceLength = code.match(/^`+/gm)?.reduce((a, b) => (a.length > b.length ? a : b)).length ??\n        0;\n    const desiredFenceLength = longestFenceLength >= 3 ? longestFenceLength + 1 : 3;\n    return [\n        `${'`'.repeat(desiredFenceLength)}${langId}`,\n        code,\n        `${'`'.repeat(desiredFenceLength)}`,\n    ].join('\\n');\n}\nfunction escapeDoubleQuotes(input) {\n    return input.replace(/\"/g, '&quot;');\n}\nfunction removeMarkdownEscapes(text) {\n    if (!text) {\n        return text;\n    }\n    return text.replace(/\\\\([\\\\`*_{}[\\]()#+\\-.!~])/g, '$1');\n}\nfunction parseHrefAndDimensions(href) {\n    const dimensions = [];\n    const splitted = ( href.split('|').map(s => s.trim()));\n    href = splitted[0];\n    const parameters = splitted[1];\n    if (parameters) {\n        const heightFromParams = /height=(\\d+)/.exec(parameters);\n        const widthFromParams = /width=(\\d+)/.exec(parameters);\n        const height = heightFromParams ? heightFromParams[1] : '';\n        const width = widthFromParams ? widthFromParams[1] : '';\n        const widthIsFinite = isFinite(parseInt(width));\n        const heightIsFinite = isFinite(parseInt(height));\n        if (widthIsFinite) {\n            dimensions.push(`width=\"${width}\"`);\n        }\n        if (heightIsFinite) {\n            dimensions.push(`height=\"${height}\"`);\n        }\n    }\n    return { href, dimensions };\n}\nexport { MarkdownString, appendEscapedMarkdownCodeBlockFence, escapeDoubleQuotes, escapeMarkdownSyntaxTokens, isEmptyMarkdownString, isMarkdownString, markdownStringEqual, parseHrefAndDimensions, removeMarkdownEscapes };\n","import { matchesFuzzy } from './filters.js';\nimport { ltrim } from './strings.js';\nimport { ThemeIcon } from './themables.js';\nconst iconStartMarker = '$(';\nconst iconsRegex = ( new RegExp(\n    `\\\\$\\\\(${ThemeIcon.iconNameExpression}(?:${ThemeIcon.iconModifierExpression})?\\\\)`,\n    'g'\n));\nconst escapeIconsRegex = ( new RegExp(`(\\\\\\\\)?${iconsRegex.source}`, 'g'));\nfunction escapeIcons(text) {\n    return text.replace(escapeIconsRegex, (match, escaped) => escaped ? match : `\\\\${match}`);\n}\nconst markdownEscapedIconsRegex = ( new RegExp(`\\\\\\\\${iconsRegex.source}`, 'g'));\nfunction markdownEscapeEscapedIcons(text) {\n    return text.replace(markdownEscapedIconsRegex, match => `\\\\${match}`);\n}\nconst stripIconsRegex = ( new RegExp(`(\\\\s)?(\\\\\\\\)?${iconsRegex.source}(\\\\s)?`, 'g'));\nfunction stripIcons(text) {\n    if (text.indexOf(iconStartMarker) === -1) {\n        return text;\n    }\n    return text.replace(stripIconsRegex, (match, preWhitespace, escaped, postWhitespace) => escaped ? match : preWhitespace || postWhitespace || '');\n}\nfunction getCodiconAriaLabel(text) {\n    if (!text) {\n        return '';\n    }\n    return text.replace(/\\$\\((.*?)\\)/g, (_match, codiconName) => ` ${codiconName} `).trim();\n}\nconst _parseIconsRegex = ( new RegExp(`\\\\$\\\\(${ThemeIcon.iconNameCharacter}+\\\\)`, 'g'));\nfunction parseLabelWithIcons(input) {\n    _parseIconsRegex.lastIndex = 0;\n    let text = '';\n    const iconOffsets = [];\n    let iconsOffset = 0;\n    while (true) {\n        const pos = _parseIconsRegex.lastIndex;\n        const match = _parseIconsRegex.exec(input);\n        const chars = input.substring(pos, match?.index);\n        if (chars.length > 0) {\n            text += chars;\n            for (let i = 0; i < chars.length; i++) {\n                iconOffsets.push(iconsOffset);\n            }\n        }\n        if (!match) {\n            break;\n        }\n        iconsOffset += match[0].length;\n    }\n    return { text, iconOffsets };\n}\nfunction matchesFuzzyIconAware(query, target, enableSeparateSubstringMatching = false) {\n    const { text, iconOffsets } = target;\n    if (!iconOffsets || iconOffsets.length === 0) {\n        return matchesFuzzy(query, text, enableSeparateSubstringMatching);\n    }\n    const wordToMatchAgainstWithoutIconsTrimmed = ltrim(text, ' ');\n    const leadingWhitespaceOffset = text.length - wordToMatchAgainstWithoutIconsTrimmed.length;\n    const matches = matchesFuzzy(query, wordToMatchAgainstWithoutIconsTrimmed, enableSeparateSubstringMatching);\n    if (matches) {\n        for (const match of matches) {\n            const iconOffset = iconOffsets[match.start + leadingWhitespaceOffset]  + leadingWhitespaceOffset ;\n            match.start += iconOffset;\n            match.end += iconOffset;\n        }\n    }\n    return matches;\n}\nexport { escapeIcons, getCodiconAriaLabel, markdownEscapeEscapedIcons, matchesFuzzyIconAware, parseLabelWithIcons, stripIcons };\n","class IdGenerator {\n    constructor(prefix) {\n        this._prefix = prefix;\n        this._lastId = 0;\n    }\n    nextId() {\n        return this._prefix + (++this._lastId);\n    }\n}\nconst defaultGenerator = ( new IdGenerator('id#'));\nexport { IdGenerator, defaultGenerator };\n","var ParseOptions;\n( (function(ParseOptions) {\n    ParseOptions.DEFAULT = {\n        allowTrailingComma: true\n    };\n})(ParseOptions || (ParseOptions = {})));\nfunction createScanner(text, ignoreTrivia = false) {\n    let pos = 0;\n    const len = text.length;\n    let value = '';\n    let tokenOffset = 0;\n    let token = 16 ;\n    let scanError = 0 ;\n    function scanHexDigits(count) {\n        let digits = 0;\n        let hexValue = 0;\n        while (digits < count) {\n            const ch = text.charCodeAt(pos);\n            if (ch >= 48  && ch <= 57 ) {\n                hexValue = hexValue * 16 + ch - 48 ;\n            }\n            else if (ch >= 65  && ch <= 70 ) {\n                hexValue = hexValue * 16 + ch - 65  + 10;\n            }\n            else if (ch >= 97  && ch <= 102 ) {\n                hexValue = hexValue * 16 + ch - 97  + 10;\n            }\n            else {\n                break;\n            }\n            pos++;\n            digits++;\n        }\n        if (digits < count) {\n            hexValue = -1;\n        }\n        return hexValue;\n    }\n    function setPosition(newPosition) {\n        pos = newPosition;\n        value = '';\n        tokenOffset = 0;\n        token = 16 ;\n        scanError = 0 ;\n    }\n    function scanNumber() {\n        const start = pos;\n        if (text.charCodeAt(pos) === 48 ) {\n            pos++;\n        }\n        else {\n            pos++;\n            while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                pos++;\n            }\n        }\n        if (pos < text.length && text.charCodeAt(pos) === 46 ) {\n            pos++;\n            if (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                pos++;\n                while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                    pos++;\n                }\n            }\n            else {\n                scanError = 3 ;\n                return text.substring(start, pos);\n            }\n        }\n        let end = pos;\n        if (pos < text.length && ((text.charCodeAt(pos) === 69  || text.charCodeAt(pos) === 101) )) {\n            pos++;\n            if (pos < text.length && text.charCodeAt(pos) === 43  || text.charCodeAt(pos) === 45 ) {\n                pos++;\n            }\n            if (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                pos++;\n                while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                    pos++;\n                }\n                end = pos;\n            }\n            else {\n                scanError = 3 ;\n            }\n        }\n        return text.substring(start, end);\n    }\n    function scanString() {\n        let result = '', start = pos;\n        while (true) {\n            if (pos >= len) {\n                result += text.substring(start, pos);\n                scanError = 2 ;\n                break;\n            }\n            const ch = text.charCodeAt(pos);\n            if (ch === 34 ) {\n                result += text.substring(start, pos);\n                pos++;\n                break;\n            }\n            if (ch === 92 ) {\n                result += text.substring(start, pos);\n                pos++;\n                if (pos >= len) {\n                    scanError = 2 ;\n                    break;\n                }\n                const ch2 = text.charCodeAt(pos++);\n                switch (ch2) {\n                    case 34 :\n                        result += '\\\"';\n                        break;\n                    case 92 :\n                        result += '\\\\';\n                        break;\n                    case 47 :\n                        result += '/';\n                        break;\n                    case 98 :\n                        result += '\\b';\n                        break;\n                    case 102 :\n                        result += '\\f';\n                        break;\n                    case 110 :\n                        result += '\\n';\n                        break;\n                    case 114 :\n                        result += '\\r';\n                        break;\n                    case 116 :\n                        result += '\\t';\n                        break;\n                    case 117 : {\n                        const ch3 = scanHexDigits(4);\n                        if (ch3 >= 0) {\n                            result += String.fromCharCode(ch3);\n                        }\n                        else {\n                            scanError = 4 ;\n                        }\n                        break;\n                    }\n                    default:\n                        scanError = 5 ;\n                }\n                start = pos;\n                continue;\n            }\n            if (ch >= 0 && ch <= 0x1F) {\n                if (isLineBreak(ch)) {\n                    result += text.substring(start, pos);\n                    scanError = 2 ;\n                    break;\n                }\n                else {\n                    scanError = 6 ;\n                }\n            }\n            pos++;\n        }\n        return result;\n    }\n    function scanNext() {\n        value = '';\n        scanError = 0 ;\n        tokenOffset = pos;\n        if (pos >= len) {\n            tokenOffset = len;\n            return token = 17 ;\n        }\n        let code = text.charCodeAt(pos);\n        if (isWhitespace(code)) {\n            do {\n                pos++;\n                value += String.fromCharCode(code);\n                code = text.charCodeAt(pos);\n            } while (isWhitespace(code));\n            return token = 15 ;\n        }\n        if (isLineBreak(code)) {\n            pos++;\n            value += String.fromCharCode(code);\n            if (code === 13  && text.charCodeAt(pos) === 10 ) {\n                pos++;\n                value += '\\n';\n            }\n            return token = 14 ;\n        }\n        switch (code) {\n            case 123 :\n                pos++;\n                return token = 1 ;\n            case 125 :\n                pos++;\n                return token = 2 ;\n            case 91 :\n                pos++;\n                return token = 3 ;\n            case 93 :\n                pos++;\n                return token = 4 ;\n            case 58 :\n                pos++;\n                return token = 6 ;\n            case 44 :\n                pos++;\n                return token = 5 ;\n            case 34 :\n                pos++;\n                value = scanString();\n                return token = 10 ;\n            case 47 : {\n                const start = pos - 1;\n                if (text.charCodeAt(pos + 1) === 47 ) {\n                    pos += 2;\n                    while (pos < len) {\n                        if (isLineBreak(text.charCodeAt(pos))) {\n                            break;\n                        }\n                        pos++;\n                    }\n                    value = text.substring(start, pos);\n                    return token = 12 ;\n                }\n                if (text.charCodeAt(pos + 1) === 42 ) {\n                    pos += 2;\n                    const safeLength = len - 1;\n                    let commentClosed = false;\n                    while (pos < safeLength) {\n                        const ch = text.charCodeAt(pos);\n                        if (ch === 42  && text.charCodeAt(pos + 1) === 47 ) {\n                            pos += 2;\n                            commentClosed = true;\n                            break;\n                        }\n                        pos++;\n                    }\n                    if (!commentClosed) {\n                        pos++;\n                        scanError = 1 ;\n                    }\n                    value = text.substring(start, pos);\n                    return token = 13 ;\n                }\n                value += String.fromCharCode(code);\n                pos++;\n                return token = 16 ;\n            }\n            case 45 :\n                value += String.fromCharCode(code);\n                pos++;\n                if (pos === len || !isDigit(text.charCodeAt(pos))) {\n                    return token = 16 ;\n                }\n            case 48 :\n            case 49 :\n            case 50 :\n            case 51 :\n            case 52 :\n            case 53 :\n            case 54 :\n            case 55 :\n            case 56 :\n            case 57 :\n                value += scanNumber();\n                return token = 11 ;\n            default:\n                while (pos < len && isUnknownContentCharacter(code)) {\n                    pos++;\n                    code = text.charCodeAt(pos);\n                }\n                if (tokenOffset !== pos) {\n                    value = text.substring(tokenOffset, pos);\n                    switch (value) {\n                        case 'true': return token = 8 ;\n                        case 'false': return token = 9 ;\n                        case 'null': return token = 7 ;\n                    }\n                    return token = 16 ;\n                }\n                value += String.fromCharCode(code);\n                pos++;\n                return token = 16 ;\n        }\n    }\n    function isUnknownContentCharacter(code) {\n        if (isWhitespace(code) || isLineBreak(code)) {\n            return false;\n        }\n        switch (code) {\n            case 125 :\n            case 93 :\n            case 123 :\n            case 91 :\n            case 34 :\n            case 58 :\n            case 44 :\n            case 47 :\n                return false;\n        }\n        return true;\n    }\n    function scanNextNonTrivia() {\n        let result;\n        do {\n            result = scanNext();\n        } while (result >= 12  && result <= 15 );\n        return result;\n    }\n    return {\n        setPosition: setPosition,\n        getPosition: () => pos,\n        scan: ignoreTrivia ? scanNextNonTrivia : scanNext,\n        getToken: () => token,\n        getTokenValue: () => value,\n        getTokenOffset: () => tokenOffset,\n        getTokenLength: () => pos - tokenOffset,\n        getTokenError: () => scanError\n    };\n}\nfunction isWhitespace(ch) {\n    return ch === 32  || ch === 9  || ch === 11  || ch === 12  ||\n        ch === 160  || ch === 5760  || ch >= 8192  && ch <= 8203  ||\n        ch === 8239  || ch === 8287  || ch === 12288  || ch === 65279 ;\n}\nfunction isLineBreak(ch) {\n    return ch === 10  || ch === 13  || ch === 8232  || ch === 8233 ;\n}\nfunction isDigit(ch) {\n    return ch >= 48  && ch <= 57 ;\n}\nfunction getLocation(text, position) {\n    const segments = [];\n    const earlyReturnException = ( new Object());\n    let previousNode = undefined;\n    const previousNodeInst = {\n        value: {},\n        offset: 0,\n        length: 0,\n        type: 'object',\n        parent: undefined\n    };\n    let isAtPropertyKey = false;\n    function setPreviousNode(value, offset, length, type) {\n        previousNodeInst.value = value;\n        previousNodeInst.offset = offset;\n        previousNodeInst.length = length;\n        previousNodeInst.type = type;\n        previousNodeInst.colonOffset = undefined;\n        previousNode = previousNodeInst;\n    }\n    try {\n        visit(text, {\n            onObjectBegin: (offset, length) => {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                isAtPropertyKey = position > offset;\n                segments.push('');\n            },\n            onObjectProperty: (name, offset, length) => {\n                if (position < offset) {\n                    throw earlyReturnException;\n                }\n                setPreviousNode(name, offset, length, 'property');\n                segments[segments.length - 1] = name;\n                if (position <= offset + length) {\n                    throw earlyReturnException;\n                }\n            },\n            onObjectEnd: (offset, length) => {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.pop();\n            },\n            onArrayBegin: (offset, length) => {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.push(0);\n            },\n            onArrayEnd: (offset, length) => {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.pop();\n            },\n            onLiteralValue: (value, offset, length) => {\n                if (position < offset) {\n                    throw earlyReturnException;\n                }\n                setPreviousNode(value, offset, length, getNodeType(value));\n                if (position <= offset + length) {\n                    throw earlyReturnException;\n                }\n            },\n            onSeparator: (sep, offset, length) => {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                if (sep === ':' && previousNode && previousNode.type === 'property') {\n                    previousNode.colonOffset = offset;\n                    isAtPropertyKey = false;\n                    previousNode = undefined;\n                }\n                else if (sep === ',') {\n                    const last = segments[segments.length - 1];\n                    if (typeof last === 'number') {\n                        segments[segments.length - 1] = last + 1;\n                    }\n                    else {\n                        isAtPropertyKey = true;\n                        segments[segments.length - 1] = '';\n                    }\n                    previousNode = undefined;\n                }\n            }\n        });\n    }\n    catch (e) {\n        if (e !== earlyReturnException) {\n            throw e;\n        }\n    }\n    return {\n        path: segments,\n        previousNode,\n        isAtPropertyKey,\n        matches: (pattern) => {\n            let k = 0;\n            for (let i = 0; k < pattern.length && i < segments.length; i++) {\n                if (pattern[k] === segments[i] || pattern[k] === '*') {\n                    k++;\n                }\n                else if (pattern[k] !== '**') {\n                    return false;\n                }\n            }\n            return k === pattern.length;\n        }\n    };\n}\nfunction parse(text, errors = [], options = ParseOptions.DEFAULT) {\n    let currentProperty = null;\n    let currentParent = [];\n    const previousParents = [];\n    function onValue(value) {\n        if (Array.isArray(currentParent)) {\n            currentParent.push(value);\n        }\n        else if (currentProperty !== null) {\n            currentParent[currentProperty] = value;\n        }\n    }\n    const visitor = {\n        onObjectBegin: () => {\n            const object = {};\n            onValue(object);\n            previousParents.push(currentParent);\n            currentParent = object;\n            currentProperty = null;\n        },\n        onObjectProperty: (name) => {\n            currentProperty = name;\n        },\n        onObjectEnd: () => {\n            currentParent = previousParents.pop();\n        },\n        onArrayBegin: () => {\n            const array = [];\n            onValue(array);\n            previousParents.push(currentParent);\n            currentParent = array;\n            currentProperty = null;\n        },\n        onArrayEnd: () => {\n            currentParent = previousParents.pop();\n        },\n        onLiteralValue: onValue,\n        onError: (error, offset, length) => {\n            errors.push({ error, offset, length });\n        }\n    };\n    visit(text, visitor, options);\n    return currentParent[0];\n}\nfunction parseTree(text, errors = [], options = ParseOptions.DEFAULT) {\n    let currentParent = { type: 'array', offset: -1, length: -1, children: [], parent: undefined };\n    function ensurePropertyComplete(endOffset) {\n        if (currentParent.type === 'property') {\n            currentParent.length = endOffset - currentParent.offset;\n            currentParent = currentParent.parent;\n        }\n    }\n    function onValue(valueNode) {\n        currentParent.children.push(valueNode);\n        return valueNode;\n    }\n    const visitor = {\n        onObjectBegin: (offset) => {\n            currentParent = onValue({ type: 'object', offset, length: -1, parent: currentParent, children: [] });\n        },\n        onObjectProperty: (name, offset, length) => {\n            currentParent = onValue({ type: 'property', offset, length: -1, parent: currentParent, children: [] });\n            currentParent.children.push({ type: 'string', value: name, offset, length, parent: currentParent });\n        },\n        onObjectEnd: (offset, length) => {\n            currentParent.length = offset + length - currentParent.offset;\n            currentParent = currentParent.parent;\n            ensurePropertyComplete(offset + length);\n        },\n        onArrayBegin: (offset, length) => {\n            currentParent = onValue({ type: 'array', offset, length: -1, parent: currentParent, children: [] });\n        },\n        onArrayEnd: (offset, length) => {\n            currentParent.length = offset + length - currentParent.offset;\n            currentParent = currentParent.parent;\n            ensurePropertyComplete(offset + length);\n        },\n        onLiteralValue: (value, offset, length) => {\n            onValue({ type: getNodeType(value), offset, length, parent: currentParent, value });\n            ensurePropertyComplete(offset + length);\n        },\n        onSeparator: (sep, offset, length) => {\n            if (currentParent.type === 'property') {\n                if (sep === ':') {\n                    currentParent.colonOffset = offset;\n                }\n                else if (sep === ',') {\n                    ensurePropertyComplete(offset);\n                }\n            }\n        },\n        onError: (error, offset, length) => {\n            errors.push({ error, offset, length });\n        }\n    };\n    visit(text, visitor, options);\n    const result = currentParent.children[0];\n    if (result) {\n        delete result.parent;\n    }\n    return result;\n}\nfunction findNodeAtLocation(root, path) {\n    if (!root) {\n        return undefined;\n    }\n    let node = root;\n    for (const segment of path) {\n        if (typeof segment === 'string') {\n            if (node.type !== 'object' || !Array.isArray(node.children)) {\n                return undefined;\n            }\n            let found = false;\n            for (const propertyNode of node.children) {\n                if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment) {\n                    node = propertyNode.children[1];\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return undefined;\n            }\n        }\n        else {\n            const index = segment;\n            if (node.type !== 'array' || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {\n                return undefined;\n            }\n            node = node.children[index];\n        }\n    }\n    return node;\n}\nfunction visit(text, visitor, options = ParseOptions.DEFAULT) {\n    const _scanner = createScanner(text, false);\n    function toNoArgVisit(visitFunction) {\n        return visitFunction ? () => visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength()) : () => true;\n    }\n    function toOneArgVisit(visitFunction) {\n        return visitFunction ? (arg) => visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength()) : () => true;\n    }\n    const onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);\n    const disallowComments = options && options.disallowComments;\n    const allowTrailingComma = options && options.allowTrailingComma;\n    function scanNext() {\n        while (true) {\n            const token = _scanner.scan();\n            switch (_scanner.getTokenError()) {\n                case 4 :\n                    handleError(14 );\n                    break;\n                case 5 :\n                    handleError(15 );\n                    break;\n                case 3 :\n                    handleError(13 );\n                    break;\n                case 1 :\n                    if (!disallowComments) {\n                        handleError(11 );\n                    }\n                    break;\n                case 2 :\n                    handleError(12 );\n                    break;\n                case 6 :\n                    handleError(16 );\n                    break;\n            }\n            switch (token) {\n                case 12 :\n                case 13 :\n                    if (disallowComments) {\n                        handleError(10 );\n                    }\n                    else {\n                        onComment();\n                    }\n                    break;\n                case 16 :\n                    handleError(1 );\n                    break;\n                case 15 :\n                case 14 :\n                    break;\n                default:\n                    return token;\n            }\n        }\n    }\n    function handleError(error, skipUntilAfter = [], skipUntil = []) {\n        onError(error);\n        if (skipUntilAfter.length + skipUntil.length > 0) {\n            let token = _scanner.getToken();\n            while (token !== 17 ) {\n                if (skipUntilAfter.indexOf(token) !== -1) {\n                    scanNext();\n                    break;\n                }\n                else if (skipUntil.indexOf(token) !== -1) {\n                    break;\n                }\n                token = scanNext();\n            }\n        }\n    }\n    function parseString(isValue) {\n        const value = _scanner.getTokenValue();\n        if (isValue) {\n            onLiteralValue(value);\n        }\n        else {\n            onObjectProperty(value);\n        }\n        scanNext();\n        return true;\n    }\n    function parseLiteral() {\n        switch (_scanner.getToken()) {\n            case 11 : {\n                let value = 0;\n                try {\n                    value = JSON.parse(_scanner.getTokenValue());\n                    if (typeof value !== 'number') {\n                        handleError(2 );\n                        value = 0;\n                    }\n                }\n                catch (e) {\n                    handleError(2 );\n                }\n                onLiteralValue(value);\n                break;\n            }\n            case 7 :\n                onLiteralValue(null);\n                break;\n            case 8 :\n                onLiteralValue(true);\n                break;\n            case 9 :\n                onLiteralValue(false);\n                break;\n            default:\n                return false;\n        }\n        scanNext();\n        return true;\n    }\n    function parseProperty() {\n        if (_scanner.getToken() !== 10 ) {\n            handleError(3 , [], [2 , 5 ]);\n            return false;\n        }\n        parseString(false);\n        if (_scanner.getToken() === 6 ) {\n            onSeparator(':');\n            scanNext();\n            if (!parseValue()) {\n                handleError(4 , [], [2 , 5 ]);\n            }\n        }\n        else {\n            handleError(5 , [], [2 , 5 ]);\n        }\n        return true;\n    }\n    function parseObject() {\n        onObjectBegin();\n        scanNext();\n        let needsComma = false;\n        while (_scanner.getToken() !== 2  && _scanner.getToken() !== 17 ) {\n            if (_scanner.getToken() === 5 ) {\n                if (!needsComma) {\n                    handleError(4 , [], []);\n                }\n                onSeparator(',');\n                scanNext();\n                if (_scanner.getToken() === 2  && allowTrailingComma) {\n                    break;\n                }\n            }\n            else if (needsComma) {\n                handleError(6 , [], []);\n            }\n            if (!parseProperty()) {\n                handleError(4 , [], [2 , 5 ]);\n            }\n            needsComma = true;\n        }\n        onObjectEnd();\n        if (_scanner.getToken() !== 2 ) {\n            handleError(7 , [2 ], []);\n        }\n        else {\n            scanNext();\n        }\n        return true;\n    }\n    function parseArray() {\n        onArrayBegin();\n        scanNext();\n        let needsComma = false;\n        while (_scanner.getToken() !== 4  && _scanner.getToken() !== 17 ) {\n            if (_scanner.getToken() === 5 ) {\n                if (!needsComma) {\n                    handleError(4 , [], []);\n                }\n                onSeparator(',');\n                scanNext();\n                if (_scanner.getToken() === 4  && allowTrailingComma) {\n                    break;\n                }\n            }\n            else if (needsComma) {\n                handleError(6 , [], []);\n            }\n            if (!parseValue()) {\n                handleError(4 , [], [4 , 5 ]);\n            }\n            needsComma = true;\n        }\n        onArrayEnd();\n        if (_scanner.getToken() !== 4 ) {\n            handleError(8 , [4 ], []);\n        }\n        else {\n            scanNext();\n        }\n        return true;\n    }\n    function parseValue() {\n        switch (_scanner.getToken()) {\n            case 3 :\n                return parseArray();\n            case 1 :\n                return parseObject();\n            case 10 :\n                return parseString(true);\n            default:\n                return parseLiteral();\n        }\n    }\n    scanNext();\n    if (_scanner.getToken() === 17 ) {\n        if (options.allowEmptyContent) {\n            return true;\n        }\n        handleError(4 , [], []);\n        return false;\n    }\n    if (!parseValue()) {\n        handleError(4 , [], []);\n        return false;\n    }\n    if (_scanner.getToken() !== 17 ) {\n        handleError(9 , [], []);\n    }\n    return true;\n}\nfunction getNodeType(value) {\n    switch (typeof value) {\n        case 'boolean': return 'boolean';\n        case 'number': return 'number';\n        case 'string': return 'string';\n        case 'object': {\n            if (!value) {\n                return 'null';\n            }\n            else if (Array.isArray(value)) {\n                return 'array';\n            }\n            return 'object';\n        }\n        default: return 'null';\n    }\n}\nexport { ParseOptions, createScanner, findNodeAtLocation, getLocation, getNodeType, parse, parseTree, visit };\n","function getCompressedContent(schema) {\n    let hasDups = false;\n    const equalsByString = ( new Map());\n    const nodeToEquals = ( new Map());\n    const visitSchemas = (next) => {\n        if (schema === next) {\n            return true;\n        }\n        const val = JSON.stringify(next);\n        if (val.length < 30) {\n            return true;\n        }\n        const eq = equalsByString.get(val);\n        if (!eq) {\n            const newEq = { schemas: [next] };\n            equalsByString.set(val, newEq);\n            nodeToEquals.set(next, newEq);\n            return true;\n        }\n        eq.schemas.push(next);\n        nodeToEquals.set(next, eq);\n        hasDups = true;\n        return false;\n    };\n    traverseNodes(schema, visitSchemas);\n    equalsByString.clear();\n    if (!hasDups) {\n        return JSON.stringify(schema);\n    }\n    let defNodeName = '$defs';\n    while (schema.hasOwnProperty(defNodeName)) {\n        defNodeName += '_';\n    }\n    const definitions = [];\n    function stringify(root) {\n        return JSON.stringify(root, (_key, value) => {\n            if (value !== root) {\n                const eq = nodeToEquals.get(value);\n                if (eq && eq.schemas.length > 1) {\n                    if (!eq.id) {\n                        eq.id = `_${definitions.length}`;\n                        definitions.push(eq.schemas[0]);\n                    }\n                    return { $ref: `#/${defNodeName}/${eq.id}` };\n                }\n            }\n            return value;\n        });\n    }\n    const str = stringify(schema);\n    const defStrings = [];\n    for (let i = 0; i < definitions.length; i++) {\n        defStrings.push(`\"_${i}\":${stringify(definitions[i])}`);\n    }\n    if (defStrings.length) {\n        return `${str.substring(0, str.length - 1)},\"${defNodeName}\":{${defStrings.join(',')}}}`;\n    }\n    return str;\n}\nfunction isObject(thing) {\n    return typeof thing === 'object' && thing !== null;\n}\nfunction traverseNodes(root, visit) {\n    if (!root || typeof root !== 'object') {\n        return;\n    }\n    const collectEntries = (...entries) => {\n        for (const entry of entries) {\n            if (isObject(entry)) {\n                toWalk.push(entry);\n            }\n        }\n    };\n    const collectMapEntries = (...maps) => {\n        for (const map of maps) {\n            if (isObject(map)) {\n                for (const key in map) {\n                    const entry = map[key];\n                    if (isObject(entry)) {\n                        toWalk.push(entry);\n                    }\n                }\n            }\n        }\n    };\n    const collectArrayEntries = (...arrays) => {\n        for (const array of arrays) {\n            if (Array.isArray(array)) {\n                for (const entry of array) {\n                    if (isObject(entry)) {\n                        toWalk.push(entry);\n                    }\n                }\n            }\n        }\n    };\n    const collectEntryOrArrayEntries = (items) => {\n        if (Array.isArray(items)) {\n            for (const entry of items) {\n                if (isObject(entry)) {\n                    toWalk.push(entry);\n                }\n            }\n        }\n        else if (isObject(items)) {\n            toWalk.push(items);\n        }\n    };\n    const toWalk = [root];\n    let next = toWalk.pop();\n    while (next) {\n        const visitChildern = visit(next);\n        if (visitChildern) {\n            collectEntries(next.additionalItems, next.additionalProperties, next.not, next.contains, next.propertyNames, next.if, next.then, next.else, next.unevaluatedItems, next.unevaluatedProperties);\n            collectMapEntries(next.definitions, next.$defs, next.properties, next.patternProperties, next.dependencies, next.dependentSchemas);\n            collectArrayEntries(next.anyOf, next.allOf, next.oneOf, next.prefixItems);\n            collectEntryOrArrayEntries(next.items);\n        }\n        next = toWalk.pop();\n    }\n}\nexport { getCompressedContent };\n","import { hasDriveLetter, toSlashes } from './extpath.js';\nimport { sep, posix, win32 } from './path.js';\nimport { isWindows, isMacintosh, OS } from './platform.js';\nimport { extUri, extUriIgnorePathCase } from './resources.js';\nimport { rtrim, startsWithIgnoreCase } from './strings.js';\nfunction getPathLabel(resource, formatting) {\n    const { os, tildify: tildifier, relative: relatifier } = formatting;\n    if (relatifier) {\n        const relativePath = getRelativePathLabel(resource, relatifier, os);\n        if (typeof relativePath === 'string') {\n            return relativePath;\n        }\n    }\n    let absolutePath = resource.fsPath;\n    if (os === 1  && !isWindows) {\n        absolutePath = absolutePath.replace(/\\//g, '\\\\');\n    }\n    else if (os !== 1  && isWindows) {\n        absolutePath = absolutePath.replace(/\\\\/g, '/');\n    }\n    if (os !== 1  && tildifier?.userHome) {\n        const userHome = tildifier.userHome.fsPath;\n        let userHomeCandidate;\n        if (resource.scheme !== tildifier.userHome.scheme && resource.path[0] === posix.sep && resource.path[1] !== posix.sep) {\n            userHomeCandidate = tildifier.userHome.with({ path: resource.path }).fsPath;\n        }\n        else {\n            userHomeCandidate = absolutePath;\n        }\n        absolutePath = tildify(userHomeCandidate, userHome, os);\n    }\n    const pathLib = os === 1  ? win32 : posix;\n    return pathLib.normalize(normalizeDriveLetter(absolutePath, os === 1 ));\n}\nfunction getRelativePathLabel(resource, relativePathProvider, os) {\n    const pathLib = os === 1  ? win32 : posix;\n    const extUriLib = os === 3  ? extUri : extUriIgnorePathCase;\n    const workspace = relativePathProvider.getWorkspace();\n    const firstFolder = workspace.folders.at(0);\n    if (!firstFolder) {\n        return undefined;\n    }\n    if (resource.scheme !== firstFolder.uri.scheme && resource.path[0] === posix.sep && resource.path[1] !== posix.sep) {\n        resource = firstFolder.uri.with({ path: resource.path });\n    }\n    const folder = relativePathProvider.getWorkspaceFolder(resource);\n    if (!folder) {\n        return undefined;\n    }\n    let relativePathLabel = undefined;\n    if (extUriLib.isEqual(folder.uri, resource)) {\n        relativePathLabel = '';\n    }\n    else {\n        relativePathLabel = extUriLib.relativePath(folder.uri, resource) ?? '';\n    }\n    if (relativePathLabel) {\n        relativePathLabel = pathLib.normalize(relativePathLabel);\n    }\n    if (workspace.folders.length > 1 && !relativePathProvider.noPrefix) {\n        const rootName = folder.name ? folder.name : extUriLib.basenameOrAuthority(folder.uri);\n        relativePathLabel = relativePathLabel ? `${rootName}  ${relativePathLabel}` : rootName;\n    }\n    return relativePathLabel;\n}\nfunction normalizeDriveLetter(path, isWindowsOS = isWindows) {\n    if (hasDriveLetter(path, isWindowsOS)) {\n        return path.charAt(0).toUpperCase() + path.slice(1);\n    }\n    return path;\n}\nlet normalizedUserHomeCached = Object.create(null);\nfunction tildify(path, userHome, os = OS) {\n    if (os === 1  || !path || !userHome) {\n        return path;\n    }\n    let normalizedUserHome = normalizedUserHomeCached.original === userHome ? normalizedUserHomeCached.normalized : undefined;\n    if (!normalizedUserHome) {\n        normalizedUserHome = userHome;\n        if (isWindows) {\n            normalizedUserHome = toSlashes(normalizedUserHome);\n        }\n        normalizedUserHome = `${rtrim(normalizedUserHome, posix.sep)}${posix.sep}`;\n        normalizedUserHomeCached = { original: userHome, normalized: normalizedUserHome };\n    }\n    let normalizedPath = path;\n    if (isWindows) {\n        normalizedPath = toSlashes(normalizedPath);\n    }\n    if (os === 3  ? normalizedPath.startsWith(normalizedUserHome) : startsWithIgnoreCase(normalizedPath, normalizedUserHome)) {\n        return `~/${normalizedPath.substr(normalizedUserHome.length)}`;\n    }\n    return path;\n}\nfunction untildify(path, userHome) {\n    return path.replace(/^~($|\\/|\\\\)/, `${userHome}$1`);\n}\nconst ellipsis = '\\u2026';\nconst unc = '\\\\\\\\';\nconst home = '~';\nfunction shorten(paths, pathSeparator = sep) {\n    const shortenedPaths = ( new Array(paths.length));\n    let match = false;\n    for (let pathIndex = 0; pathIndex < paths.length; pathIndex++) {\n        const originalPath = paths[pathIndex];\n        if (originalPath === '') {\n            shortenedPaths[pathIndex] = `.${pathSeparator}`;\n            continue;\n        }\n        if (!originalPath) {\n            shortenedPaths[pathIndex] = originalPath;\n            continue;\n        }\n        match = true;\n        let prefix = '';\n        let trimmedPath = originalPath;\n        if (trimmedPath.indexOf(unc) === 0) {\n            prefix = trimmedPath.substr(0, trimmedPath.indexOf(unc) + unc.length);\n            trimmedPath = trimmedPath.substr(trimmedPath.indexOf(unc) + unc.length);\n        }\n        else if (trimmedPath.indexOf(pathSeparator) === 0) {\n            prefix = trimmedPath.substr(0, trimmedPath.indexOf(pathSeparator) + pathSeparator.length);\n            trimmedPath = trimmedPath.substr(trimmedPath.indexOf(pathSeparator) + pathSeparator.length);\n        }\n        else if (trimmedPath.indexOf(home) === 0) {\n            prefix = trimmedPath.substr(0, trimmedPath.indexOf(home) + home.length);\n            trimmedPath = trimmedPath.substr(trimmedPath.indexOf(home) + home.length);\n        }\n        const segments = trimmedPath.split(pathSeparator);\n        for (let subpathLength = 1; match && subpathLength <= segments.length; subpathLength++) {\n            for (let start = segments.length - subpathLength; match && start >= 0; start--) {\n                match = false;\n                let subpath = segments.slice(start, start + subpathLength).join(pathSeparator);\n                for (let otherPathIndex = 0; !match && otherPathIndex < paths.length; otherPathIndex++) {\n                    if (otherPathIndex !== pathIndex && paths[otherPathIndex] && paths[otherPathIndex].indexOf(subpath) > -1) {\n                        const isSubpathEnding = (start + subpathLength === segments.length);\n                        const subpathWithSep = (start > 0 && paths[otherPathIndex].indexOf(pathSeparator) > -1) ? pathSeparator + subpath : subpath;\n                        const isOtherPathEnding = paths[otherPathIndex].endsWith(subpathWithSep);\n                        match = !isSubpathEnding || isOtherPathEnding;\n                    }\n                }\n                if (!match) {\n                    let result = '';\n                    if (segments[0].endsWith(':') || prefix !== '') {\n                        if (start === 1) {\n                            start = 0;\n                            subpathLength++;\n                            subpath = segments[0] + pathSeparator + subpath;\n                        }\n                        if (start > 0) {\n                            result = segments[0] + pathSeparator;\n                        }\n                        result = prefix + result;\n                    }\n                    if (start > 0) {\n                        result = result + ellipsis + pathSeparator;\n                    }\n                    result = result + subpath;\n                    if (start + subpathLength < segments.length) {\n                        result = result + pathSeparator + ellipsis;\n                    }\n                    shortenedPaths[pathIndex] = result;\n                }\n            }\n        }\n        if (match) {\n            shortenedPaths[pathIndex] = originalPath;\n        }\n    }\n    return shortenedPaths;\n}\nvar Type;\n( (function(Type) {\n    Type[Type[\"TEXT\"] = 0] = \"TEXT\";\n    Type[Type[\"VARIABLE\"] = 1] = \"VARIABLE\";\n    Type[Type[\"SEPARATOR\"] = 2] = \"SEPARATOR\";\n})(Type || (Type = {})));\nfunction template(template, values = Object.create(null)) {\n    const segments = [];\n    let inVariable = false;\n    let curVal = '';\n    for (const char of template) {\n        if (char === '$' || (inVariable && char === '{')) {\n            if (curVal) {\n                segments.push({ value: curVal, type: Type.TEXT });\n            }\n            curVal = '';\n            inVariable = true;\n        }\n        else if (char === '}' && inVariable) {\n            const resolved = values[curVal];\n            if (typeof resolved === 'string') {\n                if (resolved.length) {\n                    segments.push({ value: resolved, type: Type.VARIABLE });\n                }\n            }\n            else if (resolved) {\n                const prevSegment = segments[segments.length - 1];\n                if (!prevSegment || prevSegment.type !== Type.SEPARATOR) {\n                    segments.push({ value: resolved.label, type: Type.SEPARATOR });\n                }\n            }\n            curVal = '';\n            inVariable = false;\n        }\n        else {\n            curVal += char;\n        }\n    }\n    if (curVal && !inVariable) {\n        segments.push({ value: curVal, type: Type.TEXT });\n    }\n    return ( segments.filter((segment, index) => {\n        if (segment.type === Type.SEPARATOR) {\n            const left = segments[index - 1];\n            const right = segments[index + 1];\n            return [left, right].every(segment => segment && (segment.type === Type.VARIABLE || segment.type === Type.TEXT) && segment.value.length > 0);\n        }\n        return true;\n    }).map(segment => segment.value)).join('');\n}\nfunction mnemonicMenuLabel(label, forceDisableMnemonics) {\n    if (isMacintosh || forceDisableMnemonics) {\n        return label.replace(/\\(&&\\w\\)|&&/g, '').replace(/&/g, isMacintosh ? '&' : '&&');\n    }\n    return label.replace(/&&|&/g, m => m === '&' ? '&&' : '&');\n}\nfunction mnemonicButtonLabel(label, forceDisableMnemonics) {\n    if (isMacintosh || forceDisableMnemonics) {\n        return label.replace(/\\(&&\\w\\)|&&/g, '');\n    }\n    if (isWindows) {\n        return label.replace(/&&|&/g, m => m === '&' ? '&&' : '&');\n    }\n    return label.replace(/&&/g, '_');\n}\nfunction unmnemonicLabel(label) {\n    return label.replace(/&/g, '&&');\n}\nfunction splitRecentLabel(recentLabel) {\n    if (recentLabel.endsWith(']')) {\n        const lastIndexOfSquareBracket = recentLabel.lastIndexOf(' [', recentLabel.length - 2);\n        if (lastIndexOfSquareBracket !== -1) {\n            const split = splitName(recentLabel.substring(0, lastIndexOfSquareBracket));\n            const remoteNameWithSpace = recentLabel.substring(lastIndexOfSquareBracket);\n            return { name: split.name + remoteNameWithSpace, parentPath: split.parentPath };\n        }\n    }\n    return splitName(recentLabel);\n}\nfunction splitName(fullPath) {\n    const p = fullPath.indexOf('/') !== -1 ? posix : win32;\n    const name = p.basename(fullPath);\n    const parentPath = p.dirname(fullPath);\n    if (name.length) {\n        return { name, parentPath };\n    }\n    return { name: parentPath, parentPath: '' };\n}\nexport { getPathLabel, mnemonicButtonLabel, mnemonicMenuLabel, normalizeDriveLetter, shorten, splitRecentLabel, template, tildify, unmnemonicLabel, untildify };\n","import { VSBuffer } from './buffer.js';\nimport { URI } from './uri.js';\nfunction stringify(obj) {\n    return JSON.stringify(obj, replacer);\n}\nfunction parse(text) {\n    let data = JSON.parse(text);\n    data = revive(data);\n    return data;\n}\nfunction replacer(key, value) {\n    if (value instanceof RegExp) {\n        return {\n            $mid: 2 ,\n            source: value.source,\n            flags: value.flags,\n        };\n    }\n    return value;\n}\nfunction revive(obj, depth = 0) {\n    if (!obj || depth > 200) {\n        return obj;\n    }\n    if (typeof obj === 'object') {\n        switch (obj.$mid) {\n            case 1 : return URI.revive(obj);\n            case 2 : return ( new RegExp(obj.source, obj.flags));\n            case 17 : return ( new Date(obj.source));\n        }\n        if (obj instanceof VSBuffer\n            || obj instanceof Uint8Array) {\n            return obj;\n        }\n        if (Array.isArray(obj)) {\n            for (let i = 0; i < obj.length; ++i) {\n                obj[i] = revive(obj[i], depth + 1);\n            }\n        }\n        else {\n            for (const key in obj) {\n                if (Object.hasOwnProperty.call(obj, key)) {\n                    obj[key] = revive(obj[key], depth + 1);\n                }\n            }\n        }\n    }\n    return obj;\n}\nexport { parse, revive, stringify };\n","import { extname } from './path.js';\nconst Mimes = ( Object.freeze({\n    text: 'text/plain',\n    binary: 'application/octet-stream',\n    unknown: 'application/unknown',\n    markdown: 'text/markdown',\n    latex: 'text/latex',\n    uriList: 'text/uri-list',\n}));\nconst mapExtToTextMimes = {\n    '.css': 'text/css',\n    '.csv': 'text/csv',\n    '.htm': 'text/html',\n    '.html': 'text/html',\n    '.ics': 'text/calendar',\n    '.js': 'text/javascript',\n    '.mjs': 'text/javascript',\n    '.txt': 'text/plain',\n    '.xml': 'text/xml'\n};\nconst mapExtToMediaMimes = {\n    '.aac': 'audio/x-aac',\n    '.avi': 'video/x-msvideo',\n    '.bmp': 'image/bmp',\n    '.flv': 'video/x-flv',\n    '.gif': 'image/gif',\n    '.ico': 'image/x-icon',\n    '.jpe': 'image/jpg',\n    '.jpeg': 'image/jpg',\n    '.jpg': 'image/jpg',\n    '.m1v': 'video/mpeg',\n    '.m2a': 'audio/mpeg',\n    '.m2v': 'video/mpeg',\n    '.m3a': 'audio/mpeg',\n    '.mid': 'audio/midi',\n    '.midi': 'audio/midi',\n    '.mk3d': 'video/x-matroska',\n    '.mks': 'video/x-matroska',\n    '.mkv': 'video/x-matroska',\n    '.mov': 'video/quicktime',\n    '.movie': 'video/x-sgi-movie',\n    '.mp2': 'audio/mpeg',\n    '.mp2a': 'audio/mpeg',\n    '.mp3': 'audio/mpeg',\n    '.mp4': 'video/mp4',\n    '.mp4a': 'audio/mp4',\n    '.mp4v': 'video/mp4',\n    '.mpe': 'video/mpeg',\n    '.mpeg': 'video/mpeg',\n    '.mpg': 'video/mpeg',\n    '.mpg4': 'video/mp4',\n    '.mpga': 'audio/mpeg',\n    '.oga': 'audio/ogg',\n    '.ogg': 'audio/ogg',\n    '.opus': 'audio/opus',\n    '.ogv': 'video/ogg',\n    '.png': 'image/png',\n    '.psd': 'image/vnd.adobe.photoshop',\n    '.qt': 'video/quicktime',\n    '.spx': 'audio/ogg',\n    '.svg': 'image/svg+xml',\n    '.tga': 'image/x-tga',\n    '.tif': 'image/tiff',\n    '.tiff': 'image/tiff',\n    '.wav': 'audio/x-wav',\n    '.webm': 'video/webm',\n    '.webp': 'image/webp',\n    '.wma': 'audio/x-ms-wma',\n    '.wmv': 'video/x-ms-wmv',\n    '.woff': 'application/font-woff',\n};\nfunction getMediaOrTextMime(path) {\n    const ext = extname(path);\n    const textMime = mapExtToTextMimes[ext.toLowerCase()];\n    if (textMime !== undefined) {\n        return textMime;\n    }\n    else {\n        return getMediaMime(path);\n    }\n}\nfunction getMediaMime(path) {\n    const ext = extname(path);\n    return mapExtToMediaMimes[ext.toLowerCase()];\n}\nfunction getExtensionForMimeType(mimeType) {\n    for (const extension in mapExtToMediaMimes) {\n        if (mapExtToMediaMimes[extension] === mimeType) {\n            return extension;\n        }\n    }\n    return undefined;\n}\nconst _simplePattern = /^(.+)\\/(.+?)(;.+)?$/;\nfunction normalizeMimeType(mimeType, strict) {\n    const match = _simplePattern.exec(mimeType);\n    if (!match) {\n        return strict\n            ? undefined\n            : mimeType;\n    }\n    return `${match[1].toLowerCase()}/${match[2].toLowerCase()}${match[3] ?? ''}`;\n}\nexport { Mimes, getExtensionForMimeType, getMediaMime, getMediaOrTextMime, normalizeMimeType };\n","function getKoreanAltChars(code) {\n    const result = disassembleKorean(code);\n    if (result && result.length > 0) {\n        return ( new Uint32Array(result));\n    }\n    return undefined;\n}\nlet codeBufferLength = 0;\nconst codeBuffer = ( new Uint32Array(10));\nfunction disassembleKorean(code) {\n    codeBufferLength = 0;\n    getCodesFromArray(code, modernConsonants, 4352 );\n    if (codeBufferLength > 0) {\n        return codeBuffer.subarray(0, codeBufferLength);\n    }\n    getCodesFromArray(code, modernVowels, 4449 );\n    if (codeBufferLength > 0) {\n        return codeBuffer.subarray(0, codeBufferLength);\n    }\n    getCodesFromArray(code, modernFinalConsonants, 4520 );\n    if (codeBufferLength > 0) {\n        return codeBuffer.subarray(0, codeBufferLength);\n    }\n    getCodesFromArray(code, compatibilityJamo, 12593 );\n    if (codeBufferLength) {\n        return codeBuffer.subarray(0, codeBufferLength);\n    }\n    if (code >= 0xAC00 && code <= 0xD7A3) {\n        const hangulIndex = code - 0xAC00;\n        const vowelAndFinalConsonantProduct = hangulIndex % 588;\n        const initialConsonantIndex = Math.floor(hangulIndex / 588);\n        const vowelIndex = Math.floor(vowelAndFinalConsonantProduct / 28);\n        const finalConsonantIndex = vowelAndFinalConsonantProduct % 28 - 1;\n        if (initialConsonantIndex < modernConsonants.length) {\n            getCodesFromArray(initialConsonantIndex, modernConsonants, 0);\n        }\n        else if (4352  + initialConsonantIndex - 12593  < compatibilityJamo.length) {\n            getCodesFromArray(4352  + initialConsonantIndex, compatibilityJamo, 12593 );\n        }\n        if (vowelIndex < modernVowels.length) {\n            getCodesFromArray(vowelIndex, modernVowels, 0);\n        }\n        else if (4449  + vowelIndex - 12593  < compatibilityJamo.length) {\n            getCodesFromArray(4449  + vowelIndex - 12593 , compatibilityJamo, 12593 );\n        }\n        if (finalConsonantIndex >= 0) {\n            if (finalConsonantIndex < modernFinalConsonants.length) {\n                getCodesFromArray(finalConsonantIndex, modernFinalConsonants, 0);\n            }\n            else if (4520  + finalConsonantIndex - 12593  < compatibilityJamo.length) {\n                getCodesFromArray(4520  + finalConsonantIndex - 12593 , compatibilityJamo, 12593 );\n            }\n        }\n        if (codeBufferLength > 0) {\n            return codeBuffer.subarray(0, codeBufferLength);\n        }\n    }\n    return undefined;\n}\nfunction getCodesFromArray(code, array, arrayStartIndex) {\n    if (code >= arrayStartIndex && code < arrayStartIndex + array.length) {\n        addCodesToBuffer(array[code - arrayStartIndex]);\n    }\n}\nfunction addCodesToBuffer(codes) {\n    if (codes === 0 ) {\n        return;\n    }\n    codeBuffer[codeBufferLength++] = codes & 0xFF;\n    if (codes >> 8) {\n        codeBuffer[codeBufferLength++] = (codes >> 8) & 0xFF;\n    }\n    if (codes >> 16) {\n        codeBuffer[codeBufferLength++] = (codes >> 16) & 0xFF;\n    }\n}\nconst modernConsonants = ( new Uint8Array([\n    114 ,\n    82 ,\n    115 ,\n    101 ,\n    69 ,\n    102 ,\n    97 ,\n    113 ,\n    81 ,\n    116 ,\n    84 ,\n    100 ,\n    119 ,\n    87 ,\n    99 ,\n    122 ,\n    120 ,\n    118 ,\n    103 ,\n]));\nconst modernVowels = ( new Uint16Array([\n    107 ,\n    111 ,\n    105 ,\n    79 ,\n    106 ,\n    112 ,\n    117 ,\n    80 ,\n    104 ,\n    27496 ,\n    28520 ,\n    27752 ,\n    121 ,\n    110 ,\n    27246 ,\n    28782 ,\n    27758 ,\n    98 ,\n    109 ,\n    27757 ,\n    108 ,\n]));\nconst modernFinalConsonants = ( new Uint16Array([\n    114 ,\n    82 ,\n    29810 ,\n    115 ,\n    30579 ,\n    26483 ,\n    101 ,\n    102 ,\n    29286 ,\n    24934 ,\n    29030 ,\n    29798 ,\n    30822 ,\n    30310 ,\n    26470 ,\n    97 ,\n    113 ,\n    29809 ,\n    116 ,\n    84 ,\n    100 ,\n    119 ,\n    99 ,\n    122 ,\n    120 ,\n    118 ,\n    103 ,\n]));\nconst compatibilityJamo = ( new Uint16Array([\n    114 ,\n    82 ,\n    29810 ,\n    115 ,\n    30579 ,\n    26483 ,\n    101 ,\n    69 ,\n    102 ,\n    29286 ,\n    24934 ,\n    29030 ,\n    29798 ,\n    30822 ,\n    30310 ,\n    26470 ,\n    97 ,\n    113 ,\n    81 ,\n    29809 ,\n    116 ,\n    84 ,\n    100 ,\n    119 ,\n    87 ,\n    99 ,\n    122 ,\n    120 ,\n    118 ,\n    103 ,\n    107 ,\n    111 ,\n    105 ,\n    79 ,\n    106 ,\n    112 ,\n    117 ,\n    80 ,\n    104 ,\n    27496 ,\n    28520 ,\n    27752 ,\n    121 ,\n    110 ,\n    27246 ,\n    28782 ,\n    27758 ,\n    98 ,\n    109 ,\n    27757 ,\n    108 ,\n]));\nexport { getKoreanAltChars };\n","function clamp(value, min, max) {\n    return Math.min(Math.max(value, min), max);\n}\nfunction rot(index, modulo) {\n    return (modulo + (index % modulo)) % modulo;\n}\nclass Counter {\n    constructor() {\n        this._next = 0;\n    }\n    getNext() {\n        return this._next++;\n    }\n}\nclass MovingAverage {\n    constructor() {\n        this._n = 1;\n        this._val = 0;\n    }\n    update(value) {\n        this._val = this._val + (value - this._val) / this._n;\n        this._n += 1;\n        return this._val;\n    }\n    get value() {\n        return this._val;\n    }\n}\nclass SlidingWindowAverage {\n    constructor(size) {\n        this._n = 0;\n        this._val = 0;\n        this._values = [];\n        this._index = 0;\n        this._sum = 0;\n        this._values = ( new Array(size));\n        this._values.fill(0, 0, size);\n    }\n    update(value) {\n        const oldValue = this._values[this._index];\n        this._values[this._index] = value;\n        this._index = (this._index + 1) % this._values.length;\n        this._sum -= oldValue;\n        this._sum += value;\n        if (this._n < this._values.length) {\n            this._n += 1;\n        }\n        this._val = this._sum / this._n;\n        return this._val;\n    }\n    get value() {\n        return this._val;\n    }\n}\nfunction isPointWithinTriangle(x, y, ax, ay, bx, by, cx, cy) {\n    const v0x = cx - ax;\n    const v0y = cy - ay;\n    const v1x = bx - ax;\n    const v1y = by - ay;\n    const v2x = x - ax;\n    const v2y = y - ay;\n    const dot00 = v0x * v0x + v0y * v0y;\n    const dot01 = v0x * v1x + v0y * v1y;\n    const dot02 = v0x * v2x + v0y * v2y;\n    const dot11 = v1x * v1x + v1y * v1y;\n    const dot12 = v1x * v2x + v1y * v2y;\n    const invDenom = 1 / (dot00 * dot11 - dot01 * dot01);\n    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    const v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n    return u >= 0 && v >= 0 && u + v < 1;\n}\nexport { Counter, MovingAverage, SlidingWindowAverage, clamp, isPointWithinTriangle, rot };\n","const module = { exports: {} };\n(function () {\n\tfunction _definePolyfillMarks(timeOrigin) {\n\t\tconst _data = [];\n\t\tif (typeof timeOrigin === 'number') {\n\t\t\t_data.push('code/timeOrigin', timeOrigin);\n\t\t}\n\t\tfunction mark(name) {\n\t\t\t_data.push(name, Date.now());\n\t\t}\n\t\tfunction getMarks() {\n\t\t\tconst result = [];\n\t\t\tfor (let i = 0; i < _data.length; i += 2) {\n\t\t\t\tresult.push({\n\t\t\t\t\tname: _data[i],\n\t\t\t\t\tstartTime: _data[i + 1],\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\treturn { mark, getMarks };\n\t}\n\tfunction _define() {\n\t\tif (typeof performance === 'object' && typeof performance.mark === 'function' && !performance.nodeTiming) {\n\t\t\tif (typeof performance.timeOrigin !== 'number' && !performance.timing) {\n\t\t\t\treturn _definePolyfillMarks();\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\tmark(name) {\n\t\t\t\t\t\tperformance.mark(name);\n\t\t\t\t\t},\n\t\t\t\t\tgetMarks() {\n\t\t\t\t\t\tlet timeOrigin = performance.timeOrigin;\n\t\t\t\t\t\tif (typeof timeOrigin !== 'number') {\n\t\t\t\t\t\t\ttimeOrigin = performance.timing.navigationStart || performance.timing.redirectStart || performance.timing.fetchStart;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst result = [{ name: 'code/timeOrigin', startTime: Math.round(timeOrigin) }];\n\t\t\t\t\t\tfor (const entry of performance.getEntriesByType('mark')) {\n\t\t\t\t\t\t\tresult.push({\n\t\t\t\t\t\t\t\tname: entry.name,\n\t\t\t\t\t\t\t\tstartTime: Math.round(timeOrigin + entry.startTime)\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t} else if (typeof process === 'object') {\n\t\t\tconst timeOrigin = performance?.timeOrigin;\n\t\t\treturn _definePolyfillMarks(timeOrigin);\n\t\t} else {\n\t\t\tconsole.trace('perf-util loaded in UNKNOWN environment');\n\t\t\treturn _definePolyfillMarks();\n\t\t}\n\t}\n\tfunction _factory(sharedObj) {\n\t\tif (!sharedObj.MonacoPerformanceMarks) {\n\t\t\tsharedObj.MonacoPerformanceMarks = _define();\n\t\t}\n\t\treturn sharedObj.MonacoPerformanceMarks;\n\t}\n\tvar sharedObj;\n\tif (typeof global === 'object') {\n\t\tsharedObj = global;\n\t} else if (typeof self === 'object') {\n\t\tsharedObj = self;\n\t} else {\n\t\tsharedObj = {};\n\t}\n\tif (typeof module === 'object' && typeof module.exports === 'object') {\n\t\tmodule.exports = _factory(sharedObj);\n\t} else {\n\t\tconsole.trace('perf-util defined in UNKNOWN context (neither requirejs or commonjs)');\n\t\tsharedObj.perf = _factory(sharedObj);\n\t}\n})();\nconst mark = module.exports.mark;\nconst getMarks = module.exports.getMarks;\nexport { getMarks, mark };\n","import { Iterable } from './iterator.js';\nconst unset = Symbol('unset');\nclass WellDefinedPrefixTree {\n    constructor() {\n        this.root = ( new Node());\n        this._size = 0;\n    }\n    get size() {\n        return this._size;\n    }\n    get nodes() {\n        return this.root.children?.values() || Iterable.empty();\n    }\n    get entries() {\n        return this.root.children?.entries() || Iterable.empty();\n    }\n    insert(key, value, onNode) {\n        this.opNode(key, n => n._value = value, onNode);\n    }\n    mutate(key, mutate) {\n        this.opNode(key, n => n._value = mutate(n._value === unset ? undefined : n._value));\n    }\n    mutatePath(key, mutate) {\n        this.opNode(key, () => { }, n => mutate(n));\n    }\n    delete(key) {\n        const path = this.getPathToKey(key);\n        if (!path) {\n            return;\n        }\n        let i = path.length - 1;\n        const value = path[i].node._value;\n        if (value === unset) {\n            return;\n        }\n        this._size--;\n        path[i].node._value = unset;\n        for (; i > 0; i--) {\n            const { node, part } = path[i];\n            if (node.children?.size || node._value !== unset) {\n                break;\n            }\n            path[i - 1].node.children.delete(part);\n        }\n        return value;\n    }\n    *deleteRecursive(key) {\n        const path = this.getPathToKey(key);\n        if (!path) {\n            return;\n        }\n        const subtree = path[path.length - 1].node;\n        for (let i = path.length - 1; i > 0; i--) {\n            const parent = path[i - 1];\n            parent.node.children.delete(path[i].part);\n            if (parent.node.children.size > 0 || parent.node._value !== unset) {\n                break;\n            }\n        }\n        for (const node of bfsIterate(subtree)) {\n            if (node._value !== unset) {\n                this._size--;\n                yield node._value;\n            }\n        }\n    }\n    find(key) {\n        let node = this.root;\n        for (const segment of key) {\n            const next = node.children?.get(segment);\n            if (!next) {\n                return undefined;\n            }\n            node = next;\n        }\n        return node._value === unset ? undefined : node._value;\n    }\n    hasKeyOrParent(key) {\n        let node = this.root;\n        for (const segment of key) {\n            const next = node.children?.get(segment);\n            if (!next) {\n                return false;\n            }\n            if (next._value !== unset) {\n                return true;\n            }\n            node = next;\n        }\n        return false;\n    }\n    hasKeyOrChildren(key) {\n        let node = this.root;\n        for (const segment of key) {\n            const next = node.children?.get(segment);\n            if (!next) {\n                return false;\n            }\n            node = next;\n        }\n        return true;\n    }\n    hasKey(key) {\n        let node = this.root;\n        for (const segment of key) {\n            const next = node.children?.get(segment);\n            if (!next) {\n                return false;\n            }\n            node = next;\n        }\n        return node._value !== unset;\n    }\n    getPathToKey(key) {\n        const path = [{ part: '', node: this.root }];\n        let i = 0;\n        for (const part of key) {\n            const node = path[i].node.children?.get(part);\n            if (!node) {\n                return;\n            }\n            path.push({ part, node });\n            i++;\n        }\n        return path;\n    }\n    opNode(key, fn, onDescend) {\n        let node = this.root;\n        for (const part of key) {\n            if (!node.children) {\n                const next = ( new Node());\n                node.children = ( new Map([[part, next]]));\n                node = next;\n            }\n            else if (!( node.children.has(part))) {\n                const next = ( new Node());\n                node.children.set(part, next);\n                node = next;\n            }\n            else {\n                node = node.children.get(part);\n            }\n            onDescend?.(node);\n        }\n        const sizeBefore = node._value === unset ? 0 : 1;\n        fn(node);\n        const sizeAfter = node._value === unset ? 0 : 1;\n        this._size += sizeAfter - sizeBefore;\n    }\n    *values() {\n        for (const { _value } of bfsIterate(this.root)) {\n            if (_value !== unset) {\n                yield _value;\n            }\n        }\n    }\n}\nfunction* bfsIterate(root) {\n    const stack = [root];\n    while (stack.length > 0) {\n        const node = stack.pop();\n        yield node;\n        if (node.children) {\n            for (const child of ( node.children.values())) {\n                stack.push(child);\n            }\n        }\n    }\n}\nclass Node {\n    constructor() {\n        this._value = unset;\n    }\n    get value() {\n        return this._value === unset ? undefined : this._value;\n    }\n    set value(value) {\n        this._value = value === undefined ? unset : value;\n    }\n}\nexport { WellDefinedPrefixTree };\n","import { equalsIgnoreCase } from './strings.js';\nvar Severity;\n( (function(Severity) {\n    Severity[Severity[\"Ignore\"] = 0] = \"Ignore\";\n    Severity[Severity[\"Info\"] = 1] = \"Info\";\n    Severity[Severity[\"Warning\"] = 2] = \"Warning\";\n    Severity[Severity[\"Error\"] = 3] = \"Error\";\n})(Severity || (Severity = {})));\n( (function(Severity) {\n    const _error = 'error';\n    const _warning = 'warning';\n    const _warn = 'warn';\n    const _info = 'info';\n    const _ignore = 'ignore';\n    function fromValue(value) {\n        if (!value) {\n            return Severity.Ignore;\n        }\n        if (equalsIgnoreCase(_error, value)) {\n            return Severity.Error;\n        }\n        if (equalsIgnoreCase(_warning, value) || equalsIgnoreCase(_warn, value)) {\n            return Severity.Warning;\n        }\n        if (equalsIgnoreCase(_info, value)) {\n            return Severity.Info;\n        }\n        return Severity.Ignore;\n    }\n    Severity.fromValue = fromValue;\n    function toString(severity) {\n        switch (severity) {\n            case Severity.Error: return _error;\n            case Severity.Warning: return _warning;\n            case Severity.Info: return _info;\n            default: return _ignore;\n        }\n    }\n    Severity.toString = toString;\n})(Severity || (Severity = {})));\nvar Severity$1 = Severity;\nexport { Severity$1 as default };\n","import { shuffle } from './arrays.js';\nimport { compareSubstring, compareSubstringIgnoreCase, compareIgnoreCase, compare } from './strings.js';\nclass StringIterator {\n    constructor() {\n        this._value = '';\n        this._pos = 0;\n    }\n    reset(key) {\n        this._value = key;\n        this._pos = 0;\n        return this;\n    }\n    next() {\n        this._pos += 1;\n        return this;\n    }\n    hasNext() {\n        return this._pos < this._value.length - 1;\n    }\n    cmp(a) {\n        const aCode = a.charCodeAt(0);\n        const thisCode = this._value.charCodeAt(this._pos);\n        return aCode - thisCode;\n    }\n    value() {\n        return this._value[this._pos];\n    }\n}\nclass ConfigKeysIterator {\n    constructor(_caseSensitive = true) {\n        this._caseSensitive = _caseSensitive;\n    }\n    reset(key) {\n        this._value = key;\n        this._from = 0;\n        this._to = 0;\n        return this.next();\n    }\n    hasNext() {\n        return this._to < this._value.length;\n    }\n    next() {\n        this._from = this._to;\n        let justSeps = true;\n        for (; this._to < this._value.length; this._to++) {\n            const ch = this._value.charCodeAt(this._to);\n            if (ch === 46 ) {\n                if (justSeps) {\n                    this._from++;\n                }\n                else {\n                    break;\n                }\n            }\n            else {\n                justSeps = false;\n            }\n        }\n        return this;\n    }\n    cmp(a) {\n        return this._caseSensitive\n            ? compareSubstring(a, this._value, 0, a.length, this._from, this._to)\n            : compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);\n    }\n    value() {\n        return this._value.substring(this._from, this._to);\n    }\n}\nclass PathIterator {\n    constructor(_splitOnBackslash = true, _caseSensitive = true) {\n        this._splitOnBackslash = _splitOnBackslash;\n        this._caseSensitive = _caseSensitive;\n    }\n    reset(key) {\n        this._from = 0;\n        this._to = 0;\n        this._value = key;\n        this._valueLen = key.length;\n        for (let pos = key.length - 1; pos >= 0; pos--, this._valueLen--) {\n            const ch = this._value.charCodeAt(pos);\n            if (!((ch === 47  || this._splitOnBackslash && ch === 92) )) {\n                break;\n            }\n        }\n        return this.next();\n    }\n    hasNext() {\n        return this._to < this._valueLen;\n    }\n    next() {\n        this._from = this._to;\n        let justSeps = true;\n        for (; this._to < this._valueLen; this._to++) {\n            const ch = this._value.charCodeAt(this._to);\n            if (ch === 47  || this._splitOnBackslash && ch === 92 ) {\n                if (justSeps) {\n                    this._from++;\n                }\n                else {\n                    break;\n                }\n            }\n            else {\n                justSeps = false;\n            }\n        }\n        return this;\n    }\n    cmp(a) {\n        return this._caseSensitive\n            ? compareSubstring(a, this._value, 0, a.length, this._from, this._to)\n            : compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);\n    }\n    value() {\n        return this._value.substring(this._from, this._to);\n    }\n}\nclass UriIterator {\n    constructor(_ignorePathCasing, _ignoreQueryAndFragment) {\n        this._ignorePathCasing = _ignorePathCasing;\n        this._ignoreQueryAndFragment = _ignoreQueryAndFragment;\n        this._states = [];\n        this._stateIdx = 0;\n    }\n    reset(key) {\n        this._value = key;\n        this._states = [];\n        if (this._value.scheme) {\n            this._states.push(1 );\n        }\n        if (this._value.authority) {\n            this._states.push(2 );\n        }\n        if (this._value.path) {\n            this._pathIterator = ( new PathIterator(false, !this._ignorePathCasing(key)));\n            this._pathIterator.reset(key.path);\n            if (this._pathIterator.value()) {\n                this._states.push(3 );\n            }\n        }\n        if (!this._ignoreQueryAndFragment(key)) {\n            if (this._value.query) {\n                this._states.push(4 );\n            }\n            if (this._value.fragment) {\n                this._states.push(5 );\n            }\n        }\n        this._stateIdx = 0;\n        return this;\n    }\n    next() {\n        if (this._states[this._stateIdx] === 3  && this._pathIterator.hasNext()) {\n            this._pathIterator.next();\n        }\n        else {\n            this._stateIdx += 1;\n        }\n        return this;\n    }\n    hasNext() {\n        return (this._states[this._stateIdx] === 3  && this._pathIterator.hasNext())\n            || this._stateIdx < this._states.length - 1;\n    }\n    cmp(a) {\n        if (this._states[this._stateIdx] === 1 ) {\n            return compareIgnoreCase(a, this._value.scheme);\n        }\n        else if (this._states[this._stateIdx] === 2 ) {\n            return compareIgnoreCase(a, this._value.authority);\n        }\n        else if (this._states[this._stateIdx] === 3 ) {\n            return this._pathIterator.cmp(a);\n        }\n        else if (this._states[this._stateIdx] === 4 ) {\n            return compare(a, this._value.query);\n        }\n        else if (this._states[this._stateIdx] === 5 ) {\n            return compare(a, this._value.fragment);\n        }\n        throw ( new Error());\n    }\n    value() {\n        if (this._states[this._stateIdx] === 1 ) {\n            return this._value.scheme;\n        }\n        else if (this._states[this._stateIdx] === 2 ) {\n            return this._value.authority;\n        }\n        else if (this._states[this._stateIdx] === 3 ) {\n            return this._pathIterator.value();\n        }\n        else if (this._states[this._stateIdx] === 4 ) {\n            return this._value.query;\n        }\n        else if (this._states[this._stateIdx] === 5 ) {\n            return this._value.fragment;\n        }\n        throw ( new Error());\n    }\n}\nclass TernarySearchTreeNode {\n    constructor() {\n        this.height = 1;\n    }\n    isEmpty() {\n        return !this.left && !this.mid && !this.right && !this.value;\n    }\n    rotateLeft() {\n        const tmp = this.right;\n        this.right = tmp.left;\n        tmp.left = this;\n        this.updateHeight();\n        tmp.updateHeight();\n        return tmp;\n    }\n    rotateRight() {\n        const tmp = this.left;\n        this.left = tmp.right;\n        tmp.right = this;\n        this.updateHeight();\n        tmp.updateHeight();\n        return tmp;\n    }\n    updateHeight() {\n        this.height = 1 + Math.max(this.heightLeft, this.heightRight);\n    }\n    balanceFactor() {\n        return this.heightRight - this.heightLeft;\n    }\n    get heightLeft() {\n        return this.left?.height ?? 0;\n    }\n    get heightRight() {\n        return this.right?.height ?? 0;\n    }\n}\nclass TernarySearchTree {\n    static forUris(ignorePathCasing = () => false, ignoreQueryAndFragment = () => false) {\n        return ( new TernarySearchTree(( new UriIterator(ignorePathCasing, ignoreQueryAndFragment))));\n    }\n    static forPaths(ignorePathCasing = false) {\n        return ( new TernarySearchTree(( new PathIterator(undefined, !ignorePathCasing))));\n    }\n    static forStrings() {\n        return ( new TernarySearchTree(( new StringIterator())));\n    }\n    static forConfigKeys() {\n        return ( new TernarySearchTree(( new ConfigKeysIterator())));\n    }\n    constructor(segments) {\n        this._iter = segments;\n    }\n    clear() {\n        this._root = undefined;\n    }\n    fill(values, keys) {\n        if (keys) {\n            const arr = keys.slice(0);\n            shuffle(arr);\n            for (const k of arr) {\n                this.set(k, values);\n            }\n        }\n        else {\n            const arr = values.slice(0);\n            shuffle(arr);\n            for (const entry of arr) {\n                this.set(entry[0], entry[1]);\n            }\n        }\n    }\n    set(key, element) {\n        const iter = this._iter.reset(key);\n        let node;\n        if (!this._root) {\n            this._root = ( new TernarySearchTreeNode());\n            this._root.segment = iter.value();\n        }\n        const stack = [];\n        node = this._root;\n        while (true) {\n            const val = iter.cmp(node.segment);\n            if (val > 0) {\n                if (!node.left) {\n                    node.left = ( new TernarySearchTreeNode());\n                    node.left.segment = iter.value();\n                }\n                stack.push([-1 , node]);\n                node = node.left;\n            }\n            else if (val < 0) {\n                if (!node.right) {\n                    node.right = ( new TernarySearchTreeNode());\n                    node.right.segment = iter.value();\n                }\n                stack.push([1 , node]);\n                node = node.right;\n            }\n            else if (iter.hasNext()) {\n                iter.next();\n                if (!node.mid) {\n                    node.mid = ( new TernarySearchTreeNode());\n                    node.mid.segment = iter.value();\n                }\n                stack.push([0 , node]);\n                node = node.mid;\n            }\n            else {\n                break;\n            }\n        }\n        const oldElement = node.value;\n        node.value = element;\n        node.key = key;\n        for (let i = stack.length - 1; i >= 0; i--) {\n            const node = stack[i][1];\n            node.updateHeight();\n            const bf = node.balanceFactor();\n            if (bf < -1 || bf > 1) {\n                const d1 = stack[i][0];\n                const d2 = stack[i + 1][0];\n                if (d1 === 1  && d2 === 1 ) {\n                    stack[i][1] = node.rotateLeft();\n                }\n                else if (d1 === -1  && d2 === -1 ) {\n                    stack[i][1] = node.rotateRight();\n                }\n                else if (d1 === 1  && d2 === -1 ) {\n                    node.right = stack[i + 1][1] = stack[i + 1][1].rotateRight();\n                    stack[i][1] = node.rotateLeft();\n                }\n                else if (d1 === -1  && d2 === 1 ) {\n                    node.left = stack[i + 1][1] = stack[i + 1][1].rotateLeft();\n                    stack[i][1] = node.rotateRight();\n                }\n                else {\n                    throw ( new Error());\n                }\n                if (i > 0) {\n                    switch (stack[i - 1][0]) {\n                        case -1 :\n                            stack[i - 1][1].left = stack[i][1];\n                            break;\n                        case 1 :\n                            stack[i - 1][1].right = stack[i][1];\n                            break;\n                        case 0 :\n                            stack[i - 1][1].mid = stack[i][1];\n                            break;\n                    }\n                }\n                else {\n                    this._root = stack[0][1];\n                }\n            }\n        }\n        return oldElement;\n    }\n    get(key) {\n        return this._getNode(key)?.value;\n    }\n    _getNode(key) {\n        const iter = this._iter.reset(key);\n        let node = this._root;\n        while (node) {\n            const val = iter.cmp(node.segment);\n            if (val > 0) {\n                node = node.left;\n            }\n            else if (val < 0) {\n                node = node.right;\n            }\n            else if (iter.hasNext()) {\n                iter.next();\n                node = node.mid;\n            }\n            else {\n                break;\n            }\n        }\n        return node;\n    }\n    has(key) {\n        const node = this._getNode(key);\n        return !(node?.value === undefined && node?.mid === undefined);\n    }\n    delete(key) {\n        return this._delete(key, false);\n    }\n    deleteSuperstr(key) {\n        return this._delete(key, true);\n    }\n    _delete(key, superStr) {\n        const iter = this._iter.reset(key);\n        const stack = [];\n        let node = this._root;\n        while (node) {\n            const val = iter.cmp(node.segment);\n            if (val > 0) {\n                stack.push([-1 , node]);\n                node = node.left;\n            }\n            else if (val < 0) {\n                stack.push([1 , node]);\n                node = node.right;\n            }\n            else if (iter.hasNext()) {\n                iter.next();\n                stack.push([0 , node]);\n                node = node.mid;\n            }\n            else {\n                break;\n            }\n        }\n        if (!node) {\n            return;\n        }\n        if (superStr) {\n            node.left = undefined;\n            node.mid = undefined;\n            node.right = undefined;\n            node.height = 1;\n        }\n        else {\n            node.key = undefined;\n            node.value = undefined;\n        }\n        if (!node.mid && !node.value) {\n            if (node.left && node.right) {\n                const min = this._min(node.right);\n                if (min.key) {\n                    const { key, value, segment } = min;\n                    this._delete(min.key, false);\n                    node.key = key;\n                    node.value = value;\n                    node.segment = segment;\n                }\n            }\n            else {\n                const newChild = node.left ?? node.right;\n                if (stack.length > 0) {\n                    const [dir, parent] = stack[stack.length - 1];\n                    switch (dir) {\n                        case -1 :\n                            parent.left = newChild;\n                            break;\n                        case 0 :\n                            parent.mid = newChild;\n                            break;\n                        case 1 :\n                            parent.right = newChild;\n                            break;\n                    }\n                }\n                else {\n                    this._root = newChild;\n                }\n            }\n        }\n        for (let i = stack.length - 1; i >= 0; i--) {\n            const node = stack[i][1];\n            node.updateHeight();\n            const bf = node.balanceFactor();\n            if (bf > 1) {\n                if (node.right.balanceFactor() >= 0) {\n                    stack[i][1] = node.rotateLeft();\n                }\n                else {\n                    node.right = node.right.rotateRight();\n                    stack[i][1] = node.rotateLeft();\n                }\n            }\n            else if (bf < -1) {\n                if (node.left.balanceFactor() <= 0) {\n                    stack[i][1] = node.rotateRight();\n                }\n                else {\n                    node.left = node.left.rotateLeft();\n                    stack[i][1] = node.rotateRight();\n                }\n            }\n            if (i > 0) {\n                switch (stack[i - 1][0]) {\n                    case -1 :\n                        stack[i - 1][1].left = stack[i][1];\n                        break;\n                    case 1 :\n                        stack[i - 1][1].right = stack[i][1];\n                        break;\n                    case 0 :\n                        stack[i - 1][1].mid = stack[i][1];\n                        break;\n                }\n            }\n            else {\n                this._root = stack[0][1];\n            }\n        }\n    }\n    _min(node) {\n        while (node.left) {\n            node = node.left;\n        }\n        return node;\n    }\n    findSubstr(key) {\n        const iter = this._iter.reset(key);\n        let node = this._root;\n        let candidate = undefined;\n        while (node) {\n            const val = iter.cmp(node.segment);\n            if (val > 0) {\n                node = node.left;\n            }\n            else if (val < 0) {\n                node = node.right;\n            }\n            else if (iter.hasNext()) {\n                iter.next();\n                candidate = node.value || candidate;\n                node = node.mid;\n            }\n            else {\n                break;\n            }\n        }\n        return node && node.value || candidate;\n    }\n    findSuperstr(key) {\n        return this._findSuperstrOrElement(key, false);\n    }\n    _findSuperstrOrElement(key, allowValue) {\n        const iter = this._iter.reset(key);\n        let node = this._root;\n        while (node) {\n            const val = iter.cmp(node.segment);\n            if (val > 0) {\n                node = node.left;\n            }\n            else if (val < 0) {\n                node = node.right;\n            }\n            else if (iter.hasNext()) {\n                iter.next();\n                node = node.mid;\n            }\n            else {\n                if (!node.mid) {\n                    if (allowValue) {\n                        return node.value;\n                    }\n                    else {\n                        return undefined;\n                    }\n                }\n                else {\n                    return this._entries(node.mid);\n                }\n            }\n        }\n        return undefined;\n    }\n    hasElementOrSubtree(key) {\n        return this._findSuperstrOrElement(key, true) !== undefined;\n    }\n    forEach(callback) {\n        for (const [key, value] of this) {\n            callback(value, key);\n        }\n    }\n    *[Symbol.iterator]() {\n        yield* this._entries(this._root);\n    }\n    _entries(node) {\n        const result = [];\n        this._dfsEntries(node, result);\n        return result[Symbol.iterator]();\n    }\n    _dfsEntries(node, bucket) {\n        if (!node) {\n            return;\n        }\n        if (node.left) {\n            this._dfsEntries(node.left, bucket);\n        }\n        if (node.value) {\n            bucket.push([node.key, node.value]);\n        }\n        if (node.mid) {\n            this._dfsEntries(node.mid, bucket);\n        }\n        if (node.right) {\n            this._dfsEntries(node.right, bucket);\n        }\n    }\n    _isBalanced() {\n        const nodeIsBalanced = (node) => {\n            if (!node) {\n                return true;\n            }\n            const bf = node.balanceFactor();\n            if (bf < -1 || bf > 1) {\n                return false;\n            }\n            return nodeIsBalanced(node.left) && nodeIsBalanced(node.right);\n        };\n        return nodeIsBalanced(this._root);\n    }\n}\nexport { ConfigKeysIterator, PathIterator, StringIterator, TernarySearchTree, UriIterator };\n","import { Codicon } from './codicons.js';\nvar ThemeColor;\n( (function(ThemeColor) {\n    function isThemeColor(obj) {\n        return obj && typeof obj === 'object' && typeof obj.id === 'string';\n    }\n    ThemeColor.isThemeColor = isThemeColor;\n})(ThemeColor || (ThemeColor = {})));\nfunction themeColorFromId(id) {\n    return { id };\n}\nvar ThemeIcon;\n( (function(ThemeIcon) {\n    ThemeIcon.iconNameSegment = '[A-Za-z0-9]+';\n    ThemeIcon.iconNameExpression = '[A-Za-z0-9-]+';\n    ThemeIcon.iconModifierExpression = '~[A-Za-z]+';\n    ThemeIcon.iconNameCharacter = '[A-Za-z0-9~-]';\n    const ThemeIconIdRegex = ( new RegExp(\n        `^(${ThemeIcon.iconNameExpression})(${ThemeIcon.iconModifierExpression})?$`\n    ));\n    function asClassNameArray(icon) {\n        const match = ThemeIconIdRegex.exec(icon.id);\n        if (!match) {\n            return asClassNameArray(Codicon.error);\n        }\n        const [, id, modifier] = match;\n        const classNames = ['codicon', 'codicon-' + id];\n        if (modifier) {\n            classNames.push('codicon-modifier-' + modifier.substring(1));\n        }\n        return classNames;\n    }\n    ThemeIcon.asClassNameArray = asClassNameArray;\n    function asClassName(icon) {\n        return asClassNameArray(icon).join(' ');\n    }\n    ThemeIcon.asClassName = asClassName;\n    function asCSSSelector(icon) {\n        return '.' + asClassNameArray(icon).join('.');\n    }\n    ThemeIcon.asCSSSelector = asCSSSelector;\n    function isThemeIcon(obj) {\n        return obj && typeof obj === 'object' && typeof obj.id === 'string' && (typeof obj.color === 'undefined' || ThemeColor.isThemeColor(obj.color));\n    }\n    ThemeIcon.isThemeIcon = isThemeIcon;\n    const _regexFromString = ( new RegExp(\n        `^\\\\$\\\\((${ThemeIcon.iconNameExpression}(?:${ThemeIcon.iconModifierExpression})?)\\\\)$`\n    ));\n    function fromString(str) {\n        const match = _regexFromString.exec(str);\n        if (!match) {\n            return undefined;\n        }\n        const [, name] = match;\n        return { id: name };\n    }\n    ThemeIcon.fromString = fromString;\n    function fromId(id) {\n        return { id };\n    }\n    ThemeIcon.fromId = fromId;\n    function modify(icon, modifier) {\n        let id = icon.id;\n        const tildeIndex = id.lastIndexOf('~');\n        if (tildeIndex !== -1) {\n            id = id.substring(0, tildeIndex);\n        }\n        if (modifier) {\n            id = `${id}~${modifier}`;\n        }\n        return { id };\n    }\n    ThemeIcon.modify = modify;\n    function getModifier(icon) {\n        const tildeIndex = icon.id.lastIndexOf('~');\n        if (tildeIndex !== -1) {\n            return icon.id.substring(tildeIndex + 1);\n        }\n        return undefined;\n    }\n    ThemeIcon.getModifier = getModifier;\n    function isEqual(ti1, ti2) {\n        return ti1.id === ti2.id && ti1.color?.id === ti2.color?.id;\n    }\n    ThemeIcon.isEqual = isEqual;\n})(ThemeIcon || (ThemeIcon = {})));\nexport { ThemeColor, ThemeIcon, themeColorFromId };\n","import { VSBuffer } from './buffer.js';\nimport { URI } from './uri.js';\nconst DefaultURITransformer = new class {\n    transformIncoming(uri) {\n        return uri;\n    }\n    transformOutgoing(uri) {\n        return uri;\n    }\n    transformOutgoingURI(uri) {\n        return uri;\n    }\n    transformOutgoingScheme(scheme) {\n        return scheme;\n    }\n};\nfunction _transformIncomingURIs(obj, transformer, revive, depth) {\n    if (!obj || depth > 200) {\n        return null;\n    }\n    if (typeof obj === 'object') {\n        if (obj.$mid === 1 ) {\n            return revive ? URI.revive(transformer.transformIncoming(obj)) : transformer.transformIncoming(obj);\n        }\n        if (obj instanceof VSBuffer) {\n            return null;\n        }\n        for (const key in obj) {\n            if (Object.hasOwnProperty.call(obj, key)) {\n                const r = _transformIncomingURIs(obj[key], transformer, revive, depth + 1);\n                if (r !== null) {\n                    obj[key] = r;\n                }\n            }\n        }\n    }\n    return null;\n}\nfunction transformIncomingURIs(obj, transformer) {\n    const result = _transformIncomingURIs(obj, transformer, false, 0);\n    if (result === null) {\n        return obj;\n    }\n    return result;\n}\nfunction transformAndReviveIncomingURIs(obj, transformer) {\n    const result = _transformIncomingURIs(obj, transformer, true, 0);\n    if (result === null) {\n        return obj;\n    }\n    return result;\n}\nexport { DefaultURITransformer, transformAndReviveIncomingURIs, transformIncomingURIs };\n","const _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\nfunction isUUID(value) {\n    return _UUIDPattern.test(value);\n}\nconst generateUuid = ( (function() {\n    if (typeof crypto === 'object' && typeof crypto.randomUUID === 'function') {\n        return crypto.randomUUID.bind(crypto);\n    }\n    let getRandomValues;\n    if (typeof crypto === 'object' && typeof crypto.getRandomValues === 'function') {\n        getRandomValues = crypto.getRandomValues.bind(crypto);\n    }\n    else {\n        getRandomValues = function (bucket) {\n            for (let i = 0; i < bucket.length; i++) {\n                bucket[i] = Math.floor(Math.random() * 256);\n            }\n            return bucket;\n        };\n    }\n    const _data = ( new Uint8Array(16));\n    const _hex = [];\n    for (let i = 0; i < 256; i++) {\n        _hex.push(( i.toString(16)).padStart(2, '0'));\n    }\n    return function generateUuid() {\n        getRandomValues(_data);\n        _data[6] = (_data[6] & 0x0f) | 0x40;\n        _data[8] = (_data[8] & 0x3f) | 0x80;\n        let i = 0;\n        let result = '';\n        result += _hex[_data[i++]];\n        result += _hex[_data[i++]];\n        result += _hex[_data[i++]];\n        result += _hex[_data[i++]];\n        result += '-';\n        result += _hex[_data[i++]];\n        result += _hex[_data[i++]];\n        result += '-';\n        result += _hex[_data[i++]];\n        result += _hex[_data[i++]];\n        result += '-';\n        result += _hex[_data[i++]];\n        result += _hex[_data[i++]];\n        result += '-';\n        result += _hex[_data[i++]];\n        result += _hex[_data[i++]];\n        result += _hex[_data[i++]];\n        result += _hex[_data[i++]];\n        result += _hex[_data[i++]];\n        result += _hex[_data[i++]];\n        return result;\n    };\n})());\nexport { generateUuid, isUUID };\n","import { equals } from '../../../base/common/arrays.js';\nimport { equals as equals$1 } from '../../../base/common/objects.js';\nimport { isMacintosh, isLinux } from '../../../base/common/platform.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nimport { USUAL_WORD_SEPARATORS } from '../core/wordHelper.js';\nimport { localize } from '../../../nls.js';\nconst MINIMAP_GUTTER_WIDTH = 8;\nclass ConfigurationChangedEvent {\n    constructor(values) {\n        this._values = values;\n    }\n    hasChanged(id) {\n        return this._values[id];\n    }\n}\nclass ComputeOptionsMemory {\n    constructor() {\n        this.stableMinimapLayoutInput = null;\n        this.stableFitMaxMinimapScale = 0;\n        this.stableFitRemainingWidth = 0;\n    }\n}\nclass BaseEditorOption {\n    constructor(id, name, defaultValue, schema) {\n        this.id = id;\n        this.name = name;\n        this.defaultValue = defaultValue;\n        this.schema = schema;\n    }\n    applyUpdate(value, update) {\n        return applyUpdate(value, update);\n    }\n    compute(env, options, value) {\n        return value;\n    }\n}\nclass ApplyUpdateResult {\n    constructor(newValue, didChange) {\n        this.newValue = newValue;\n        this.didChange = didChange;\n    }\n}\nfunction applyUpdate(value, update) {\n    if (typeof value !== 'object' || typeof update !== 'object' || !value || !update) {\n        return (\n             (new ApplyUpdateResult(update, value !== update))\n        );\n    }\n    if (Array.isArray(value) || Array.isArray(update)) {\n        const arrayEquals = Array.isArray(value) && Array.isArray(update) && equals(value, update);\n        return (\n             (new ApplyUpdateResult(update, !arrayEquals))\n        );\n    }\n    let didChange = false;\n    for (const key in update) {\n        if (update.hasOwnProperty(key)) {\n            const result = applyUpdate(value[key], update[key]);\n            if (result.didChange) {\n                value[key] = result.newValue;\n                didChange = true;\n            }\n        }\n    }\n    return (\n         (new ApplyUpdateResult(value, didChange))\n    );\n}\nclass ComputedEditorOption {\n    constructor(id) {\n        this.schema = undefined;\n        this.id = id;\n        this.name = '_never_';\n        this.defaultValue = undefined;\n    }\n    applyUpdate(value, update) {\n        return applyUpdate(value, update);\n    }\n    validate(input) {\n        return this.defaultValue;\n    }\n}\nclass SimpleEditorOption {\n    constructor(id, name, defaultValue, schema) {\n        this.id = id;\n        this.name = name;\n        this.defaultValue = defaultValue;\n        this.schema = schema;\n    }\n    applyUpdate(value, update) {\n        return applyUpdate(value, update);\n    }\n    validate(input) {\n        if (typeof input === 'undefined') {\n            return this.defaultValue;\n        }\n        return input;\n    }\n    compute(env, options, value) {\n        return value;\n    }\n}\nfunction boolean(value, defaultValue) {\n    if (typeof value === 'undefined') {\n        return defaultValue;\n    }\n    if (value === 'false') {\n        return false;\n    }\n    return Boolean(value);\n}\nclass EditorBooleanOption extends SimpleEditorOption {\n    constructor(id, name, defaultValue, schema = undefined) {\n        if (typeof schema !== 'undefined') {\n            schema.type = 'boolean';\n            schema.default = defaultValue;\n        }\n        super(id, name, defaultValue, schema);\n    }\n    validate(input) {\n        return boolean(input, this.defaultValue);\n    }\n}\nfunction clampedInt(value, defaultValue, minimum, maximum) {\n    if (typeof value === 'undefined') {\n        return defaultValue;\n    }\n    let r = parseInt(value, 10);\n    if (isNaN(r)) {\n        return defaultValue;\n    }\n    r = Math.max(minimum, r);\n    r = Math.min(maximum, r);\n    return r | 0;\n}\nclass EditorIntOption extends SimpleEditorOption {\n    static clampedInt(value, defaultValue, minimum, maximum) {\n        return clampedInt(value, defaultValue, minimum, maximum);\n    }\n    constructor(id, name, defaultValue, minimum, maximum, schema = undefined) {\n        if (typeof schema !== 'undefined') {\n            schema.type = 'integer';\n            schema.default = defaultValue;\n            schema.minimum = minimum;\n            schema.maximum = maximum;\n        }\n        super(id, name, defaultValue, schema);\n        this.minimum = minimum;\n        this.maximum = maximum;\n    }\n    validate(input) {\n        return EditorIntOption.clampedInt(input, this.defaultValue, this.minimum, this.maximum);\n    }\n}\nfunction clampedFloat(value, defaultValue, minimum, maximum) {\n    if (typeof value === 'undefined') {\n        return defaultValue;\n    }\n    const r = EditorFloatOption.float(value, defaultValue);\n    return EditorFloatOption.clamp(r, minimum, maximum);\n}\nclass EditorFloatOption extends SimpleEditorOption {\n    static clamp(n, min, max) {\n        if (n < min) {\n            return min;\n        }\n        if (n > max) {\n            return max;\n        }\n        return n;\n    }\n    static float(value, defaultValue) {\n        if (typeof value === 'number') {\n            return value;\n        }\n        if (typeof value === 'undefined') {\n            return defaultValue;\n        }\n        const r = parseFloat(value);\n        return (isNaN(r) ? defaultValue : r);\n    }\n    constructor(id, name, defaultValue, validationFn, schema) {\n        if (typeof schema !== 'undefined') {\n            schema.type = 'number';\n            schema.default = defaultValue;\n        }\n        super(id, name, defaultValue, schema);\n        this.validationFn = validationFn;\n    }\n    validate(input) {\n        return this.validationFn(EditorFloatOption.float(input, this.defaultValue));\n    }\n}\nclass EditorStringOption extends SimpleEditorOption {\n    static string(value, defaultValue) {\n        if (typeof value !== 'string') {\n            return defaultValue;\n        }\n        return value;\n    }\n    constructor(id, name, defaultValue, schema = undefined) {\n        if (typeof schema !== 'undefined') {\n            schema.type = 'string';\n            schema.default = defaultValue;\n        }\n        super(id, name, defaultValue, schema);\n    }\n    validate(input) {\n        return EditorStringOption.string(input, this.defaultValue);\n    }\n}\nfunction stringSet(value, defaultValue, allowedValues, renamedValues) {\n    if (typeof value !== 'string') {\n        return defaultValue;\n    }\n    if (renamedValues && value in renamedValues) {\n        return renamedValues[value];\n    }\n    if (allowedValues.indexOf(value) === -1) {\n        return defaultValue;\n    }\n    return value;\n}\nclass EditorStringEnumOption extends SimpleEditorOption {\n    constructor(id, name, defaultValue, allowedValues, schema = undefined) {\n        if (typeof schema !== 'undefined') {\n            schema.type = 'string';\n            schema.enum = allowedValues;\n            schema.default = defaultValue;\n        }\n        super(id, name, defaultValue, schema);\n        this._allowedValues = allowedValues;\n    }\n    validate(input) {\n        return stringSet(input, this.defaultValue, this._allowedValues);\n    }\n}\nclass EditorEnumOption extends BaseEditorOption {\n    constructor(id, name, defaultValue, defaultStringValue, allowedValues, convert, schema = undefined) {\n        if (typeof schema !== 'undefined') {\n            schema.type = 'string';\n            schema.enum = allowedValues;\n            schema.default = defaultStringValue;\n        }\n        super(id, name, defaultValue, schema);\n        this._allowedValues = allowedValues;\n        this._convert = convert;\n    }\n    validate(input) {\n        if (typeof input !== 'string') {\n            return this.defaultValue;\n        }\n        if (this._allowedValues.indexOf(input) === -1) {\n            return this.defaultValue;\n        }\n        return this._convert(input);\n    }\n}\nfunction _autoIndentFromString(autoIndent) {\n    switch (autoIndent) {\n        case 'none': return 0 ;\n        case 'keep': return 1 ;\n        case 'brackets': return 2 ;\n        case 'advanced': return 3 ;\n        case 'full': return 4 ;\n    }\n}\nclass EditorAccessibilitySupport extends BaseEditorOption {\n    constructor() {\n        super(2 , 'accessibilitySupport', 0 , {\n            type: 'string',\n            enum: ['auto', 'on', 'off'],\n            enumDescriptions: [\n                ( localize(75, \"Use platform APIs to detect when a Screen Reader is attached.\")),\n                ( localize(76, \"Optimize for usage with a Screen Reader.\")),\n                ( localize(77, \"Assume a screen reader is not attached.\")),\n            ],\n            default: 'auto',\n            tags: ['accessibility'],\n            description: ( localize(\n                78,\n                \"Controls if the UI should run in a mode where it is optimized for screen readers.\"\n            ))\n        });\n    }\n    validate(input) {\n        switch (input) {\n            case 'auto': return 0 ;\n            case 'off': return 1 ;\n            case 'on': return 2 ;\n        }\n        return this.defaultValue;\n    }\n    compute(env, options, value) {\n        if (value === 0 ) {\n            return env.accessibilitySupport;\n        }\n        return value;\n    }\n}\nclass EditorComments extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            insertSpace: true,\n            ignoreEmptyLines: true,\n        };\n        super(23 , 'comments', defaults, {\n            'editor.comments.insertSpace': {\n                type: 'boolean',\n                default: defaults.insertSpace,\n                description: ( localize(79, \"Controls whether a space character is inserted when commenting.\"))\n            },\n            'editor.comments.ignoreEmptyLines': {\n                type: 'boolean',\n                default: defaults.ignoreEmptyLines,\n                description: ( localize(\n                    80,\n                    'Controls if empty lines should be ignored with toggle, add or remove actions for line comments.'\n                ))\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            insertSpace: boolean(input.insertSpace, this.defaultValue.insertSpace),\n            ignoreEmptyLines: boolean(input.ignoreEmptyLines, this.defaultValue.ignoreEmptyLines),\n        };\n    }\n}\nfunction cursorBlinkingStyleFromString(cursorBlinkingStyle) {\n    switch (cursorBlinkingStyle) {\n        case 'blink': return 1 ;\n        case 'smooth': return 2 ;\n        case 'phase': return 3 ;\n        case 'expand': return 4 ;\n        case 'solid': return 5 ;\n    }\n}\nvar TextEditorCursorStyle;\n( ((function(TextEditorCursorStyle) {\n    TextEditorCursorStyle[TextEditorCursorStyle[\"Line\"] = 1] = \"Line\";\n    TextEditorCursorStyle[TextEditorCursorStyle[\"Block\"] = 2] = \"Block\";\n    TextEditorCursorStyle[TextEditorCursorStyle[\"Underline\"] = 3] = \"Underline\";\n    TextEditorCursorStyle[TextEditorCursorStyle[\"LineThin\"] = 4] = \"LineThin\";\n    TextEditorCursorStyle[TextEditorCursorStyle[\"BlockOutline\"] = 5] = \"BlockOutline\";\n    TextEditorCursorStyle[TextEditorCursorStyle[\"UnderlineThin\"] = 6] = \"UnderlineThin\";\n})(TextEditorCursorStyle || (TextEditorCursorStyle = {}))));\nfunction cursorStyleToString(cursorStyle) {\n    switch (cursorStyle) {\n        case TextEditorCursorStyle.Line: return 'line';\n        case TextEditorCursorStyle.Block: return 'block';\n        case TextEditorCursorStyle.Underline: return 'underline';\n        case TextEditorCursorStyle.LineThin: return 'line-thin';\n        case TextEditorCursorStyle.BlockOutline: return 'block-outline';\n        case TextEditorCursorStyle.UnderlineThin: return 'underline-thin';\n    }\n}\nfunction cursorStyleFromString(cursorStyle) {\n    switch (cursorStyle) {\n        case 'line': return TextEditorCursorStyle.Line;\n        case 'block': return TextEditorCursorStyle.Block;\n        case 'underline': return TextEditorCursorStyle.Underline;\n        case 'line-thin': return TextEditorCursorStyle.LineThin;\n        case 'block-outline': return TextEditorCursorStyle.BlockOutline;\n        case 'underline-thin': return TextEditorCursorStyle.UnderlineThin;\n    }\n}\nclass EditorClassName extends ComputedEditorOption {\n    constructor() {\n        super(145 );\n    }\n    compute(env, options, _) {\n        const classNames = ['monaco-editor'];\n        if (options.get(41 )) {\n            classNames.push(options.get(41 ));\n        }\n        if (env.extraEditorClassName) {\n            classNames.push(env.extraEditorClassName);\n        }\n        if (options.get(76 ) === 'default') {\n            classNames.push('mouse-default');\n        }\n        else if (options.get(76 ) === 'copy') {\n            classNames.push('mouse-copy');\n        }\n        if (options.get(114 )) {\n            classNames.push('showUnused');\n        }\n        if (options.get(143 )) {\n            classNames.push('showDeprecated');\n        }\n        return classNames.join(' ');\n    }\n}\nclass EditorEmptySelectionClipboard extends EditorBooleanOption {\n    constructor() {\n        super(38 , 'emptySelectionClipboard', true, { description: ( localize(\n            81,\n            \"Controls whether copying without a selection copies the current line.\"\n        )) });\n    }\n    compute(env, options, value) {\n        return value && env.emptySelectionClipboard;\n    }\n}\nclass EditorFind extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            cursorMoveOnType: true,\n            seedSearchStringFromSelection: 'always',\n            autoFindInSelection: 'never',\n            globalFindClipboard: false,\n            addExtraSpaceOnTop: true,\n            loop: true\n        };\n        super(43 , 'find', defaults, {\n            'editor.find.cursorMoveOnType': {\n                type: 'boolean',\n                default: defaults.cursorMoveOnType,\n                description: ( localize(\n                    82,\n                    \"Controls whether the cursor should jump to find matches while typing.\"\n                ))\n            },\n            'editor.find.seedSearchStringFromSelection': {\n                type: 'string',\n                enum: ['never', 'always', 'selection'],\n                default: defaults.seedSearchStringFromSelection,\n                enumDescriptions: [\n                    ( localize(83, 'Never seed search string from the editor selection.')),\n                    ( localize(\n                        84,\n                        'Always seed search string from the editor selection, including word at cursor position.'\n                    )),\n                    ( localize(85, 'Only seed search string from the editor selection.'))\n                ],\n                description: ( localize(\n                    86,\n                    \"Controls whether the search string in the Find Widget is seeded from the editor selection.\"\n                ))\n            },\n            'editor.find.autoFindInSelection': {\n                type: 'string',\n                enum: ['never', 'always', 'multiline'],\n                default: defaults.autoFindInSelection,\n                enumDescriptions: [\n                    ( localize(87, 'Never turn on Find in Selection automatically (default).')),\n                    ( localize(88, 'Always turn on Find in Selection automatically.')),\n                    ( localize(\n                        89,\n                        'Turn on Find in Selection automatically when multiple lines of content are selected.'\n                    ))\n                ],\n                description: ( localize(\n                    90,\n                    \"Controls the condition for turning on Find in Selection automatically.\"\n                ))\n            },\n            'editor.find.globalFindClipboard': {\n                type: 'boolean',\n                default: defaults.globalFindClipboard,\n                description: ( localize(\n                    91,\n                    \"Controls whether the Find Widget should read or modify the shared find clipboard on macOS.\"\n                )),\n                included: isMacintosh\n            },\n            'editor.find.addExtraSpaceOnTop': {\n                type: 'boolean',\n                default: defaults.addExtraSpaceOnTop,\n                description: ( localize(\n                    92,\n                    \"Controls whether the Find Widget should add extra lines on top of the editor. When true, you can scroll beyond the first line when the Find Widget is visible.\"\n                ))\n            },\n            'editor.find.loop': {\n                type: 'boolean',\n                default: defaults.loop,\n                description: ( localize(\n                    93,\n                    \"Controls whether the search automatically restarts from the beginning (or the end) when no further matches can be found.\"\n                ))\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            cursorMoveOnType: boolean(input.cursorMoveOnType, this.defaultValue.cursorMoveOnType),\n            seedSearchStringFromSelection: typeof _input.seedSearchStringFromSelection === 'boolean'\n                ? (_input.seedSearchStringFromSelection ? 'always' : 'never')\n                : stringSet(input.seedSearchStringFromSelection, this.defaultValue.seedSearchStringFromSelection, ['never', 'always', 'selection']),\n            autoFindInSelection: typeof _input.autoFindInSelection === 'boolean'\n                ? (_input.autoFindInSelection ? 'always' : 'never')\n                : stringSet(input.autoFindInSelection, this.defaultValue.autoFindInSelection, ['never', 'always', 'multiline']),\n            globalFindClipboard: boolean(input.globalFindClipboard, this.defaultValue.globalFindClipboard),\n            addExtraSpaceOnTop: boolean(input.addExtraSpaceOnTop, this.defaultValue.addExtraSpaceOnTop),\n            loop: boolean(input.loop, this.defaultValue.loop),\n        };\n    }\n}\nclass EditorFontLigatures extends BaseEditorOption {\n    static { this.OFF = '\"liga\" off, \"calt\" off'; }\n    static { this.ON = '\"liga\" on, \"calt\" on'; }\n    constructor() {\n        super(53 , 'fontLigatures', EditorFontLigatures.OFF, {\n            anyOf: [\n                {\n                    type: 'boolean',\n                    description: ( localize(\n                        94,\n                        \"Enables/Disables font ligatures ('calt' and 'liga' font features). Change this to a string for fine-grained control of the 'font-feature-settings' CSS property.\"\n                    )),\n                },\n                {\n                    type: 'string',\n                    description: ( localize(\n                        95,\n                        \"Explicit 'font-feature-settings' CSS property. A boolean can be passed instead if one only needs to turn on/off ligatures.\"\n                    ))\n                }\n            ],\n            description: ( localize(\n                96,\n                \"Configures font ligatures or font features. Can be either a boolean to enable/disable ligatures or a string for the value of the CSS 'font-feature-settings' property.\"\n            )),\n            default: false\n        });\n    }\n    validate(input) {\n        if (typeof input === 'undefined') {\n            return this.defaultValue;\n        }\n        if (typeof input === 'string') {\n            if (input === 'false' || input.length === 0) {\n                return EditorFontLigatures.OFF;\n            }\n            if (input === 'true') {\n                return EditorFontLigatures.ON;\n            }\n            return input;\n        }\n        if (Boolean(input)) {\n            return EditorFontLigatures.ON;\n        }\n        return EditorFontLigatures.OFF;\n    }\n}\nclass EditorFontVariations extends BaseEditorOption {\n    static { this.OFF = 'normal'; }\n    static { this.TRANSLATE = 'translate'; }\n    constructor() {\n        super(56 , 'fontVariations', EditorFontVariations.OFF, {\n            anyOf: [\n                {\n                    type: 'boolean',\n                    description: ( localize(\n                        97,\n                        \"Enables/Disables the translation from font-weight to font-variation-settings. Change this to a string for fine-grained control of the 'font-variation-settings' CSS property.\"\n                    )),\n                },\n                {\n                    type: 'string',\n                    description: ( localize(\n                        98,\n                        \"Explicit 'font-variation-settings' CSS property. A boolean can be passed instead if one only needs to translate font-weight to font-variation-settings.\"\n                    ))\n                }\n            ],\n            description: ( localize(\n                99,\n                \"Configures font variations. Can be either a boolean to enable/disable the translation from font-weight to font-variation-settings or a string for the value of the CSS 'font-variation-settings' property.\"\n            )),\n            default: false\n        });\n    }\n    validate(input) {\n        if (typeof input === 'undefined') {\n            return this.defaultValue;\n        }\n        if (typeof input === 'string') {\n            if (input === 'false') {\n                return EditorFontVariations.OFF;\n            }\n            if (input === 'true') {\n                return EditorFontVariations.TRANSLATE;\n            }\n            return input;\n        }\n        if (Boolean(input)) {\n            return EditorFontVariations.TRANSLATE;\n        }\n        return EditorFontVariations.OFF;\n    }\n    compute(env, options, value) {\n        return env.fontInfo.fontVariationSettings;\n    }\n}\nclass EditorFontInfo extends ComputedEditorOption {\n    constructor() {\n        super(52 );\n    }\n    compute(env, options, _) {\n        return env.fontInfo;\n    }\n}\nclass EditorFontSize extends SimpleEditorOption {\n    constructor() {\n        super(54 , 'fontSize', EDITOR_FONT_DEFAULTS.fontSize, {\n            type: 'number',\n            minimum: 6,\n            maximum: 100,\n            default: EDITOR_FONT_DEFAULTS.fontSize,\n            description: ( localize(100, \"Controls the font size in pixels.\"))\n        });\n    }\n    validate(input) {\n        const r = EditorFloatOption.float(input, this.defaultValue);\n        if (r === 0) {\n            return EDITOR_FONT_DEFAULTS.fontSize;\n        }\n        return EditorFloatOption.clamp(r, 6, 100);\n    }\n    compute(env, options, value) {\n        return env.fontInfo.fontSize;\n    }\n}\nclass EditorFontWeight extends BaseEditorOption {\n    static { this.SUGGESTION_VALUES = ['normal', 'bold', '100', '200', '300', '400', '500', '600', '700', '800', '900']; }\n    static { this.MINIMUM_VALUE = 1; }\n    static { this.MAXIMUM_VALUE = 1000; }\n    constructor() {\n        super(55 , 'fontWeight', EDITOR_FONT_DEFAULTS.fontWeight, {\n            anyOf: [\n                {\n                    type: 'number',\n                    minimum: EditorFontWeight.MINIMUM_VALUE,\n                    maximum: EditorFontWeight.MAXIMUM_VALUE,\n                    errorMessage: ( localize(\n                        101,\n                        \"Only \\\"normal\\\" and \\\"bold\\\" keywords or numbers between 1 and 1000 are allowed.\"\n                    ))\n                },\n                {\n                    type: 'string',\n                    pattern: '^(normal|bold|1000|[1-9][0-9]{0,2})$'\n                },\n                {\n                    enum: EditorFontWeight.SUGGESTION_VALUES\n                }\n            ],\n            default: EDITOR_FONT_DEFAULTS.fontWeight,\n            description: ( localize(\n                102,\n                \"Controls the font weight. Accepts \\\"normal\\\" and \\\"bold\\\" keywords or numbers between 1 and 1000.\"\n            ))\n        });\n    }\n    validate(input) {\n        if (input === 'normal' || input === 'bold') {\n            return input;\n        }\n        return String(EditorIntOption.clampedInt(input, EDITOR_FONT_DEFAULTS.fontWeight, EditorFontWeight.MINIMUM_VALUE, EditorFontWeight.MAXIMUM_VALUE));\n    }\n}\nclass EditorGoToLocation extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            multiple: 'peek',\n            multipleDefinitions: 'peek',\n            multipleTypeDefinitions: 'peek',\n            multipleDeclarations: 'peek',\n            multipleImplementations: 'peek',\n            multipleReferences: 'peek',\n            multipleTests: 'peek',\n            alternativeDefinitionCommand: 'editor.action.goToReferences',\n            alternativeTypeDefinitionCommand: 'editor.action.goToReferences',\n            alternativeDeclarationCommand: 'editor.action.goToReferences',\n            alternativeImplementationCommand: '',\n            alternativeReferenceCommand: '',\n            alternativeTestsCommand: '',\n        };\n        const jsonSubset = {\n            type: 'string',\n            enum: ['peek', 'gotoAndPeek', 'goto'],\n            default: defaults.multiple,\n            enumDescriptions: [\n                ( localize(103, 'Show Peek view of the results (default)')),\n                ( localize(104, 'Go to the primary result and show a Peek view')),\n                ( localize(105, 'Go to the primary result and enable Peek-less navigation to others'))\n            ]\n        };\n        const alternativeCommandOptions = ['', 'editor.action.referenceSearch.trigger', 'editor.action.goToReferences', 'editor.action.peekImplementation', 'editor.action.goToImplementation', 'editor.action.peekTypeDefinition', 'editor.action.goToTypeDefinition', 'editor.action.peekDeclaration', 'editor.action.revealDeclaration', 'editor.action.peekDefinition', 'editor.action.revealDefinitionAside', 'editor.action.revealDefinition'];\n        super(60 , 'gotoLocation', defaults, {\n            'editor.gotoLocation.multiple': {\n                deprecationMessage: ( localize(\n                    106,\n                    \"This setting is deprecated, please use separate settings like 'editor.editor.gotoLocation.multipleDefinitions' or 'editor.editor.gotoLocation.multipleImplementations' instead.\"\n                )),\n            },\n            'editor.gotoLocation.multipleDefinitions': {\n                description: ( localize(\n                    107,\n                    \"Controls the behavior the 'Go to Definition'-command when multiple target locations exist.\"\n                )),\n                ...jsonSubset,\n            },\n            'editor.gotoLocation.multipleTypeDefinitions': {\n                description: ( localize(\n                    108,\n                    \"Controls the behavior the 'Go to Type Definition'-command when multiple target locations exist.\"\n                )),\n                ...jsonSubset,\n            },\n            'editor.gotoLocation.multipleDeclarations': {\n                description: ( localize(\n                    109,\n                    \"Controls the behavior the 'Go to Declaration'-command when multiple target locations exist.\"\n                )),\n                ...jsonSubset,\n            },\n            'editor.gotoLocation.multipleImplementations': {\n                description: ( localize(\n                    110,\n                    \"Controls the behavior the 'Go to Implementations'-command when multiple target locations exist.\"\n                )),\n                ...jsonSubset,\n            },\n            'editor.gotoLocation.multipleReferences': {\n                description: ( localize(\n                    111,\n                    \"Controls the behavior the 'Go to References'-command when multiple target locations exist.\"\n                )),\n                ...jsonSubset,\n            },\n            'editor.gotoLocation.alternativeDefinitionCommand': {\n                type: 'string',\n                default: defaults.alternativeDefinitionCommand,\n                enum: alternativeCommandOptions,\n                description: ( localize(\n                    112,\n                    \"Alternative command id that is being executed when the result of 'Go to Definition' is the current location.\"\n                ))\n            },\n            'editor.gotoLocation.alternativeTypeDefinitionCommand': {\n                type: 'string',\n                default: defaults.alternativeTypeDefinitionCommand,\n                enum: alternativeCommandOptions,\n                description: ( localize(\n                    113,\n                    \"Alternative command id that is being executed when the result of 'Go to Type Definition' is the current location.\"\n                ))\n            },\n            'editor.gotoLocation.alternativeDeclarationCommand': {\n                type: 'string',\n                default: defaults.alternativeDeclarationCommand,\n                enum: alternativeCommandOptions,\n                description: ( localize(\n                    114,\n                    \"Alternative command id that is being executed when the result of 'Go to Declaration' is the current location.\"\n                ))\n            },\n            'editor.gotoLocation.alternativeImplementationCommand': {\n                type: 'string',\n                default: defaults.alternativeImplementationCommand,\n                enum: alternativeCommandOptions,\n                description: ( localize(\n                    115,\n                    \"Alternative command id that is being executed when the result of 'Go to Implementation' is the current location.\"\n                ))\n            },\n            'editor.gotoLocation.alternativeReferenceCommand': {\n                type: 'string',\n                default: defaults.alternativeReferenceCommand,\n                enum: alternativeCommandOptions,\n                description: ( localize(\n                    116,\n                    \"Alternative command id that is being executed when the result of 'Go to Reference' is the current location.\"\n                ))\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            multiple: stringSet(input.multiple, this.defaultValue.multiple, ['peek', 'gotoAndPeek', 'goto']),\n            multipleDefinitions: input.multipleDefinitions ?? stringSet(input.multipleDefinitions, 'peek', ['peek', 'gotoAndPeek', 'goto']),\n            multipleTypeDefinitions: input.multipleTypeDefinitions ?? stringSet(input.multipleTypeDefinitions, 'peek', ['peek', 'gotoAndPeek', 'goto']),\n            multipleDeclarations: input.multipleDeclarations ?? stringSet(input.multipleDeclarations, 'peek', ['peek', 'gotoAndPeek', 'goto']),\n            multipleImplementations: input.multipleImplementations ?? stringSet(input.multipleImplementations, 'peek', ['peek', 'gotoAndPeek', 'goto']),\n            multipleReferences: input.multipleReferences ?? stringSet(input.multipleReferences, 'peek', ['peek', 'gotoAndPeek', 'goto']),\n            multipleTests: input.multipleTests ?? stringSet(input.multipleTests, 'peek', ['peek', 'gotoAndPeek', 'goto']),\n            alternativeDefinitionCommand: EditorStringOption.string(input.alternativeDefinitionCommand, this.defaultValue.alternativeDefinitionCommand),\n            alternativeTypeDefinitionCommand: EditorStringOption.string(input.alternativeTypeDefinitionCommand, this.defaultValue.alternativeTypeDefinitionCommand),\n            alternativeDeclarationCommand: EditorStringOption.string(input.alternativeDeclarationCommand, this.defaultValue.alternativeDeclarationCommand),\n            alternativeImplementationCommand: EditorStringOption.string(input.alternativeImplementationCommand, this.defaultValue.alternativeImplementationCommand),\n            alternativeReferenceCommand: EditorStringOption.string(input.alternativeReferenceCommand, this.defaultValue.alternativeReferenceCommand),\n            alternativeTestsCommand: EditorStringOption.string(input.alternativeTestsCommand, this.defaultValue.alternativeTestsCommand),\n        };\n    }\n}\nclass EditorHover extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            enabled: true,\n            delay: 300,\n            hidingDelay: 300,\n            sticky: true,\n            above: true,\n        };\n        super(62 , 'hover', defaults, {\n            'editor.hover.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                description: ( localize(117, \"Controls whether the hover is shown.\"))\n            },\n            'editor.hover.delay': {\n                type: 'number',\n                default: defaults.delay,\n                minimum: 0,\n                maximum: 10000,\n                description: ( localize(118, \"Controls the delay in milliseconds after which the hover is shown.\"))\n            },\n            'editor.hover.sticky': {\n                type: 'boolean',\n                default: defaults.sticky,\n                description: ( localize(\n                    119,\n                    \"Controls whether the hover should remain visible when mouse is moved over it.\"\n                ))\n            },\n            'editor.hover.hidingDelay': {\n                type: 'integer',\n                minimum: 0,\n                default: defaults.hidingDelay,\n                description: ( localize(\n                    120,\n                    \"Controls the delay in milliseconds after which the hover is hidden. Requires `editor.hover.sticky` to be enabled.\"\n                ))\n            },\n            'editor.hover.above': {\n                type: 'boolean',\n                default: defaults.above,\n                description: ( localize(121, \"Prefer showing hovers above the line, if there's space.\"))\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled),\n            delay: EditorIntOption.clampedInt(input.delay, this.defaultValue.delay, 0, 10000),\n            sticky: boolean(input.sticky, this.defaultValue.sticky),\n            hidingDelay: EditorIntOption.clampedInt(input.hidingDelay, this.defaultValue.hidingDelay, 0, 600000),\n            above: boolean(input.above, this.defaultValue.above),\n        };\n    }\n}\nclass EditorLayoutInfoComputer extends ComputedEditorOption {\n    constructor() {\n        super(148 );\n    }\n    compute(env, options, _) {\n        return EditorLayoutInfoComputer.computeLayout(options, {\n            memory: env.memory,\n            outerWidth: env.outerWidth,\n            outerHeight: env.outerHeight,\n            isDominatedByLongLines: env.isDominatedByLongLines,\n            lineHeight: env.fontInfo.lineHeight,\n            viewLineCount: env.viewLineCount,\n            lineNumbersDigitCount: env.lineNumbersDigitCount,\n            typicalHalfwidthCharacterWidth: env.fontInfo.typicalHalfwidthCharacterWidth,\n            maxDigitWidth: env.fontInfo.maxDigitWidth,\n            pixelRatio: env.pixelRatio,\n            glyphMarginDecorationLaneCount: env.glyphMarginDecorationLaneCount\n        });\n    }\n    static computeContainedMinimapLineCount(input) {\n        const typicalViewportLineCount = input.height / input.lineHeight;\n        const extraLinesBeforeFirstLine = Math.floor(input.paddingTop / input.lineHeight);\n        let extraLinesBeyondLastLine = Math.floor(input.paddingBottom / input.lineHeight);\n        if (input.scrollBeyondLastLine) {\n            extraLinesBeyondLastLine = Math.max(extraLinesBeyondLastLine, typicalViewportLineCount - 1);\n        }\n        const desiredRatio = (extraLinesBeforeFirstLine + input.viewLineCount + extraLinesBeyondLastLine) / (input.pixelRatio * input.height);\n        const minimapLineCount = Math.floor(input.viewLineCount / desiredRatio);\n        return { typicalViewportLineCount, extraLinesBeforeFirstLine, extraLinesBeyondLastLine, desiredRatio, minimapLineCount };\n    }\n    static _computeMinimapLayout(input, memory) {\n        const outerWidth = input.outerWidth;\n        const outerHeight = input.outerHeight;\n        const pixelRatio = input.pixelRatio;\n        if (!input.minimap.enabled) {\n            return {\n                renderMinimap: 0 ,\n                minimapLeft: 0,\n                minimapWidth: 0,\n                minimapHeightIsEditorHeight: false,\n                minimapIsSampling: false,\n                minimapScale: 1,\n                minimapLineHeight: 1,\n                minimapCanvasInnerWidth: 0,\n                minimapCanvasInnerHeight: Math.floor(pixelRatio * outerHeight),\n                minimapCanvasOuterWidth: 0,\n                minimapCanvasOuterHeight: outerHeight,\n            };\n        }\n        const stableMinimapLayoutInput = memory.stableMinimapLayoutInput;\n        const couldUseMemory = (stableMinimapLayoutInput\n            && input.outerHeight === stableMinimapLayoutInput.outerHeight\n            && input.lineHeight === stableMinimapLayoutInput.lineHeight\n            && input.typicalHalfwidthCharacterWidth === stableMinimapLayoutInput.typicalHalfwidthCharacterWidth\n            && input.pixelRatio === stableMinimapLayoutInput.pixelRatio\n            && input.scrollBeyondLastLine === stableMinimapLayoutInput.scrollBeyondLastLine\n            && input.paddingTop === stableMinimapLayoutInput.paddingTop\n            && input.paddingBottom === stableMinimapLayoutInput.paddingBottom\n            && input.minimap.enabled === stableMinimapLayoutInput.minimap.enabled\n            && input.minimap.side === stableMinimapLayoutInput.minimap.side\n            && input.minimap.size === stableMinimapLayoutInput.minimap.size\n            && input.minimap.showSlider === stableMinimapLayoutInput.minimap.showSlider\n            && input.minimap.renderCharacters === stableMinimapLayoutInput.minimap.renderCharacters\n            && input.minimap.maxColumn === stableMinimapLayoutInput.minimap.maxColumn\n            && input.minimap.scale === stableMinimapLayoutInput.minimap.scale\n            && input.verticalScrollbarWidth === stableMinimapLayoutInput.verticalScrollbarWidth\n            && input.isViewportWrapping === stableMinimapLayoutInput.isViewportWrapping);\n        const lineHeight = input.lineHeight;\n        const typicalHalfwidthCharacterWidth = input.typicalHalfwidthCharacterWidth;\n        const scrollBeyondLastLine = input.scrollBeyondLastLine;\n        const minimapRenderCharacters = input.minimap.renderCharacters;\n        let minimapScale = (pixelRatio >= 2 ? Math.round(input.minimap.scale * 2) : input.minimap.scale);\n        const minimapMaxColumn = input.minimap.maxColumn;\n        const minimapSize = input.minimap.size;\n        const minimapSide = input.minimap.side;\n        const verticalScrollbarWidth = input.verticalScrollbarWidth;\n        const viewLineCount = input.viewLineCount;\n        const remainingWidth = input.remainingWidth;\n        const isViewportWrapping = input.isViewportWrapping;\n        const baseCharHeight = minimapRenderCharacters ? 2 : 3;\n        let minimapCanvasInnerHeight = Math.floor(pixelRatio * outerHeight);\n        const minimapCanvasOuterHeight = minimapCanvasInnerHeight / pixelRatio;\n        let minimapHeightIsEditorHeight = false;\n        let minimapIsSampling = false;\n        let minimapLineHeight = baseCharHeight * minimapScale;\n        let minimapCharWidth = minimapScale / pixelRatio;\n        let minimapWidthMultiplier = 1;\n        if (minimapSize === 'fill' || minimapSize === 'fit') {\n            const { typicalViewportLineCount, extraLinesBeforeFirstLine, extraLinesBeyondLastLine, desiredRatio, minimapLineCount } = EditorLayoutInfoComputer.computeContainedMinimapLineCount({\n                viewLineCount: viewLineCount,\n                scrollBeyondLastLine: scrollBeyondLastLine,\n                paddingTop: input.paddingTop,\n                paddingBottom: input.paddingBottom,\n                height: outerHeight,\n                lineHeight: lineHeight,\n                pixelRatio: pixelRatio\n            });\n            const ratio = viewLineCount / minimapLineCount;\n            if (ratio > 1) {\n                minimapHeightIsEditorHeight = true;\n                minimapIsSampling = true;\n                minimapScale = 1;\n                minimapLineHeight = 1;\n                minimapCharWidth = minimapScale / pixelRatio;\n            }\n            else {\n                let fitBecomesFill = false;\n                let maxMinimapScale = minimapScale + 1;\n                if (minimapSize === 'fit') {\n                    const effectiveMinimapHeight = Math.ceil((extraLinesBeforeFirstLine + viewLineCount + extraLinesBeyondLastLine) * minimapLineHeight);\n                    if (isViewportWrapping && couldUseMemory && remainingWidth <= memory.stableFitRemainingWidth) {\n                        fitBecomesFill = true;\n                        maxMinimapScale = memory.stableFitMaxMinimapScale;\n                    }\n                    else {\n                        fitBecomesFill = (effectiveMinimapHeight > minimapCanvasInnerHeight);\n                    }\n                }\n                if (minimapSize === 'fill' || fitBecomesFill) {\n                    minimapHeightIsEditorHeight = true;\n                    const configuredMinimapScale = minimapScale;\n                    minimapLineHeight = Math.min(lineHeight * pixelRatio, Math.max(1, Math.floor(1 / desiredRatio)));\n                    if (isViewportWrapping && couldUseMemory && remainingWidth <= memory.stableFitRemainingWidth) {\n                        maxMinimapScale = memory.stableFitMaxMinimapScale;\n                    }\n                    minimapScale = Math.min(maxMinimapScale, Math.max(1, Math.floor(minimapLineHeight / baseCharHeight)));\n                    if (minimapScale > configuredMinimapScale) {\n                        minimapWidthMultiplier = Math.min(2, minimapScale / configuredMinimapScale);\n                    }\n                    minimapCharWidth = minimapScale / pixelRatio / minimapWidthMultiplier;\n                    minimapCanvasInnerHeight = Math.ceil((Math.max(typicalViewportLineCount, extraLinesBeforeFirstLine + viewLineCount + extraLinesBeyondLastLine)) * minimapLineHeight);\n                    if (isViewportWrapping) {\n                        memory.stableMinimapLayoutInput = input;\n                        memory.stableFitRemainingWidth = remainingWidth;\n                        memory.stableFitMaxMinimapScale = minimapScale;\n                    }\n                    else {\n                        memory.stableMinimapLayoutInput = null;\n                        memory.stableFitRemainingWidth = 0;\n                    }\n                }\n            }\n        }\n        const minimapMaxWidth = Math.floor(minimapMaxColumn * minimapCharWidth);\n        const minimapWidth = Math.min(minimapMaxWidth, Math.max(0, Math.floor(((remainingWidth - verticalScrollbarWidth - 2) * minimapCharWidth) / (typicalHalfwidthCharacterWidth + minimapCharWidth))) + MINIMAP_GUTTER_WIDTH);\n        let minimapCanvasInnerWidth = Math.floor(pixelRatio * minimapWidth);\n        const minimapCanvasOuterWidth = minimapCanvasInnerWidth / pixelRatio;\n        minimapCanvasInnerWidth = Math.floor(minimapCanvasInnerWidth * minimapWidthMultiplier);\n        const renderMinimap = ((minimapRenderCharacters ? 1  : 2) );\n        const minimapLeft = (minimapSide === 'left' ? 0 : (outerWidth - minimapWidth - verticalScrollbarWidth));\n        return {\n            renderMinimap,\n            minimapLeft,\n            minimapWidth,\n            minimapHeightIsEditorHeight,\n            minimapIsSampling,\n            minimapScale,\n            minimapLineHeight,\n            minimapCanvasInnerWidth,\n            minimapCanvasInnerHeight,\n            minimapCanvasOuterWidth,\n            minimapCanvasOuterHeight,\n        };\n    }\n    static computeLayout(options, env) {\n        const outerWidth = env.outerWidth | 0;\n        const outerHeight = env.outerHeight | 0;\n        const lineHeight = env.lineHeight | 0;\n        const lineNumbersDigitCount = env.lineNumbersDigitCount | 0;\n        const typicalHalfwidthCharacterWidth = env.typicalHalfwidthCharacterWidth;\n        const maxDigitWidth = env.maxDigitWidth;\n        const pixelRatio = env.pixelRatio;\n        const viewLineCount = env.viewLineCount;\n        const wordWrapOverride2 = options.get(140 );\n        const wordWrapOverride1 = (wordWrapOverride2 === 'inherit' ? options.get(139 ) : wordWrapOverride2);\n        const wordWrap = (wordWrapOverride1 === 'inherit' ? options.get(135 ) : wordWrapOverride1);\n        const wordWrapColumn = options.get(138 );\n        const isDominatedByLongLines = env.isDominatedByLongLines;\n        const showGlyphMargin = options.get(59 );\n        const showLineNumbers = ((options.get(70 ).renderType !== 0) );\n        const lineNumbersMinChars = options.get(71 );\n        const scrollBeyondLastLine = options.get(108 );\n        const padding = options.get(86 );\n        const minimap = options.get(75 );\n        const scrollbar = options.get(106 );\n        const verticalScrollbarWidth = scrollbar.verticalScrollbarSize;\n        const verticalScrollbarHasArrows = scrollbar.verticalHasArrows;\n        const scrollbarArrowSize = scrollbar.arrowSize;\n        const horizontalScrollbarHeight = scrollbar.horizontalScrollbarSize;\n        const folding = options.get(45 );\n        const showFoldingDecoration = options.get(113 ) !== 'never';\n        let lineDecorationsWidth = options.get(68 );\n        if (folding && showFoldingDecoration) {\n            lineDecorationsWidth += 16;\n        }\n        let lineNumbersWidth = 0;\n        if (showLineNumbers) {\n            const digitCount = Math.max(lineNumbersDigitCount, lineNumbersMinChars);\n            lineNumbersWidth = Math.round(digitCount * maxDigitWidth);\n        }\n        let glyphMarginWidth = 0;\n        if (showGlyphMargin) {\n            glyphMarginWidth = lineHeight * env.glyphMarginDecorationLaneCount;\n        }\n        let glyphMarginLeft = 0;\n        let lineNumbersLeft = glyphMarginLeft + glyphMarginWidth;\n        let decorationsLeft = lineNumbersLeft + lineNumbersWidth;\n        let contentLeft = decorationsLeft + lineDecorationsWidth;\n        const remainingWidth = outerWidth - glyphMarginWidth - lineNumbersWidth - lineDecorationsWidth;\n        let isWordWrapMinified = false;\n        let isViewportWrapping = false;\n        let wrappingColumn = -1;\n        if (wordWrapOverride1 === 'inherit' && isDominatedByLongLines) {\n            isWordWrapMinified = true;\n            isViewportWrapping = true;\n        }\n        else if (wordWrap === 'on' || wordWrap === 'bounded') {\n            isViewportWrapping = true;\n        }\n        else if (wordWrap === 'wordWrapColumn') {\n            wrappingColumn = wordWrapColumn;\n        }\n        const minimapLayout = EditorLayoutInfoComputer._computeMinimapLayout({\n            outerWidth: outerWidth,\n            outerHeight: outerHeight,\n            lineHeight: lineHeight,\n            typicalHalfwidthCharacterWidth: typicalHalfwidthCharacterWidth,\n            pixelRatio: pixelRatio,\n            scrollBeyondLastLine: scrollBeyondLastLine,\n            paddingTop: padding.top,\n            paddingBottom: padding.bottom,\n            minimap: minimap,\n            verticalScrollbarWidth: verticalScrollbarWidth,\n            viewLineCount: viewLineCount,\n            remainingWidth: remainingWidth,\n            isViewportWrapping: isViewportWrapping,\n        }, env.memory || ( (new ComputeOptionsMemory())));\n        if (minimapLayout.renderMinimap !== 0  && minimapLayout.minimapLeft === 0) {\n            glyphMarginLeft += minimapLayout.minimapWidth;\n            lineNumbersLeft += minimapLayout.minimapWidth;\n            decorationsLeft += minimapLayout.minimapWidth;\n            contentLeft += minimapLayout.minimapWidth;\n        }\n        const contentWidth = remainingWidth - minimapLayout.minimapWidth;\n        const viewportColumn = Math.max(1, Math.floor((contentWidth - verticalScrollbarWidth - 2) / typicalHalfwidthCharacterWidth));\n        const verticalArrowSize = (verticalScrollbarHasArrows ? scrollbarArrowSize : 0);\n        if (isViewportWrapping) {\n            wrappingColumn = Math.max(1, viewportColumn);\n            if (wordWrap === 'bounded') {\n                wrappingColumn = Math.min(wrappingColumn, wordWrapColumn);\n            }\n        }\n        return {\n            width: outerWidth,\n            height: outerHeight,\n            glyphMarginLeft: glyphMarginLeft,\n            glyphMarginWidth: glyphMarginWidth,\n            glyphMarginDecorationLaneCount: env.glyphMarginDecorationLaneCount,\n            lineNumbersLeft: lineNumbersLeft,\n            lineNumbersWidth: lineNumbersWidth,\n            decorationsLeft: decorationsLeft,\n            decorationsWidth: lineDecorationsWidth,\n            contentLeft: contentLeft,\n            contentWidth: contentWidth,\n            minimap: minimapLayout,\n            viewportColumn: viewportColumn,\n            isWordWrapMinified: isWordWrapMinified,\n            isViewportWrapping: isViewportWrapping,\n            wrappingColumn: wrappingColumn,\n            verticalScrollbarWidth: verticalScrollbarWidth,\n            horizontalScrollbarHeight: horizontalScrollbarHeight,\n            overviewRuler: {\n                top: verticalArrowSize,\n                width: verticalScrollbarWidth,\n                height: (outerHeight - 2 * verticalArrowSize),\n                right: 0\n            }\n        };\n    }\n}\nclass WrappingStrategy extends BaseEditorOption {\n    constructor() {\n        super(142 , 'wrappingStrategy', 'simple', {\n            'editor.wrappingStrategy': {\n                enumDescriptions: [\n                    ( localize(\n                        122,\n                        \"Assumes that all characters are of the same width. This is a fast algorithm that works correctly for monospace fonts and certain scripts (like Latin characters) where glyphs are of equal width.\"\n                    )),\n                    ( localize(\n                        123,\n                        \"Delegates wrapping points computation to the browser. This is a slow algorithm, that might cause freezes for large files, but it works correctly in all cases.\"\n                    ))\n                ],\n                type: 'string',\n                enum: ['simple', 'advanced'],\n                default: 'simple',\n                description: ( localize(\n                    124,\n                    \"Controls the algorithm that computes wrapping points. Note that when in accessibility mode, advanced will be used for the best experience.\"\n                ))\n            }\n        });\n    }\n    validate(input) {\n        return stringSet(input, 'simple', ['simple', 'advanced']);\n    }\n    compute(env, options, value) {\n        const accessibilitySupport = options.get(2 );\n        if (accessibilitySupport === 2 ) {\n            return 'advanced';\n        }\n        return value;\n    }\n}\nvar ShowLightbulbIconMode;\n( ((function(ShowLightbulbIconMode) {\n    ShowLightbulbIconMode[\"Off\"] = \"off\";\n    ShowLightbulbIconMode[\"OnCode\"] = \"onCode\";\n    ShowLightbulbIconMode[\"On\"] = \"on\";\n})(ShowLightbulbIconMode || (ShowLightbulbIconMode = {}))));\nclass EditorLightbulb extends BaseEditorOption {\n    constructor() {\n        const defaults = { enabled: ShowLightbulbIconMode.OnCode };\n        super(67 , 'lightbulb', defaults, {\n            'editor.lightbulb.enabled': {\n                type: 'string',\n                tags: ['experimental'],\n                enum: [ShowLightbulbIconMode.Off, ShowLightbulbIconMode.OnCode, ShowLightbulbIconMode.On],\n                default: defaults.enabled,\n                enumDescriptions: [\n                    ( localize(125, 'Disable the code action menu.')),\n                    ( localize(126, 'Show the code action menu when the cursor is on lines with code.')),\n                    ( localize(\n                        127,\n                        'Show the code action menu when the cursor is on lines with code or on empty lines.'\n                    )),\n                ],\n                description: ( localize(128, \"Enables the Code Action lightbulb in the editor.\"))\n            }\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: stringSet(input.enabled, this.defaultValue.enabled, [ShowLightbulbIconMode.Off, ShowLightbulbIconMode.OnCode, ShowLightbulbIconMode.On])\n        };\n    }\n}\nclass EditorStickyScroll extends BaseEditorOption {\n    constructor() {\n        const defaults = { enabled: true, maxLineCount: 5, defaultModel: 'outlineModel', scrollWithEditor: true };\n        super(118 , 'stickyScroll', defaults, {\n            'editor.stickyScroll.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                description: ( localize(\n                    129,\n                    \"Shows the nested current scopes during the scroll at the top of the editor.\"\n                )),\n                tags: ['experimental']\n            },\n            'editor.stickyScroll.maxLineCount': {\n                type: 'number',\n                default: defaults.maxLineCount,\n                minimum: 1,\n                maximum: 20,\n                description: ( localize(130, \"Defines the maximum number of sticky lines to show.\"))\n            },\n            'editor.stickyScroll.defaultModel': {\n                type: 'string',\n                enum: ['outlineModel', 'foldingProviderModel', 'indentationModel'],\n                default: defaults.defaultModel,\n                description: ( localize(\n                    131,\n                    \"Defines the model to use for determining which lines to stick. If the outline model does not exist, it will fall back on the folding provider model which falls back on the indentation model. This order is respected in all three cases.\"\n                ))\n            },\n            'editor.stickyScroll.scrollWithEditor': {\n                type: 'boolean',\n                default: defaults.scrollWithEditor,\n                description: ( localize(\n                    132,\n                    \"Enable scrolling of Sticky Scroll with the editor's horizontal scrollbar.\"\n                ))\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled),\n            maxLineCount: EditorIntOption.clampedInt(input.maxLineCount, this.defaultValue.maxLineCount, 1, 20),\n            defaultModel: stringSet(input.defaultModel, this.defaultValue.defaultModel, ['outlineModel', 'foldingProviderModel', 'indentationModel']),\n            scrollWithEditor: boolean(input.scrollWithEditor, this.defaultValue.scrollWithEditor)\n        };\n    }\n}\nclass EditorInlayHints extends BaseEditorOption {\n    constructor() {\n        const defaults = { enabled: 'on', fontSize: 0, fontFamily: '', padding: false, maximumLength: 43 };\n        super(144 , 'inlayHints', defaults, {\n            'editor.inlayHints.enabled': {\n                type: 'string',\n                default: defaults.enabled,\n                description: ( localize(133, \"Enables the inlay hints in the editor.\")),\n                enum: ['on', 'onUnlessPressed', 'offUnlessPressed', 'off'],\n                markdownEnumDescriptions: [\n                    ( localize(134, \"Inlay hints are enabled\")),\n                    ( localize(\n                        135,\n                        \"Inlay hints are showing by default and hide when holding {0}\",\n                        isMacintosh ? `Ctrl+Option` : `Ctrl+Alt`\n                    )),\n                    ( localize(\n                        136,\n                        \"Inlay hints are hidden by default and show when holding {0}\",\n                        isMacintosh ? `Ctrl+Option` : `Ctrl+Alt`\n                    )),\n                    ( localize(137, \"Inlay hints are disabled\")),\n                ],\n            },\n            'editor.inlayHints.fontSize': {\n                type: 'number',\n                default: defaults.fontSize,\n                markdownDescription: ( localize(\n                    138,\n                    \"Controls font size of inlay hints in the editor. As default the {0} is used when the configured value is less than {1} or greater than the editor font size.\",\n                    '`#editor.fontSize#`',\n                    '`5`'\n                ))\n            },\n            'editor.inlayHints.fontFamily': {\n                type: 'string',\n                default: defaults.fontFamily,\n                markdownDescription: ( localize(\n                    139,\n                    \"Controls font family of inlay hints in the editor. When set to empty, the {0} is used.\",\n                    '`#editor.fontFamily#`'\n                ))\n            },\n            'editor.inlayHints.padding': {\n                type: 'boolean',\n                default: defaults.padding,\n                description: ( localize(140, \"Enables the padding around the inlay hints in the editor.\"))\n            },\n            'editor.inlayHints.maximumLength': {\n                type: 'number',\n                default: defaults.maximumLength,\n                markdownDescription: ( localize(\n                    141,\n                    \"Maximum overall length of inlay hints, for a single line, before they get truncated by the editor. Set to `0` to never truncate\"\n                ))\n            }\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        if (typeof input.enabled === 'boolean') {\n            input.enabled = input.enabled ? 'on' : 'off';\n        }\n        return {\n            enabled: stringSet(input.enabled, this.defaultValue.enabled, ['on', 'off', 'offUnlessPressed', 'onUnlessPressed']),\n            fontSize: EditorIntOption.clampedInt(input.fontSize, this.defaultValue.fontSize, 0, 100),\n            fontFamily: EditorStringOption.string(input.fontFamily, this.defaultValue.fontFamily),\n            padding: boolean(input.padding, this.defaultValue.padding),\n            maximumLength: EditorIntOption.clampedInt(input.maximumLength, this.defaultValue.maximumLength, 0, Number.MAX_SAFE_INTEGER),\n        };\n    }\n}\nclass EditorLineDecorationsWidth extends BaseEditorOption {\n    constructor() {\n        super(68 , 'lineDecorationsWidth', 10);\n    }\n    validate(input) {\n        if (typeof input === 'string' && /^\\d+(\\.\\d+)?ch$/.test(input)) {\n            const multiple = parseFloat(input.substring(0, input.length - 2));\n            return -multiple;\n        }\n        else {\n            return EditorIntOption.clampedInt(input, this.defaultValue, 0, 1000);\n        }\n    }\n    compute(env, options, value) {\n        if (value < 0) {\n            return EditorIntOption.clampedInt(-value * env.fontInfo.typicalHalfwidthCharacterWidth, this.defaultValue, 0, 1000);\n        }\n        else {\n            return value;\n        }\n    }\n}\nclass EditorLineHeight extends EditorFloatOption {\n    constructor() {\n        super(69 , 'lineHeight', EDITOR_FONT_DEFAULTS.lineHeight, x => EditorFloatOption.clamp(x, 0, 150), { markdownDescription: ( localize(\n            142,\n            \"Controls the line height. \\n - Use 0 to automatically compute the line height from the font size.\\n - Values between 0 and 8 will be used as a multiplier with the font size.\\n - Values greater than or equal to 8 will be used as effective values.\"\n        )) });\n    }\n    compute(env, options, value) {\n        return env.fontInfo.lineHeight;\n    }\n}\nclass EditorMinimap extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            enabled: true,\n            size: 'proportional',\n            side: 'right',\n            showSlider: 'mouseover',\n            autohide: false,\n            renderCharacters: true,\n            maxColumn: 120,\n            scale: 1,\n            showRegionSectionHeaders: true,\n            showMarkSectionHeaders: true,\n            sectionHeaderFontSize: 9,\n            sectionHeaderLetterSpacing: 1,\n        };\n        super(75 , 'minimap', defaults, {\n            'editor.minimap.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                description: ( localize(143, \"Controls whether the minimap is shown.\"))\n            },\n            'editor.minimap.autohide': {\n                type: 'boolean',\n                default: defaults.autohide,\n                description: ( localize(144, \"Controls whether the minimap is hidden automatically.\"))\n            },\n            'editor.minimap.size': {\n                type: 'string',\n                enum: ['proportional', 'fill', 'fit'],\n                enumDescriptions: [\n                    ( localize(\n                        145,\n                        \"The minimap has the same size as the editor contents (and might scroll).\"\n                    )),\n                    ( localize(\n                        146,\n                        \"The minimap will stretch or shrink as necessary to fill the height of the editor (no scrolling).\"\n                    )),\n                    ( localize(\n                        147,\n                        \"The minimap will shrink as necessary to never be larger than the editor (no scrolling).\"\n                    )),\n                ],\n                default: defaults.size,\n                description: ( localize(148, \"Controls the size of the minimap.\"))\n            },\n            'editor.minimap.side': {\n                type: 'string',\n                enum: ['left', 'right'],\n                default: defaults.side,\n                description: ( localize(149, \"Controls the side where to render the minimap.\"))\n            },\n            'editor.minimap.showSlider': {\n                type: 'string',\n                enum: ['always', 'mouseover'],\n                default: defaults.showSlider,\n                description: ( localize(150, \"Controls when the minimap slider is shown.\"))\n            },\n            'editor.minimap.scale': {\n                type: 'number',\n                default: defaults.scale,\n                minimum: 1,\n                maximum: 3,\n                enum: [1, 2, 3],\n                description: ( localize(151, \"Scale of content drawn in the minimap: 1, 2 or 3.\"))\n            },\n            'editor.minimap.renderCharacters': {\n                type: 'boolean',\n                default: defaults.renderCharacters,\n                description: ( localize(152, \"Render the actual characters on a line as opposed to color blocks.\"))\n            },\n            'editor.minimap.maxColumn': {\n                type: 'number',\n                default: defaults.maxColumn,\n                description: ( localize(\n                    153,\n                    \"Limit the width of the minimap to render at most a certain number of columns.\"\n                ))\n            },\n            'editor.minimap.showRegionSectionHeaders': {\n                type: 'boolean',\n                default: defaults.showRegionSectionHeaders,\n                description: ( localize(\n                    154,\n                    \"Controls whether named regions are shown as section headers in the minimap.\"\n                ))\n            },\n            'editor.minimap.showMarkSectionHeaders': {\n                type: 'boolean',\n                default: defaults.showMarkSectionHeaders,\n                description: ( localize(\n                    155,\n                    \"Controls whether MARK: comments are shown as section headers in the minimap.\"\n                ))\n            },\n            'editor.minimap.sectionHeaderFontSize': {\n                type: 'number',\n                default: defaults.sectionHeaderFontSize,\n                description: ( localize(156, \"Controls the font size of section headers in the minimap.\"))\n            },\n            'editor.minimap.sectionHeaderLetterSpacing': {\n                type: 'number',\n                default: defaults.sectionHeaderLetterSpacing,\n                description: ( localize(\n                    157,\n                    \"Controls the amount of space (in pixels) between characters of section header. This helps the readability of the header in small font sizes.\"\n                ))\n            }\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled),\n            autohide: boolean(input.autohide, this.defaultValue.autohide),\n            size: stringSet(input.size, this.defaultValue.size, ['proportional', 'fill', 'fit']),\n            side: stringSet(input.side, this.defaultValue.side, ['right', 'left']),\n            showSlider: stringSet(input.showSlider, this.defaultValue.showSlider, ['always', 'mouseover']),\n            renderCharacters: boolean(input.renderCharacters, this.defaultValue.renderCharacters),\n            scale: EditorIntOption.clampedInt(input.scale, 1, 1, 3),\n            maxColumn: EditorIntOption.clampedInt(input.maxColumn, this.defaultValue.maxColumn, 1, 10000),\n            showRegionSectionHeaders: boolean(input.showRegionSectionHeaders, this.defaultValue.showRegionSectionHeaders),\n            showMarkSectionHeaders: boolean(input.showMarkSectionHeaders, this.defaultValue.showMarkSectionHeaders),\n            sectionHeaderFontSize: EditorFloatOption.clamp(input.sectionHeaderFontSize ?? this.defaultValue.sectionHeaderFontSize, 4, 32),\n            sectionHeaderLetterSpacing: EditorFloatOption.clamp(input.sectionHeaderLetterSpacing ?? this.defaultValue.sectionHeaderLetterSpacing, 0, 5),\n        };\n    }\n}\nfunction _multiCursorModifierFromString(multiCursorModifier) {\n    if (multiCursorModifier === 'ctrlCmd') {\n        return (isMacintosh ? 'metaKey' : 'ctrlKey');\n    }\n    return 'altKey';\n}\nclass EditorPadding extends BaseEditorOption {\n    constructor() {\n        super(86 , 'padding', { top: 0, bottom: 0 }, {\n            'editor.padding.top': {\n                type: 'number',\n                default: 0,\n                minimum: 0,\n                maximum: 1000,\n                description: ( localize(\n                    158,\n                    \"Controls the amount of space between the top edge of the editor and the first line.\"\n                ))\n            },\n            'editor.padding.bottom': {\n                type: 'number',\n                default: 0,\n                minimum: 0,\n                maximum: 1000,\n                description: ( localize(\n                    159,\n                    \"Controls the amount of space between the bottom edge of the editor and the last line.\"\n                ))\n            }\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            top: EditorIntOption.clampedInt(input.top, 0, 0, 1000),\n            bottom: EditorIntOption.clampedInt(input.bottom, 0, 0, 1000)\n        };\n    }\n}\nclass EditorParameterHints extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            enabled: true,\n            cycle: true\n        };\n        super(88 , 'parameterHints', defaults, {\n            'editor.parameterHints.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                description: ( localize(\n                    160,\n                    \"Enables a pop-up that shows parameter documentation and type information as you type.\"\n                ))\n            },\n            'editor.parameterHints.cycle': {\n                type: 'boolean',\n                default: defaults.cycle,\n                description: ( localize(\n                    161,\n                    \"Controls whether the parameter hints menu cycles or closes when reaching the end of the list.\"\n                ))\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled),\n            cycle: boolean(input.cycle, this.defaultValue.cycle)\n        };\n    }\n}\nclass EditorPixelRatio extends ComputedEditorOption {\n    constructor() {\n        super(146 );\n    }\n    compute(env, options, _) {\n        return env.pixelRatio;\n    }\n}\nclass PlaceholderOption extends BaseEditorOption {\n    constructor() {\n        super(90 , 'placeholder', undefined);\n    }\n    validate(input) {\n        if (typeof input === 'undefined') {\n            return this.defaultValue;\n        }\n        if (typeof input === 'string') {\n            return input;\n        }\n        return this.defaultValue;\n    }\n}\nclass EditorQuickSuggestions extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            other: 'on',\n            comments: 'off',\n            strings: 'off'\n        };\n        const types = [\n            { type: 'boolean' },\n            {\n                type: 'string',\n                enum: ['on', 'inline', 'off'],\n                enumDescriptions: [( localize(162, \"Quick suggestions show inside the suggest widget\")), ( localize(163, \"Quick suggestions show as ghost text\")), ( localize(164, \"Quick suggestions are disabled\"))]\n            }\n        ];\n        super(92 , 'quickSuggestions', defaults, {\n            type: 'object',\n            additionalProperties: false,\n            properties: {\n                strings: {\n                    anyOf: types,\n                    default: defaults.strings,\n                    description: ( localize(165, \"Enable quick suggestions inside strings.\"))\n                },\n                comments: {\n                    anyOf: types,\n                    default: defaults.comments,\n                    description: ( localize(166, \"Enable quick suggestions inside comments.\"))\n                },\n                other: {\n                    anyOf: types,\n                    default: defaults.other,\n                    description: ( localize(167, \"Enable quick suggestions outside of strings and comments.\"))\n                },\n            },\n            default: defaults,\n            markdownDescription: ( localize(\n                168,\n                \"Controls whether suggestions should automatically show up while typing. This can be controlled for typing in comments, strings, and other code. Quick suggestion can be configured to show as ghost text or with the suggest widget. Also be aware of the {0}-setting which controls if suggestions are triggered by special characters.\",\n                '`#editor.suggestOnTriggerCharacters#`'\n            ))\n        });\n        this.defaultValue = defaults;\n    }\n    validate(input) {\n        if (typeof input === 'boolean') {\n            const value = input ? 'on' : 'off';\n            return { comments: value, strings: value, other: value };\n        }\n        if (!input || typeof input !== 'object') {\n            return this.defaultValue;\n        }\n        const { other, comments, strings } = input;\n        const allowedValues = ['on', 'inline', 'off'];\n        let validatedOther;\n        let validatedComments;\n        let validatedStrings;\n        if (typeof other === 'boolean') {\n            validatedOther = other ? 'on' : 'off';\n        }\n        else {\n            validatedOther = stringSet(other, this.defaultValue.other, allowedValues);\n        }\n        if (typeof comments === 'boolean') {\n            validatedComments = comments ? 'on' : 'off';\n        }\n        else {\n            validatedComments = stringSet(comments, this.defaultValue.comments, allowedValues);\n        }\n        if (typeof strings === 'boolean') {\n            validatedStrings = strings ? 'on' : 'off';\n        }\n        else {\n            validatedStrings = stringSet(strings, this.defaultValue.strings, allowedValues);\n        }\n        return {\n            other: validatedOther,\n            comments: validatedComments,\n            strings: validatedStrings\n        };\n    }\n}\nclass EditorRenderLineNumbersOption extends BaseEditorOption {\n    constructor() {\n        super(70 , 'lineNumbers', { renderType: 1 , renderFn: null }, {\n            type: 'string',\n            enum: ['off', 'on', 'relative', 'interval'],\n            enumDescriptions: [\n                ( localize(169, \"Line numbers are not rendered.\")),\n                ( localize(170, \"Line numbers are rendered as absolute number.\")),\n                ( localize(171, \"Line numbers are rendered as distance in lines to cursor position.\")),\n                ( localize(172, \"Line numbers are rendered every 10 lines.\"))\n            ],\n            default: 'on',\n            description: ( localize(173, \"Controls the display of line numbers.\"))\n        });\n    }\n    validate(lineNumbers) {\n        let renderType = this.defaultValue.renderType;\n        let renderFn = this.defaultValue.renderFn;\n        if (typeof lineNumbers !== 'undefined') {\n            if (typeof lineNumbers === 'function') {\n                renderType = 4 ;\n                renderFn = lineNumbers;\n            }\n            else if (lineNumbers === 'interval') {\n                renderType = 3 ;\n            }\n            else if (lineNumbers === 'relative') {\n                renderType = 2 ;\n            }\n            else if (lineNumbers === 'on') {\n                renderType = 1 ;\n            }\n            else {\n                renderType = 0 ;\n            }\n        }\n        return {\n            renderType,\n            renderFn\n        };\n    }\n}\nfunction filterValidationDecorations(options) {\n    const renderValidationDecorations = options.get(101 );\n    if (renderValidationDecorations === 'editable') {\n        return options.get(94 );\n    }\n    return renderValidationDecorations === 'on' ? false : true;\n}\nclass EditorRulers extends BaseEditorOption {\n    constructor() {\n        const defaults = [];\n        const columnSchema = { type: 'number', description: ( localize(\n            174,\n            \"Number of monospace characters at which this editor ruler will render.\"\n        )) };\n        super(105 , 'rulers', defaults, {\n            type: 'array',\n            items: {\n                anyOf: [\n                    columnSchema,\n                    {\n                        type: [\n                            'object'\n                        ],\n                        properties: {\n                            column: columnSchema,\n                            color: {\n                                type: 'string',\n                                description: ( localize(175, \"Color of this editor ruler.\")),\n                                format: 'color-hex'\n                            }\n                        }\n                    }\n                ]\n            },\n            default: defaults,\n            description: ( localize(\n                176,\n                \"Render vertical rulers after a certain number of monospace characters. Use multiple values for multiple rulers. No rulers are drawn if array is empty.\"\n            ))\n        });\n    }\n    validate(input) {\n        if (Array.isArray(input)) {\n            const rulers = [];\n            for (const _element of input) {\n                if (typeof _element === 'number') {\n                    rulers.push({\n                        column: EditorIntOption.clampedInt(_element, 0, 0, 10000),\n                        color: null\n                    });\n                }\n                else if (_element && typeof _element === 'object') {\n                    const element = _element;\n                    rulers.push({\n                        column: EditorIntOption.clampedInt(element.column, 0, 0, 10000),\n                        color: element.color\n                    });\n                }\n            }\n            rulers.sort((a, b) => a.column - b.column);\n            return rulers;\n        }\n        return this.defaultValue;\n    }\n}\nclass ReadonlyMessage extends BaseEditorOption {\n    constructor() {\n        const defaults = undefined;\n        super(95 , 'readOnlyMessage', defaults);\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        return _input;\n    }\n}\nfunction _scrollbarVisibilityFromString(visibility, defaultValue) {\n    if (typeof visibility !== 'string') {\n        return defaultValue;\n    }\n    switch (visibility) {\n        case 'hidden': return 2 ;\n        case 'visible': return 3 ;\n        default: return 1 ;\n    }\n}\nclass EditorScrollbar extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            vertical: 1 ,\n            horizontal: 1 ,\n            arrowSize: 11,\n            useShadows: true,\n            verticalHasArrows: false,\n            horizontalHasArrows: false,\n            horizontalScrollbarSize: 12,\n            horizontalSliderSize: 12,\n            verticalScrollbarSize: 14,\n            verticalSliderSize: 14,\n            handleMouseWheel: true,\n            alwaysConsumeMouseWheel: true,\n            scrollByPage: false,\n            ignoreHorizontalScrollbarInContentHeight: false,\n        };\n        super(106 , 'scrollbar', defaults, {\n            'editor.scrollbar.vertical': {\n                type: 'string',\n                enum: ['auto', 'visible', 'hidden'],\n                enumDescriptions: [\n                    ( localize(177, \"The vertical scrollbar will be visible only when necessary.\")),\n                    ( localize(178, \"The vertical scrollbar will always be visible.\")),\n                    ( localize(179, \"The vertical scrollbar will always be hidden.\")),\n                ],\n                default: 'auto',\n                description: ( localize(180, \"Controls the visibility of the vertical scrollbar.\"))\n            },\n            'editor.scrollbar.horizontal': {\n                type: 'string',\n                enum: ['auto', 'visible', 'hidden'],\n                enumDescriptions: [\n                    ( localize(181, \"The horizontal scrollbar will be visible only when necessary.\")),\n                    ( localize(182, \"The horizontal scrollbar will always be visible.\")),\n                    ( localize(183, \"The horizontal scrollbar will always be hidden.\")),\n                ],\n                default: 'auto',\n                description: ( localize(184, \"Controls the visibility of the horizontal scrollbar.\"))\n            },\n            'editor.scrollbar.verticalScrollbarSize': {\n                type: 'number',\n                default: defaults.verticalScrollbarSize,\n                description: ( localize(185, \"The width of the vertical scrollbar.\"))\n            },\n            'editor.scrollbar.horizontalScrollbarSize': {\n                type: 'number',\n                default: defaults.horizontalScrollbarSize,\n                description: ( localize(186, \"The height of the horizontal scrollbar.\"))\n            },\n            'editor.scrollbar.scrollByPage': {\n                type: 'boolean',\n                default: defaults.scrollByPage,\n                description: ( localize(187, \"Controls whether clicks scroll by page or jump to click position.\"))\n            },\n            'editor.scrollbar.ignoreHorizontalScrollbarInContentHeight': {\n                type: 'boolean',\n                default: defaults.ignoreHorizontalScrollbarInContentHeight,\n                description: ( localize(\n                    188,\n                    \"When set, the horizontal scrollbar will not increase the size of the editor's content.\"\n                ))\n            }\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        const horizontalScrollbarSize = EditorIntOption.clampedInt(input.horizontalScrollbarSize, this.defaultValue.horizontalScrollbarSize, 0, 1000);\n        const verticalScrollbarSize = EditorIntOption.clampedInt(input.verticalScrollbarSize, this.defaultValue.verticalScrollbarSize, 0, 1000);\n        return {\n            arrowSize: EditorIntOption.clampedInt(input.arrowSize, this.defaultValue.arrowSize, 0, 1000),\n            vertical: _scrollbarVisibilityFromString(input.vertical, this.defaultValue.vertical),\n            horizontal: _scrollbarVisibilityFromString(input.horizontal, this.defaultValue.horizontal),\n            useShadows: boolean(input.useShadows, this.defaultValue.useShadows),\n            verticalHasArrows: boolean(input.verticalHasArrows, this.defaultValue.verticalHasArrows),\n            horizontalHasArrows: boolean(input.horizontalHasArrows, this.defaultValue.horizontalHasArrows),\n            handleMouseWheel: boolean(input.handleMouseWheel, this.defaultValue.handleMouseWheel),\n            alwaysConsumeMouseWheel: boolean(input.alwaysConsumeMouseWheel, this.defaultValue.alwaysConsumeMouseWheel),\n            horizontalScrollbarSize: horizontalScrollbarSize,\n            horizontalSliderSize: EditorIntOption.clampedInt(input.horizontalSliderSize, horizontalScrollbarSize, 0, 1000),\n            verticalScrollbarSize: verticalScrollbarSize,\n            verticalSliderSize: EditorIntOption.clampedInt(input.verticalSliderSize, verticalScrollbarSize, 0, 1000),\n            scrollByPage: boolean(input.scrollByPage, this.defaultValue.scrollByPage),\n            ignoreHorizontalScrollbarInContentHeight: boolean(input.ignoreHorizontalScrollbarInContentHeight, this.defaultValue.ignoreHorizontalScrollbarInContentHeight),\n        };\n    }\n}\nconst inUntrustedWorkspace = 'inUntrustedWorkspace';\nconst unicodeHighlightConfigKeys = {\n    allowedCharacters: 'editor.unicodeHighlight.allowedCharacters',\n    invisibleCharacters: 'editor.unicodeHighlight.invisibleCharacters',\n    nonBasicASCII: 'editor.unicodeHighlight.nonBasicASCII',\n    ambiguousCharacters: 'editor.unicodeHighlight.ambiguousCharacters',\n    includeComments: 'editor.unicodeHighlight.includeComments',\n    includeStrings: 'editor.unicodeHighlight.includeStrings',\n    allowedLocales: 'editor.unicodeHighlight.allowedLocales',\n};\nclass UnicodeHighlight extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            nonBasicASCII: inUntrustedWorkspace,\n            invisibleCharacters: true,\n            ambiguousCharacters: true,\n            includeComments: inUntrustedWorkspace,\n            includeStrings: true,\n            allowedCharacters: {},\n            allowedLocales: { _os: true, _vscode: true },\n        };\n        super(128 , 'unicodeHighlight', defaults, {\n            [unicodeHighlightConfigKeys.nonBasicASCII]: {\n                restricted: true,\n                type: ['boolean', 'string'],\n                enum: [true, false, inUntrustedWorkspace],\n                default: defaults.nonBasicASCII,\n                description: ( localize(\n                    189,\n                    \"Controls whether all non-basic ASCII characters are highlighted. Only characters between U+0020 and U+007E, tab, line-feed and carriage-return are considered basic ASCII.\"\n                ))\n            },\n            [unicodeHighlightConfigKeys.invisibleCharacters]: {\n                restricted: true,\n                type: 'boolean',\n                default: defaults.invisibleCharacters,\n                description: ( localize(\n                    190,\n                    \"Controls whether characters that just reserve space or have no width at all are highlighted.\"\n                ))\n            },\n            [unicodeHighlightConfigKeys.ambiguousCharacters]: {\n                restricted: true,\n                type: 'boolean',\n                default: defaults.ambiguousCharacters,\n                description: ( localize(\n                    191,\n                    \"Controls whether characters are highlighted that can be confused with basic ASCII characters, except those that are common in the current user locale.\"\n                ))\n            },\n            [unicodeHighlightConfigKeys.includeComments]: {\n                restricted: true,\n                type: ['boolean', 'string'],\n                enum: [true, false, inUntrustedWorkspace],\n                default: defaults.includeComments,\n                description: ( localize(\n                    192,\n                    \"Controls whether characters in comments should also be subject to Unicode highlighting.\"\n                ))\n            },\n            [unicodeHighlightConfigKeys.includeStrings]: {\n                restricted: true,\n                type: ['boolean', 'string'],\n                enum: [true, false, inUntrustedWorkspace],\n                default: defaults.includeStrings,\n                description: ( localize(\n                    193,\n                    \"Controls whether characters in strings should also be subject to Unicode highlighting.\"\n                ))\n            },\n            [unicodeHighlightConfigKeys.allowedCharacters]: {\n                restricted: true,\n                type: 'object',\n                default: defaults.allowedCharacters,\n                description: ( localize(194, \"Defines allowed characters that are not being highlighted.\")),\n                additionalProperties: {\n                    type: 'boolean'\n                }\n            },\n            [unicodeHighlightConfigKeys.allowedLocales]: {\n                restricted: true,\n                type: 'object',\n                additionalProperties: {\n                    type: 'boolean'\n                },\n                default: defaults.allowedLocales,\n                description: ( localize(\n                    195,\n                    \"Unicode characters that are common in allowed locales are not being highlighted.\"\n                ))\n            },\n        });\n    }\n    applyUpdate(value, update) {\n        let didChange = false;\n        if (update.allowedCharacters && value) {\n            if (!equals$1(value.allowedCharacters, update.allowedCharacters)) {\n                value = { ...value, allowedCharacters: update.allowedCharacters };\n                didChange = true;\n            }\n        }\n        if (update.allowedLocales && value) {\n            if (!equals$1(value.allowedLocales, update.allowedLocales)) {\n                value = { ...value, allowedLocales: update.allowedLocales };\n                didChange = true;\n            }\n        }\n        const result = super.applyUpdate(value, update);\n        if (didChange) {\n            return (\n                 (new ApplyUpdateResult(result.newValue, true))\n            );\n        }\n        return result;\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            nonBasicASCII: primitiveSet(input.nonBasicASCII, inUntrustedWorkspace, [true, false, inUntrustedWorkspace]),\n            invisibleCharacters: boolean(input.invisibleCharacters, this.defaultValue.invisibleCharacters),\n            ambiguousCharacters: boolean(input.ambiguousCharacters, this.defaultValue.ambiguousCharacters),\n            includeComments: primitiveSet(input.includeComments, inUntrustedWorkspace, [true, false, inUntrustedWorkspace]),\n            includeStrings: primitiveSet(input.includeStrings, inUntrustedWorkspace, [true, false, inUntrustedWorkspace]),\n            allowedCharacters: this.validateBooleanMap(_input.allowedCharacters, this.defaultValue.allowedCharacters),\n            allowedLocales: this.validateBooleanMap(_input.allowedLocales, this.defaultValue.allowedLocales),\n        };\n    }\n    validateBooleanMap(map, defaultValue) {\n        if ((typeof map !== 'object') || !map) {\n            return defaultValue;\n        }\n        const result = {};\n        for (const [key, value] of Object.entries(map)) {\n            if (value === true) {\n                result[key] = true;\n            }\n        }\n        return result;\n    }\n}\nclass InlineEditorSuggest extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            enabled: true,\n            mode: 'subwordSmart',\n            showToolbar: 'onHover',\n            suppressSuggestions: false,\n            keepOnBlur: false,\n            fontFamily: 'default',\n            syntaxHighlightingEnabled: false,\n        };\n        super(64 , 'inlineSuggest', defaults, {\n            'editor.inlineSuggest.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                description: ( localize(\n                    196,\n                    \"Controls whether to automatically show inline suggestions in the editor.\"\n                ))\n            },\n            'editor.inlineSuggest.showToolbar': {\n                type: 'string',\n                default: defaults.showToolbar,\n                enum: ['always', 'onHover', 'never'],\n                enumDescriptions: [\n                    ( localize(\n                        197,\n                        \"Show the inline suggestion toolbar whenever an inline suggestion is shown.\"\n                    )),\n                    ( localize(\n                        198,\n                        \"Show the inline suggestion toolbar when hovering over an inline suggestion.\"\n                    )),\n                    ( localize(199, \"Never show the inline suggestion toolbar.\")),\n                ],\n                description: ( localize(200, \"Controls when to show the inline suggestion toolbar.\")),\n            },\n            'editor.inlineSuggest.syntaxHighlightingEnabled': {\n                type: 'boolean',\n                default: defaults.syntaxHighlightingEnabled,\n                description: ( localize(\n                    201,\n                    \"Controls whether to show syntax highlighting for inline suggestions in the editor.\"\n                )),\n            },\n            'editor.inlineSuggest.suppressSuggestions': {\n                type: 'boolean',\n                default: defaults.suppressSuggestions,\n                description: ( localize(\n                    202,\n                    \"Controls how inline suggestions interact with the suggest widget. If enabled, the suggest widget is not shown automatically when inline suggestions are available.\"\n                ))\n            },\n            'editor.inlineSuggest.fontFamily': {\n                type: 'string',\n                default: defaults.fontFamily,\n                description: ( localize(203, \"Controls the font family of the inline suggestions.\"))\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled),\n            mode: stringSet(input.mode, this.defaultValue.mode, ['prefix', 'subword', 'subwordSmart']),\n            showToolbar: stringSet(input.showToolbar, this.defaultValue.showToolbar, ['always', 'onHover', 'never']),\n            suppressSuggestions: boolean(input.suppressSuggestions, this.defaultValue.suppressSuggestions),\n            keepOnBlur: boolean(input.keepOnBlur, this.defaultValue.keepOnBlur),\n            fontFamily: EditorStringOption.string(input.fontFamily, this.defaultValue.fontFamily),\n            syntaxHighlightingEnabled: boolean(input.syntaxHighlightingEnabled, this.defaultValue.syntaxHighlightingEnabled),\n        };\n    }\n}\nclass InlineEditorEdit extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            enabled: false,\n            showToolbar: 'onHover',\n            fontFamily: 'default',\n            keepOnBlur: false,\n        };\n        super(65 , 'experimentalInlineEdit', defaults, {\n            'editor.experimentalInlineEdit.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                description: ( localize(204, \"Controls whether to show inline edits in the editor.\"))\n            },\n            'editor.experimentalInlineEdit.showToolbar': {\n                type: 'string',\n                default: defaults.showToolbar,\n                enum: ['always', 'onHover', 'never'],\n                enumDescriptions: [\n                    ( localize(\n                        205,\n                        \"Show the inline edit toolbar whenever an inline suggestion is shown.\"\n                    )),\n                    ( localize(\n                        206,\n                        \"Show the inline edit toolbar when hovering over an inline suggestion.\"\n                    )),\n                    ( localize(207, \"Never show the inline edit toolbar.\")),\n                ],\n                description: ( localize(208, \"Controls when to show the inline edit toolbar.\")),\n            },\n            'editor.experimentalInlineEdit.fontFamily': {\n                type: 'string',\n                default: defaults.fontFamily,\n                description: ( localize(209, \"Controls the font family of the inline edit.\"))\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled),\n            showToolbar: stringSet(input.showToolbar, this.defaultValue.showToolbar, ['always', 'onHover', 'never']),\n            fontFamily: EditorStringOption.string(input.fontFamily, this.defaultValue.fontFamily),\n            keepOnBlur: boolean(input.keepOnBlur, this.defaultValue.keepOnBlur),\n        };\n    }\n}\nclass BracketPairColorization extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            enabled: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions.enabled,\n            independentColorPoolPerBracketType: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions.independentColorPoolPerBracketType,\n        };\n        super(15 , 'bracketPairColorization', defaults, {\n            'editor.bracketPairColorization.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                markdownDescription: ( localize(\n                    210,\n                    \"Controls whether bracket pair colorization is enabled or not. Use {0} to override the bracket highlight colors.\",\n                    '`#workbench.colorCustomizations#`'\n                ))\n            },\n            'editor.bracketPairColorization.independentColorPoolPerBracketType': {\n                type: 'boolean',\n                default: defaults.independentColorPoolPerBracketType,\n                description: ( localize(\n                    211,\n                    \"Controls whether each bracket type has its own independent color pool.\"\n                ))\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled),\n            independentColorPoolPerBracketType: boolean(input.independentColorPoolPerBracketType, this.defaultValue.independentColorPoolPerBracketType),\n        };\n    }\n}\nclass GuideOptions extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            bracketPairs: false,\n            bracketPairsHorizontal: 'active',\n            highlightActiveBracketPair: true,\n            indentation: true,\n            highlightActiveIndentation: true\n        };\n        super(16 , 'guides', defaults, {\n            'editor.guides.bracketPairs': {\n                type: ['boolean', 'string'],\n                enum: [true, 'active', false],\n                enumDescriptions: [\n                    ( localize(212, \"Enables bracket pair guides.\")),\n                    ( localize(213, \"Enables bracket pair guides only for the active bracket pair.\")),\n                    ( localize(214, \"Disables bracket pair guides.\")),\n                ],\n                default: defaults.bracketPairs,\n                description: ( localize(215, \"Controls whether bracket pair guides are enabled or not.\"))\n            },\n            'editor.guides.bracketPairsHorizontal': {\n                type: ['boolean', 'string'],\n                enum: [true, 'active', false],\n                enumDescriptions: [\n                    ( localize(\n                        216,\n                        \"Enables horizontal guides as addition to vertical bracket pair guides.\"\n                    )),\n                    ( localize(217, \"Enables horizontal guides only for the active bracket pair.\")),\n                    ( localize(218, \"Disables horizontal bracket pair guides.\")),\n                ],\n                default: defaults.bracketPairsHorizontal,\n                description: ( localize(219, \"Controls whether horizontal bracket pair guides are enabled or not.\"))\n            },\n            'editor.guides.highlightActiveBracketPair': {\n                type: 'boolean',\n                default: defaults.highlightActiveBracketPair,\n                description: ( localize(\n                    220,\n                    \"Controls whether the editor should highlight the active bracket pair.\"\n                ))\n            },\n            'editor.guides.indentation': {\n                type: 'boolean',\n                default: defaults.indentation,\n                description: ( localize(221, \"Controls whether the editor should render indent guides.\"))\n            },\n            'editor.guides.highlightActiveIndentation': {\n                type: ['boolean', 'string'],\n                enum: [true, 'always', false],\n                enumDescriptions: [\n                    ( localize(222, \"Highlights the active indent guide.\")),\n                    ( localize(\n                        223,\n                        \"Highlights the active indent guide even if bracket guides are highlighted.\"\n                    )),\n                    ( localize(224, \"Do not highlight the active indent guide.\")),\n                ],\n                default: defaults.highlightActiveIndentation,\n                description: ( localize(\n                    225,\n                    \"Controls whether the editor should highlight the active indent guide.\"\n                ))\n            }\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            bracketPairs: primitiveSet(input.bracketPairs, this.defaultValue.bracketPairs, [true, false, 'active']),\n            bracketPairsHorizontal: primitiveSet(input.bracketPairsHorizontal, this.defaultValue.bracketPairsHorizontal, [true, false, 'active']),\n            highlightActiveBracketPair: boolean(input.highlightActiveBracketPair, this.defaultValue.highlightActiveBracketPair),\n            indentation: boolean(input.indentation, this.defaultValue.indentation),\n            highlightActiveIndentation: primitiveSet(input.highlightActiveIndentation, this.defaultValue.highlightActiveIndentation, [true, false, 'always']),\n        };\n    }\n}\nfunction primitiveSet(value, defaultValue, allowedValues) {\n    const idx = allowedValues.indexOf(value);\n    if (idx === -1) {\n        return defaultValue;\n    }\n    return allowedValues[idx];\n}\nclass EditorSuggest extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            insertMode: 'insert',\n            filterGraceful: true,\n            snippetsPreventQuickSuggestions: false,\n            localityBonus: false,\n            shareSuggestSelections: false,\n            selectionMode: 'always',\n            showIcons: true,\n            showStatusBar: false,\n            preview: false,\n            previewMode: 'subwordSmart',\n            showInlineDetails: true,\n            showMethods: true,\n            showFunctions: true,\n            showConstructors: true,\n            showDeprecated: true,\n            matchOnWordStartOnly: true,\n            showFields: true,\n            showVariables: true,\n            showClasses: true,\n            showStructs: true,\n            showInterfaces: true,\n            showModules: true,\n            showProperties: true,\n            showEvents: true,\n            showOperators: true,\n            showUnits: true,\n            showValues: true,\n            showConstants: true,\n            showEnums: true,\n            showEnumMembers: true,\n            showKeywords: true,\n            showWords: true,\n            showColors: true,\n            showFiles: true,\n            showReferences: true,\n            showFolders: true,\n            showTypeParameters: true,\n            showSnippets: true,\n            showUsers: true,\n            showIssues: true,\n        };\n        super(121 , 'suggest', defaults, {\n            'editor.suggest.insertMode': {\n                type: 'string',\n                enum: ['insert', 'replace'],\n                enumDescriptions: [\n                    ( localize(226, \"Insert suggestion without overwriting text right of the cursor.\")),\n                    ( localize(227, \"Insert suggestion and overwrite text right of the cursor.\")),\n                ],\n                default: defaults.insertMode,\n                description: ( localize(\n                    228,\n                    \"Controls whether words are overwritten when accepting completions. Note that this depends on extensions opting into this feature.\"\n                ))\n            },\n            'editor.suggest.filterGraceful': {\n                type: 'boolean',\n                default: defaults.filterGraceful,\n                description: ( localize(\n                    229,\n                    \"Controls whether filtering and sorting suggestions accounts for small typos.\"\n                ))\n            },\n            'editor.suggest.localityBonus': {\n                type: 'boolean',\n                default: defaults.localityBonus,\n                description: ( localize(\n                    230,\n                    \"Controls whether sorting favors words that appear close to the cursor.\"\n                ))\n            },\n            'editor.suggest.shareSuggestSelections': {\n                type: 'boolean',\n                default: defaults.shareSuggestSelections,\n                markdownDescription: ( localize(\n                    231,\n                    \"Controls whether remembered suggestion selections are shared between multiple workspaces and windows (needs `#editor.suggestSelection#`).\"\n                ))\n            },\n            'editor.suggest.selectionMode': {\n                type: 'string',\n                enum: ['always', 'never', 'whenTriggerCharacter', 'whenQuickSuggestion'],\n                enumDescriptions: [\n                    ( localize(\n                        232,\n                        \"Always select a suggestion when automatically triggering IntelliSense.\"\n                    )),\n                    ( localize(\n                        233,\n                        \"Never select a suggestion when automatically triggering IntelliSense.\"\n                    )),\n                    ( localize(\n                        234,\n                        \"Select a suggestion only when triggering IntelliSense from a trigger character.\"\n                    )),\n                    ( localize(235, \"Select a suggestion only when triggering IntelliSense as you type.\")),\n                ],\n                default: defaults.selectionMode,\n                markdownDescription: ( localize(\n                    236,\n                    \"Controls whether a suggestion is selected when the widget shows. Note that this only applies to automatically triggered suggestions ({0} and {1}) and that a suggestion is always selected when explicitly invoked, e.g via `Ctrl+Space`.\",\n                    '`#editor.quickSuggestions#`',\n                    '`#editor.suggestOnTriggerCharacters#`'\n                ))\n            },\n            'editor.suggest.snippetsPreventQuickSuggestions': {\n                type: 'boolean',\n                default: defaults.snippetsPreventQuickSuggestions,\n                description: ( localize(237, \"Controls whether an active snippet prevents quick suggestions.\"))\n            },\n            'editor.suggest.showIcons': {\n                type: 'boolean',\n                default: defaults.showIcons,\n                description: ( localize(238, \"Controls whether to show or hide icons in suggestions.\"))\n            },\n            'editor.suggest.showStatusBar': {\n                type: 'boolean',\n                default: defaults.showStatusBar,\n                description: ( localize(\n                    239,\n                    \"Controls the visibility of the status bar at the bottom of the suggest widget.\"\n                ))\n            },\n            'editor.suggest.preview': {\n                type: 'boolean',\n                default: defaults.preview,\n                description: ( localize(240, \"Controls whether to preview the suggestion outcome in the editor.\"))\n            },\n            'editor.suggest.showInlineDetails': {\n                type: 'boolean',\n                default: defaults.showInlineDetails,\n                description: ( localize(\n                    241,\n                    \"Controls whether suggest details show inline with the label or only in the details widget.\"\n                ))\n            },\n            'editor.suggest.maxVisibleSuggestions': {\n                type: 'number',\n                deprecationMessage: ( localize(242, \"This setting is deprecated. The suggest widget can now be resized.\")),\n            },\n            'editor.suggest.filteredTypes': {\n                type: 'object',\n                deprecationMessage: ( localize(\n                    243,\n                    \"This setting is deprecated, please use separate settings like 'editor.suggest.showKeywords' or 'editor.suggest.showSnippets' instead.\"\n                ))\n            },\n            'editor.suggest.showMethods': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: ( localize(244, \"When enabled IntelliSense shows `method`-suggestions.\"))\n            },\n            'editor.suggest.showFunctions': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: ( localize(245, \"When enabled IntelliSense shows `function`-suggestions.\"))\n            },\n            'editor.suggest.showConstructors': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: ( localize(246, \"When enabled IntelliSense shows `constructor`-suggestions.\"))\n            },\n            'editor.suggest.showDeprecated': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: ( localize(247, \"When enabled IntelliSense shows `deprecated`-suggestions.\"))\n            },\n            'editor.suggest.matchOnWordStartOnly': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: ( localize(\n                    248,\n                    \"When enabled IntelliSense filtering requires that the first character matches on a word start. For example, `c` on `Console` or `WebContext` but _not_ on `description`. When disabled IntelliSense will show more results but still sorts them by match quality.\"\n                ))\n            },\n            'editor.suggest.showFields': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: ( localize(249, \"When enabled IntelliSense shows `field`-suggestions.\"))\n            },\n            'editor.suggest.showVariables': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: ( localize(250, \"When enabled IntelliSense shows `variable`-suggestions.\"))\n            },\n            'editor.suggest.showClasses': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: ( localize(251, \"When enabled IntelliSense shows `class`-suggestions.\"))\n            },\n            'editor.suggest.showStructs': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: ( localize(252, \"When enabled IntelliSense shows `struct`-suggestions.\"))\n            },\n            'editor.suggest.showInterfaces': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: ( localize(253, \"When enabled IntelliSense shows `interface`-suggestions.\"))\n            },\n            'editor.suggest.showModules': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: ( localize(254, \"When enabled IntelliSense shows `module`-suggestions.\"))\n            },\n            'editor.suggest.showProperties': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: ( localize(255, \"When enabled IntelliSense shows `property`-suggestions.\"))\n            },\n            'editor.suggest.showEvents': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: ( localize(256, \"When enabled IntelliSense shows `event`-suggestions.\"))\n            },\n            'editor.suggest.showOperators': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: ( localize(257, \"When enabled IntelliSense shows `operator`-suggestions.\"))\n            },\n            'editor.suggest.showUnits': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: ( localize(258, \"When enabled IntelliSense shows `unit`-suggestions.\"))\n            },\n            'editor.suggest.showValues': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: ( localize(259, \"When enabled IntelliSense shows `value`-suggestions.\"))\n            },\n            'editor.suggest.showConstants': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: ( localize(260, \"When enabled IntelliSense shows `constant`-suggestions.\"))\n            },\n            'editor.suggest.showEnums': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: ( localize(261, \"When enabled IntelliSense shows `enum`-suggestions.\"))\n            },\n            'editor.suggest.showEnumMembers': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: ( localize(262, \"When enabled IntelliSense shows `enumMember`-suggestions.\"))\n            },\n            'editor.suggest.showKeywords': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: ( localize(263, \"When enabled IntelliSense shows `keyword`-suggestions.\"))\n            },\n            'editor.suggest.showWords': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: ( localize(264, \"When enabled IntelliSense shows `text`-suggestions.\"))\n            },\n            'editor.suggest.showColors': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: ( localize(265, \"When enabled IntelliSense shows `color`-suggestions.\"))\n            },\n            'editor.suggest.showFiles': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: ( localize(266, \"When enabled IntelliSense shows `file`-suggestions.\"))\n            },\n            'editor.suggest.showReferences': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: ( localize(267, \"When enabled IntelliSense shows `reference`-suggestions.\"))\n            },\n            'editor.suggest.showCustomcolors': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: ( localize(268, \"When enabled IntelliSense shows `customcolor`-suggestions.\"))\n            },\n            'editor.suggest.showFolders': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: ( localize(269, \"When enabled IntelliSense shows `folder`-suggestions.\"))\n            },\n            'editor.suggest.showTypeParameters': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: ( localize(270, \"When enabled IntelliSense shows `typeParameter`-suggestions.\"))\n            },\n            'editor.suggest.showSnippets': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: ( localize(271, \"When enabled IntelliSense shows `snippet`-suggestions.\"))\n            },\n            'editor.suggest.showUsers': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: ( localize(272, \"When enabled IntelliSense shows `user`-suggestions.\"))\n            },\n            'editor.suggest.showIssues': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: ( localize(273, \"When enabled IntelliSense shows `issues`-suggestions.\"))\n            }\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            insertMode: stringSet(input.insertMode, this.defaultValue.insertMode, ['insert', 'replace']),\n            filterGraceful: boolean(input.filterGraceful, this.defaultValue.filterGraceful),\n            snippetsPreventQuickSuggestions: boolean(input.snippetsPreventQuickSuggestions, this.defaultValue.filterGraceful),\n            localityBonus: boolean(input.localityBonus, this.defaultValue.localityBonus),\n            shareSuggestSelections: boolean(input.shareSuggestSelections, this.defaultValue.shareSuggestSelections),\n            selectionMode: stringSet(input.selectionMode, this.defaultValue.selectionMode, ['always', 'never', 'whenQuickSuggestion', 'whenTriggerCharacter']),\n            showIcons: boolean(input.showIcons, this.defaultValue.showIcons),\n            showStatusBar: boolean(input.showStatusBar, this.defaultValue.showStatusBar),\n            preview: boolean(input.preview, this.defaultValue.preview),\n            previewMode: stringSet(input.previewMode, this.defaultValue.previewMode, ['prefix', 'subword', 'subwordSmart']),\n            showInlineDetails: boolean(input.showInlineDetails, this.defaultValue.showInlineDetails),\n            showMethods: boolean(input.showMethods, this.defaultValue.showMethods),\n            showFunctions: boolean(input.showFunctions, this.defaultValue.showFunctions),\n            showConstructors: boolean(input.showConstructors, this.defaultValue.showConstructors),\n            showDeprecated: boolean(input.showDeprecated, this.defaultValue.showDeprecated),\n            matchOnWordStartOnly: boolean(input.matchOnWordStartOnly, this.defaultValue.matchOnWordStartOnly),\n            showFields: boolean(input.showFields, this.defaultValue.showFields),\n            showVariables: boolean(input.showVariables, this.defaultValue.showVariables),\n            showClasses: boolean(input.showClasses, this.defaultValue.showClasses),\n            showStructs: boolean(input.showStructs, this.defaultValue.showStructs),\n            showInterfaces: boolean(input.showInterfaces, this.defaultValue.showInterfaces),\n            showModules: boolean(input.showModules, this.defaultValue.showModules),\n            showProperties: boolean(input.showProperties, this.defaultValue.showProperties),\n            showEvents: boolean(input.showEvents, this.defaultValue.showEvents),\n            showOperators: boolean(input.showOperators, this.defaultValue.showOperators),\n            showUnits: boolean(input.showUnits, this.defaultValue.showUnits),\n            showValues: boolean(input.showValues, this.defaultValue.showValues),\n            showConstants: boolean(input.showConstants, this.defaultValue.showConstants),\n            showEnums: boolean(input.showEnums, this.defaultValue.showEnums),\n            showEnumMembers: boolean(input.showEnumMembers, this.defaultValue.showEnumMembers),\n            showKeywords: boolean(input.showKeywords, this.defaultValue.showKeywords),\n            showWords: boolean(input.showWords, this.defaultValue.showWords),\n            showColors: boolean(input.showColors, this.defaultValue.showColors),\n            showFiles: boolean(input.showFiles, this.defaultValue.showFiles),\n            showReferences: boolean(input.showReferences, this.defaultValue.showReferences),\n            showFolders: boolean(input.showFolders, this.defaultValue.showFolders),\n            showTypeParameters: boolean(input.showTypeParameters, this.defaultValue.showTypeParameters),\n            showSnippets: boolean(input.showSnippets, this.defaultValue.showSnippets),\n            showUsers: boolean(input.showUsers, this.defaultValue.showUsers),\n            showIssues: boolean(input.showIssues, this.defaultValue.showIssues),\n        };\n    }\n}\nclass SmartSelect extends BaseEditorOption {\n    constructor() {\n        super(116 , 'smartSelect', {\n            selectLeadingAndTrailingWhitespace: true,\n            selectSubwords: true,\n        }, {\n            'editor.smartSelect.selectLeadingAndTrailingWhitespace': {\n                description: ( localize(274, \"Whether leading and trailing whitespace should always be selected.\")),\n                default: true,\n                type: 'boolean'\n            },\n            'editor.smartSelect.selectSubwords': {\n                description: ( localize(\n                    275,\n                    \"Whether subwords (like 'foo' in 'fooBar' or 'foo_bar') should be selected.\"\n                )),\n                default: true,\n                type: 'boolean'\n            }\n        });\n    }\n    validate(input) {\n        if (!input || typeof input !== 'object') {\n            return this.defaultValue;\n        }\n        return {\n            selectLeadingAndTrailingWhitespace: boolean(input.selectLeadingAndTrailingWhitespace, this.defaultValue.selectLeadingAndTrailingWhitespace),\n            selectSubwords: boolean(input.selectSubwords, this.defaultValue.selectSubwords),\n        };\n    }\n}\nclass WordSegmenterLocales extends BaseEditorOption {\n    constructor() {\n        const defaults = [];\n        super(133 , 'wordSegmenterLocales', defaults, {\n            anyOf: [\n                {\n                    description: ( localize(\n                        276,\n                        \"Locales to be used for word segmentation when doing word related navigations or operations. Specify the BCP 47 language tag of the word you wish to recognize (e.g., ja, zh-CN, zh-Hant-TW, etc.).\"\n                    )),\n                    type: 'string',\n                }, {\n                    description: ( localize(\n                        276,\n                        \"Locales to be used for word segmentation when doing word related navigations or operations. Specify the BCP 47 language tag of the word you wish to recognize (e.g., ja, zh-CN, zh-Hant-TW, etc.).\"\n                    )),\n                    type: 'array',\n                    items: {\n                        type: 'string'\n                    }\n                }\n            ]\n        });\n    }\n    validate(input) {\n        if (typeof input === 'string') {\n            input = [input];\n        }\n        if (Array.isArray(input)) {\n            const validLocales = [];\n            for (const locale of input) {\n                if (typeof locale === 'string') {\n                    try {\n                        if (Intl.Segmenter.supportedLocalesOf(locale).length > 0) {\n                            validLocales.push(locale);\n                        }\n                    }\n                    catch {\n                    }\n                }\n            }\n            return validLocales;\n        }\n        return this.defaultValue;\n    }\n}\nclass WrappingIndentOption extends BaseEditorOption {\n    constructor() {\n        super(141 , 'wrappingIndent', 1 , {\n            'editor.wrappingIndent': {\n                type: 'string',\n                enum: ['none', 'same', 'indent', 'deepIndent'],\n                enumDescriptions: [\n                    ( localize(277, \"No indentation. Wrapped lines begin at column 1.\")),\n                    ( localize(278, \"Wrapped lines get the same indentation as the parent.\")),\n                    ( localize(279, \"Wrapped lines get +1 indentation toward the parent.\")),\n                    ( localize(280, \"Wrapped lines get +2 indentation toward the parent.\")),\n                ],\n                description: ( localize(281, \"Controls the indentation of wrapped lines.\")),\n                default: 'same'\n            }\n        });\n    }\n    validate(input) {\n        switch (input) {\n            case 'none': return 0 ;\n            case 'same': return 1 ;\n            case 'indent': return 2 ;\n            case 'deepIndent': return 3 ;\n        }\n        return 1 ;\n    }\n    compute(env, options, value) {\n        const accessibilitySupport = options.get(2 );\n        if (accessibilitySupport === 2 ) {\n            return 0 ;\n        }\n        return value;\n    }\n}\nclass EditorWrappingInfoComputer extends ComputedEditorOption {\n    constructor() {\n        super(149 );\n    }\n    compute(env, options, _) {\n        const layoutInfo = options.get(148 );\n        return {\n            isDominatedByLongLines: env.isDominatedByLongLines,\n            isWordWrapMinified: layoutInfo.isWordWrapMinified,\n            isViewportWrapping: layoutInfo.isViewportWrapping,\n            wrappingColumn: layoutInfo.wrappingColumn,\n        };\n    }\n}\nclass EditorDropIntoEditor extends BaseEditorOption {\n    constructor() {\n        const defaults = { enabled: true, showDropSelector: 'afterDrop' };\n        super(36 , 'dropIntoEditor', defaults, {\n            'editor.dropIntoEditor.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                markdownDescription: ( localize(\n                    282,\n                    \"Controls whether you can drag and drop a file into a text editor by holding down the `Shift` key (instead of opening the file in an editor).\"\n                )),\n            },\n            'editor.dropIntoEditor.showDropSelector': {\n                type: 'string',\n                markdownDescription: ( localize(\n                    283,\n                    \"Controls if a widget is shown when dropping files into the editor. This widget lets you control how the file is dropped.\"\n                )),\n                enum: [\n                    'afterDrop',\n                    'never'\n                ],\n                enumDescriptions: [\n                    ( localize(\n                        284,\n                        \"Show the drop selector widget after a file is dropped into the editor.\"\n                    )),\n                    ( localize(\n                        285,\n                        \"Never show the drop selector widget. Instead the default drop provider is always used.\"\n                    )),\n                ],\n                default: 'afterDrop',\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled),\n            showDropSelector: stringSet(input.showDropSelector, this.defaultValue.showDropSelector, ['afterDrop', 'never']),\n        };\n    }\n}\nclass EditorPasteAs extends BaseEditorOption {\n    constructor() {\n        const defaults = { enabled: true, showPasteSelector: 'afterPaste' };\n        super(87 , 'pasteAs', defaults, {\n            'editor.pasteAs.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                markdownDescription: ( localize(286, \"Controls whether you can paste content in different ways.\")),\n            },\n            'editor.pasteAs.showPasteSelector': {\n                type: 'string',\n                markdownDescription: ( localize(\n                    287,\n                    \"Controls if a widget is shown when pasting content in to the editor. This widget lets you control how the file is pasted.\"\n                )),\n                enum: [\n                    'afterPaste',\n                    'never'\n                ],\n                enumDescriptions: [\n                    ( localize(\n                        288,\n                        \"Show the paste selector widget after content is pasted into the editor.\"\n                    )),\n                    ( localize(\n                        289,\n                        \"Never show the paste selector widget. Instead the default pasting behavior is always used.\"\n                    )),\n                ],\n                default: 'afterPaste',\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled),\n            showPasteSelector: stringSet(input.showPasteSelector, this.defaultValue.showPasteSelector, ['afterPaste', 'never']),\n        };\n    }\n}\nconst DEFAULT_WINDOWS_FONT_FAMILY = 'Consolas, \\'Courier New\\', monospace';\nconst DEFAULT_MAC_FONT_FAMILY = 'Menlo, Monaco, \\'Courier New\\', monospace';\nconst DEFAULT_LINUX_FONT_FAMILY = '\\'Droid Sans Mono\\', \\'monospace\\', monospace';\nconst EDITOR_FONT_DEFAULTS = {\n    fontFamily: (isMacintosh ? DEFAULT_MAC_FONT_FAMILY : (isLinux ? DEFAULT_LINUX_FONT_FAMILY : DEFAULT_WINDOWS_FONT_FAMILY)),\n    fontWeight: 'normal',\n    fontSize: (isMacintosh ? 12 : 14),\n    lineHeight: 0,\n    letterSpacing: 0,\n};\nconst editorOptionsRegistry = [];\nfunction register(option) {\n    editorOptionsRegistry[option.id] = option;\n    return option;\n}\nconst EditorOptions = {\n    acceptSuggestionOnCommitCharacter: register(( (new EditorBooleanOption(\n        0 ,\n        'acceptSuggestionOnCommitCharacter',\n        true,\n        { markdownDescription: ( localize(\n            290,\n            \"Controls whether suggestions should be accepted on commit characters. For example, in JavaScript, the semi-colon (`;`) can be a commit character that accepts a suggestion and types that character.\"\n        )) }\n    )))),\n    acceptSuggestionOnEnter: register(( (new EditorStringEnumOption(\n        1 ,\n        'acceptSuggestionOnEnter',\n        'on',\n        ['on', 'smart', 'off'],\n        {\n            markdownEnumDescriptions: [\n                '',\n                ( localize(\n                    291,\n                    \"Only accept a suggestion with `Enter` when it makes a textual change.\"\n                )),\n                ''\n            ],\n            markdownDescription: ( localize(\n                292,\n                \"Controls whether suggestions should be accepted on `Enter`, in addition to `Tab`. Helps to avoid ambiguity between inserting new lines or accepting suggestions.\"\n            ))\n        }\n    )))),\n    accessibilitySupport: register(( (new EditorAccessibilitySupport()))),\n    accessibilityPageSize: register(( (new EditorIntOption(\n        3 ,\n        'accessibilityPageSize',\n        10,\n        1,\n        1073741824 ,\n        {\n            description: ( localize(\n                293,\n                \"Controls the number of lines in the editor that can be read out by a screen reader at once. When we detect a screen reader we automatically set the default to be 500. Warning: this has a performance implication for numbers larger than the default.\"\n            )),\n            tags: ['accessibility']\n        }\n    )))),\n    ariaLabel: register(( (new EditorStringOption(4 , 'ariaLabel', ( localize(294, \"Editor content\")))))),\n    ariaRequired: register(( (new EditorBooleanOption(5 , 'ariaRequired', false, undefined)))),\n    screenReaderAnnounceInlineSuggestion: register(( (new EditorBooleanOption(\n        8 ,\n        'screenReaderAnnounceInlineSuggestion',\n        true,\n        {\n            description: ( localize(\n                295,\n                \"Control whether inline suggestions are announced by a screen reader.\"\n            )),\n            tags: ['accessibility']\n        }\n    )))),\n    autoClosingBrackets: register(( (new EditorStringEnumOption(\n        6 ,\n        'autoClosingBrackets',\n        'languageDefined',\n        ['always', 'languageDefined', 'beforeWhitespace', 'never'],\n        {\n            enumDescriptions: [\n                '',\n                ( localize(\n                    296,\n                    \"Use language configurations to determine when to autoclose brackets.\"\n                )),\n                ( localize(\n                    297,\n                    \"Autoclose brackets only when the cursor is to the left of whitespace.\"\n                )),\n                '',\n            ],\n            description: ( localize(\n                298,\n                \"Controls whether the editor should automatically close brackets after the user adds an opening bracket.\"\n            ))\n        }\n    )))),\n    autoClosingComments: register(( (new EditorStringEnumOption(\n        7 ,\n        'autoClosingComments',\n        'languageDefined',\n        ['always', 'languageDefined', 'beforeWhitespace', 'never'],\n        {\n            enumDescriptions: [\n                '',\n                ( localize(\n                    299,\n                    \"Use language configurations to determine when to autoclose comments.\"\n                )),\n                ( localize(\n                    300,\n                    \"Autoclose comments only when the cursor is to the left of whitespace.\"\n                )),\n                '',\n            ],\n            description: ( localize(\n                301,\n                \"Controls whether the editor should automatically close comments after the user adds an opening comment.\"\n            ))\n        }\n    )))),\n    autoClosingDelete: register(( (new EditorStringEnumOption(\n        9 ,\n        'autoClosingDelete',\n        'auto',\n        ['always', 'auto', 'never'],\n        {\n            enumDescriptions: [\n                '',\n                ( localize(\n                    302,\n                    \"Remove adjacent closing quotes or brackets only if they were automatically inserted.\"\n                )),\n                '',\n            ],\n            description: ( localize(\n                303,\n                \"Controls whether the editor should remove adjacent closing quotes or brackets when deleting.\"\n            ))\n        }\n    )))),\n    autoClosingOvertype: register(( (new EditorStringEnumOption(\n        10 ,\n        'autoClosingOvertype',\n        'auto',\n        ['always', 'auto', 'never'],\n        {\n            enumDescriptions: [\n                '',\n                ( localize(\n                    304,\n                    \"Type over closing quotes or brackets only if they were automatically inserted.\"\n                )),\n                '',\n            ],\n            description: ( localize(\n                305,\n                \"Controls whether the editor should type over closing quotes or brackets.\"\n            ))\n        }\n    )))),\n    autoClosingQuotes: register(( (new EditorStringEnumOption(\n        11 ,\n        'autoClosingQuotes',\n        'languageDefined',\n        ['always', 'languageDefined', 'beforeWhitespace', 'never'],\n        {\n            enumDescriptions: [\n                '',\n                ( localize(306, \"Use language configurations to determine when to autoclose quotes.\")),\n                ( localize(307, \"Autoclose quotes only when the cursor is to the left of whitespace.\")),\n                '',\n            ],\n            description: ( localize(\n                308,\n                \"Controls whether the editor should automatically close quotes after the user adds an opening quote.\"\n            ))\n        }\n    )))),\n    autoIndent: register(( (new EditorEnumOption(\n        12 ,\n        'autoIndent',\n        4 ,\n        'full',\n        ['none', 'keep', 'brackets', 'advanced', 'full'],\n        _autoIndentFromString,\n        {\n            enumDescriptions: [\n                ( localize(309, \"The editor will not insert indentation automatically.\")),\n                ( localize(310, \"The editor will keep the current line's indentation.\")),\n                ( localize(\n                    311,\n                    \"The editor will keep the current line's indentation and honor language defined brackets.\"\n                )),\n                ( localize(\n                    312,\n                    \"The editor will keep the current line's indentation, honor language defined brackets and invoke special onEnterRules defined by languages.\"\n                )),\n                ( localize(\n                    313,\n                    \"The editor will keep the current line's indentation, honor language defined brackets, invoke special onEnterRules defined by languages, and honor indentationRules defined by languages.\"\n                )),\n            ],\n            description: ( localize(\n                314,\n                \"Controls whether the editor should automatically adjust the indentation when users type, paste, move or indent lines.\"\n            ))\n        }\n    )))),\n    automaticLayout: register(( (new EditorBooleanOption(13 , 'automaticLayout', false)))),\n    autoSurround: register(( (new EditorStringEnumOption(\n        14 ,\n        'autoSurround',\n        'languageDefined',\n        ['languageDefined', 'quotes', 'brackets', 'never'],\n        {\n            enumDescriptions: [\n                ( localize(\n                    315,\n                    \"Use language configurations to determine when to automatically surround selections.\"\n                )),\n                ( localize(316, \"Surround with quotes but not brackets.\")),\n                ( localize(317, \"Surround with brackets but not quotes.\")),\n                ''\n            ],\n            description: ( localize(\n                318,\n                \"Controls whether the editor should automatically surround selections when typing quotes or brackets.\"\n            ))\n        }\n    )))),\n    bracketPairColorization: register(( (new BracketPairColorization()))),\n    bracketPairGuides: register(( (new GuideOptions()))),\n    stickyTabStops: register(( (new EditorBooleanOption(\n        119 ,\n        'stickyTabStops',\n        false,\n        { description: ( localize(\n            319,\n            \"Emulate selection behavior of tab characters when using spaces for indentation. Selection will stick to tab stops.\"\n        )) }\n    )))),\n    codeLens: register(( (new EditorBooleanOption(\n        17 ,\n        'codeLens',\n        true,\n        { description: ( localize(320, \"Controls whether the editor shows CodeLens.\")) }\n    )))),\n    codeLensFontFamily: register(( (new EditorStringOption(\n        18 ,\n        'codeLensFontFamily',\n        '',\n        { description: ( localize(321, \"Controls the font family for CodeLens.\")) }\n    )))),\n    codeLensFontSize: register(( (new EditorIntOption(19 , 'codeLensFontSize', 0, 0, 100, {\n        type: 'number',\n        default: 0,\n        minimum: 0,\n        maximum: 100,\n        markdownDescription: ( localize(\n            322,\n            \"Controls the font size in pixels for CodeLens. When set to 0, 90% of `#editor.fontSize#` is used.\"\n        ))\n    })))),\n    colorDecorators: register(( (new EditorBooleanOption(\n        20 ,\n        'colorDecorators',\n        true,\n        { description: ( localize(\n            323,\n            \"Controls whether the editor should render the inline color decorators and color picker.\"\n        )) }\n    )))),\n    colorDecoratorActivatedOn: register(( (new EditorStringEnumOption(\n        151 ,\n        'colorDecoratorsActivatedOn',\n        'clickAndHover',\n        ['clickAndHover', 'hover', 'click'],\n        {\n            enumDescriptions: [\n                ( localize(\n                    324,\n                    \"Make the color picker appear both on click and hover of the color decorator\"\n                )),\n                ( localize(325, \"Make the color picker appear on hover of the color decorator\")),\n                ( localize(326, \"Make the color picker appear on click of the color decorator\"))\n            ],\n            description: ( localize(\n                327,\n                \"Controls the condition to make a color picker appear from a color decorator\"\n            ))\n        }\n    )))),\n    colorDecoratorsLimit: register(( (new EditorIntOption(\n        21 ,\n        'colorDecoratorsLimit',\n        500,\n        1,\n        1000000,\n        {\n            markdownDescription: ( localize(\n                328,\n                \"Controls the max number of color decorators that can be rendered in an editor at once.\"\n            ))\n        }\n    )))),\n    columnSelection: register(( (new EditorBooleanOption(\n        22 ,\n        'columnSelection',\n        false,\n        { description: ( localize(\n            329,\n            \"Enable that the selection with the mouse and keys is doing column selection.\"\n        )) }\n    )))),\n    comments: register(( (new EditorComments()))),\n    contextmenu: register(( (new EditorBooleanOption(24 , 'contextmenu', true)))),\n    copyWithSyntaxHighlighting: register(( (new EditorBooleanOption(\n        25 ,\n        'copyWithSyntaxHighlighting',\n        true,\n        { description: ( localize(\n            330,\n            \"Controls whether syntax highlighting should be copied into the clipboard.\"\n        )) }\n    )))),\n    cursorBlinking: register(( (new EditorEnumOption(\n        26 ,\n        'cursorBlinking',\n        1 ,\n        'blink',\n        ['blink', 'smooth', 'phase', 'expand', 'solid'],\n        cursorBlinkingStyleFromString,\n        { description: ( localize(331, \"Control the cursor animation style.\")) }\n    )))),\n    cursorSmoothCaretAnimation: register(( (new EditorStringEnumOption(\n        27 ,\n        'cursorSmoothCaretAnimation',\n        'off',\n        ['off', 'explicit', 'on'],\n        {\n            enumDescriptions: [\n                ( localize(332, \"Smooth caret animation is disabled.\")),\n                ( localize(\n                    333,\n                    \"Smooth caret animation is enabled only when the user moves the cursor with an explicit gesture.\"\n                )),\n                ( localize(334, \"Smooth caret animation is always enabled.\"))\n            ],\n            description: ( localize(335, \"Controls whether the smooth caret animation should be enabled.\"))\n        }\n    )))),\n    cursorStyle: register(( (new EditorEnumOption(\n        28 ,\n        'cursorStyle',\n        TextEditorCursorStyle.Line,\n        'line',\n        ['line', 'block', 'underline', 'line-thin', 'block-outline', 'underline-thin'],\n        cursorStyleFromString,\n        { description: ( localize(336, \"Controls the cursor style.\")) }\n    )))),\n    cursorSurroundingLines: register(( (new EditorIntOption(\n        29 ,\n        'cursorSurroundingLines',\n        0,\n        0,\n        1073741824 ,\n        { description: ( localize(\n            337,\n            \"Controls the minimal number of visible leading lines (minimum 0) and trailing lines (minimum 1) surrounding the cursor. Known as 'scrollOff' or 'scrollOffset' in some other editors.\"\n        )) }\n    )))),\n    cursorSurroundingLinesStyle: register(( (new EditorStringEnumOption(\n        30 ,\n        'cursorSurroundingLinesStyle',\n        'default',\n        ['default', 'all'],\n        {\n            enumDescriptions: [\n                ( localize(\n                    338,\n                    \"`cursorSurroundingLines` is enforced only when triggered via the keyboard or API.\"\n                )),\n                ( localize(339, \"`cursorSurroundingLines` is enforced always.\"))\n            ],\n            markdownDescription: ( localize(340, \"Controls when `#editor.cursorSurroundingLines#` should be enforced.\"))\n        }\n    )))),\n    cursorWidth: register(( (new EditorIntOption(\n        31 ,\n        'cursorWidth',\n        0,\n        0,\n        1073741824 ,\n        { markdownDescription: ( localize(\n            341,\n            \"Controls the width of the cursor when `#editor.cursorStyle#` is set to `line`.\"\n        )) }\n    )))),\n    disableLayerHinting: register(( (new EditorBooleanOption(32 , 'disableLayerHinting', false)))),\n    disableMonospaceOptimizations: register(( (new EditorBooleanOption(\n        33 ,\n        'disableMonospaceOptimizations',\n        false\n    )))),\n    domReadOnly: register(( (new EditorBooleanOption(34 , 'domReadOnly', false)))),\n    dragAndDrop: register(( (new EditorBooleanOption(\n        35 ,\n        'dragAndDrop',\n        true,\n        { description: ( localize(\n            342,\n            \"Controls whether the editor should allow moving selections via drag and drop.\"\n        )) }\n    )))),\n    emptySelectionClipboard: register(( (new EditorEmptySelectionClipboard()))),\n    dropIntoEditor: register(( (new EditorDropIntoEditor()))),\n    experimentalEditContextEnabled: register(( (new EditorBooleanOption(\n        37 ,\n        'experimentalEditContextEnabled',\n        false,\n        {\n            description: ( localize(\n                343,\n                \"Sets whether the new experimental edit context should be used instead of the text area.\"\n            ))\n        }\n    )))),\n    stickyScroll: register(( (new EditorStickyScroll()))),\n    experimentalGpuAcceleration: register(( (new EditorStringEnumOption(\n        39 ,\n        'experimentalGpuAcceleration',\n        'off',\n        ['off', 'on'],\n        undefined\n    )))),\n    experimentalWhitespaceRendering: register(( (new EditorStringEnumOption(\n        40 ,\n        'experimentalWhitespaceRendering',\n        'svg',\n        ['svg', 'font', 'off'],\n        {\n            enumDescriptions: [\n                ( localize(344, \"Use a new rendering method with svgs.\")),\n                ( localize(345, \"Use a new rendering method with font characters.\")),\n                ( localize(346, \"Use the stable rendering method.\")),\n            ],\n            description: ( localize(\n                347,\n                \"Controls whether whitespace is rendered with a new, experimental method.\"\n            ))\n        }\n    )))),\n    extraEditorClassName: register(( (new EditorStringOption(41 , 'extraEditorClassName', '')))),\n    fastScrollSensitivity: register(( (new EditorFloatOption(\n        42 ,\n        'fastScrollSensitivity',\n        5,\n        x => (x <= 0 ? 5 : x),\n        { markdownDescription: ( localize(348, \"Scrolling speed multiplier when pressing `Alt`.\")) }\n    )))),\n    find: register(( (new EditorFind()))),\n    fixedOverflowWidgets: register(( (new EditorBooleanOption(44 , 'fixedOverflowWidgets', false)))),\n    folding: register(( (new EditorBooleanOption(\n        45 ,\n        'folding',\n        true,\n        { description: ( localize(349, \"Controls whether the editor has code folding enabled.\")) }\n    )))),\n    foldingStrategy: register(( (new EditorStringEnumOption(\n        46 ,\n        'foldingStrategy',\n        'auto',\n        ['auto', 'indentation'],\n        {\n            enumDescriptions: [\n                ( localize(\n                    350,\n                    \"Use a language-specific folding strategy if available, else the indentation-based one.\"\n                )),\n                ( localize(351, \"Use the indentation-based folding strategy.\")),\n            ],\n            description: ( localize(352, \"Controls the strategy for computing folding ranges.\"))\n        }\n    )))),\n    foldingHighlight: register(( (new EditorBooleanOption(\n        47 ,\n        'foldingHighlight',\n        true,\n        { description: ( localize(353, \"Controls whether the editor should highlight folded ranges.\")) }\n    )))),\n    foldingImportsByDefault: register(( (new EditorBooleanOption(\n        48 ,\n        'foldingImportsByDefault',\n        false,\n        { description: ( localize(354, \"Controls whether the editor automatically collapses import ranges.\")) }\n    )))),\n    foldingMaximumRegions: register(( (new EditorIntOption(\n        49 ,\n        'foldingMaximumRegions',\n        5000,\n        10,\n        65000,\n        { description: ( localize(\n            355,\n            \"The maximum number of foldable regions. Increasing this value may result in the editor becoming less responsive when the current source has a large number of foldable regions.\"\n        )) }\n    )))),\n    unfoldOnClickAfterEndOfLine: register(( (new EditorBooleanOption(\n        50 ,\n        'unfoldOnClickAfterEndOfLine',\n        false,\n        { description: ( localize(\n            356,\n            \"Controls whether clicking on the empty content after a folded line will unfold the line.\"\n        )) }\n    )))),\n    fontFamily: register(( (new EditorStringOption(\n        51 ,\n        'fontFamily',\n        EDITOR_FONT_DEFAULTS.fontFamily,\n        { description: ( localize(357, \"Controls the font family.\")) }\n    )))),\n    fontInfo: register(( (new EditorFontInfo()))),\n    fontLigatures2: register(( (new EditorFontLigatures()))),\n    fontSize: register(( (new EditorFontSize()))),\n    fontWeight: register(( (new EditorFontWeight()))),\n    fontVariations: register(( (new EditorFontVariations()))),\n    formatOnPaste: register(( (new EditorBooleanOption(\n        57 ,\n        'formatOnPaste',\n        false,\n        { description: ( localize(\n            358,\n            \"Controls whether the editor should automatically format the pasted content. A formatter must be available and the formatter should be able to format a range in a document.\"\n        )) }\n    )))),\n    formatOnType: register(( (new EditorBooleanOption(\n        58 ,\n        'formatOnType',\n        false,\n        { description: ( localize(\n            359,\n            \"Controls whether the editor should automatically format the line after typing.\"\n        )) }\n    )))),\n    glyphMargin: register(( (new EditorBooleanOption(\n        59 ,\n        'glyphMargin',\n        true,\n        { description: ( localize(\n            360,\n            \"Controls whether the editor should render the vertical glyph margin. Glyph margin is mostly used for debugging.\"\n        )) }\n    )))),\n    gotoLocation: register(( (new EditorGoToLocation()))),\n    hideCursorInOverviewRuler: register(( (new EditorBooleanOption(\n        61 ,\n        'hideCursorInOverviewRuler',\n        false,\n        { description: ( localize(361, \"Controls whether the cursor should be hidden in the overview ruler.\")) }\n    )))),\n    hover: register(( (new EditorHover()))),\n    inDiffEditor: register(( (new EditorBooleanOption(63 , 'inDiffEditor', false)))),\n    letterSpacing: register(( (new EditorFloatOption(\n        66 ,\n        'letterSpacing',\n        EDITOR_FONT_DEFAULTS.letterSpacing,\n        x => EditorFloatOption.clamp(x, -5, 20),\n        { description: ( localize(362, \"Controls the letter spacing in pixels.\")) }\n    )))),\n    lightbulb: register(( (new EditorLightbulb()))),\n    lineDecorationsWidth: register(( (new EditorLineDecorationsWidth()))),\n    lineHeight: register(( (new EditorLineHeight()))),\n    lineNumbers: register(( (new EditorRenderLineNumbersOption()))),\n    lineNumbersMinChars: register(( (new EditorIntOption(\n        71 ,\n        'lineNumbersMinChars',\n        5,\n        1,\n        300\n    )))),\n    linkedEditing: register(( (new EditorBooleanOption(\n        72 ,\n        'linkedEditing',\n        false,\n        { description: ( localize(\n            363,\n            \"Controls whether the editor has linked editing enabled. Depending on the language, related symbols such as HTML tags, are updated while editing.\"\n        )) }\n    )))),\n    links: register(( (new EditorBooleanOption(73 , 'links', true, { description: ( localize(\n        364,\n        \"Controls whether the editor should detect links and make them clickable.\"\n    )) })))),\n    matchBrackets: register(( (new EditorStringEnumOption(\n        74 ,\n        'matchBrackets',\n        'always',\n        ['always', 'near', 'never'],\n        { description: ( localize(365, \"Highlight matching brackets.\")) }\n    )))),\n    minimap: register(( (new EditorMinimap()))),\n    mouseStyle: register(( (new EditorStringEnumOption(\n        76 ,\n        'mouseStyle',\n        'text',\n        ['text', 'default', 'copy']\n    )))),\n    mouseWheelScrollSensitivity: register(( (new EditorFloatOption(\n        77 ,\n        'mouseWheelScrollSensitivity',\n        1,\n        x => (x === 0 ? 1 : x),\n        { markdownDescription: ( localize(\n            366,\n            \"A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.\"\n        )) }\n    )))),\n    mouseWheelZoom: register(( (new EditorBooleanOption(78 , 'mouseWheelZoom', false, {\n        markdownDescription: isMacintosh\n            ? ( localize(\n            367,\n            \"Zoom the font of the editor when using mouse wheel and holding `Cmd`.\"\n        ))\n            : ( localize(\n            368,\n            \"Zoom the font of the editor when using mouse wheel and holding `Ctrl`.\"\n        ))\n    })))),\n    multiCursorMergeOverlapping: register(( (new EditorBooleanOption(\n        79 ,\n        'multiCursorMergeOverlapping',\n        true,\n        { description: ( localize(369, \"Merge multiple cursors when they are overlapping.\")) }\n    )))),\n    multiCursorModifier: register(( (new EditorEnumOption(\n        80 ,\n        'multiCursorModifier',\n        'altKey',\n        'alt',\n        ['ctrlCmd', 'alt'],\n        _multiCursorModifierFromString,\n        {\n            markdownEnumDescriptions: [\n                ( localize(370, \"Maps to `Control` on Windows and Linux and to `Command` on macOS.\")),\n                ( localize(371, \"Maps to `Alt` on Windows and Linux and to `Option` on macOS.\"))\n            ],\n            markdownDescription: ( localize(\n                372,\n                \"The modifier to be used to add multiple cursors with the mouse. The Go to Definition and Open Link mouse gestures will adapt such that they do not conflict with the [multicursor modifier](https://code.visualstudio.com/docs/editor/codebasics#_multicursor-modifier).\"\n            ))\n        }\n    )))),\n    multiCursorPaste: register(( (new EditorStringEnumOption(\n        81 ,\n        'multiCursorPaste',\n        'spread',\n        ['spread', 'full'],\n        {\n            markdownEnumDescriptions: [\n                ( localize(373, \"Each cursor pastes a single line of the text.\")),\n                ( localize(374, \"Each cursor pastes the full text.\"))\n            ],\n            markdownDescription: ( localize(\n                375,\n                \"Controls pasting when the line count of the pasted text matches the cursor count.\"\n            ))\n        }\n    )))),\n    multiCursorLimit: register(( (new EditorIntOption(\n        82 ,\n        'multiCursorLimit',\n        10000,\n        1,\n        100000,\n        {\n            markdownDescription: ( localize(\n                376,\n                \"Controls the max number of cursors that can be in an active editor at once.\"\n            ))\n        }\n    )))),\n    occurrencesHighlight: register(( (new EditorStringEnumOption(\n        83 ,\n        'occurrencesHighlight',\n        'singleFile',\n        ['off', 'singleFile', 'multiFile'],\n        {\n            markdownEnumDescriptions: [\n                ( localize(377, \"Does not highlight occurrences.\")),\n                ( localize(378, \"Highlights occurrences only in the current file.\")),\n                ( localize(379, \"Experimental: Highlights occurrences across all valid open files.\"))\n            ],\n            markdownDescription: ( localize(\n                380,\n                \"Controls whether occurrences should be highlighted across open files.\"\n            ))\n        }\n    )))),\n    overviewRulerBorder: register(( (new EditorBooleanOption(\n        84 ,\n        'overviewRulerBorder',\n        true,\n        { description: ( localize(\n            381,\n            \"Controls whether a border should be drawn around the overview ruler.\"\n        )) }\n    )))),\n    overviewRulerLanes: register(( (new EditorIntOption(85 , 'overviewRulerLanes', 3, 0, 3)))),\n    padding: register(( (new EditorPadding()))),\n    pasteAs: register(( (new EditorPasteAs()))),\n    parameterHints: register(( (new EditorParameterHints()))),\n    peekWidgetDefaultFocus: register(( (new EditorStringEnumOption(\n        89 ,\n        'peekWidgetDefaultFocus',\n        'tree',\n        ['tree', 'editor'],\n        {\n            enumDescriptions: [\n                ( localize(382, \"Focus the tree when opening peek\")),\n                ( localize(383, \"Focus the editor when opening peek\"))\n            ],\n            description: ( localize(\n                384,\n                \"Controls whether to focus the inline editor or the tree in the peek widget.\"\n            ))\n        }\n    )))),\n    placeholder: register(( (new PlaceholderOption()))),\n    definitionLinkOpensInPeek: register(( (new EditorBooleanOption(\n        91 ,\n        'definitionLinkOpensInPeek',\n        false,\n        { description: ( localize(\n            385,\n            \"Controls whether the Go to Definition mouse gesture always opens the peek widget.\"\n        )) }\n    )))),\n    quickSuggestions: register(( (new EditorQuickSuggestions()))),\n    quickSuggestionsDelay: register(( (new EditorIntOption(\n        93 ,\n        'quickSuggestionsDelay',\n        10,\n        0,\n        1073741824 ,\n        { description: ( localize(\n            386,\n            \"Controls the delay in milliseconds after which quick suggestions will show up.\"\n        )) }\n    )))),\n    readOnly: register(( (new EditorBooleanOption(94 , 'readOnly', false)))),\n    readOnlyMessage: register(( (new ReadonlyMessage()))),\n    renameOnType: register(( (new EditorBooleanOption(\n        96 ,\n        'renameOnType',\n        false,\n        { description: ( localize(387, \"Controls whether the editor auto renames on type.\")), markdownDeprecationMessage: ( localize(388, \"Deprecated, use `editor.linkedEditing` instead.\")) }\n    )))),\n    renderControlCharacters: register(( (new EditorBooleanOption(\n        97 ,\n        'renderControlCharacters',\n        true,\n        { description: ( localize(389, \"Controls whether the editor should render control characters.\")), restricted: true }\n    )))),\n    renderFinalNewline: register(( (new EditorStringEnumOption(\n        98 ,\n        'renderFinalNewline',\n        (isLinux ? 'dimmed' : 'on'),\n        ['off', 'on', 'dimmed'],\n        { description: ( localize(390, \"Render last line number when the file ends with a newline.\")) }\n    )))),\n    renderLineHighlight: register(( (new EditorStringEnumOption(\n        99 ,\n        'renderLineHighlight',\n        'line',\n        ['none', 'gutter', 'line', 'all'],\n        {\n            enumDescriptions: [\n                '',\n                '',\n                '',\n                ( localize(391, \"Highlights both the gutter and the current line.\")),\n            ],\n            description: ( localize(392, \"Controls how the editor should render the current line highlight.\"))\n        }\n    )))),\n    renderLineHighlightOnlyWhenFocus: register(( (new EditorBooleanOption(\n        100 ,\n        'renderLineHighlightOnlyWhenFocus',\n        false,\n        { description: ( localize(\n            393,\n            \"Controls if the editor should render the current line highlight only when the editor is focused.\"\n        )) }\n    )))),\n    renderValidationDecorations: register(( (new EditorStringEnumOption(\n        101 ,\n        'renderValidationDecorations',\n        'editable',\n        ['editable', 'on', 'off']\n    )))),\n    renderWhitespace: register(( (new EditorStringEnumOption(\n        102 ,\n        'renderWhitespace',\n        'selection',\n        ['none', 'boundary', 'selection', 'trailing', 'all'],\n        {\n            enumDescriptions: [\n                '',\n                ( localize(\n                    394,\n                    \"Render whitespace characters except for single spaces between words.\"\n                )),\n                ( localize(395, \"Render whitespace characters only on selected text.\")),\n                ( localize(396, \"Render only trailing whitespace characters.\")),\n                ''\n            ],\n            description: ( localize(397, \"Controls how the editor should render whitespace characters.\"))\n        }\n    )))),\n    revealHorizontalRightPadding: register(( (new EditorIntOption(\n        103 ,\n        'revealHorizontalRightPadding',\n        15,\n        0,\n        1000\n    )))),\n    roundedSelection: register(( (new EditorBooleanOption(\n        104 ,\n        'roundedSelection',\n        true,\n        { description: ( localize(398, \"Controls whether selections should have rounded corners.\")) }\n    )))),\n    rulers: register(( (new EditorRulers()))),\n    scrollbar: register(( (new EditorScrollbar()))),\n    scrollBeyondLastColumn: register(( (new EditorIntOption(\n        107 ,\n        'scrollBeyondLastColumn',\n        4,\n        0,\n        1073741824 ,\n        { description: ( localize(\n            399,\n            \"Controls the number of extra characters beyond which the editor will scroll horizontally.\"\n        )) }\n    )))),\n    scrollBeyondLastLine: register(( (new EditorBooleanOption(\n        108 ,\n        'scrollBeyondLastLine',\n        true,\n        { description: ( localize(400, \"Controls whether the editor will scroll beyond the last line.\")) }\n    )))),\n    scrollPredominantAxis: register(( (new EditorBooleanOption(\n        109 ,\n        'scrollPredominantAxis',\n        true,\n        { description: ( localize(\n            401,\n            \"Scroll only along the predominant axis when scrolling both vertically and horizontally at the same time. Prevents horizontal drift when scrolling vertically on a trackpad.\"\n        )) }\n    )))),\n    selectionClipboard: register(( (new EditorBooleanOption(110 , 'selectionClipboard', true, {\n        description: ( localize(402, \"Controls whether the Linux primary clipboard should be supported.\")),\n        included: isLinux\n    })))),\n    selectionHighlight: register(( (new EditorBooleanOption(\n        111 ,\n        'selectionHighlight',\n        true,\n        { description: ( localize(\n            403,\n            \"Controls whether the editor should highlight matches similar to the selection.\"\n        )) }\n    )))),\n    selectOnLineNumbers: register(( (new EditorBooleanOption(112 , 'selectOnLineNumbers', true)))),\n    showFoldingControls: register(( (new EditorStringEnumOption(\n        113 ,\n        'showFoldingControls',\n        'mouseover',\n        ['always', 'never', 'mouseover'],\n        {\n            enumDescriptions: [\n                ( localize(404, \"Always show the folding controls.\")),\n                ( localize(405, \"Never show the folding controls and reduce the gutter size.\")),\n                ( localize(406, \"Only show the folding controls when the mouse is over the gutter.\")),\n            ],\n            description: ( localize(407, \"Controls when the folding controls on the gutter are shown.\"))\n        }\n    )))),\n    showUnused: register(( (new EditorBooleanOption(\n        114 ,\n        'showUnused',\n        true,\n        { description: ( localize(408, \"Controls fading out of unused code.\")) }\n    )))),\n    showDeprecated: register(( (new EditorBooleanOption(\n        143 ,\n        'showDeprecated',\n        true,\n        { description: ( localize(409, \"Controls strikethrough deprecated variables.\")) }\n    )))),\n    inlayHints: register(( (new EditorInlayHints()))),\n    snippetSuggestions: register(( (new EditorStringEnumOption(\n        115 ,\n        'snippetSuggestions',\n        'inline',\n        ['top', 'bottom', 'inline', 'none'],\n        {\n            enumDescriptions: [\n                ( localize(410, \"Show snippet suggestions on top of other suggestions.\")),\n                ( localize(411, \"Show snippet suggestions below other suggestions.\")),\n                ( localize(412, \"Show snippets suggestions with other suggestions.\")),\n                ( localize(413, \"Do not show snippet suggestions.\")),\n            ],\n            description: ( localize(\n                414,\n                \"Controls whether snippets are shown with other suggestions and how they are sorted.\"\n            ))\n        }\n    )))),\n    smartSelect: register(( (new SmartSelect()))),\n    smoothScrolling: register(( (new EditorBooleanOption(\n        117 ,\n        'smoothScrolling',\n        false,\n        { description: ( localize(415, \"Controls whether the editor will scroll using an animation.\")) }\n    )))),\n    stopRenderingLineAfter: register(( (new EditorIntOption(\n        120 ,\n        'stopRenderingLineAfter',\n        10000,\n        -1,\n        1073741824\n    )))),\n    suggest: register(( (new EditorSuggest()))),\n    inlineSuggest: register(( (new InlineEditorSuggest()))),\n    inlineEdit: register(( (new InlineEditorEdit()))),\n    inlineCompletionsAccessibilityVerbose: register(( (new EditorBooleanOption(\n        152 ,\n        'inlineCompletionsAccessibilityVerbose',\n        false,\n        { description: ( localize(\n            416,\n            \"Controls whether the accessibility hint should be provided to screen reader users when an inline completion is shown.\"\n        )) }\n    )))),\n    suggestFontSize: register(( (new EditorIntOption(\n        122 ,\n        'suggestFontSize',\n        0,\n        0,\n        1000,\n        { markdownDescription: ( localize(\n            417,\n            \"Font size for the suggest widget. When set to {0}, the value of {1} is used.\",\n            '`0`',\n            '`#editor.fontSize#`'\n        )) }\n    )))),\n    suggestLineHeight: register(( (new EditorIntOption(\n        123 ,\n        'suggestLineHeight',\n        0,\n        0,\n        1000,\n        { markdownDescription: ( localize(\n            418,\n            \"Line height for the suggest widget. When set to {0}, the value of {1} is used. The minimum value is 8.\",\n            '`0`',\n            '`#editor.lineHeight#`'\n        )) }\n    )))),\n    suggestOnTriggerCharacters: register(( (new EditorBooleanOption(\n        124 ,\n        'suggestOnTriggerCharacters',\n        true,\n        { description: ( localize(\n            419,\n            \"Controls whether suggestions should automatically show up when typing trigger characters.\"\n        )) }\n    )))),\n    suggestSelection: register(( (new EditorStringEnumOption(\n        125 ,\n        'suggestSelection',\n        'first',\n        ['first', 'recentlyUsed', 'recentlyUsedByPrefix'],\n        {\n            markdownEnumDescriptions: [\n                ( localize(420, \"Always select the first suggestion.\")),\n                ( localize(\n                    421,\n                    \"Select recent suggestions unless further typing selects one, e.g. `console.| -> console.log` because `log` has been completed recently.\"\n                )),\n                ( localize(\n                    422,\n                    \"Select suggestions based on previous prefixes that have completed those suggestions, e.g. `co -> console` and `con -> const`.\"\n                )),\n            ],\n            description: ( localize(\n                423,\n                \"Controls how suggestions are pre-selected when showing the suggest list.\"\n            ))\n        }\n    )))),\n    tabCompletion: register(( (new EditorStringEnumOption(\n        126 ,\n        'tabCompletion',\n        'off',\n        ['on', 'off', 'onlySnippets'],\n        {\n            enumDescriptions: [\n                ( localize(\n                    424,\n                    \"Tab complete will insert the best matching suggestion when pressing tab.\"\n                )),\n                ( localize(425, \"Disable tab completions.\")),\n                ( localize(\n                    426,\n                    \"Tab complete snippets when their prefix match. Works best when 'quickSuggestions' aren't enabled.\"\n                )),\n            ],\n            description: ( localize(427, \"Enables tab completions.\"))\n        }\n    )))),\n    tabIndex: register(( (new EditorIntOption(\n        127 ,\n        'tabIndex',\n        0,\n        -1,\n        1073741824\n    )))),\n    unicodeHighlight: register(( (new UnicodeHighlight()))),\n    unusualLineTerminators: register(( (new EditorStringEnumOption(\n        129 ,\n        'unusualLineTerminators',\n        'prompt',\n        ['auto', 'off', 'prompt'],\n        {\n            enumDescriptions: [\n                ( localize(428, \"Unusual line terminators are automatically removed.\")),\n                ( localize(429, \"Unusual line terminators are ignored.\")),\n                ( localize(430, \"Unusual line terminators prompt to be removed.\")),\n            ],\n            description: ( localize(431, \"Remove unusual line terminators that might cause problems.\"))\n        }\n    )))),\n    useShadowDOM: register(( (new EditorBooleanOption(130 , 'useShadowDOM', true)))),\n    useTabStops: register(( (new EditorBooleanOption(\n        131 ,\n        'useTabStops',\n        true,\n        { description: ( localize(\n            432,\n            \"Spaces and tabs are inserted and deleted in alignment with tab stops.\"\n        )) }\n    )))),\n    wordBreak: register(( (new EditorStringEnumOption(\n        132 ,\n        'wordBreak',\n        'normal',\n        ['normal', 'keepAll'],\n        {\n            markdownEnumDescriptions: [\n                ( localize(433, \"Use the default line break rule.\")),\n                ( localize(\n                    434,\n                    \"Word breaks should not be used for Chinese/Japanese/Korean (CJK) text. Non-CJK text behavior is the same as for normal.\"\n                )),\n            ],\n            description: ( localize(\n                435,\n                \"Controls the word break rules used for Chinese/Japanese/Korean (CJK) text.\"\n            ))\n        }\n    )))),\n    wordSegmenterLocales: register(( (new WordSegmenterLocales()))),\n    wordSeparators: register(( (new EditorStringOption(\n        134 ,\n        'wordSeparators',\n        USUAL_WORD_SEPARATORS,\n        { description: ( localize(\n            436,\n            \"Characters that will be used as word separators when doing word related navigations or operations.\"\n        )) }\n    )))),\n    wordWrap: register(( (new EditorStringEnumOption(\n        135 ,\n        'wordWrap',\n        'off',\n        ['off', 'on', 'wordWrapColumn', 'bounded'],\n        {\n            markdownEnumDescriptions: [\n                ( localize(437, \"Lines will never wrap.\")),\n                ( localize(438, \"Lines will wrap at the viewport width.\")),\n                ( localize(439, \"Lines will wrap at `#editor.wordWrapColumn#`.\")),\n                ( localize(\n                    440,\n                    \"Lines will wrap at the minimum of viewport and `#editor.wordWrapColumn#`.\"\n                )),\n            ],\n            description: ( localize(441, \"Controls how lines should wrap.\"))\n        }\n    )))),\n    wordWrapBreakAfterCharacters: register(( (new EditorStringOption(\n        136 ,\n        'wordWrapBreakAfterCharacters',\n        ' \\t})]?|/&.,;'\n    )))),\n    wordWrapBreakBeforeCharacters: register(( (new EditorStringOption(\n        137 ,\n        'wordWrapBreakBeforeCharacters',\n        '([{+'\n    )))),\n    wordWrapColumn: register(( (new EditorIntOption(\n        138 ,\n        'wordWrapColumn',\n        80,\n        1,\n        1073741824 ,\n        {\n            markdownDescription: ( localize(\n                442,\n                \"Controls the wrapping column of the editor when `#editor.wordWrap#` is `wordWrapColumn` or `bounded`.\"\n            ))\n        }\n    )))),\n    wordWrapOverride1: register(( (new EditorStringEnumOption(\n        139 ,\n        'wordWrapOverride1',\n        'inherit',\n        ['off', 'on', 'inherit']\n    )))),\n    wordWrapOverride2: register(( (new EditorStringEnumOption(\n        140 ,\n        'wordWrapOverride2',\n        'inherit',\n        ['off', 'on', 'inherit']\n    )))),\n    editorClassName: register(( (new EditorClassName()))),\n    defaultColorDecorators: register(( (new EditorBooleanOption(\n        150 ,\n        'defaultColorDecorators',\n        false,\n        { markdownDescription: ( localize(\n            443,\n            \"Controls whether inline color decorations should be shown using the default document color provider\"\n        )) }\n    )))),\n    pixelRatio: register(( (new EditorPixelRatio()))),\n    tabFocusMode: register(( (new EditorBooleanOption(\n        147 ,\n        'tabFocusMode',\n        false,\n        { markdownDescription: ( localize(\n            444,\n            \"Controls whether the editor receives tabs or defers them to the workbench for navigation.\"\n        )) }\n    )))),\n    layoutInfo: register(( (new EditorLayoutInfoComputer()))),\n    wrappingInfo: register(( (new EditorWrappingInfoComputer()))),\n    wrappingIndent: register(( (new WrappingIndentOption()))),\n    wrappingStrategy: register(( (new WrappingStrategy())))\n};\nexport { ApplyUpdateResult, ComputeOptionsMemory, ConfigurationChangedEvent, EDITOR_FONT_DEFAULTS, EditorFontLigatures, EditorFontVariations, EditorLayoutInfoComputer, EditorOptions, MINIMAP_GUTTER_WIDTH, ShowLightbulbIconMode, TextEditorCursorStyle, boolean, clampedFloat, clampedInt, cursorBlinkingStyleFromString, cursorStyleFromString, cursorStyleToString, editorOptionsRegistry, filterValidationDecorations, inUntrustedWorkspace, stringSet, unicodeHighlightConfigKeys };\n","import { isHighSurrogate } from '../../../base/common/strings.js';\nimport { isLittleEndian } from '../../../base/common/platform.js';\nimport { readUInt16LE } from '../../../base/common/buffer.js';\nlet _utf16LE_TextDecoder;\nfunction getUTF16LE_TextDecoder() {\n    if (!_utf16LE_TextDecoder) {\n        _utf16LE_TextDecoder = ( new TextDecoder('UTF-16LE'));\n    }\n    return _utf16LE_TextDecoder;\n}\nlet _utf16BE_TextDecoder;\nfunction getUTF16BE_TextDecoder() {\n    if (!_utf16BE_TextDecoder) {\n        _utf16BE_TextDecoder = ( new TextDecoder('UTF-16BE'));\n    }\n    return _utf16BE_TextDecoder;\n}\nlet _platformTextDecoder;\nfunction getPlatformTextDecoder() {\n    if (!_platformTextDecoder) {\n        _platformTextDecoder = isLittleEndian() ? getUTF16LE_TextDecoder() : getUTF16BE_TextDecoder();\n    }\n    return _platformTextDecoder;\n}\nfunction decodeUTF16LE(source, offset, len) {\n    const view = ( new Uint16Array(source.buffer, offset, len));\n    if (len > 0 && (view[0] === 0xFEFF || view[0] === 0xFFFE)) {\n        return compatDecodeUTF16LE(source, offset, len);\n    }\n    return getUTF16LE_TextDecoder().decode(view);\n}\nfunction compatDecodeUTF16LE(source, offset, len) {\n    const result = [];\n    let resultLen = 0;\n    for (let i = 0; i < len; i++) {\n        const charCode = readUInt16LE(source, offset);\n        offset += 2;\n        result[resultLen++] = String.fromCharCode(charCode);\n    }\n    return result.join('');\n}\nclass StringBuilder {\n    constructor(capacity) {\n        this._capacity = capacity | 0;\n        this._buffer = ( new Uint16Array(this._capacity));\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    reset() {\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    build() {\n        if (this._completedStrings !== null) {\n            this._flushBuffer();\n            return this._completedStrings.join('');\n        }\n        return this._buildBuffer();\n    }\n    _buildBuffer() {\n        if (this._bufferLength === 0) {\n            return '';\n        }\n        const view = ( new Uint16Array(this._buffer.buffer, 0, this._bufferLength));\n        return getPlatformTextDecoder().decode(view);\n    }\n    _flushBuffer() {\n        const bufferString = this._buildBuffer();\n        this._bufferLength = 0;\n        if (this._completedStrings === null) {\n            this._completedStrings = [bufferString];\n        }\n        else {\n            this._completedStrings[this._completedStrings.length] = bufferString;\n        }\n    }\n    appendCharCode(charCode) {\n        const remainingSpace = this._capacity - this._bufferLength;\n        if (remainingSpace <= 1) {\n            if (remainingSpace === 0 || isHighSurrogate(charCode)) {\n                this._flushBuffer();\n            }\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    appendASCIICharCode(charCode) {\n        if (this._bufferLength === this._capacity) {\n            this._flushBuffer();\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    appendString(str) {\n        const strLen = str.length;\n        if (this._bufferLength + strLen >= this._capacity) {\n            this._flushBuffer();\n            this._completedStrings[this._completedStrings.length] = str;\n            return;\n        }\n        for (let i = 0; i < strLen; i++) {\n            this._buffer[this._bufferLength++] = str.charCodeAt(i);\n        }\n    }\n}\nexport { StringBuilder, decodeUTF16LE, getPlatformTextDecoder };\n","import { writeUInt32BE, writeUInt16LE, readUInt32BE } from '../../../base/common/buffer.js';\nimport { decodeUTF16LE } from './stringBuilder.js';\nfunction escapeNewLine(str) {\n    return (str\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r'));\n}\nclass TextChange {\n    get oldLength() {\n        return this.oldText.length;\n    }\n    get oldEnd() {\n        return this.oldPosition + this.oldText.length;\n    }\n    get newLength() {\n        return this.newText.length;\n    }\n    get newEnd() {\n        return this.newPosition + this.newText.length;\n    }\n    constructor(oldPosition, oldText, newPosition, newText) {\n        this.oldPosition = oldPosition;\n        this.oldText = oldText;\n        this.newPosition = newPosition;\n        this.newText = newText;\n    }\n    toString() {\n        if (this.oldText.length === 0) {\n            return `(insert@${this.oldPosition} \"${escapeNewLine(this.newText)}\")`;\n        }\n        if (this.newText.length === 0) {\n            return `(delete@${this.oldPosition} \"${escapeNewLine(this.oldText)}\")`;\n        }\n        return `(replace@${this.oldPosition} \"${escapeNewLine(this.oldText)}\" with \"${escapeNewLine(this.newText)}\")`;\n    }\n    static _writeStringSize(str) {\n        return (4 + 2 * str.length);\n    }\n    static _writeString(b, str, offset) {\n        const len = str.length;\n        writeUInt32BE(b, len, offset);\n        offset += 4;\n        for (let i = 0; i < len; i++) {\n            writeUInt16LE(b, str.charCodeAt(i), offset);\n            offset += 2;\n        }\n        return offset;\n    }\n    static _readString(b, offset) {\n        const len = readUInt32BE(b, offset);\n        offset += 4;\n        return decodeUTF16LE(b, offset, len);\n    }\n    writeSize() {\n        return (+4\n            + 4\n            + TextChange._writeStringSize(this.oldText)\n            + TextChange._writeStringSize(this.newText));\n    }\n    write(b, offset) {\n        writeUInt32BE(b, this.oldPosition, offset);\n        offset += 4;\n        writeUInt32BE(b, this.newPosition, offset);\n        offset += 4;\n        offset = TextChange._writeString(b, this.oldText, offset);\n        offset = TextChange._writeString(b, this.newText, offset);\n        return offset;\n    }\n    static read(b, offset, dest) {\n        const oldPosition = readUInt32BE(b, offset);\n        offset += 4;\n        const newPosition = readUInt32BE(b, offset);\n        offset += 4;\n        const oldText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(oldText);\n        const newText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(newText);\n        dest.push(( new TextChange(oldPosition, oldText, newPosition, newText)));\n        return offset;\n    }\n}\nfunction compressConsecutiveTextChanges(prevEdits, currEdits) {\n    if (prevEdits === null || prevEdits.length === 0) {\n        return currEdits;\n    }\n    const compressor = ( new TextChangeCompressor(prevEdits, currEdits));\n    return compressor.compress();\n}\nclass TextChangeCompressor {\n    constructor(prevEdits, currEdits) {\n        this._prevEdits = prevEdits;\n        this._currEdits = currEdits;\n        this._result = [];\n        this._resultLen = 0;\n        this._prevLen = this._prevEdits.length;\n        this._prevDeltaOffset = 0;\n        this._currLen = this._currEdits.length;\n        this._currDeltaOffset = 0;\n    }\n    compress() {\n        let prevIndex = 0;\n        let currIndex = 0;\n        let prevEdit = this._getPrev(prevIndex);\n        let currEdit = this._getCurr(currIndex);\n        while (prevIndex < this._prevLen || currIndex < this._currLen) {\n            if (prevEdit === null) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (currEdit === null) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldEnd <= prevEdit.newPosition) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (prevEdit.newEnd <= currEdit.oldPosition) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldPosition < prevEdit.newPosition) {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newPosition - currEdit.oldPosition);\n                this._acceptCurr(e1);\n                currEdit = e2;\n                continue;\n            }\n            if (prevEdit.newPosition < currEdit.oldPosition) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldPosition - prevEdit.newPosition);\n                this._acceptPrev(e1);\n                prevEdit = e2;\n                continue;\n            }\n            let mergePrev;\n            let mergeCurr;\n            if (currEdit.oldEnd === prevEdit.newEnd) {\n                mergePrev = prevEdit;\n                mergeCurr = currEdit;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = this._getCurr(++currIndex);\n            }\n            else if (currEdit.oldEnd < prevEdit.newEnd) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldLength);\n                mergePrev = e1;\n                mergeCurr = currEdit;\n                prevEdit = e2;\n                currEdit = this._getCurr(++currIndex);\n            }\n            else {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newLength);\n                mergePrev = prevEdit;\n                mergeCurr = e1;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = e2;\n            }\n            this._result[this._resultLen++] = ( new TextChange(\n                mergePrev.oldPosition,\n                mergePrev.oldText,\n                mergeCurr.newPosition,\n                mergeCurr.newText\n            ));\n            this._prevDeltaOffset += mergePrev.newLength - mergePrev.oldLength;\n            this._currDeltaOffset += mergeCurr.newLength - mergeCurr.oldLength;\n        }\n        const merged = TextChangeCompressor._merge(this._result);\n        const cleaned = TextChangeCompressor._removeNoOps(merged);\n        return cleaned;\n    }\n    _acceptCurr(currEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebaseCurr(this._prevDeltaOffset, currEdit);\n        this._currDeltaOffset += currEdit.newLength - currEdit.oldLength;\n    }\n    _getCurr(currIndex) {\n        return (currIndex < this._currLen ? this._currEdits[currIndex] : null);\n    }\n    _acceptPrev(prevEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebasePrev(this._currDeltaOffset, prevEdit);\n        this._prevDeltaOffset += prevEdit.newLength - prevEdit.oldLength;\n    }\n    _getPrev(prevIndex) {\n        return (prevIndex < this._prevLen ? this._prevEdits[prevIndex] : null);\n    }\n    static _rebaseCurr(prevDeltaOffset, currEdit) {\n        return ( new TextChange(\n            currEdit.oldPosition - prevDeltaOffset,\n            currEdit.oldText,\n            currEdit.newPosition,\n            currEdit.newText\n        ));\n    }\n    static _rebasePrev(currDeltaOffset, prevEdit) {\n        return ( new TextChange(\n            prevEdit.oldPosition,\n            prevEdit.oldText,\n            prevEdit.newPosition + currDeltaOffset,\n            prevEdit.newText\n        ));\n    }\n    static _splitPrev(edit, offset) {\n        const preText = edit.newText.substr(0, offset);\n        const postText = edit.newText.substr(offset);\n        return [\n            ( new TextChange(edit.oldPosition, edit.oldText, edit.newPosition, preText)),\n            ( new TextChange(edit.oldEnd, '', edit.newPosition + offset, postText))\n        ];\n    }\n    static _splitCurr(edit, offset) {\n        const preText = edit.oldText.substr(0, offset);\n        const postText = edit.oldText.substr(offset);\n        return [\n            ( new TextChange(edit.oldPosition, preText, edit.newPosition, edit.newText)),\n            ( new TextChange(edit.oldPosition + offset, postText, edit.newEnd, ''))\n        ];\n    }\n    static _merge(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        let prev = edits[0];\n        for (let i = 1; i < edits.length; i++) {\n            const curr = edits[i];\n            if (prev.oldEnd === curr.oldPosition) {\n                prev = ( new TextChange(\n                    prev.oldPosition,\n                    prev.oldText + curr.oldText,\n                    prev.newPosition,\n                    prev.newText + curr.newText\n                ));\n            }\n            else {\n                result[resultLen++] = prev;\n                prev = curr;\n            }\n        }\n        result[resultLen++] = prev;\n        return result;\n    }\n    static _removeNoOps(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0; i < edits.length; i++) {\n            const edit = edits[i];\n            if (edit.oldText === edit.newText) {\n                continue;\n            }\n            result[resultLen++] = edit;\n        }\n        return result;\n    }\n}\nexport { TextChange, compressConsecutiveTextChanges };\n","const EDITOR_MODEL_DEFAULTS = {\n    tabSize: 4,\n    indentSize: 4,\n    insertSpaces: true,\n    detectIndentation: true,\n    trimAutoWhitespace: true,\n    largeFileOptimizations: true,\n    bracketPairColorizationOptions: {\n        enabled: true,\n        independentColorPoolPerBracketType: false,\n    },\n};\nexport { EDITOR_MODEL_DEFAULTS };\n","import { match } from '../../base/common/glob.js';\nimport { normalize } from '../../base/common/path.js';\nfunction score(selector, candidateUri, candidateLanguage, candidateIsSynchronized, candidateNotebookUri, candidateNotebookType) {\n    if (Array.isArray(selector)) {\n        let ret = 0;\n        for (const filter of selector) {\n            const value = score(filter, candidateUri, candidateLanguage, candidateIsSynchronized, candidateNotebookUri, candidateNotebookType);\n            if (value === 10) {\n                return value;\n            }\n            if (value > ret) {\n                ret = value;\n            }\n        }\n        return ret;\n    }\n    else if (typeof selector === 'string') {\n        if (!candidateIsSynchronized) {\n            return 0;\n        }\n        if (selector === '*') {\n            return 5;\n        }\n        else if (selector === candidateLanguage) {\n            return 10;\n        }\n        else {\n            return 0;\n        }\n    }\n    else if (selector) {\n        const { language, pattern, scheme, hasAccessToAllModels, notebookType } = selector;\n        if (!candidateIsSynchronized && !hasAccessToAllModels) {\n            return 0;\n        }\n        if (notebookType && candidateNotebookUri) {\n            candidateUri = candidateNotebookUri;\n        }\n        let ret = 0;\n        if (scheme) {\n            if (scheme === candidateUri.scheme) {\n                ret = 10;\n            }\n            else if (scheme === '*') {\n                ret = 5;\n            }\n            else {\n                return 0;\n            }\n        }\n        if (language) {\n            if (language === candidateLanguage) {\n                ret = 10;\n            }\n            else if (language === '*') {\n                ret = Math.max(ret, 5);\n            }\n            else {\n                return 0;\n            }\n        }\n        if (notebookType) {\n            if (notebookType === candidateNotebookType) {\n                ret = 10;\n            }\n            else if (notebookType === '*' && candidateNotebookType !== undefined) {\n                ret = Math.max(ret, 5);\n            }\n            else {\n                return 0;\n            }\n        }\n        if (pattern) {\n            let normalizedPattern;\n            if (typeof pattern === 'string') {\n                normalizedPattern = pattern;\n            }\n            else {\n                normalizedPattern = { ...pattern, base: normalize(pattern.base) };\n            }\n            if (normalizedPattern === candidateUri.fsPath || match(normalizedPattern, candidateUri.fsPath)) {\n                ret = 10;\n            }\n            else {\n                return 0;\n            }\n        }\n        return ret;\n    }\n    else {\n        return 0;\n    }\n}\nfunction targetsNotebooks(selector) {\n    if (typeof selector === 'string') {\n        return false;\n    }\n    else if (Array.isArray(selector)) {\n        return ( selector.some(targetsNotebooks));\n    }\n    else {\n        return !!selector.notebookType;\n    }\n}\nexport { score, targetsNotebooks };\n","var IndentAction;\n( (function(IndentAction) {\n    IndentAction[IndentAction[\"None\"] = 0] = \"None\";\n    IndentAction[IndentAction[\"Indent\"] = 1] = \"Indent\";\n    IndentAction[IndentAction[\"IndentOutdent\"] = 2] = \"IndentOutdent\";\n    IndentAction[IndentAction[\"Outdent\"] = 3] = \"Outdent\";\n})(IndentAction || (IndentAction = {})));\nclass StandardAutoClosingPairConditional {\n    constructor(source) {\n        this._neutralCharacter = null;\n        this._neutralCharacterSearched = false;\n        this.open = source.open;\n        this.close = source.close;\n        this._inString = true;\n        this._inComment = true;\n        this._inRegEx = true;\n        if (Array.isArray(source.notIn)) {\n            for (let i = 0, len = source.notIn.length; i < len; i++) {\n                const notIn = source.notIn[i];\n                switch (notIn) {\n                    case 'string':\n                        this._inString = false;\n                        break;\n                    case 'comment':\n                        this._inComment = false;\n                        break;\n                    case 'regex':\n                        this._inRegEx = false;\n                        break;\n                }\n            }\n        }\n    }\n    isOK(standardToken) {\n        switch (standardToken) {\n            case 0 :\n                return true;\n            case 1 :\n                return this._inComment;\n            case 2 :\n                return this._inString;\n            case 3 :\n                return this._inRegEx;\n        }\n    }\n    shouldAutoClose(context, column) {\n        if (context.getTokenCount() === 0) {\n            return true;\n        }\n        const tokenIndex = context.findTokenIndexAtOffset(column - 2);\n        const standardTokenType = context.getStandardTokenType(tokenIndex);\n        return this.isOK(standardTokenType);\n    }\n    _findNeutralCharacterInRange(fromCharCode, toCharCode) {\n        for (let charCode = fromCharCode; charCode <= toCharCode; charCode++) {\n            const character = String.fromCharCode(charCode);\n            if (!this.open.includes(character) && !this.close.includes(character)) {\n                return character;\n            }\n        }\n        return null;\n    }\n    findNeutralCharacter() {\n        if (!this._neutralCharacterSearched) {\n            this._neutralCharacterSearched = true;\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(48 , 57 );\n            }\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(97 , 122 );\n            }\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(65 , 90 );\n            }\n        }\n        return this._neutralCharacter;\n    }\n}\nclass AutoClosingPairs {\n    constructor(autoClosingPairs) {\n        this.autoClosingPairsOpenByStart = ( new Map());\n        this.autoClosingPairsOpenByEnd = ( new Map());\n        this.autoClosingPairsCloseByStart = ( new Map());\n        this.autoClosingPairsCloseByEnd = ( new Map());\n        this.autoClosingPairsCloseSingleChar = ( new Map());\n        for (const pair of autoClosingPairs) {\n            appendEntry(this.autoClosingPairsOpenByStart, pair.open.charAt(0), pair);\n            appendEntry(this.autoClosingPairsOpenByEnd, pair.open.charAt(pair.open.length - 1), pair);\n            appendEntry(this.autoClosingPairsCloseByStart, pair.close.charAt(0), pair);\n            appendEntry(this.autoClosingPairsCloseByEnd, pair.close.charAt(pair.close.length - 1), pair);\n            if (pair.close.length === 1 && pair.open.length === 1) {\n                appendEntry(this.autoClosingPairsCloseSingleChar, pair.close, pair);\n            }\n        }\n    }\n}\nfunction appendEntry(target, key, value) {\n    if (( target.has(key))) {\n        target.get(key).push(value);\n    }\n    else {\n        target.set(key, [value]);\n    }\n}\nexport { AutoClosingPairs, IndentAction, StandardAutoClosingPairConditional };\n","import { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { FindMatch } from '../../model.js';\nimport { SENTINEL, rbDelete, updateTreeMetadata, leftest, fixInsert, righttest, TreeNode } from './rbTreeBase.js';\nimport { createFindMatch, isValidMatch, Searcher } from '../textModelSearch.js';\nconst AverageBufferSize = 65535;\nfunction createUintArray(arr) {\n    let r;\n    if (arr[arr.length - 1] < 65536) {\n        r = ( new Uint16Array(arr.length));\n    }\n    else {\n        r = ( new Uint32Array(arr.length));\n    }\n    r.set(arr, 0);\n    return r;\n}\nclass LineStarts {\n    constructor(lineStarts, cr, lf, crlf, isBasicASCII) {\n        this.lineStarts = lineStarts;\n        this.cr = cr;\n        this.lf = lf;\n        this.crlf = crlf;\n        this.isBasicASCII = isBasicASCII;\n    }\n}\nfunction createLineStartsFast(str, readonly = true) {\n    const r = [0];\n    let rLength = 1;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 ) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 ) {\n                r[rLength++] = i + 2;\n                i++;\n            }\n            else {\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 ) {\n            r[rLength++] = i + 1;\n        }\n    }\n    if (readonly) {\n        return createUintArray(r);\n    }\n    else {\n        return r;\n    }\n}\nfunction createLineStarts(r, str) {\n    r.length = 0;\n    r[0] = 0;\n    let rLength = 1;\n    let cr = 0, lf = 0, crlf = 0;\n    let isBasicASCII = true;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 ) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 ) {\n                crlf++;\n                r[rLength++] = i + 2;\n                i++;\n            }\n            else {\n                cr++;\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 ) {\n            lf++;\n            r[rLength++] = i + 1;\n        }\n        else {\n            if (isBasicASCII) {\n                if (chr !== 9  && (chr < 32 || chr > 126)) {\n                    isBasicASCII = false;\n                }\n            }\n        }\n    }\n    const result = ( new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII));\n    r.length = 0;\n    return result;\n}\nclass Piece {\n    constructor(bufferIndex, start, end, lineFeedCnt, length) {\n        this.bufferIndex = bufferIndex;\n        this.start = start;\n        this.end = end;\n        this.lineFeedCnt = lineFeedCnt;\n        this.length = length;\n    }\n}\nclass StringBuffer {\n    constructor(buffer, lineStarts) {\n        this.buffer = buffer;\n        this.lineStarts = lineStarts;\n    }\n}\nclass PieceTreeSnapshot {\n    constructor(tree, BOM) {\n        this._pieces = [];\n        this._tree = tree;\n        this._BOM = BOM;\n        this._index = 0;\n        if (tree.root !== SENTINEL) {\n            tree.iterate(tree.root, node => {\n                if (node !== SENTINEL) {\n                    this._pieces.push(node.piece);\n                }\n                return true;\n            });\n        }\n    }\n    read() {\n        if (this._pieces.length === 0) {\n            if (this._index === 0) {\n                this._index++;\n                return this._BOM;\n            }\n            else {\n                return null;\n            }\n        }\n        if (this._index > this._pieces.length - 1) {\n            return null;\n        }\n        if (this._index === 0) {\n            return this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);\n        }\n        return this._tree.getPieceContent(this._pieces[this._index++]);\n    }\n}\nclass PieceTreeSearchCache {\n    constructor(limit) {\n        this._limit = limit;\n        this._cache = [];\n    }\n    get(offset) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            const nodePos = this._cache[i];\n            if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    get2(lineNumber) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            const nodePos = this._cache[i];\n            if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    set(nodePosition) {\n        if (this._cache.length >= this._limit) {\n            this._cache.shift();\n        }\n        this._cache.push(nodePosition);\n    }\n    validate(offset) {\n        let hasInvalidVal = false;\n        const tmp = this._cache;\n        for (let i = 0; i < tmp.length; i++) {\n            const nodePos = tmp[i];\n            if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {\n                tmp[i] = null;\n                hasInvalidVal = true;\n                continue;\n            }\n        }\n        if (hasInvalidVal) {\n            const newArr = [];\n            for (const entry of tmp) {\n                if (entry !== null) {\n                    newArr.push(entry);\n                }\n            }\n            this._cache = newArr;\n        }\n    }\n}\nclass PieceTreeBase {\n    constructor(chunks, eol, eolNormalized) {\n        this.create(chunks, eol, eolNormalized);\n    }\n    create(chunks, eol, eolNormalized) {\n        this._buffers = [\n            ( new StringBuffer('', [0]))\n        ];\n        this._lastChangeBufferPos = { line: 0, column: 0 };\n        this.root = SENTINEL;\n        this._lineCnt = 1;\n        this._length = 0;\n        this._EOL = eol;\n        this._EOLLength = eol.length;\n        this._EOLNormalized = eolNormalized;\n        let lastNode = null;\n        for (let i = 0, len = chunks.length; i < len; i++) {\n            if (chunks[i].buffer.length > 0) {\n                if (!chunks[i].lineStarts) {\n                    chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);\n                }\n                const piece = ( new Piece(\n                    i + 1,\n                    { line: 0, column: 0 },\n                    { line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1] },\n                    chunks[i].lineStarts.length - 1,\n                    chunks[i].buffer.length\n                ));\n                this._buffers.push(chunks[i]);\n                lastNode = this.rbInsertRight(lastNode, piece);\n            }\n        }\n        this._searchCache = ( new PieceTreeSearchCache(1));\n        this._lastVisitedLine = { lineNumber: 0, value: '' };\n        this.computeBufferMetadata();\n    }\n    normalizeEOL(eol) {\n        const averageBufferSize = AverageBufferSize;\n        const min = averageBufferSize - Math.floor(averageBufferSize / 3);\n        const max = min * 2;\n        let tempChunk = '';\n        let tempChunkLen = 0;\n        const chunks = [];\n        this.iterate(this.root, node => {\n            const str = this.getNodeContent(node);\n            const len = str.length;\n            if (tempChunkLen <= min || tempChunkLen + len < max) {\n                tempChunk += str;\n                tempChunkLen += len;\n                return true;\n            }\n            const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(( new StringBuffer(text, createLineStartsFast(text))));\n            tempChunk = str;\n            tempChunkLen = len;\n            return true;\n        });\n        if (tempChunkLen > 0) {\n            const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(( new StringBuffer(text, createLineStartsFast(text))));\n        }\n        this.create(chunks, eol, true);\n    }\n    getEOL() {\n        return this._EOL;\n    }\n    setEOL(newEOL) {\n        this._EOL = newEOL;\n        this._EOLLength = this._EOL.length;\n        this.normalizeEOL(newEOL);\n    }\n    createSnapshot(BOM) {\n        return ( new PieceTreeSnapshot(this, BOM));\n    }\n    equal(other) {\n        if (this.getLength() !== other.getLength()) {\n            return false;\n        }\n        if (this.getLineCount() !== other.getLineCount()) {\n            return false;\n        }\n        let offset = 0;\n        const ret = this.iterate(this.root, node => {\n            if (node === SENTINEL) {\n                return true;\n            }\n            const str = this.getNodeContent(node);\n            const len = str.length;\n            const startPosition = other.nodeAt(offset);\n            const endPosition = other.nodeAt(offset + len);\n            const val = other.getValueInRange2(startPosition, endPosition);\n            offset += len;\n            return str === val;\n        });\n        return ret;\n    }\n    getOffsetAt(lineNumber, column) {\n        let leftLen = 0;\n        let x = this.root;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left + 1 >= lineNumber) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {\n                leftLen += x.size_left;\n                const accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                return leftLen += accumualtedValInCurrentIndex + column - 1;\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                leftLen += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return leftLen;\n    }\n    getPositionAt(offset) {\n        offset = Math.floor(offset);\n        offset = Math.max(0, offset);\n        let x = this.root;\n        let lfCnt = 0;\n        const originalOffset = offset;\n        while (x !== SENTINEL) {\n            if (x.size_left !== 0 && x.size_left >= offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                const out = this.getIndexOf(x, offset - x.size_left);\n                lfCnt += x.lf_left + out.index;\n                if (out.index === 0) {\n                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    const column = originalOffset - lineStartOffset;\n                    return ( new Position(lfCnt + 1, column + 1));\n                }\n                return ( new Position(lfCnt + 1, out.remainder + 1));\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                lfCnt += x.lf_left + x.piece.lineFeedCnt;\n                if (x.right === SENTINEL) {\n                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    const column = originalOffset - offset - lineStartOffset;\n                    return ( new Position(lfCnt + 1, column + 1));\n                }\n                else {\n                    x = x.right;\n                }\n            }\n        }\n        return ( new Position(1, 1));\n    }\n    getValueInRange(range, eol) {\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n            return '';\n        }\n        const startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);\n        const endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);\n        const value = this.getValueInRange2(startPosition, endPosition);\n        if (eol) {\n            if (eol !== this._EOL || !this._EOLNormalized) {\n                return value.replace(/\\r\\n|\\r|\\n/g, eol);\n            }\n            if (eol === this.getEOL() && this._EOLNormalized) {\n                return value;\n            }\n            return value.replace(/\\r\\n|\\r|\\n/g, eol);\n        }\n        return value;\n    }\n    getValueInRange2(startPosition, endPosition) {\n        if (startPosition.node === endPosition.node) {\n            const node = startPosition.node;\n            const buffer = this._buffers[node.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n            return buffer.substring(startOffset + startPosition.remainder, startOffset + endPosition.remainder);\n        }\n        let x = startPosition.node;\n        const buffer = this._buffers[x.piece.bufferIndex].buffer;\n        const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n        let ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);\n        x = x.next();\n        while (x !== SENTINEL) {\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (x === endPosition.node) {\n                ret += buffer.substring(startOffset, startOffset + endPosition.remainder);\n                break;\n            }\n            else {\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    getLinesContent() {\n        const lines = [];\n        let linesLength = 0;\n        let currentLine = '';\n        let danglingCR = false;\n        this.iterate(this.root, node => {\n            if (node === SENTINEL) {\n                return true;\n            }\n            const piece = node.piece;\n            let pieceLength = piece.length;\n            if (pieceLength === 0) {\n                return true;\n            }\n            const buffer = this._buffers[piece.bufferIndex].buffer;\n            const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n            const pieceStartLine = piece.start.line;\n            const pieceEndLine = piece.end.line;\n            let pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;\n            if (danglingCR) {\n                if (buffer.charCodeAt(pieceStartOffset) === 10 ) {\n                    pieceStartOffset++;\n                    pieceLength--;\n                }\n                lines[linesLength++] = currentLine;\n                currentLine = '';\n                danglingCR = false;\n                if (pieceLength === 0) {\n                    return true;\n                }\n            }\n            if (pieceStartLine === pieceEndLine) {\n                if (!this._EOLNormalized && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === 13 ) {\n                    danglingCR = true;\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength - 1);\n                }\n                else {\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength);\n                }\n                return true;\n            }\n            currentLine += (this._EOLNormalized\n                ? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - this._EOLLength))\n                : buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n            lines[linesLength++] = currentLine;\n            for (let line = pieceStartLine + 1; line < pieceEndLine; line++) {\n                currentLine = (this._EOLNormalized\n                    ? buffer.substring(lineStarts[line], lineStarts[line + 1] - this._EOLLength)\n                    : buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n                lines[linesLength++] = currentLine;\n            }\n            if (!this._EOLNormalized && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === 13 ) {\n                danglingCR = true;\n                if (piece.end.column === 0) {\n                    linesLength--;\n                }\n                else {\n                    currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);\n                }\n            }\n            else {\n                currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);\n            }\n            return true;\n        });\n        if (danglingCR) {\n            lines[linesLength++] = currentLine;\n            currentLine = '';\n        }\n        lines[linesLength++] = currentLine;\n        return lines;\n    }\n    getLength() {\n        return this._length;\n    }\n    getLineCount() {\n        return this._lineCnt;\n    }\n    getLineContent(lineNumber) {\n        if (this._lastVisitedLine.lineNumber === lineNumber) {\n            return this._lastVisitedLine.value;\n        }\n        this._lastVisitedLine.lineNumber = lineNumber;\n        if (lineNumber === this._lineCnt) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber);\n        }\n        else if (this._EOLNormalized) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);\n        }\n        else {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\\r\\n|\\r|\\n)$/, '');\n        }\n        return this._lastVisitedLine.value;\n    }\n    _getCharCode(nodePos) {\n        if (nodePos.remainder === nodePos.node.piece.length) {\n            const matchingNode = nodePos.node.next();\n            if (!matchingNode) {\n                return 0;\n            }\n            const buffer = this._buffers[matchingNode.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n            return buffer.buffer.charCodeAt(startOffset);\n        }\n        else {\n            const buffer = this._buffers[nodePos.node.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n            const targetOffset = startOffset + nodePos.remainder;\n            return buffer.buffer.charCodeAt(targetOffset);\n        }\n    }\n    getLineCharCode(lineNumber, index) {\n        const nodePos = this.nodeAt2(lineNumber, index + 1);\n        return this._getCharCode(nodePos);\n    }\n    getLineLength(lineNumber) {\n        if (lineNumber === this.getLineCount()) {\n            const startOffset = this.getOffsetAt(lineNumber, 1);\n            return this.getLength() - startOffset;\n        }\n        return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;\n    }\n    getCharCode(offset) {\n        const nodePos = this.nodeAt(offset);\n        return this._getCharCode(nodePos);\n    }\n    getNearestChunk(offset) {\n        const nodePos = this.nodeAt(offset);\n        if (nodePos.remainder === nodePos.node.piece.length) {\n            const matchingNode = nodePos.node.next();\n            if (!matchingNode || matchingNode === SENTINEL) {\n                return '';\n            }\n            const buffer = this._buffers[matchingNode.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n            return buffer.buffer.substring(startOffset, startOffset + matchingNode.piece.length);\n        }\n        else {\n            const buffer = this._buffers[nodePos.node.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n            const targetOffset = startOffset + nodePos.remainder;\n            const targetEnd = startOffset + nodePos.node.piece.length;\n            return buffer.buffer.substring(targetOffset, targetEnd);\n        }\n    }\n    findMatchesInNode(node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n        const start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);\n        const end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);\n        let m;\n        const ret = { line: 0, column: 0 };\n        let searchText;\n        let offsetInBuffer;\n        if (searcher._wordSeparators) {\n            searchText = buffer.buffer.substring(start, end);\n            offsetInBuffer = (offset) => offset + start;\n            searcher.reset(0);\n        }\n        else {\n            searchText = buffer.buffer;\n            offsetInBuffer = (offset) => offset;\n            searcher.reset(start);\n        }\n        do {\n            m = searcher.next(searchText);\n            if (m) {\n                if (offsetInBuffer(m.index) >= end) {\n                    return resultLen;\n                }\n                this.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);\n                const lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);\n                const retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;\n                const retEndColumn = retStartColumn + m[0].length;\n                result[resultLen++] = createFindMatch(( new Range(\n                    startLineNumber + lineFeedCnt,\n                    retStartColumn,\n                    startLineNumber + lineFeedCnt,\n                    retEndColumn\n                )), m, captureMatches);\n                if (offsetInBuffer(m.index) + m[0].length >= end) {\n                    return resultLen;\n                }\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        const result = [];\n        let resultLen = 0;\n        const searcher = ( new Searcher(searchData.wordSeparators, searchData.regex));\n        let startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);\n        if (startPosition === null) {\n            return [];\n        }\n        const endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);\n        if (endPosition === null) {\n            return [];\n        }\n        let start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        const end = this.positionInBuffer(endPosition.node, endPosition.remainder);\n        if (startPosition.node === endPosition.node) {\n            this.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n            return result;\n        }\n        let startLineNumber = searchRange.startLineNumber;\n        let currentNode = startPosition.node;\n        while (currentNode !== endPosition.node) {\n            const lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);\n            if (lineBreakCnt >= 1) {\n                const lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;\n                const startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);\n                const nextLineStartOffset = lineStarts[start.line + lineBreakCnt];\n                const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n                resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);\n                if (resultLen >= limitResultCount) {\n                    return result;\n                }\n                startLineNumber += lineBreakCnt;\n            }\n            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            if (startLineNumber === searchRange.endLineNumber) {\n                const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n                resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n                return result;\n            }\n            resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn), startLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            if (resultLen >= limitResultCount) {\n                return result;\n            }\n            startLineNumber++;\n            startPosition = this.nodeAt2(startLineNumber, 1);\n            currentNode = startPosition.node;\n            start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        }\n        if (startLineNumber === searchRange.endLineNumber) {\n            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            return result;\n        }\n        const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n        resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n        return result;\n    }\n    _findMatchesInLine(searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n        const wordSeparators = searchData.wordSeparators;\n        if (!captureMatches && searchData.simpleSearch) {\n            const searchString = searchData.simpleSearch;\n            const searchStringLen = searchString.length;\n            const textLength = text.length;\n            let lastMatchIndex = -searchStringLen;\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n                    result[resultLen++] = ( new FindMatch(( new Range(\n                        lineNumber,\n                        lastMatchIndex + 1 + deltaOffset,\n                        lineNumber,\n                        lastMatchIndex + 1 + searchStringLen + deltaOffset\n                    )), null));\n                    if (resultLen >= limitResultCount) {\n                        return resultLen;\n                    }\n                }\n            }\n            return resultLen;\n        }\n        let m;\n        searcher.reset(0);\n        do {\n            m = searcher.next(text);\n            if (m) {\n                result[resultLen++] = createFindMatch(( new Range(\n                    lineNumber,\n                    m.index + 1 + deltaOffset,\n                    lineNumber,\n                    m.index + 1 + m[0].length + deltaOffset\n                )), m, captureMatches);\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    insert(offset, value, eolNormalized = false) {\n        this._EOLNormalized = this._EOLNormalized && eolNormalized;\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (this.root !== SENTINEL) {\n            const { node, remainder, nodeStartOffset } = this.nodeAt(offset);\n            const piece = node.piece;\n            const bufferIndex = piece.bufferIndex;\n            const insertPosInBuffer = this.positionInBuffer(node, remainder);\n            if (node.piece.bufferIndex === 0 &&\n                piece.end.line === this._lastChangeBufferPos.line &&\n                piece.end.column === this._lastChangeBufferPos.column &&\n                (nodeStartOffset + piece.length === offset) &&\n                value.length < AverageBufferSize) {\n                this.appendToNode(node, value);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (nodeStartOffset === offset) {\n                this.insertContentToNodeLeft(value, node);\n                this._searchCache.validate(offset);\n            }\n            else if (nodeStartOffset + node.piece.length > offset) {\n                const nodesToDel = [];\n                let newRightPiece = ( new Piece(\n                    piece.bufferIndex,\n                    insertPosInBuffer,\n                    piece.end,\n                    this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end),\n                    this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer)\n                ));\n                if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n                    const headOfRight = this.nodeCharCodeAt(node, remainder);\n                    if (headOfRight === 10 ) {\n                        const newStart = { line: newRightPiece.start.line + 1, column: 0 };\n                        newRightPiece = ( new Piece(\n                            newRightPiece.bufferIndex,\n                            newStart,\n                            newRightPiece.end,\n                            this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end),\n                            newRightPiece.length - 1\n                        ));\n                        value += '\\n';\n                    }\n                }\n                if (this.shouldCheckCRLF() && this.startWithLF(value)) {\n                    const tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);\n                    if (tailOfLeft === 13 ) {\n                        const previousPos = this.positionInBuffer(node, remainder - 1);\n                        this.deleteNodeTail(node, previousPos);\n                        value = '\\r' + value;\n                        if (node.piece.length === 0) {\n                            nodesToDel.push(node);\n                        }\n                    }\n                    else {\n                        this.deleteNodeTail(node, insertPosInBuffer);\n                    }\n                }\n                else {\n                    this.deleteNodeTail(node, insertPosInBuffer);\n                }\n                const newPieces = this.createNewPieces(value);\n                if (newRightPiece.length > 0) {\n                    this.rbInsertRight(node, newRightPiece);\n                }\n                let tmpNode = node;\n                for (let k = 0; k < newPieces.length; k++) {\n                    tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n                }\n                this.deleteNodes(nodesToDel);\n            }\n            else {\n                this.insertContentToNodeRight(value, node);\n            }\n        }\n        else {\n            const pieces = this.createNewPieces(value);\n            let node = this.rbInsertLeft(null, pieces[0]);\n            for (let k = 1; k < pieces.length; k++) {\n                node = this.rbInsertRight(node, pieces[k]);\n            }\n        }\n        this.computeBufferMetadata();\n    }\n    delete(offset, cnt) {\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (cnt <= 0 || this.root === SENTINEL) {\n            return;\n        }\n        const startPosition = this.nodeAt(offset);\n        const endPosition = this.nodeAt(offset + cnt);\n        const startNode = startPosition.node;\n        const endNode = endPosition.node;\n        if (startNode === endNode) {\n            const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n            const endSplitPosInBuffer = this.positionInBuffer(startNode, endPosition.remainder);\n            if (startPosition.nodeStartOffset === offset) {\n                if (cnt === startNode.piece.length) {\n                    const next = startNode.next();\n                    rbDelete(this, startNode);\n                    this.validateCRLFWithPrevNode(next);\n                    this.computeBufferMetadata();\n                    return;\n                }\n                this.deleteNodeHead(startNode, endSplitPosInBuffer);\n                this._searchCache.validate(offset);\n                this.validateCRLFWithPrevNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {\n                this.deleteNodeTail(startNode, startSplitPosInBuffer);\n                this.validateCRLFWithNextNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            this.shrinkNode(startNode, startSplitPosInBuffer, endSplitPosInBuffer);\n            this.computeBufferMetadata();\n            return;\n        }\n        const nodesToDel = [];\n        const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n        this.deleteNodeTail(startNode, startSplitPosInBuffer);\n        this._searchCache.validate(offset);\n        if (startNode.piece.length === 0) {\n            nodesToDel.push(startNode);\n        }\n        const endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);\n        this.deleteNodeHead(endNode, endSplitPosInBuffer);\n        if (endNode.piece.length === 0) {\n            nodesToDel.push(endNode);\n        }\n        const secondNode = startNode.next();\n        for (let node = secondNode; node !== SENTINEL && node !== endNode; node = node.next()) {\n            nodesToDel.push(node);\n        }\n        const prev = startNode.piece.length === 0 ? startNode.prev() : startNode;\n        this.deleteNodes(nodesToDel);\n        this.validateCRLFWithNextNode(prev);\n        this.computeBufferMetadata();\n    }\n    insertContentToNodeLeft(value, node) {\n        const nodesToDel = [];\n        if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {\n            const piece = node.piece;\n            const newStart = { line: piece.start.line + 1, column: 0 };\n            const nPiece = ( new Piece(\n                piece.bufferIndex,\n                newStart,\n                piece.end,\n                this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end),\n                piece.length - 1\n            ));\n            node.piece = nPiece;\n            value += '\\n';\n            updateTreeMetadata(this, node, -1, -1);\n            if (node.piece.length === 0) {\n                nodesToDel.push(node);\n            }\n        }\n        const newPieces = this.createNewPieces(value);\n        let newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);\n        for (let k = newPieces.length - 2; k >= 0; k--) {\n            newNode = this.rbInsertLeft(newNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n        this.deleteNodes(nodesToDel);\n    }\n    insertContentToNodeRight(value, node) {\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            value += '\\n';\n        }\n        const newPieces = this.createNewPieces(value);\n        const newNode = this.rbInsertRight(node, newPieces[0]);\n        let tmpNode = newNode;\n        for (let k = 1; k < newPieces.length; k++) {\n            tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    positionInBuffer(node, remainder, ret) {\n        const piece = node.piece;\n        const bufferIndex = node.piece.bufferIndex;\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        const startOffset = lineStarts[piece.start.line] + piece.start.column;\n        const offset = startOffset + remainder;\n        let low = piece.start.line;\n        let high = piece.end.line;\n        let mid = 0;\n        let midStop = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            midStart = lineStarts[mid];\n            if (mid === high) {\n                break;\n            }\n            midStop = lineStarts[mid + 1];\n            if (offset < midStart) {\n                high = mid - 1;\n            }\n            else if (offset >= midStop) {\n                low = mid + 1;\n            }\n            else {\n                break;\n            }\n        }\n        if (ret) {\n            ret.line = mid;\n            ret.column = offset - midStart;\n            return null;\n        }\n        return {\n            line: mid,\n            column: offset - midStart\n        };\n    }\n    getLineFeedCnt(bufferIndex, start, end) {\n        if (end.column === 0) {\n            return end.line - start.line;\n        }\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        if (end.line === lineStarts.length - 1) {\n            return end.line - start.line;\n        }\n        const nextLineStartOffset = lineStarts[end.line + 1];\n        const endOffset = lineStarts[end.line] + end.column;\n        if (nextLineStartOffset > endOffset + 1) {\n            return end.line - start.line;\n        }\n        const previousCharOffset = endOffset - 1;\n        const buffer = this._buffers[bufferIndex].buffer;\n        if (buffer.charCodeAt(previousCharOffset) === 13) {\n            return end.line - start.line + 1;\n        }\n        else {\n            return end.line - start.line;\n        }\n    }\n    offsetInBuffer(bufferIndex, cursor) {\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        return lineStarts[cursor.line] + cursor.column;\n    }\n    deleteNodes(nodes) {\n        for (let i = 0; i < nodes.length; i++) {\n            rbDelete(this, nodes[i]);\n        }\n    }\n    createNewPieces(text) {\n        if (text.length > AverageBufferSize) {\n            const newPieces = [];\n            while (text.length > AverageBufferSize) {\n                const lastChar = text.charCodeAt(AverageBufferSize - 1);\n                let splitText;\n                if (lastChar === 13  || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n                    splitText = text.substring(0, AverageBufferSize - 1);\n                    text = text.substring(AverageBufferSize - 1);\n                }\n                else {\n                    splitText = text.substring(0, AverageBufferSize);\n                    text = text.substring(AverageBufferSize);\n                }\n                const lineStarts = createLineStartsFast(splitText);\n                newPieces.push(( new Piece(\n                    this._buffers.length,\n                     { line: 0, column: 0 },\n                    { line: lineStarts.length - 1, column: splitText.length - lineStarts[lineStarts.length - 1] },\n                    lineStarts.length - 1,\n                    splitText.length\n                )));\n                this._buffers.push(( new StringBuffer(splitText, lineStarts)));\n            }\n            const lineStarts = createLineStartsFast(text);\n            newPieces.push(( new Piece(\n                this._buffers.length,\n                 { line: 0, column: 0 },\n                { line: lineStarts.length - 1, column: text.length - lineStarts[lineStarts.length - 1] },\n                lineStarts.length - 1,\n                text.length\n            )));\n            this._buffers.push(( new StringBuffer(text, lineStarts)));\n            return newPieces;\n        }\n        let startOffset = this._buffers[0].buffer.length;\n        const lineStarts = createLineStartsFast(text, false);\n        let start = this._lastChangeBufferPos;\n        if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset\n            && startOffset !== 0\n            && this.startWithLF(text)\n            && this.endWithCR(this._buffers[0].buffer)\n        ) {\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 };\n            start = this._lastChangeBufferPos;\n            for (let i = 0; i < lineStarts.length; i++) {\n                lineStarts[i] += startOffset + 1;\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += '_' + text;\n            startOffset += 1;\n        }\n        else {\n            if (startOffset !== 0) {\n                for (let i = 0; i < lineStarts.length; i++) {\n                    lineStarts[i] += startOffset;\n                }\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += text;\n        }\n        const endOffset = this._buffers[0].buffer.length;\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = endOffset - this._buffers[0].lineStarts[endIndex];\n        const endPos = { line: endIndex, column: endColumn };\n        const newPiece = ( new Piece(\n            0,\n             start,\n            endPos,\n            this.getLineFeedCnt(0, start, endPos),\n            endOffset - startOffset\n        ));\n        this._lastChangeBufferPos = endPos;\n        return [newPiece];\n    }\n    getLinesRawContent() {\n        return this.getContentOfSubTree(this.root);\n    }\n    getLineRawContent(lineNumber, endOffset = 0) {\n        let x = this.root;\n        let ret = '';\n        const cache = this._searchCache.get2(lineNumber);\n        if (cache) {\n            x = cache.node;\n            const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {\n                ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n            }\n            else {\n                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);\n                return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n            }\n        }\n        else {\n            let nodeStartOffset = 0;\n            const originalLineNumber = lineNumber;\n            while (x !== SENTINEL) {\n                if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                    x = x.left;\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    nodeStartOffset += x.size_left;\n                    this._searchCache.set({\n                        node: x,\n                        nodeStartOffset,\n                        nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)\n                    });\n                    return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n                    break;\n                }\n                else {\n                    lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                    nodeStartOffset += x.size_left + x.piece.length;\n                    x = x.right;\n                }\n            }\n        }\n        x = x.next();\n        while (x !== SENTINEL) {\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            if (x.piece.lineFeedCnt > 0) {\n                const accumulatedValue = this.getAccumulatedValue(x, 0);\n                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substring(startOffset, startOffset + accumulatedValue - endOffset);\n                return ret;\n            }\n            else {\n                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    computeBufferMetadata() {\n        let x = this.root;\n        let lfCnt = 1;\n        let len = 0;\n        while (x !== SENTINEL) {\n            lfCnt += x.lf_left + x.piece.lineFeedCnt;\n            len += x.size_left + x.piece.length;\n            x = x.right;\n        }\n        this._lineCnt = lfCnt;\n        this._length = len;\n        this._searchCache.validate(this._length);\n    }\n    getIndexOf(node, accumulatedValue) {\n        const piece = node.piece;\n        const pos = this.positionInBuffer(node, accumulatedValue);\n        const lineCnt = pos.line - piece.start.line;\n        if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {\n            const realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);\n            if (realLineCnt !== lineCnt) {\n                return { index: realLineCnt, remainder: 0 };\n            }\n        }\n        return { index: lineCnt, remainder: pos.column };\n    }\n    getAccumulatedValue(node, index) {\n        if (index < 0) {\n            return 0;\n        }\n        const piece = node.piece;\n        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        const expectedLineStartIndex = piece.start.line + index + 1;\n        if (expectedLineStartIndex > piece.end.line) {\n            return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;\n        }\n        else {\n            return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;\n        }\n    }\n    deleteNodeTail(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const newEnd = pos;\n        const newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = newEndOffset - originalEndOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = ( new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength));\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    deleteNodeHead(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const newStart = pos;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n        const newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = originalStartOffset - newStartOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = ( new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength));\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    shrinkNode(node, start, end) {\n        const piece = node.piece;\n        const originalStartPos = piece.start;\n        const originalEndPos = piece.end;\n        const oldLength = piece.length;\n        const oldLFCnt = piece.lineFeedCnt;\n        const newEnd = start;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);\n        node.piece = ( new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength));\n        updateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);\n        const newPiece = ( new Piece(\n            piece.bufferIndex,\n            end,\n            originalEndPos,\n            this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos),\n            this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end)\n        ));\n        const newNode = this.rbInsertRight(node, newPiece);\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    appendToNode(node, value) {\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            value += '\\n';\n        }\n        const hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);\n        const startOffset = this._buffers[0].buffer.length;\n        this._buffers[0].buffer += value;\n        const lineStarts = createLineStartsFast(value, false);\n        for (let i = 0; i < lineStarts.length; i++) {\n            lineStarts[i] += startOffset;\n        }\n        if (hitCRLF) {\n            const prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];\n            this._buffers[0].lineStarts.pop();\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: startOffset - prevStartOffset };\n        }\n        this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];\n        const newEnd = { line: endIndex, column: endColumn };\n        const newLength = node.piece.length + value.length;\n        const oldLineFeedCnt = node.piece.lineFeedCnt;\n        const newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - oldLineFeedCnt;\n        node.piece = ( new Piece(\n            node.piece.bufferIndex,\n            node.piece.start,\n            newEnd,\n            newLineFeedCnt,\n            newLength\n        ));\n        this._lastChangeBufferPos = newEnd;\n        updateTreeMetadata(this, node, value.length, lf_delta);\n    }\n    nodeAt(offset) {\n        let x = this.root;\n        const cache = this._searchCache.get(offset);\n        if (cache) {\n            return {\n                node: cache.node,\n                nodeStartOffset: cache.nodeStartOffset,\n                remainder: offset - cache.nodeStartOffset\n            };\n        }\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.size_left > offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                nodeStartOffset += x.size_left;\n                const ret = {\n                    node: x,\n                    remainder: offset - x.size_left,\n                    nodeStartOffset\n                };\n                this._searchCache.set(ret);\n                return ret;\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return null;\n    }\n    nodeAt2(lineNumber, column) {\n        let x = this.root;\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                nodeStartOffset += x.size_left;\n                return {\n                    node: x,\n                    remainder: Math.min(prevAccumualtedValue + column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                if (prevAccumualtedValue + column - 1 <= x.piece.length) {\n                    return {\n                        node: x,\n                        remainder: prevAccumualtedValue + column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length - prevAccumualtedValue;\n                    break;\n                }\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        x = x.next();\n        while (x !== SENTINEL) {\n            if (x.piece.lineFeedCnt > 0) {\n                const accumulatedValue = this.getAccumulatedValue(x, 0);\n                const nodeStartOffset = this.offsetOfNode(x);\n                return {\n                    node: x,\n                    remainder: Math.min(column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else {\n                if (x.piece.length >= column - 1) {\n                    const nodeStartOffset = this.offsetOfNode(x);\n                    return {\n                        node: x,\n                        remainder: column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length;\n                }\n            }\n            x = x.next();\n        }\n        return null;\n    }\n    nodeCharCodeAt(node, offset) {\n        if (node.piece.lineFeedCnt < 1) {\n            return -1;\n        }\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;\n        return buffer.buffer.charCodeAt(newOffset);\n    }\n    offsetOfNode(node) {\n        if (!node) {\n            return 0;\n        }\n        let pos = node.size_left;\n        while (node !== this.root) {\n            if (node.parent.right === node) {\n                pos += node.parent.size_left + node.parent.piece.length;\n            }\n            node = node.parent;\n        }\n        return pos;\n    }\n    shouldCheckCRLF() {\n        return !(this._EOLNormalized && this._EOL === '\\n');\n    }\n    startWithLF(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(0) === 10;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        const piece = val.piece;\n        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        const line = piece.start.line;\n        const startOffset = lineStarts[line] + piece.start.column;\n        if (line === lineStarts.length - 1) {\n            return false;\n        }\n        const nextLineOffset = lineStarts[line + 1];\n        if (nextLineOffset > startOffset + 1) {\n            return false;\n        }\n        return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;\n    }\n    endWithCR(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(val.length - 1) === 13;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;\n    }\n    validateCRLFWithPrevNode(nextNode) {\n        if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {\n            const node = nextNode.prev();\n            if (this.endWithCR(node)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    validateCRLFWithNextNode(node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(node)) {\n            const nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    fixCRLF(prev, next) {\n        const nodesToDel = [];\n        const lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;\n        let newEnd;\n        if (prev.piece.end.column === 0) {\n            newEnd = { line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1 };\n        }\n        else {\n            newEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };\n        }\n        const prevNewLength = prev.piece.length - 1;\n        const prevNewLFCnt = prev.piece.lineFeedCnt - 1;\n        prev.piece = ( new Piece(\n            prev.piece.bufferIndex,\n            prev.piece.start,\n            newEnd,\n            prevNewLFCnt,\n            prevNewLength\n        ));\n        updateTreeMetadata(this, prev, -1, -1);\n        if (prev.piece.length === 0) {\n            nodesToDel.push(prev);\n        }\n        const newStart = { line: next.piece.start.line + 1, column: 0 };\n        const newLength = next.piece.length - 1;\n        const newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);\n        next.piece = ( new Piece(\n            next.piece.bufferIndex,\n            newStart,\n            next.piece.end,\n            newLineFeedCnt,\n            newLength\n        ));\n        updateTreeMetadata(this, next, -1, -1);\n        if (next.piece.length === 0) {\n            nodesToDel.push(next);\n        }\n        const pieces = this.createNewPieces('\\r\\n');\n        this.rbInsertRight(prev, pieces[0]);\n        for (let i = 0; i < nodesToDel.length; i++) {\n            rbDelete(this, nodesToDel[i]);\n        }\n    }\n    adjustCarriageReturnFromNext(value, node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n            const nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                value += '\\n';\n                if (nextNode.piece.length === 1) {\n                    rbDelete(this, nextNode);\n                }\n                else {\n                    const piece = nextNode.piece;\n                    const newStart = { line: piece.start.line + 1, column: 0 };\n                    const newLength = piece.length - 1;\n                    const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n                    nextNode.piece = ( new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength));\n                    updateTreeMetadata(this, nextNode, -1, -1);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    iterate(node, callback) {\n        if (node === SENTINEL) {\n            return callback(SENTINEL);\n        }\n        const leftRet = this.iterate(node.left, callback);\n        if (!leftRet) {\n            return leftRet;\n        }\n        return callback(node) && this.iterate(node.right, callback);\n    }\n    getNodeContent(node) {\n        if (node === SENTINEL) {\n            return '';\n        }\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const piece = node.piece;\n        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    getPieceContent(piece) {\n        const buffer = this._buffers[piece.bufferIndex];\n        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    rbInsertRight(node, p) {\n        const z = ( new TreeNode(p, 1 ));\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        const x = this.root;\n        if (x === SENTINEL) {\n            this.root = z;\n            z.color = 0 ;\n        }\n        else if (node.right === SENTINEL) {\n            node.right = z;\n            z.parent = node;\n        }\n        else {\n            const nextNode = leftest(node.right);\n            nextNode.left = z;\n            z.parent = nextNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n    rbInsertLeft(node, p) {\n        const z = ( new TreeNode(p, 1 ));\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        if (this.root === SENTINEL) {\n            this.root = z;\n            z.color = 0 ;\n        }\n        else if (node.left === SENTINEL) {\n            node.left = z;\n            z.parent = node;\n        }\n        else {\n            const prevNode = righttest(node.left);\n            prevNode.right = z;\n            z.parent = prevNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n    getContentOfSubTree(node) {\n        let str = '';\n        this.iterate(node, node => {\n            str += this.getNodeContent(node);\n            return true;\n        });\n        return str;\n    }\n}\nexport { Piece, PieceTreeBase, StringBuffer, createLineStarts, createLineStartsFast };\n","import { Emitter } from '../../../../base/common/event.js';\nimport { isHighSurrogate, firstNonWhitespaceIndex, lastNonWhitespaceIndex, containsRTL, isBasicASCII, containsUnusualLineTerminators } from '../../../../base/common/strings.js';\nimport { Range } from '../../core/range.js';\nimport { ApplyEditsResult } from '../../model.js';\nimport { PieceTreeBase } from './pieceTreeBase.js';\nimport { countEOL } from '../../core/eolCounter.js';\nimport { TextChange } from '../../core/textChange.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nclass PieceTreeTextBuffer extends Disposable {\n    constructor(chunks, BOM, eol, containsRTL, containsUnusualLineTerminators, isBasicASCII, eolNormalized) {\n        super();\n        this._onDidChangeContent = this._register(( new Emitter()));\n        this.onDidChangeContent = this._onDidChangeContent.event;\n        this._BOM = BOM;\n        this._mightContainNonBasicASCII = !isBasicASCII;\n        this._mightContainRTL = containsRTL;\n        this._mightContainUnusualLineTerminators = containsUnusualLineTerminators;\n        this._pieceTree = ( new PieceTreeBase(chunks, eol, eolNormalized));\n    }\n    equals(other) {\n        if (!(other instanceof PieceTreeTextBuffer)) {\n            return false;\n        }\n        if (this._BOM !== other._BOM) {\n            return false;\n        }\n        if (this.getEOL() !== other.getEOL()) {\n            return false;\n        }\n        return this._pieceTree.equal(other._pieceTree);\n    }\n    mightContainRTL() {\n        return this._mightContainRTL;\n    }\n    mightContainUnusualLineTerminators() {\n        return this._mightContainUnusualLineTerminators;\n    }\n    resetMightContainUnusualLineTerminators() {\n        this._mightContainUnusualLineTerminators = false;\n    }\n    mightContainNonBasicASCII() {\n        return this._mightContainNonBasicASCII;\n    }\n    getBOM() {\n        return this._BOM;\n    }\n    getEOL() {\n        return this._pieceTree.getEOL();\n    }\n    createSnapshot(preserveBOM) {\n        return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\n    }\n    getOffsetAt(lineNumber, column) {\n        return this._pieceTree.getOffsetAt(lineNumber, column);\n    }\n    getPositionAt(offset) {\n        return this._pieceTree.getPositionAt(offset);\n    }\n    getRangeAt(start, length) {\n        const end = start + length;\n        const startPosition = this.getPositionAt(start);\n        const endPosition = this.getPositionAt(end);\n        return ( new Range(\n            startPosition.lineNumber,\n            startPosition.column,\n            endPosition.lineNumber,\n            endPosition.column\n        ));\n    }\n    getValueInRange(range, eol = 0 ) {\n        if (range.isEmpty()) {\n            return '';\n        }\n        const lineEnding = this._getEndOfLine(eol);\n        return this._pieceTree.getValueInRange(range, lineEnding);\n    }\n    getValueLengthInRange(range, eol = 0 ) {\n        if (range.isEmpty()) {\n            return 0;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            return (range.endColumn - range.startColumn);\n        }\n        const startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n        let eolOffsetCompensation = 0;\n        const desiredEOL = this._getEndOfLine(eol);\n        const actualEOL = this.getEOL();\n        if (desiredEOL.length !== actualEOL.length) {\n            const delta = desiredEOL.length - actualEOL.length;\n            const eolCount = range.endLineNumber - range.startLineNumber;\n            eolOffsetCompensation = delta * eolCount;\n        }\n        return endOffset - startOffset + eolOffsetCompensation;\n    }\n    getCharacterCountInRange(range, eol = 0 ) {\n        if (this._mightContainNonBasicASCII) {\n            let result = 0;\n            const fromLineNumber = range.startLineNumber;\n            const toLineNumber = range.endLineNumber;\n            for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n                const lineContent = this.getLineContent(lineNumber);\n                const fromOffset = (lineNumber === fromLineNumber ? range.startColumn - 1 : 0);\n                const toOffset = (lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length);\n                for (let offset = fromOffset; offset < toOffset; offset++) {\n                    if (isHighSurrogate(lineContent.charCodeAt(offset))) {\n                        result = result + 1;\n                        offset = offset + 1;\n                    }\n                    else {\n                        result = result + 1;\n                    }\n                }\n            }\n            result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\n            return result;\n        }\n        return this.getValueLengthInRange(range, eol);\n    }\n    getNearestChunk(offset) {\n        return this._pieceTree.getNearestChunk(offset);\n    }\n    getLength() {\n        return this._pieceTree.getLength();\n    }\n    getLineCount() {\n        return this._pieceTree.getLineCount();\n    }\n    getLinesContent() {\n        return this._pieceTree.getLinesContent();\n    }\n    getLineContent(lineNumber) {\n        return this._pieceTree.getLineContent(lineNumber);\n    }\n    getLineCharCode(lineNumber, index) {\n        return this._pieceTree.getLineCharCode(lineNumber, index);\n    }\n    getCharCode(offset) {\n        return this._pieceTree.getCharCode(offset);\n    }\n    getLineLength(lineNumber) {\n        return this._pieceTree.getLineLength(lineNumber);\n    }\n    getLineMinColumn(lineNumber) {\n        return 1;\n    }\n    getLineMaxColumn(lineNumber) {\n        return this.getLineLength(lineNumber) + 1;\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        const result = firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 1;\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        const result = lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 2;\n    }\n    _getEndOfLine(eol) {\n        switch (eol) {\n            case 1 :\n                return '\\n';\n            case 2 :\n                return '\\r\\n';\n            case 0 :\n                return this.getEOL();\n            default:\n                throw ( new Error('Unknown EOL preference'));\n        }\n    }\n    setEOL(newEOL) {\n        this._pieceTree.setEOL(newEOL);\n    }\n    applyEdits(rawOperations, recordTrimAutoWhitespace, computeUndoEdits) {\n        let mightContainRTL = this._mightContainRTL;\n        let mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;\n        let mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n        let canReduceOperations = true;\n        let operations = [];\n        for (let i = 0; i < rawOperations.length; i++) {\n            const op = rawOperations[i];\n            if (canReduceOperations && op._isTracked) {\n                canReduceOperations = false;\n            }\n            const validatedRange = op.range;\n            if (op.text) {\n                let textMightContainNonBasicASCII = true;\n                if (!mightContainNonBasicASCII) {\n                    textMightContainNonBasicASCII = !isBasicASCII(op.text);\n                    mightContainNonBasicASCII = textMightContainNonBasicASCII;\n                }\n                if (!mightContainRTL && textMightContainNonBasicASCII) {\n                    mightContainRTL = containsRTL(op.text);\n                }\n                if (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {\n                    mightContainUnusualLineTerminators = containsUnusualLineTerminators(op.text);\n                }\n            }\n            let validText = '';\n            let eolCount = 0;\n            let firstLineLength = 0;\n            let lastLineLength = 0;\n            if (op.text) {\n                let strEOL;\n                [eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);\n                const bufferEOL = this.getEOL();\n                const expectedStrEOL = ((bufferEOL === '\\r\\n' ? 2  : 1) );\n                if (strEOL === 0  || strEOL === expectedStrEOL) {\n                    validText = op.text;\n                }\n                else {\n                    validText = op.text.replace(/\\r\\n|\\r|\\n/g, bufferEOL);\n                }\n            }\n            operations[i] = {\n                sortIndex: i,\n                identifier: op.identifier || null,\n                range: validatedRange,\n                rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n                rangeLength: this.getValueLengthInRange(validatedRange),\n                text: validText,\n                eolCount: eolCount,\n                firstLineLength: firstLineLength,\n                lastLineLength: lastLineLength,\n                forceMoveMarkers: Boolean(op.forceMoveMarkers),\n                isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n            };\n        }\n        operations.sort(PieceTreeTextBuffer._sortOpsAscending);\n        let hasTouchingRanges = false;\n        for (let i = 0, count = operations.length - 1; i < count; i++) {\n            const rangeEnd = operations[i].range.getEndPosition();\n            const nextRangeStart = operations[i + 1].range.getStartPosition();\n            if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n                if (nextRangeStart.isBefore(rangeEnd)) {\n                    throw ( new Error('Overlapping ranges are not allowed!'));\n                }\n                hasTouchingRanges = true;\n            }\n        }\n        if (canReduceOperations) {\n            operations = this._reduceOperations(operations);\n        }\n        const reverseRanges = (computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : []);\n        const newTrimAutoWhitespaceCandidates = [];\n        if (recordTrimAutoWhitespace) {\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                if (op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n                    for (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n                        let currentLineContent = '';\n                        if (lineNumber === reverseRange.startLineNumber) {\n                            currentLineContent = this.getLineContent(op.range.startLineNumber);\n                            if (firstNonWhitespaceIndex(currentLineContent) !== -1) {\n                                continue;\n                            }\n                        }\n                        newTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });\n                    }\n                }\n            }\n        }\n        let reverseOperations = null;\n        if (computeUndoEdits) {\n            let reverseRangeDeltaOffset = 0;\n            reverseOperations = [];\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                const bufferText = this.getValueInRange(op.range);\n                const reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;\n                reverseRangeDeltaOffset += (op.text.length - bufferText.length);\n                reverseOperations[i] = {\n                    sortIndex: op.sortIndex,\n                    identifier: op.identifier,\n                    range: reverseRange,\n                    text: bufferText,\n                    textChange: ( new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text))\n                };\n            }\n            if (!hasTouchingRanges) {\n                reverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);\n            }\n        }\n        this._mightContainRTL = mightContainRTL;\n        this._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;\n        this._mightContainNonBasicASCII = mightContainNonBasicASCII;\n        const contentChanges = this._doApplyEdits(operations);\n        let trimAutoWhitespaceLineNumbers = null;\n        if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n            newTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);\n            trimAutoWhitespaceLineNumbers = [];\n            for (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n                const lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n                if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n                    continue;\n                }\n                const prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n                const lineContent = this.getLineContent(lineNumber);\n                if (lineContent.length === 0 || lineContent === prevContent || firstNonWhitespaceIndex(lineContent) !== -1) {\n                    continue;\n                }\n                trimAutoWhitespaceLineNumbers.push(lineNumber);\n            }\n        }\n        this._onDidChangeContent.fire();\n        return ( new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers));\n    }\n    _reduceOperations(operations) {\n        if (operations.length < 1000) {\n            return operations;\n        }\n        return [this._toSingleEditOperation(operations)];\n    }\n    _toSingleEditOperation(operations) {\n        let forceMoveMarkers = false;\n        const firstEditRange = operations[0].range;\n        const lastEditRange = operations[operations.length - 1].range;\n        const entireEditRange = ( new Range(\n            firstEditRange.startLineNumber,\n            firstEditRange.startColumn,\n            lastEditRange.endLineNumber,\n            lastEditRange.endColumn\n        ));\n        let lastEndLineNumber = firstEditRange.startLineNumber;\n        let lastEndColumn = firstEditRange.startColumn;\n        const result = [];\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const operation = operations[i];\n            const range = operation.range;\n            forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\n            result.push(this.getValueInRange(( new Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn))));\n            if (operation.text.length > 0) {\n                result.push(operation.text);\n            }\n            lastEndLineNumber = range.endLineNumber;\n            lastEndColumn = range.endColumn;\n        }\n        const text = result.join('');\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n        return {\n            sortIndex: 0,\n            identifier: operations[0].identifier,\n            range: entireEditRange,\n            rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n            rangeLength: this.getValueLengthInRange(entireEditRange, 0 ),\n            text: text,\n            eolCount: eolCount,\n            firstLineLength: firstLineLength,\n            lastLineLength: lastLineLength,\n            forceMoveMarkers: forceMoveMarkers,\n            isAutoWhitespaceEdit: false\n        };\n    }\n    _doApplyEdits(operations) {\n        operations.sort(PieceTreeTextBuffer._sortOpsDescending);\n        const contentChanges = [];\n        for (let i = 0; i < operations.length; i++) {\n            const op = operations[i];\n            const startLineNumber = op.range.startLineNumber;\n            const startColumn = op.range.startColumn;\n            const endLineNumber = op.range.endLineNumber;\n            const endColumn = op.range.endColumn;\n            if (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {\n                continue;\n            }\n            if (op.text) {\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n                this._pieceTree.insert(op.rangeOffset, op.text, true);\n            }\n            else {\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n            }\n            const contentChangeRange = ( new Range(startLineNumber, startColumn, endLineNumber, endColumn));\n            contentChanges.push({\n                range: contentChangeRange,\n                rangeLength: op.rangeLength,\n                text: op.text,\n                rangeOffset: op.rangeOffset,\n                forceMoveMarkers: op.forceMoveMarkers\n            });\n        }\n        return contentChanges;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    getPieceTree() {\n        return this._pieceTree;\n    }\n    static _getInverseEditRange(range, text) {\n        const startLineNumber = range.startLineNumber;\n        const startColumn = range.startColumn;\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n        let resultRange;\n        if (text.length > 0) {\n            const lineCount = eolCount + 1;\n            if (lineCount === 1) {\n                resultRange = ( new Range(\n                    startLineNumber,\n                    startColumn,\n                    startLineNumber,\n                    startColumn + firstLineLength\n                ));\n            }\n            else {\n                resultRange = ( new Range(\n                    startLineNumber,\n                    startColumn,\n                    startLineNumber + lineCount - 1,\n                    lastLineLength + 1\n                ));\n            }\n        }\n        else {\n            resultRange = ( new Range(startLineNumber, startColumn, startLineNumber, startColumn));\n        }\n        return resultRange;\n    }\n    static _getInverseEditRanges(operations) {\n        const result = [];\n        let prevOpEndLineNumber = 0;\n        let prevOpEndColumn = 0;\n        let prevOp = null;\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const op = operations[i];\n            let startLineNumber;\n            let startColumn;\n            if (prevOp) {\n                if (prevOp.range.endLineNumber === op.range.startLineNumber) {\n                    startLineNumber = prevOpEndLineNumber;\n                    startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n                }\n                else {\n                    startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n                    startColumn = op.range.startColumn;\n                }\n            }\n            else {\n                startLineNumber = op.range.startLineNumber;\n                startColumn = op.range.startColumn;\n            }\n            let resultRange;\n            if (op.text.length > 0) {\n                const lineCount = op.eolCount + 1;\n                if (lineCount === 1) {\n                    resultRange = ( new Range(\n                        startLineNumber,\n                        startColumn,\n                        startLineNumber,\n                        startColumn + op.firstLineLength\n                    ));\n                }\n                else {\n                    resultRange = ( new Range(\n                        startLineNumber,\n                        startColumn,\n                        startLineNumber + lineCount - 1,\n                        op.lastLineLength + 1\n                    ));\n                }\n            }\n            else {\n                resultRange = ( new Range(startLineNumber, startColumn, startLineNumber, startColumn));\n            }\n            prevOpEndLineNumber = resultRange.endLineNumber;\n            prevOpEndColumn = resultRange.endColumn;\n            result.push(resultRange);\n            prevOp = op;\n        }\n        return result;\n    }\n    static _sortOpsAscending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return a.sortIndex - b.sortIndex;\n        }\n        return r;\n    }\n    static _sortOpsDescending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return b.sortIndex - a.sortIndex;\n        }\n        return -r;\n    }\n}\nexport { PieceTreeTextBuffer };\n","import { startsWithUTF8BOM, UTF8_BOM_CHARACTER, containsRTL, containsUnusualLineTerminators } from '../../../../base/common/strings.js';\nimport { createLineStarts, StringBuffer, createLineStartsFast } from './pieceTreeBase.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer.js';\nclass PieceTreeTextBufferFactory {\n    constructor(_chunks, _bom, _cr, _lf, _crlf, _containsRTL, _containsUnusualLineTerminators, _isBasicASCII, _normalizeEOL) {\n        this._chunks = _chunks;\n        this._bom = _bom;\n        this._cr = _cr;\n        this._lf = _lf;\n        this._crlf = _crlf;\n        this._containsRTL = _containsRTL;\n        this._containsUnusualLineTerminators = _containsUnusualLineTerminators;\n        this._isBasicASCII = _isBasicASCII;\n        this._normalizeEOL = _normalizeEOL;\n    }\n    _getEOL(defaultEOL) {\n        const totalEOLCount = this._cr + this._lf + this._crlf;\n        const totalCRCount = this._cr + this._crlf;\n        if (totalEOLCount === 0) {\n            return (defaultEOL === 1  ? '\\n' : '\\r\\n');\n        }\n        if (totalCRCount > totalEOLCount / 2) {\n            return '\\r\\n';\n        }\n        return '\\n';\n    }\n    create(defaultEOL) {\n        const eol = this._getEOL(defaultEOL);\n        const chunks = this._chunks;\n        if (this._normalizeEOL &&\n            ((eol === '\\r\\n' && (this._cr > 0 || this._lf > 0))\n                || (eol === '\\n' && (this._cr > 0 || this._crlf > 0)))) {\n            for (let i = 0, len = chunks.length; i < len; i++) {\n                const str = chunks[i].buffer.replace(/\\r\\n|\\r|\\n/g, eol);\n                const newLineStart = createLineStartsFast(str);\n                chunks[i] = ( new StringBuffer(str, newLineStart));\n            }\n        }\n        const textBuffer = ( new PieceTreeTextBuffer(\n            chunks,\n            this._bom,\n            eol,\n            this._containsRTL,\n            this._containsUnusualLineTerminators,\n            this._isBasicASCII,\n            this._normalizeEOL\n        ));\n        return { textBuffer: textBuffer, disposable: textBuffer };\n    }\n    getFirstLineText(lengthLimit) {\n        return this._chunks[0].buffer.substr(0, lengthLimit).split(/\\r\\n|\\r|\\n/)[0];\n    }\n}\nclass PieceTreeTextBufferBuilder {\n    constructor() {\n        this.chunks = [];\n        this.BOM = '';\n        this._hasPreviousChar = false;\n        this._previousChar = 0;\n        this._tmpLineStarts = [];\n        this.cr = 0;\n        this.lf = 0;\n        this.crlf = 0;\n        this.containsRTL = false;\n        this.containsUnusualLineTerminators = false;\n        this.isBasicASCII = true;\n    }\n    acceptChunk(chunk) {\n        if (chunk.length === 0) {\n            return;\n        }\n        if (this.chunks.length === 0) {\n            if (startsWithUTF8BOM(chunk)) {\n                this.BOM = UTF8_BOM_CHARACTER;\n                chunk = chunk.substr(1);\n            }\n        }\n        const lastChar = chunk.charCodeAt(chunk.length - 1);\n        if (lastChar === 13  || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n            this._acceptChunk1(chunk.substr(0, chunk.length - 1), false);\n            this._hasPreviousChar = true;\n            this._previousChar = lastChar;\n        }\n        else {\n            this._acceptChunk1(chunk, false);\n            this._hasPreviousChar = false;\n            this._previousChar = lastChar;\n        }\n    }\n    _acceptChunk1(chunk, allowEmptyStrings) {\n        if (!allowEmptyStrings && chunk.length === 0) {\n            return;\n        }\n        if (this._hasPreviousChar) {\n            this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);\n        }\n        else {\n            this._acceptChunk2(chunk);\n        }\n    }\n    _acceptChunk2(chunk) {\n        const lineStarts = createLineStarts(this._tmpLineStarts, chunk);\n        this.chunks.push(( new StringBuffer(chunk, lineStarts.lineStarts)));\n        this.cr += lineStarts.cr;\n        this.lf += lineStarts.lf;\n        this.crlf += lineStarts.crlf;\n        if (!lineStarts.isBasicASCII) {\n            this.isBasicASCII = false;\n            if (!this.containsRTL) {\n                this.containsRTL = containsRTL(chunk);\n            }\n            if (!this.containsUnusualLineTerminators) {\n                this.containsUnusualLineTerminators = containsUnusualLineTerminators(chunk);\n            }\n        }\n    }\n    finish(normalizeEOL = true) {\n        this._finish();\n        return ( new PieceTreeTextBufferFactory(\n            this.chunks,\n            this.BOM,\n            this.cr,\n            this.lf,\n            this.crlf,\n            this.containsRTL,\n            this.containsUnusualLineTerminators,\n            this.isBasicASCII,\n            normalizeEOL\n        ));\n    }\n    _finish() {\n        if (this.chunks.length === 0) {\n            this._acceptChunk1('', true);\n        }\n        if (this._hasPreviousChar) {\n            this._hasPreviousChar = false;\n            const lastChunk = this.chunks[this.chunks.length - 1];\n            lastChunk.buffer += String.fromCharCode(this._previousChar);\n            const newLineStarts = createLineStartsFast(lastChunk.buffer);\n            lastChunk.lineStarts = newLineStarts;\n            if (this._previousChar === 13 ) {\n                this.cr++;\n            }\n        }\n    }\n}\nexport { PieceTreeTextBufferBuilder };\n","class TreeNode {\n    constructor(piece, color) {\n        this.piece = piece;\n        this.color = color;\n        this.size_left = 0;\n        this.lf_left = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n    }\n    next() {\n        if (this.right !== SENTINEL) {\n            return leftest(this.right);\n        }\n        let node = this;\n        while (node.parent !== SENTINEL) {\n            if (node.parent.left === node) {\n                break;\n            }\n            node = node.parent;\n        }\n        if (node.parent === SENTINEL) {\n            return SENTINEL;\n        }\n        else {\n            return node.parent;\n        }\n    }\n    prev() {\n        if (this.left !== SENTINEL) {\n            return righttest(this.left);\n        }\n        let node = this;\n        while (node.parent !== SENTINEL) {\n            if (node.parent.right === node) {\n                break;\n            }\n            node = node.parent;\n        }\n        if (node.parent === SENTINEL) {\n            return SENTINEL;\n        }\n        else {\n            return node.parent;\n        }\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nconst SENTINEL = ( new TreeNode(null, 0 ));\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nSENTINEL.color = 0 ;\nfunction leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nfunction righttest(node) {\n    while (node.right !== SENTINEL) {\n        node = node.right;\n    }\n    return node;\n}\nfunction calculateSize(node) {\n    if (node === SENTINEL) {\n        return 0;\n    }\n    return node.size_left + node.piece.length + calculateSize(node.right);\n}\nfunction calculateLF(node) {\n    if (node === SENTINEL) {\n        return 0;\n    }\n    return node.lf_left + node.piece.lineFeedCnt + calculateLF(node.right);\n}\nfunction resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n}\nfunction leftRotate(tree, x) {\n    const y = x.right;\n    y.size_left += x.size_left + (x.piece ? x.piece.length : 0);\n    y.lf_left += x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n    x.right = y.left;\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent;\n    if (x.parent === SENTINEL) {\n        tree.root = y;\n    }\n    else if (x.parent.left === x) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x;\n    x.parent = y;\n}\nfunction rightRotate(tree, y) {\n    const x = y.left;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    y.size_left -= x.size_left + (x.piece ? x.piece.length : 0);\n    y.lf_left -= x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n    if (y.parent === SENTINEL) {\n        tree.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n}\nfunction rbDelete(tree, z) {\n    let x;\n    let y;\n    if (z.left === SENTINEL) {\n        y = z;\n        x = y.right;\n    }\n    else if (z.right === SENTINEL) {\n        y = z;\n        x = y.left;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n    }\n    if (y === tree.root) {\n        tree.root = x;\n        x.color = 0 ;\n        z.detach();\n        resetSentinel();\n        tree.root.parent = SENTINEL;\n        return;\n    }\n    const yWasRed = ((y.color === 1) );\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n        recomputeTreeMetadata(tree, x);\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        recomputeTreeMetadata(tree, x);\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        y.color = z.color;\n        if (z === tree.root) {\n            tree.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n        y.size_left = z.size_left;\n        y.lf_left = z.lf_left;\n        recomputeTreeMetadata(tree, y);\n    }\n    z.detach();\n    if (x.parent.left === x) {\n        const newSizeLeft = calculateSize(x);\n        const newLFLeft = calculateLF(x);\n        if (newSizeLeft !== x.parent.size_left || newLFLeft !== x.parent.lf_left) {\n            const delta = newSizeLeft - x.parent.size_left;\n            const lf_delta = newLFLeft - x.parent.lf_left;\n            x.parent.size_left = newSizeLeft;\n            x.parent.lf_left = newLFLeft;\n            updateTreeMetadata(tree, x.parent, delta, lf_delta);\n        }\n    }\n    recomputeTreeMetadata(tree, x.parent);\n    if (yWasRed) {\n        resetSentinel();\n        return;\n    }\n    let w;\n    while (x !== tree.root && x.color === 0 ) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (w.color === 1 ) {\n                w.color = 0 ;\n                x.parent.color = 1 ;\n                leftRotate(tree, x.parent);\n                w = x.parent.right;\n            }\n            if (w.left.color === 0  && w.right.color === 0 ) {\n                w.color = 1 ;\n                x = x.parent;\n            }\n            else {\n                if (w.right.color === 0 ) {\n                    w.left.color = 0 ;\n                    w.color = 1 ;\n                    rightRotate(tree, w);\n                    w = x.parent.right;\n                }\n                w.color = x.parent.color;\n                x.parent.color = 0 ;\n                w.right.color = 0 ;\n                leftRotate(tree, x.parent);\n                x = tree.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (w.color === 1 ) {\n                w.color = 0 ;\n                x.parent.color = 1 ;\n                rightRotate(tree, x.parent);\n                w = x.parent.left;\n            }\n            if (w.left.color === 0  && w.right.color === 0 ) {\n                w.color = 1 ;\n                x = x.parent;\n            }\n            else {\n                if (w.left.color === 0 ) {\n                    w.right.color = 0 ;\n                    w.color = 1 ;\n                    leftRotate(tree, w);\n                    w = x.parent.left;\n                }\n                w.color = x.parent.color;\n                x.parent.color = 0 ;\n                w.left.color = 0 ;\n                rightRotate(tree, x.parent);\n                x = tree.root;\n            }\n        }\n    }\n    x.color = 0 ;\n    resetSentinel();\n}\nfunction fixInsert(tree, x) {\n    recomputeTreeMetadata(tree, x);\n    while (x !== tree.root && x.parent.color === 1 ) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (y.color === 1 ) {\n                x.parent.color = 0 ;\n                y.color = 0 ;\n                x.parent.parent.color = 1 ;\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(tree, x);\n                }\n                x.parent.color = 0 ;\n                x.parent.parent.color = 1 ;\n                rightRotate(tree, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (y.color === 1 ) {\n                x.parent.color = 0 ;\n                y.color = 0 ;\n                x.parent.parent.color = 1 ;\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(tree, x);\n                }\n                x.parent.color = 0 ;\n                x.parent.parent.color = 1 ;\n                leftRotate(tree, x.parent.parent);\n            }\n        }\n    }\n    tree.root.color = 0 ;\n}\nfunction updateTreeMetadata(tree, x, delta, lineFeedCntDelta) {\n    while (x !== tree.root && x !== SENTINEL) {\n        if (x.parent.left === x) {\n            x.parent.size_left += delta;\n            x.parent.lf_left += lineFeedCntDelta;\n        }\n        x = x.parent;\n    }\n}\nfunction recomputeTreeMetadata(tree, x) {\n    let delta = 0;\n    let lf_delta = 0;\n    if (x === tree.root) {\n        return;\n    }\n    while (x !== tree.root && x === x.parent.right) {\n        x = x.parent;\n    }\n    if (x === tree.root) {\n        return;\n    }\n    x = x.parent;\n    delta = calculateSize(x.left) - x.size_left;\n    lf_delta = calculateLF(x.left) - x.lf_left;\n    x.size_left += delta;\n    x.lf_left += lf_delta;\n    while (x !== tree.root && (delta !== 0 || lf_delta !== 0)) {\n        if (x.parent.left === x) {\n            x.parent.size_left += delta;\n            x.parent.lf_left += lf_delta;\n        }\n        x = x.parent;\n    }\n}\nexport { SENTINEL, TreeNode, fixInsert, leftRotate, leftest, rbDelete, recomputeTreeMetadata, rightRotate, righttest, updateTreeMetadata };\n","import { VSBuffer } from '../../../base/common/buffer.js';\nimport { isLittleEndian } from '../../../base/common/platform.js';\nfunction reverseEndianness(arr) {\n    for (let i = 0, len = arr.length; i < len; i += 4) {\n        const b0 = arr[i + 0];\n        const b1 = arr[i + 1];\n        const b2 = arr[i + 2];\n        const b3 = arr[i + 3];\n        arr[i + 0] = b3;\n        arr[i + 1] = b2;\n        arr[i + 2] = b1;\n        arr[i + 3] = b0;\n    }\n}\nfunction toLittleEndianBuffer(arr) {\n    const uint8Arr = ( new Uint8Array(arr.buffer, arr.byteOffset, arr.length * 4));\n    if (!isLittleEndian()) {\n        reverseEndianness(uint8Arr);\n    }\n    return VSBuffer.wrap(uint8Arr);\n}\nfunction fromLittleEndianBuffer(buff) {\n    const uint8Arr = buff.buffer;\n    if (!isLittleEndian()) {\n        reverseEndianness(uint8Arr);\n    }\n    if (uint8Arr.byteOffset % 4 === 0) {\n        return ( new Uint32Array(uint8Arr.buffer, uint8Arr.byteOffset, uint8Arr.length / 4));\n    }\n    else {\n        const data = ( new Uint8Array(uint8Arr.byteLength));\n        data.set(uint8Arr);\n        return ( new Uint32Array(data.buffer, data.byteOffset, data.length / 4));\n    }\n}\nfunction encodeSemanticTokensDto(semanticTokens) {\n    const dest = ( new Uint32Array(encodeSemanticTokensDtoSize(semanticTokens)));\n    let offset = 0;\n    dest[offset++] = semanticTokens.id;\n    if (semanticTokens.type === 'full') {\n        dest[offset++] = 1 ;\n        dest[offset++] = semanticTokens.data.length;\n        dest.set(semanticTokens.data, offset);\n        offset += semanticTokens.data.length;\n    }\n    else {\n        dest[offset++] = 2 ;\n        dest[offset++] = semanticTokens.deltas.length;\n        for (const delta of semanticTokens.deltas) {\n            dest[offset++] = delta.start;\n            dest[offset++] = delta.deleteCount;\n            if (delta.data) {\n                dest[offset++] = delta.data.length;\n                dest.set(delta.data, offset);\n                offset += delta.data.length;\n            }\n            else {\n                dest[offset++] = 0;\n            }\n        }\n    }\n    return toLittleEndianBuffer(dest);\n}\nfunction encodeSemanticTokensDtoSize(semanticTokens) {\n    let result = 0;\n    result += ((\n    +1 + 1)\n    );\n    if (semanticTokens.type === 'full') {\n        result += (+1\n            + semanticTokens.data.length);\n    }\n    else {\n        result += ((+1)\n        );\n        result += ((\n        +1\n            + 1 + 1)\n        ) * semanticTokens.deltas.length;\n        for (const delta of semanticTokens.deltas) {\n            if (delta.data) {\n                result += delta.data.length;\n            }\n        }\n    }\n    return result;\n}\nfunction decodeSemanticTokensDto(_buff) {\n    const src = fromLittleEndianBuffer(_buff);\n    let offset = 0;\n    const id = src[offset++];\n    const type = src[offset++];\n    if (type === 1 ) {\n        const length = src[offset++];\n        const data = src.subarray(offset, offset + length);\n        offset += length;\n        return {\n            id: id,\n            type: 'full',\n            data: data\n        };\n    }\n    const deltaCount = src[offset++];\n    const deltas = [];\n    for (let i = 0; i < deltaCount; i++) {\n        const start = src[offset++];\n        const deleteCount = src[offset++];\n        const length = src[offset++];\n        let data;\n        if (length > 0) {\n            data = src.subarray(offset, offset + length);\n            offset += length;\n        }\n        deltas[i] = { start, deleteCount, data };\n    }\n    return {\n        id: id,\n        type: 'delta',\n        deltas: deltas\n    };\n}\nexport { decodeSemanticTokensDto, encodeSemanticTokensDto };\n","class TreeViewsDnDService {\n    constructor() {\n        this._dragOperations = ( new Map());\n    }\n    removeDragOperationTransfer(uuid) {\n        if ((uuid && ( this._dragOperations.has(uuid)))) {\n            const operation = this._dragOperations.get(uuid);\n            this._dragOperations.delete(uuid);\n            return operation;\n        }\n        return undefined;\n    }\n    addDragOperationTransfer(uuid, transferPromise) {\n        this._dragOperations.set(uuid, transferPromise);\n    }\n}\nclass DraggedTreeItemsIdentifier {\n    constructor(identifier) {\n        this.identifier = identifier;\n    }\n}\nexport { DraggedTreeItemsIdentifier, TreeViewsDnDService };\n","import { URI } from '../../../base/common/uri.js';\nfunction isConfigurationOverrides(thing) {\n    return thing\n        && typeof thing === 'object'\n        && (!thing.overrideIdentifier || typeof thing.overrideIdentifier === 'string')\n        && (!thing.resource || thing.resource instanceof URI);\n}\nfunction isConfigurationUpdateOverrides(thing) {\n    return thing\n        && typeof thing === 'object'\n        && (!thing.overrideIdentifiers || Array.isArray(thing.overrideIdentifiers))\n        && !thing.overrideIdentifier\n        && (!thing.resource || thing.resource instanceof URI);\n}\nvar ConfigurationTarget;\n( (function(ConfigurationTarget) {\n    ConfigurationTarget[ConfigurationTarget[\"APPLICATION\"] = 1] = \"APPLICATION\";\n    ConfigurationTarget[ConfigurationTarget[\"USER\"] = 2] = \"USER\";\n    ConfigurationTarget[ConfigurationTarget[\"USER_LOCAL\"] = 3] = \"USER_LOCAL\";\n    ConfigurationTarget[ConfigurationTarget[\"USER_REMOTE\"] = 4] = \"USER_REMOTE\";\n    ConfigurationTarget[ConfigurationTarget[\"WORKSPACE\"] = 5] = \"WORKSPACE\";\n    ConfigurationTarget[ConfigurationTarget[\"WORKSPACE_FOLDER\"] = 6] = \"WORKSPACE_FOLDER\";\n    ConfigurationTarget[ConfigurationTarget[\"DEFAULT\"] = 7] = \"DEFAULT\";\n    ConfigurationTarget[ConfigurationTarget[\"MEMORY\"] = 8] = \"MEMORY\";\n})(ConfigurationTarget || (ConfigurationTarget = {})));\nfunction ConfigurationTargetToString(configurationTarget) {\n    switch (configurationTarget) {\n        case 1 : return 'APPLICATION';\n        case 2 : return 'USER';\n        case 3 : return 'USER_LOCAL';\n        case 4 : return 'USER_REMOTE';\n        case 5 : return 'WORKSPACE';\n        case 6 : return 'WORKSPACE_FOLDER';\n        case 7 : return 'DEFAULT';\n        case 8 : return 'MEMORY';\n    }\n}\nfunction isConfigured(configValue) {\n    return configValue.applicationValue !== undefined ||\n        configValue.userValue !== undefined ||\n        configValue.userLocalValue !== undefined ||\n        configValue.userRemoteValue !== undefined ||\n        configValue.workspaceValue !== undefined ||\n        configValue.workspaceFolderValue !== undefined;\n}\nfunction toValuesTree(properties, conflictReporter) {\n    const root = Object.create(null);\n    for (const key in properties) {\n        addToValueTree(root, key, properties[key], conflictReporter);\n    }\n    return root;\n}\nfunction addToValueTree(settingsTreeRoot, key, value, conflictReporter) {\n    const segments = key.split('.');\n    const last = segments.pop();\n    let curr = settingsTreeRoot;\n    for (let i = 0; i < segments.length; i++) {\n        const s = segments[i];\n        let obj = curr[s];\n        switch (typeof obj) {\n            case 'undefined':\n                obj = curr[s] = Object.create(null);\n                break;\n            case 'object':\n                if (obj === null) {\n                    conflictReporter(`Ignoring ${key} as ${segments.slice(0, i + 1).join('.')} is null`);\n                    return;\n                }\n                break;\n            default:\n                conflictReporter(`Ignoring ${key} as ${segments.slice(0, i + 1).join('.')} is ${JSON.stringify(obj)}`);\n                return;\n        }\n        curr = obj;\n    }\n    if (typeof curr === 'object' && curr !== null) {\n        try {\n            curr[last] = value;\n        }\n        catch (e) {\n            conflictReporter(`Ignoring ${key} as ${segments.join('.')} is ${JSON.stringify(curr)}`);\n        }\n    }\n    else {\n        conflictReporter(`Ignoring ${key} as ${segments.join('.')} is ${JSON.stringify(curr)}`);\n    }\n}\nfunction removeFromValueTree(valueTree, key) {\n    const segments = key.split('.');\n    doRemoveFromValueTree(valueTree, segments);\n}\nfunction doRemoveFromValueTree(valueTree, segments) {\n    const first = segments.shift();\n    if (segments.length === 0) {\n        delete valueTree[first];\n        return;\n    }\n    if (( Object.keys(valueTree)).indexOf(first) !== -1) {\n        const value = valueTree[first];\n        if (typeof value === 'object' && !Array.isArray(value)) {\n            doRemoveFromValueTree(value, segments);\n            if (( Object.keys(value)).length === 0) {\n                delete valueTree[first];\n            }\n        }\n    }\n}\nfunction getConfigurationValue(config, settingPath, defaultValue) {\n    function accessSetting(config, path) {\n        let current = config;\n        for (const component of path) {\n            if (typeof current !== 'object' || current === null) {\n                return undefined;\n            }\n            current = current[component];\n        }\n        return current;\n    }\n    const path = settingPath.split('.');\n    const result = accessSetting(config, path);\n    return typeof result === 'undefined' ? defaultValue : result;\n}\nfunction getLanguageTagSettingPlainKey(settingKey) {\n    return settingKey.replace(/[\\[\\]]/g, '');\n}\nexport { ConfigurationTarget, ConfigurationTargetToString, addToValueTree, getConfigurationValue, getLanguageTagSettingPlainKey, isConfigurationOverrides, isConfigurationUpdateOverrides, isConfigured, removeFromValueTree, toValuesTree };\n","import { createDecorator } from '../../instantiation/common/instantiation.js';\nconst IConfigurationService = ( createDecorator('configurationService'));\nexport { IConfigurationService };\n","import { distinct, equals } from '../../../base/common/arrays.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { visit } from '../../../base/common/json.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { ResourceMap, getOrSet } from '../../../base/common/map.js';\nimport { deepClone, deepFreeze, equals as equals$1 } from '../../../base/common/objects.js';\nimport { isObject, isUndefinedOrNull } from '../../../base/common/types.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { getConfigurationValue, removeFromValueTree, addToValueTree, toValuesTree } from './configuration.js';\nimport { OVERRIDE_PROPERTY_REGEX, overrideIdentifiersFromKey, Extensions } from './configurationRegistry.js';\nimport { Registry } from '../../registry/common/platform.js';\nfunction freeze(data) {\n    return Object.isFrozen(data) ? data : deepFreeze(data);\n}\nclass ConfigurationModel {\n    static createEmptyModel(logService) {\n        return ( new ConfigurationModel({}, [], [], undefined, logService));\n    }\n    constructor(_contents, _keys, _overrides, raw, logService) {\n        this._contents = _contents;\n        this._keys = _keys;\n        this._overrides = _overrides;\n        this.raw = raw;\n        this.logService = logService;\n        this.overrideConfigurations = ( new Map());\n    }\n    get rawConfiguration() {\n        if (!this._rawConfiguration) {\n            if (this.raw?.length) {\n                const rawConfigurationModels = ( this.raw.map(raw => {\n                    if (raw instanceof ConfigurationModel) {\n                        return raw;\n                    }\n                    const parser = ( new ConfigurationModelParser('', this.logService));\n                    parser.parseRaw(raw);\n                    return parser.configurationModel;\n                }));\n                this._rawConfiguration = rawConfigurationModels.reduce((previous, current) => current === previous ? current : previous.merge(current), rawConfigurationModels[0]);\n            }\n            else {\n                this._rawConfiguration = this;\n            }\n        }\n        return this._rawConfiguration;\n    }\n    get contents() {\n        return this._contents;\n    }\n    get overrides() {\n        return this._overrides;\n    }\n    get keys() {\n        return this._keys;\n    }\n    isEmpty() {\n        return this._keys.length === 0 && ( Object.keys(this._contents)).length === 0 && this._overrides.length === 0;\n    }\n    getValue(section) {\n        return section ? getConfigurationValue(this.contents, section) : this.contents;\n    }\n    inspect(section, overrideIdentifier) {\n        const that = this;\n        return {\n            get value() {\n                return freeze(that.rawConfiguration.getValue(section));\n            },\n            get override() {\n                return overrideIdentifier ? freeze(that.rawConfiguration.getOverrideValue(section, overrideIdentifier)) : undefined;\n            },\n            get merged() {\n                return freeze(overrideIdentifier ? that.rawConfiguration.override(overrideIdentifier).getValue(section) : that.rawConfiguration.getValue(section));\n            },\n            get overrides() {\n                const overrides = [];\n                for (const { contents, identifiers, keys } of that.rawConfiguration.overrides) {\n                    const value = ( new ConfigurationModel(contents, keys, [], undefined, that.logService)).getValue(section);\n                    if (value !== undefined) {\n                        overrides.push({ identifiers, value });\n                    }\n                }\n                return overrides.length ? freeze(overrides) : undefined;\n            }\n        };\n    }\n    getOverrideValue(section, overrideIdentifier) {\n        const overrideContents = this.getContentsForOverrideIdentifer(overrideIdentifier);\n        return overrideContents\n            ? section ? getConfigurationValue(overrideContents, section) : overrideContents\n            : undefined;\n    }\n    getKeysForOverrideIdentifier(identifier) {\n        const keys = [];\n        for (const override of this.overrides) {\n            if (override.identifiers.includes(identifier)) {\n                keys.push(...override.keys);\n            }\n        }\n        return distinct(keys);\n    }\n    getAllOverrideIdentifiers() {\n        const result = [];\n        for (const override of this.overrides) {\n            result.push(...override.identifiers);\n        }\n        return distinct(result);\n    }\n    override(identifier) {\n        let overrideConfigurationModel = this.overrideConfigurations.get(identifier);\n        if (!overrideConfigurationModel) {\n            overrideConfigurationModel = this.createOverrideConfigurationModel(identifier);\n            this.overrideConfigurations.set(identifier, overrideConfigurationModel);\n        }\n        return overrideConfigurationModel;\n    }\n    merge(...others) {\n        const contents = deepClone(this.contents);\n        const overrides = deepClone(this.overrides);\n        const keys = [...this.keys];\n        const raws = this.raw?.length ? [...this.raw] : [this];\n        for (const other of others) {\n            raws.push(...(other.raw?.length ? other.raw : [other]));\n            if (other.isEmpty()) {\n                continue;\n            }\n            this.mergeContents(contents, other.contents);\n            for (const otherOverride of other.overrides) {\n                const [override] = overrides.filter(o => equals(o.identifiers, otherOverride.identifiers));\n                if (override) {\n                    this.mergeContents(override.contents, otherOverride.contents);\n                    override.keys.push(...otherOverride.keys);\n                    override.keys = distinct(override.keys);\n                }\n                else {\n                    overrides.push(deepClone(otherOverride));\n                }\n            }\n            for (const key of other.keys) {\n                if (keys.indexOf(key) === -1) {\n                    keys.push(key);\n                }\n            }\n        }\n        return ( new ConfigurationModel(\n            contents,\n            keys,\n            overrides,\n            raws.every(raw => raw instanceof ConfigurationModel) ? undefined : raws,\n            this.logService\n        ));\n    }\n    createOverrideConfigurationModel(identifier) {\n        const overrideContents = this.getContentsForOverrideIdentifer(identifier);\n        if (!overrideContents || typeof overrideContents !== 'object' || !( Object.keys(overrideContents)).length) {\n            return this;\n        }\n        const contents = {};\n        for (const key of distinct([...( Object.keys(this.contents)), ...( Object.keys(overrideContents))])) {\n            let contentsForKey = this.contents[key];\n            const overrideContentsForKey = overrideContents[key];\n            if (overrideContentsForKey) {\n                if (typeof contentsForKey === 'object' && typeof overrideContentsForKey === 'object') {\n                    contentsForKey = deepClone(contentsForKey);\n                    this.mergeContents(contentsForKey, overrideContentsForKey);\n                }\n                else {\n                    contentsForKey = overrideContentsForKey;\n                }\n            }\n            contents[key] = contentsForKey;\n        }\n        return ( new ConfigurationModel(contents, this.keys, this.overrides, undefined, this.logService));\n    }\n    mergeContents(source, target) {\n        for (const key of ( Object.keys(target))) {\n            if (key in source) {\n                if (isObject(source[key]) && isObject(target[key])) {\n                    this.mergeContents(source[key], target[key]);\n                    continue;\n                }\n            }\n            source[key] = deepClone(target[key]);\n        }\n    }\n    getContentsForOverrideIdentifer(identifier) {\n        let contentsForIdentifierOnly = null;\n        let contents = null;\n        const mergeContents = (contentsToMerge) => {\n            if (contentsToMerge) {\n                if (contents) {\n                    this.mergeContents(contents, contentsToMerge);\n                }\n                else {\n                    contents = deepClone(contentsToMerge);\n                }\n            }\n        };\n        for (const override of this.overrides) {\n            if (override.identifiers.length === 1 && override.identifiers[0] === identifier) {\n                contentsForIdentifierOnly = override.contents;\n            }\n            else if (override.identifiers.includes(identifier)) {\n                mergeContents(override.contents);\n            }\n        }\n        mergeContents(contentsForIdentifierOnly);\n        return contents;\n    }\n    toJSON() {\n        return {\n            contents: this.contents,\n            overrides: this.overrides,\n            keys: this.keys\n        };\n    }\n    addValue(key, value) {\n        this.updateValue(key, value, true);\n    }\n    setValue(key, value) {\n        this.updateValue(key, value, false);\n    }\n    removeValue(key) {\n        const index = this.keys.indexOf(key);\n        if (index === -1) {\n            return;\n        }\n        this.keys.splice(index, 1);\n        removeFromValueTree(this.contents, key);\n        if (OVERRIDE_PROPERTY_REGEX.test(key)) {\n            this.overrides.splice(this.overrides.findIndex(o => equals(o.identifiers, overrideIdentifiersFromKey(key))), 1);\n        }\n    }\n    updateValue(key, value, add) {\n        addToValueTree(this.contents, key, value, e => this.logService.error(e));\n        add = add || this.keys.indexOf(key) === -1;\n        if (add) {\n            this.keys.push(key);\n        }\n        if (OVERRIDE_PROPERTY_REGEX.test(key)) {\n            const identifiers = overrideIdentifiersFromKey(key);\n            const override = {\n                identifiers,\n                keys: ( Object.keys(this.contents[key])),\n                contents: toValuesTree(this.contents[key], message => this.logService.error(message)),\n            };\n            const index = this.overrides.findIndex(o => equals(o.identifiers, identifiers));\n            if (index !== -1) {\n                this.overrides[index] = override;\n            }\n            else {\n                this.overrides.push(override);\n            }\n        }\n    }\n}\nclass ConfigurationModelParser {\n    constructor(_name, logService) {\n        this._name = _name;\n        this.logService = logService;\n        this._raw = null;\n        this._configurationModel = null;\n        this._restrictedConfigurations = [];\n        this._parseErrors = [];\n    }\n    get configurationModel() {\n        return this._configurationModel || ConfigurationModel.createEmptyModel(this.logService);\n    }\n    get restrictedConfigurations() {\n        return this._restrictedConfigurations;\n    }\n    get errors() {\n        return this._parseErrors;\n    }\n    parse(content, options) {\n        if (!isUndefinedOrNull(content)) {\n            const raw = this.doParseContent(content);\n            this.parseRaw(raw, options);\n        }\n    }\n    reparse(options) {\n        if (this._raw) {\n            this.parseRaw(this._raw, options);\n        }\n    }\n    parseRaw(raw, options) {\n        this._raw = raw;\n        const { contents, keys, overrides, restricted, hasExcludedProperties } = this.doParseRaw(raw, options);\n        this._configurationModel = ( new ConfigurationModel(\n            contents,\n            keys,\n            overrides,\n            hasExcludedProperties ? [raw] : undefined ,\n            this.logService\n        ));\n        this._restrictedConfigurations = restricted || [];\n    }\n    doParseContent(content) {\n        let raw = {};\n        let currentProperty = null;\n        let currentParent = [];\n        const previousParents = [];\n        function onValue(value) {\n            if (Array.isArray(currentParent)) {\n                currentParent.push(value);\n            }\n            else if (currentProperty !== null) {\n                currentParent[currentProperty] = value;\n            }\n        }\n        const visitor = {\n            onObjectBegin: () => {\n                const object = {};\n                onValue(object);\n                previousParents.push(currentParent);\n                currentParent = object;\n                currentProperty = null;\n            },\n            onObjectProperty: (name) => {\n                currentProperty = name;\n            },\n            onObjectEnd: () => {\n                currentParent = previousParents.pop();\n            },\n            onArrayBegin: () => {\n                const array = [];\n                onValue(array);\n                previousParents.push(currentParent);\n                currentParent = array;\n                currentProperty = null;\n            },\n            onArrayEnd: () => {\n                currentParent = previousParents.pop();\n            },\n            onLiteralValue: onValue,\n            onError: (error, offset, length) => {\n            }\n        };\n        if (content) {\n            try {\n                visit(content, visitor);\n                raw = currentParent[0] || {};\n            }\n            catch (e) {\n                this.logService.error(`Error while parsing settings file ${this._name}: ${e}`);\n                this._parseErrors = [e];\n            }\n        }\n        return raw;\n    }\n    doParseRaw(raw, options) {\n        const configurationProperties = ( Registry.as(Extensions.Configuration)).getConfigurationProperties();\n        const filtered = this.filter(raw, configurationProperties, true, options);\n        raw = filtered.raw;\n        const contents = toValuesTree(raw, message => this.logService.error(`Conflict in settings file ${this._name}: ${message}`));\n        const keys = ( Object.keys(raw));\n        const overrides = this.toOverrides(raw, message => this.logService.error(`Conflict in settings file ${this._name}: ${message}`));\n        return { contents, keys, overrides, restricted: filtered.restricted, hasExcludedProperties: filtered.hasExcludedProperties };\n    }\n    filter(properties, configurationProperties, filterOverriddenProperties, options) {\n        let hasExcludedProperties = false;\n        if (!options?.scopes && !options?.skipRestricted && !options?.exclude?.length) {\n            return { raw: properties, restricted: [], hasExcludedProperties };\n        }\n        const raw = {};\n        const restricted = [];\n        for (const key in properties) {\n            if (OVERRIDE_PROPERTY_REGEX.test(key) && filterOverriddenProperties) {\n                const result = this.filter(properties[key], configurationProperties, false, options);\n                raw[key] = result.raw;\n                hasExcludedProperties = hasExcludedProperties || result.hasExcludedProperties;\n                restricted.push(...result.restricted);\n            }\n            else {\n                const propertySchema = configurationProperties[key];\n                const scope = propertySchema ? typeof propertySchema.scope !== 'undefined' ? propertySchema.scope : 3  : undefined;\n                if (propertySchema?.restricted) {\n                    restricted.push(key);\n                }\n                if (!options.exclude?.includes(key)\n                    && (options.include?.includes(key)\n                        || ((scope === undefined || options.scopes === undefined || options.scopes.includes(scope))\n                            && !(options.skipRestricted && propertySchema?.restricted))))  {\n                    raw[key] = properties[key];\n                }\n                else {\n                    hasExcludedProperties = true;\n                }\n            }\n        }\n        return { raw, restricted, hasExcludedProperties };\n    }\n    toOverrides(raw, conflictReporter) {\n        const overrides = [];\n        for (const key of ( Object.keys(raw))) {\n            if (OVERRIDE_PROPERTY_REGEX.test(key)) {\n                const overrideRaw = {};\n                for (const keyInOverrideRaw in raw[key]) {\n                    overrideRaw[keyInOverrideRaw] = raw[key][keyInOverrideRaw];\n                }\n                overrides.push({\n                    identifiers: overrideIdentifiersFromKey(key),\n                    keys: ( Object.keys(overrideRaw)),\n                    contents: toValuesTree(overrideRaw, conflictReporter)\n                });\n            }\n        }\n        return overrides;\n    }\n}\nclass UserSettings extends Disposable {\n    constructor(userSettingsResource, parseOptions, extUri, fileService, logService) {\n        super();\n        this.userSettingsResource = userSettingsResource;\n        this.parseOptions = parseOptions;\n        this.fileService = fileService;\n        this.logService = logService;\n        this._onDidChange = this._register(( new Emitter()));\n        this.onDidChange = this._onDidChange.event;\n        this.parser = ( new ConfigurationModelParser(( this.userSettingsResource.toString()), logService));\n        this._register(this.fileService.watch(extUri.dirname(this.userSettingsResource)));\n        this._register(this.fileService.watch(this.userSettingsResource));\n        this._register(Event.any(Event.filter(this.fileService.onDidFilesChange, e => e.contains(this.userSettingsResource)), Event.filter(this.fileService.onDidRunOperation, e => (e.isOperation(0 ) || e.isOperation(3 ) || e.isOperation(1 ) || e.isOperation(4 )) && extUri.isEqual(e.resource, userSettingsResource)))(() => this._onDidChange.fire()));\n    }\n    async loadConfiguration() {\n        try {\n            const content = await this.fileService.readFile(this.userSettingsResource);\n            this.parser.parse(( content.value.toString()) || '{}', this.parseOptions);\n            return this.parser.configurationModel;\n        }\n        catch (e) {\n            return ConfigurationModel.createEmptyModel(this.logService);\n        }\n    }\n    reparse(parseOptions) {\n        if (parseOptions) {\n            this.parseOptions = parseOptions;\n        }\n        this.parser.reparse(this.parseOptions);\n        return this.parser.configurationModel;\n    }\n    getRestrictedSettings() {\n        return this.parser.restrictedConfigurations;\n    }\n}\nclass ConfigurationInspectValue {\n    constructor(key, overrides, _value, overrideIdentifiers, defaultConfiguration, policyConfiguration, applicationConfiguration, userConfiguration, localUserConfiguration, remoteUserConfiguration, workspaceConfiguration, folderConfigurationModel, memoryConfigurationModel) {\n        this.key = key;\n        this.overrides = overrides;\n        this._value = _value;\n        this.overrideIdentifiers = overrideIdentifiers;\n        this.defaultConfiguration = defaultConfiguration;\n        this.policyConfiguration = policyConfiguration;\n        this.applicationConfiguration = applicationConfiguration;\n        this.userConfiguration = userConfiguration;\n        this.localUserConfiguration = localUserConfiguration;\n        this.remoteUserConfiguration = remoteUserConfiguration;\n        this.workspaceConfiguration = workspaceConfiguration;\n        this.folderConfigurationModel = folderConfigurationModel;\n        this.memoryConfigurationModel = memoryConfigurationModel;\n    }\n    get value() {\n        return freeze(this._value);\n    }\n    toInspectValue(inspectValue) {\n        return inspectValue?.value !== undefined || inspectValue?.override !== undefined || inspectValue?.overrides !== undefined ? inspectValue : undefined;\n    }\n    get defaultInspectValue() {\n        if (!this._defaultInspectValue) {\n            this._defaultInspectValue = this.defaultConfiguration.inspect(this.key, this.overrides.overrideIdentifier);\n        }\n        return this._defaultInspectValue;\n    }\n    get defaultValue() {\n        return this.defaultInspectValue.merged;\n    }\n    get default() {\n        return this.toInspectValue(this.defaultInspectValue);\n    }\n    get policyInspectValue() {\n        if (this._policyInspectValue === undefined) {\n            this._policyInspectValue = this.policyConfiguration ? this.policyConfiguration.inspect(this.key) : null;\n        }\n        return this._policyInspectValue;\n    }\n    get policyValue() {\n        return this.policyInspectValue?.merged;\n    }\n    get policy() {\n        return this.policyInspectValue?.value !== undefined ? { value: this.policyInspectValue.value } : undefined;\n    }\n    get applicationInspectValue() {\n        if (this._applicationInspectValue === undefined) {\n            this._applicationInspectValue = this.applicationConfiguration ? this.applicationConfiguration.inspect(this.key) : null;\n        }\n        return this._applicationInspectValue;\n    }\n    get applicationValue() {\n        return this.applicationInspectValue?.merged;\n    }\n    get application() {\n        return this.toInspectValue(this.applicationInspectValue);\n    }\n    get userInspectValue() {\n        if (!this._userInspectValue) {\n            this._userInspectValue = this.userConfiguration.inspect(this.key, this.overrides.overrideIdentifier);\n        }\n        return this._userInspectValue;\n    }\n    get userValue() {\n        return this.userInspectValue.merged;\n    }\n    get user() {\n        return this.toInspectValue(this.userInspectValue);\n    }\n    get userLocalInspectValue() {\n        if (!this._userLocalInspectValue) {\n            this._userLocalInspectValue = this.localUserConfiguration.inspect(this.key, this.overrides.overrideIdentifier);\n        }\n        return this._userLocalInspectValue;\n    }\n    get userLocalValue() {\n        return this.userLocalInspectValue.merged;\n    }\n    get userLocal() {\n        return this.toInspectValue(this.userLocalInspectValue);\n    }\n    get userRemoteInspectValue() {\n        if (!this._userRemoteInspectValue) {\n            this._userRemoteInspectValue = this.remoteUserConfiguration.inspect(this.key, this.overrides.overrideIdentifier);\n        }\n        return this._userRemoteInspectValue;\n    }\n    get userRemoteValue() {\n        return this.userRemoteInspectValue.merged;\n    }\n    get userRemote() {\n        return this.toInspectValue(this.userRemoteInspectValue);\n    }\n    get workspaceInspectValue() {\n        if (this._workspaceInspectValue === undefined) {\n            this._workspaceInspectValue = this.workspaceConfiguration ? this.workspaceConfiguration.inspect(this.key, this.overrides.overrideIdentifier) : null;\n        }\n        return this._workspaceInspectValue;\n    }\n    get workspaceValue() {\n        return this.workspaceInspectValue?.merged;\n    }\n    get workspace() {\n        return this.toInspectValue(this.workspaceInspectValue);\n    }\n    get workspaceFolderInspectValue() {\n        if (this._workspaceFolderInspectValue === undefined) {\n            this._workspaceFolderInspectValue = this.folderConfigurationModel ? this.folderConfigurationModel.inspect(this.key, this.overrides.overrideIdentifier) : null;\n        }\n        return this._workspaceFolderInspectValue;\n    }\n    get workspaceFolderValue() {\n        return this.workspaceFolderInspectValue?.merged;\n    }\n    get workspaceFolder() {\n        return this.toInspectValue(this.workspaceFolderInspectValue);\n    }\n    get memoryInspectValue() {\n        if (this._memoryInspectValue === undefined) {\n            this._memoryInspectValue = this.memoryConfigurationModel.inspect(this.key, this.overrides.overrideIdentifier);\n        }\n        return this._memoryInspectValue;\n    }\n    get memoryValue() {\n        return this.memoryInspectValue.merged;\n    }\n    get memory() {\n        return this.toInspectValue(this.memoryInspectValue);\n    }\n}\nlet Configuration$1 = class Configuration {\n    constructor(_defaultConfiguration, _policyConfiguration, _applicationConfiguration, _localUserConfiguration, _remoteUserConfiguration, _workspaceConfiguration, _folderConfigurations, _memoryConfiguration, _memoryConfigurationByResource, logService) {\n        this._defaultConfiguration = _defaultConfiguration;\n        this._policyConfiguration = _policyConfiguration;\n        this._applicationConfiguration = _applicationConfiguration;\n        this._localUserConfiguration = _localUserConfiguration;\n        this._remoteUserConfiguration = _remoteUserConfiguration;\n        this._workspaceConfiguration = _workspaceConfiguration;\n        this._folderConfigurations = _folderConfigurations;\n        this._memoryConfiguration = _memoryConfiguration;\n        this._memoryConfigurationByResource = _memoryConfigurationByResource;\n        this.logService = logService;\n        this._workspaceConsolidatedConfiguration = null;\n        this._foldersConsolidatedConfigurations = ( new ResourceMap());\n        this._userConfiguration = null;\n    }\n    getValue(section, overrides, workspace) {\n        const consolidateConfigurationModel = this.getConsolidatedConfigurationModel(section, overrides, workspace);\n        return consolidateConfigurationModel.getValue(section);\n    }\n    updateValue(key, value, overrides = {}) {\n        let memoryConfiguration;\n        if (overrides.resource) {\n            memoryConfiguration = this._memoryConfigurationByResource.get(overrides.resource);\n            if (!memoryConfiguration) {\n                memoryConfiguration = ConfigurationModel.createEmptyModel(this.logService);\n                this._memoryConfigurationByResource.set(overrides.resource, memoryConfiguration);\n            }\n        }\n        else {\n            memoryConfiguration = this._memoryConfiguration;\n        }\n        if (value === undefined) {\n            memoryConfiguration.removeValue(key);\n        }\n        else {\n            memoryConfiguration.setValue(key, value);\n        }\n        if (!overrides.resource) {\n            this._workspaceConsolidatedConfiguration = null;\n        }\n    }\n    inspect(key, overrides, workspace) {\n        const consolidateConfigurationModel = this.getConsolidatedConfigurationModel(key, overrides, workspace);\n        const folderConfigurationModel = this.getFolderConfigurationModelForResource(overrides.resource, workspace);\n        const memoryConfigurationModel = overrides.resource ? this._memoryConfigurationByResource.get(overrides.resource) || this._memoryConfiguration : this._memoryConfiguration;\n        const overrideIdentifiers = ( new Set());\n        for (const override of consolidateConfigurationModel.overrides) {\n            for (const overrideIdentifier of override.identifiers) {\n                if (consolidateConfigurationModel.getOverrideValue(key, overrideIdentifier) !== undefined) {\n                    overrideIdentifiers.add(overrideIdentifier);\n                }\n            }\n        }\n        return ( new ConfigurationInspectValue(\n            key,\n            overrides,\n            consolidateConfigurationModel.getValue(key),\n            overrideIdentifiers.size ? [...overrideIdentifiers] : undefined,\n            this._defaultConfiguration,\n            this._policyConfiguration.isEmpty() ? undefined : this._policyConfiguration,\n            this.applicationConfiguration.isEmpty() ? undefined : this.applicationConfiguration,\n            this.userConfiguration,\n            this.localUserConfiguration,\n            this.remoteUserConfiguration,\n            workspace ? this._workspaceConfiguration : undefined,\n            folderConfigurationModel ? folderConfigurationModel : undefined,\n            memoryConfigurationModel\n        ));\n    }\n    keys(workspace) {\n        const folderConfigurationModel = this.getFolderConfigurationModelForResource(undefined, workspace);\n        return {\n            default: this._defaultConfiguration.keys.slice(0),\n            user: this.userConfiguration.keys.slice(0),\n            workspace: this._workspaceConfiguration.keys.slice(0),\n            workspaceFolder: folderConfigurationModel ? folderConfigurationModel.keys.slice(0) : []\n        };\n    }\n    updateDefaultConfiguration(defaultConfiguration) {\n        this._defaultConfiguration = defaultConfiguration;\n        this._workspaceConsolidatedConfiguration = null;\n        this._foldersConsolidatedConfigurations.clear();\n    }\n    updatePolicyConfiguration(policyConfiguration) {\n        this._policyConfiguration = policyConfiguration;\n    }\n    updateApplicationConfiguration(applicationConfiguration) {\n        this._applicationConfiguration = applicationConfiguration;\n        this._workspaceConsolidatedConfiguration = null;\n        this._foldersConsolidatedConfigurations.clear();\n    }\n    updateLocalUserConfiguration(localUserConfiguration) {\n        this._localUserConfiguration = localUserConfiguration;\n        this._userConfiguration = null;\n        this._workspaceConsolidatedConfiguration = null;\n        this._foldersConsolidatedConfigurations.clear();\n    }\n    updateRemoteUserConfiguration(remoteUserConfiguration) {\n        this._remoteUserConfiguration = remoteUserConfiguration;\n        this._userConfiguration = null;\n        this._workspaceConsolidatedConfiguration = null;\n        this._foldersConsolidatedConfigurations.clear();\n    }\n    updateWorkspaceConfiguration(workspaceConfiguration) {\n        this._workspaceConfiguration = workspaceConfiguration;\n        this._workspaceConsolidatedConfiguration = null;\n        this._foldersConsolidatedConfigurations.clear();\n    }\n    updateFolderConfiguration(resource, configuration) {\n        this._folderConfigurations.set(resource, configuration);\n        this._foldersConsolidatedConfigurations.delete(resource);\n    }\n    deleteFolderConfiguration(resource) {\n        this.folderConfigurations.delete(resource);\n        this._foldersConsolidatedConfigurations.delete(resource);\n    }\n    compareAndUpdateDefaultConfiguration(defaults, keys) {\n        const overrides = [];\n        if (!keys) {\n            const { added, updated, removed } = compare(this._defaultConfiguration, defaults);\n            keys = [...added, ...updated, ...removed];\n        }\n        for (const key of keys) {\n            for (const overrideIdentifier of overrideIdentifiersFromKey(key)) {\n                const fromKeys = this._defaultConfiguration.getKeysForOverrideIdentifier(overrideIdentifier);\n                const toKeys = defaults.getKeysForOverrideIdentifier(overrideIdentifier);\n                const keys = [\n                    ...toKeys.filter(key => fromKeys.indexOf(key) === -1),\n                    ...fromKeys.filter(key => toKeys.indexOf(key) === -1),\n                    ...fromKeys.filter(key => !equals$1(this._defaultConfiguration.override(overrideIdentifier).getValue(key), defaults.override(overrideIdentifier).getValue(key)))\n                ];\n                overrides.push([overrideIdentifier, keys]);\n            }\n        }\n        this.updateDefaultConfiguration(defaults);\n        return { keys, overrides };\n    }\n    compareAndUpdatePolicyConfiguration(policyConfiguration) {\n        const { added, updated, removed } = compare(this._policyConfiguration, policyConfiguration);\n        const keys = [...added, ...updated, ...removed];\n        if (keys.length) {\n            this.updatePolicyConfiguration(policyConfiguration);\n        }\n        return { keys, overrides: [] };\n    }\n    compareAndUpdateApplicationConfiguration(application) {\n        const { added, updated, removed, overrides } = compare(this.applicationConfiguration, application);\n        const keys = [...added, ...updated, ...removed];\n        if (keys.length) {\n            this.updateApplicationConfiguration(application);\n        }\n        return { keys, overrides };\n    }\n    compareAndUpdateLocalUserConfiguration(user) {\n        const { added, updated, removed, overrides } = compare(this.localUserConfiguration, user);\n        const keys = [...added, ...updated, ...removed];\n        if (keys.length) {\n            this.updateLocalUserConfiguration(user);\n        }\n        return { keys, overrides };\n    }\n    compareAndUpdateRemoteUserConfiguration(user) {\n        const { added, updated, removed, overrides } = compare(this.remoteUserConfiguration, user);\n        const keys = [...added, ...updated, ...removed];\n        if (keys.length) {\n            this.updateRemoteUserConfiguration(user);\n        }\n        return { keys, overrides };\n    }\n    compareAndUpdateWorkspaceConfiguration(workspaceConfiguration) {\n        const { added, updated, removed, overrides } = compare(this.workspaceConfiguration, workspaceConfiguration);\n        const keys = [...added, ...updated, ...removed];\n        if (keys.length) {\n            this.updateWorkspaceConfiguration(workspaceConfiguration);\n        }\n        return { keys, overrides };\n    }\n    compareAndUpdateFolderConfiguration(resource, folderConfiguration) {\n        const currentFolderConfiguration = this.folderConfigurations.get(resource);\n        const { added, updated, removed, overrides } = compare(currentFolderConfiguration, folderConfiguration);\n        const keys = [...added, ...updated, ...removed];\n        if (keys.length || !currentFolderConfiguration) {\n            this.updateFolderConfiguration(resource, folderConfiguration);\n        }\n        return { keys, overrides };\n    }\n    compareAndDeleteFolderConfiguration(folder) {\n        const folderConfig = this.folderConfigurations.get(folder);\n        if (!folderConfig) {\n            throw ( new Error('Unknown folder'));\n        }\n        this.deleteFolderConfiguration(folder);\n        const { added, updated, removed, overrides } = compare(folderConfig, undefined);\n        return { keys: [...added, ...updated, ...removed], overrides };\n    }\n    get defaults() {\n        return this._defaultConfiguration;\n    }\n    get applicationConfiguration() {\n        return this._applicationConfiguration;\n    }\n    get userConfiguration() {\n        if (!this._userConfiguration) {\n            this._userConfiguration = this._remoteUserConfiguration.isEmpty() ? this._localUserConfiguration : this._localUserConfiguration.merge(this._remoteUserConfiguration);\n        }\n        return this._userConfiguration;\n    }\n    get localUserConfiguration() {\n        return this._localUserConfiguration;\n    }\n    get remoteUserConfiguration() {\n        return this._remoteUserConfiguration;\n    }\n    get workspaceConfiguration() {\n        return this._workspaceConfiguration;\n    }\n    get folderConfigurations() {\n        return this._folderConfigurations;\n    }\n    getConsolidatedConfigurationModel(section, overrides, workspace) {\n        let configurationModel = this.getConsolidatedConfigurationModelForResource(overrides, workspace);\n        if (overrides.overrideIdentifier) {\n            configurationModel = configurationModel.override(overrides.overrideIdentifier);\n        }\n        if (!this._policyConfiguration.isEmpty() && this._policyConfiguration.getValue(section) !== undefined) {\n            configurationModel = configurationModel.merge(this._policyConfiguration);\n        }\n        return configurationModel;\n    }\n    getConsolidatedConfigurationModelForResource({ resource }, workspace) {\n        let consolidateConfiguration = this.getWorkspaceConsolidatedConfiguration();\n        if (workspace && resource) {\n            const root = workspace.getFolder(resource);\n            if (root) {\n                consolidateConfiguration = this.getFolderConsolidatedConfiguration(root.uri) || consolidateConfiguration;\n            }\n            const memoryConfigurationForResource = this._memoryConfigurationByResource.get(resource);\n            if (memoryConfigurationForResource) {\n                consolidateConfiguration = consolidateConfiguration.merge(memoryConfigurationForResource);\n            }\n        }\n        return consolidateConfiguration;\n    }\n    getWorkspaceConsolidatedConfiguration() {\n        if (!this._workspaceConsolidatedConfiguration) {\n            this._workspaceConsolidatedConfiguration = this._defaultConfiguration.merge(this.applicationConfiguration, this.userConfiguration, this._workspaceConfiguration, this._memoryConfiguration);\n        }\n        return this._workspaceConsolidatedConfiguration;\n    }\n    getFolderConsolidatedConfiguration(folder) {\n        let folderConsolidatedConfiguration = this._foldersConsolidatedConfigurations.get(folder);\n        if (!folderConsolidatedConfiguration) {\n            const workspaceConsolidateConfiguration = this.getWorkspaceConsolidatedConfiguration();\n            const folderConfiguration = this._folderConfigurations.get(folder);\n            if (folderConfiguration) {\n                folderConsolidatedConfiguration = workspaceConsolidateConfiguration.merge(folderConfiguration);\n                this._foldersConsolidatedConfigurations.set(folder, folderConsolidatedConfiguration);\n            }\n            else {\n                folderConsolidatedConfiguration = workspaceConsolidateConfiguration;\n            }\n        }\n        return folderConsolidatedConfiguration;\n    }\n    getFolderConfigurationModelForResource(resource, workspace) {\n        if (workspace && resource) {\n            const root = workspace.getFolder(resource);\n            if (root) {\n                return this._folderConfigurations.get(root.uri);\n            }\n        }\n        return undefined;\n    }\n    toData() {\n        return {\n            defaults: {\n                contents: this._defaultConfiguration.contents,\n                overrides: this._defaultConfiguration.overrides,\n                keys: this._defaultConfiguration.keys\n            },\n            policy: {\n                contents: this._policyConfiguration.contents,\n                overrides: this._policyConfiguration.overrides,\n                keys: this._policyConfiguration.keys\n            },\n            application: {\n                contents: this.applicationConfiguration.contents,\n                overrides: this.applicationConfiguration.overrides,\n                keys: this.applicationConfiguration.keys\n            },\n            user: {\n                contents: this.userConfiguration.contents,\n                overrides: this.userConfiguration.overrides,\n                keys: this.userConfiguration.keys\n            },\n            workspace: {\n                contents: this._workspaceConfiguration.contents,\n                overrides: this._workspaceConfiguration.overrides,\n                keys: this._workspaceConfiguration.keys\n            },\n            folders: [...( this._folderConfigurations.keys())].reduce((result, folder) => {\n                const { contents, overrides, keys } = this._folderConfigurations.get(folder);\n                result.push([folder, { contents, overrides, keys }]);\n                return result;\n            }, [])\n        };\n    }\n    allKeys() {\n        const keys = ( new Set());\n        this._defaultConfiguration.keys.forEach(key => keys.add(key));\n        this.userConfiguration.keys.forEach(key => keys.add(key));\n        this._workspaceConfiguration.keys.forEach(key => keys.add(key));\n        this._folderConfigurations.forEach(folderConfiguration => folderConfiguration.keys.forEach(key => keys.add(key)));\n        return [...( keys.values())];\n    }\n    allOverrideIdentifiers() {\n        const keys = ( new Set());\n        this._defaultConfiguration.getAllOverrideIdentifiers().forEach(key => keys.add(key));\n        this.userConfiguration.getAllOverrideIdentifiers().forEach(key => keys.add(key));\n        this._workspaceConfiguration.getAllOverrideIdentifiers().forEach(key => keys.add(key));\n        this._folderConfigurations.forEach(folderConfiguration => folderConfiguration.getAllOverrideIdentifiers().forEach(key => keys.add(key)));\n        return [...( keys.values())];\n    }\n    getAllKeysForOverrideIdentifier(overrideIdentifier) {\n        const keys = ( new Set());\n        this._defaultConfiguration.getKeysForOverrideIdentifier(overrideIdentifier).forEach(key => keys.add(key));\n        this.userConfiguration.getKeysForOverrideIdentifier(overrideIdentifier).forEach(key => keys.add(key));\n        this._workspaceConfiguration.getKeysForOverrideIdentifier(overrideIdentifier).forEach(key => keys.add(key));\n        this._folderConfigurations.forEach(folderConfiguration => folderConfiguration.getKeysForOverrideIdentifier(overrideIdentifier).forEach(key => keys.add(key)));\n        return [...( keys.values())];\n    }\n    static parse(data, logService) {\n        const defaultConfiguration = this.parseConfigurationModel(data.defaults, logService);\n        const policyConfiguration = this.parseConfigurationModel(data.policy, logService);\n        const applicationConfiguration = this.parseConfigurationModel(data.application, logService);\n        const userConfiguration = this.parseConfigurationModel(data.user, logService);\n        const workspaceConfiguration = this.parseConfigurationModel(data.workspace, logService);\n        const folders = data.folders.reduce((result, value) => {\n            result.set(URI.revive(value[0]), this.parseConfigurationModel(value[1], logService));\n            return result;\n        }, ( new ResourceMap()));\n        return ( new Configuration(\n            defaultConfiguration,\n            policyConfiguration,\n            applicationConfiguration,\n            userConfiguration,\n            ConfigurationModel.createEmptyModel(logService),\n            workspaceConfiguration,\n            folders,\n            ConfigurationModel.createEmptyModel(logService),\n            ( new ResourceMap()),\n            logService\n        ));\n    }\n    static parseConfigurationModel(model, logService) {\n        return ( new ConfigurationModel(model.contents, model.keys, model.overrides, undefined, logService));\n    }\n};\nfunction mergeChanges(...changes) {\n    if (changes.length === 0) {\n        return { keys: [], overrides: [] };\n    }\n    if (changes.length === 1) {\n        return changes[0];\n    }\n    const keysSet = ( new Set());\n    const overridesMap = ( new Map());\n    for (const change of changes) {\n        change.keys.forEach(key => keysSet.add(key));\n        change.overrides.forEach(([identifier, keys]) => {\n            const result = getOrSet(overridesMap, identifier, ( new Set()));\n            keys.forEach(key => result.add(key));\n        });\n    }\n    const overrides = [];\n    overridesMap.forEach((keys, identifier) => overrides.push([identifier, [...( keys.values())]]));\n    return { keys: [...( keysSet.values())], overrides };\n}\nclass ConfigurationChangeEvent {\n    constructor(change, previous, currentConfiguraiton, currentWorkspace, logService) {\n        this.change = change;\n        this.previous = previous;\n        this.currentConfiguraiton = currentConfiguraiton;\n        this.currentWorkspace = currentWorkspace;\n        this.logService = logService;\n        this._marker = '\\n';\n        this._markerCode1 = this._marker.charCodeAt(0);\n        this._markerCode2 = '.'.charCodeAt(0);\n        this.affectedKeys = ( new Set());\n        this._previousConfiguration = undefined;\n        for (const key of change.keys) {\n            this.affectedKeys.add(key);\n        }\n        for (const [, keys] of change.overrides) {\n            for (const key of keys) {\n                this.affectedKeys.add(key);\n            }\n        }\n        this._affectsConfigStr = this._marker;\n        for (const key of this.affectedKeys) {\n            this._affectsConfigStr += key + this._marker;\n        }\n    }\n    get previousConfiguration() {\n        if (!this._previousConfiguration && this.previous) {\n            this._previousConfiguration = Configuration$1.parse(this.previous.data, this.logService);\n        }\n        return this._previousConfiguration;\n    }\n    affectsConfiguration(section, overrides) {\n        const needle = this._marker + section;\n        const idx = this._affectsConfigStr.indexOf(needle);\n        if (idx < 0) {\n            return false;\n        }\n        const pos = idx + needle.length;\n        if (pos >= this._affectsConfigStr.length) {\n            return false;\n        }\n        const code = this._affectsConfigStr.charCodeAt(pos);\n        if (code !== this._markerCode1 && code !== this._markerCode2) {\n            return false;\n        }\n        if (overrides) {\n            const value1 = this.previousConfiguration ? this.previousConfiguration.getValue(section, overrides, this.previous?.workspace) : undefined;\n            const value2 = this.currentConfiguraiton.getValue(section, overrides, this.currentWorkspace);\n            return !equals$1(value1, value2);\n        }\n        return true;\n    }\n}\nfunction compare(from, to) {\n    const { added, removed, updated } = compareConfigurationContents(to?.rawConfiguration, from?.rawConfiguration);\n    const overrides = [];\n    const fromOverrideIdentifiers = from?.getAllOverrideIdentifiers() || [];\n    const toOverrideIdentifiers = to?.getAllOverrideIdentifiers() || [];\n    if (to) {\n        const addedOverrideIdentifiers = toOverrideIdentifiers.filter(key => !fromOverrideIdentifiers.includes(key));\n        for (const identifier of addedOverrideIdentifiers) {\n            overrides.push([identifier, to.getKeysForOverrideIdentifier(identifier)]);\n        }\n    }\n    if (from) {\n        const removedOverrideIdentifiers = fromOverrideIdentifiers.filter(key => !toOverrideIdentifiers.includes(key));\n        for (const identifier of removedOverrideIdentifiers) {\n            overrides.push([identifier, from.getKeysForOverrideIdentifier(identifier)]);\n        }\n    }\n    if (to && from) {\n        for (const identifier of fromOverrideIdentifiers) {\n            if (toOverrideIdentifiers.includes(identifier)) {\n                const result = compareConfigurationContents({ contents: from.getOverrideValue(undefined, identifier) || {}, keys: from.getKeysForOverrideIdentifier(identifier) }, { contents: to.getOverrideValue(undefined, identifier) || {}, keys: to.getKeysForOverrideIdentifier(identifier) });\n                overrides.push([identifier, [...result.added, ...result.removed, ...result.updated]]);\n            }\n        }\n    }\n    return { added, removed, updated, overrides };\n}\nfunction compareConfigurationContents(to, from) {\n    const added = to\n        ? from ? to.keys.filter(key => from.keys.indexOf(key) === -1) : [...to.keys]\n        : [];\n    const removed = from\n        ? to ? from.keys.filter(key => to.keys.indexOf(key) === -1) : [...from.keys]\n        : [];\n    const updated = [];\n    if (to && from) {\n        for (const key of from.keys) {\n            if (to.keys.indexOf(key) !== -1) {\n                const value1 = getConfigurationValue(from.contents, key);\n                const value2 = getConfigurationValue(to.contents, key);\n                if (!equals$1(value1, value2)) {\n                    updated.push(key);\n                }\n            }\n        }\n    }\n    return { added, removed, updated };\n}\nexport { Configuration$1 as Configuration, ConfigurationChangeEvent, ConfigurationModel, ConfigurationModelParser, UserSettings, mergeChanges };\n","import { distinct } from '../../../base/common/arrays.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { isEmptyObject, isObject, isUndefinedOrNull, isUndefined } from '../../../base/common/types.js';\nimport { localize } from '../../../nls.js';\nimport { getLanguageTagSettingPlainKey } from './configuration.js';\nimport { Extensions as Extensions$1 } from '../../jsonschemas/common/jsonContributionRegistry.js';\nimport { Registry } from '../../registry/common/platform.js';\nvar EditPresentationTypes;\n( ((function(EditPresentationTypes) {\n    EditPresentationTypes[\"Multiline\"] = \"multilineText\";\n    EditPresentationTypes[\"Singleline\"] = \"singlelineText\";\n})(EditPresentationTypes || (EditPresentationTypes = {}))));\nconst Extensions = {\n    Configuration: 'base.contributions.configuration'\n};\nvar ConfigurationScope;\n( ((function(ConfigurationScope) {\n    ConfigurationScope[ConfigurationScope[\"APPLICATION\"] = 1] = \"APPLICATION\";\n    ConfigurationScope[ConfigurationScope[\"MACHINE\"] = 2] = \"MACHINE\";\n    ConfigurationScope[ConfigurationScope[\"WINDOW\"] = 3] = \"WINDOW\";\n    ConfigurationScope[ConfigurationScope[\"RESOURCE\"] = 4] = \"RESOURCE\";\n    ConfigurationScope[ConfigurationScope[\"LANGUAGE_OVERRIDABLE\"] = 5] = \"LANGUAGE_OVERRIDABLE\";\n    ConfigurationScope[ConfigurationScope[\"MACHINE_OVERRIDABLE\"] = 6] = \"MACHINE_OVERRIDABLE\";\n})(ConfigurationScope || (ConfigurationScope = {}))));\nconst allSettings = { properties: {}, patternProperties: {} };\nconst applicationSettings = { properties: {}, patternProperties: {} };\nconst machineSettings = { properties: {}, patternProperties: {} };\nconst machineOverridableSettings = { properties: {}, patternProperties: {} };\nconst windowSettings = { properties: {}, patternProperties: {} };\nconst resourceSettings = { properties: {}, patternProperties: {} };\nconst resourceLanguageSettingsSchemaId = 'vscode://schemas/settings/resourceLanguage';\nconst configurationDefaultsSchemaId = 'vscode://schemas/settings/configurationDefaults';\nconst contributionRegistry = ( (Registry.as(Extensions$1.JSONContribution)));\nclass ConfigurationRegistry {\n    constructor() {\n        this.registeredConfigurationDefaults = [];\n        this.overrideIdentifiers = ( (new Set()));\n        this._onDidSchemaChange = ( (new Emitter()));\n        this.onDidSchemaChange = this._onDidSchemaChange.event;\n        this._onDidUpdateConfiguration = ( (new Emitter()));\n        this.onDidUpdateConfiguration = this._onDidUpdateConfiguration.event;\n        this.configurationDefaultsOverrides = ( (new Map()));\n        this.defaultLanguageConfigurationOverridesNode = {\n            id: 'defaultOverrides',\n            title: ( localize(476, \"Default Language Configuration Overrides\")),\n            properties: {}\n        };\n        this.configurationContributors = [this.defaultLanguageConfigurationOverridesNode];\n        this.resourceLanguageSettingsSchema = {\n            properties: {},\n            patternProperties: {},\n            additionalProperties: true,\n            allowTrailingCommas: true,\n            allowComments: true\n        };\n        this.configurationProperties = {};\n        this.policyConfigurations = ( (new Map()));\n        this.excludedConfigurationProperties = {};\n        contributionRegistry.registerSchema(resourceLanguageSettingsSchemaId, this.resourceLanguageSettingsSchema);\n        this.registerOverridePropertyPatternKey();\n    }\n    registerConfiguration(configuration, validate = true) {\n        this.registerConfigurations([configuration], validate);\n    }\n    registerConfigurations(configurations, validate = true) {\n        const properties = ( (new Set()));\n        this.doRegisterConfigurations(configurations, validate, properties);\n        contributionRegistry.registerSchema(resourceLanguageSettingsSchemaId, this.resourceLanguageSettingsSchema);\n        this._onDidSchemaChange.fire();\n        this._onDidUpdateConfiguration.fire({ properties });\n    }\n    deregisterConfigurations(configurations) {\n        const properties = ( (new Set()));\n        this.doDeregisterConfigurations(configurations, properties);\n        contributionRegistry.registerSchema(resourceLanguageSettingsSchemaId, this.resourceLanguageSettingsSchema);\n        this._onDidSchemaChange.fire();\n        this._onDidUpdateConfiguration.fire({ properties });\n    }\n    updateConfigurations({ add, remove }) {\n        const properties = ( (new Set()));\n        this.doDeregisterConfigurations(remove, properties);\n        this.doRegisterConfigurations(add, false, properties);\n        contributionRegistry.registerSchema(resourceLanguageSettingsSchemaId, this.resourceLanguageSettingsSchema);\n        this._onDidSchemaChange.fire();\n        this._onDidUpdateConfiguration.fire({ properties });\n    }\n    registerDefaultConfigurations(configurationDefaults) {\n        const properties = ( (new Set()));\n        this.doRegisterDefaultConfigurations(configurationDefaults, properties);\n        this._onDidSchemaChange.fire();\n        this._onDidUpdateConfiguration.fire({ properties, defaultsOverrides: true });\n    }\n    doRegisterDefaultConfigurations(configurationDefaults, bucket) {\n        this.registeredConfigurationDefaults.push(...configurationDefaults);\n        const overrideIdentifiers = [];\n        for (const { overrides, source } of configurationDefaults) {\n            for (const key in overrides) {\n                bucket.add(key);\n                const configurationDefaultOverridesForKey = this.configurationDefaultsOverrides.get(key)\n                    ?? this.configurationDefaultsOverrides.set(key, { configurationDefaultOverrides: [] }).get(key);\n                const value = overrides[key];\n                configurationDefaultOverridesForKey.configurationDefaultOverrides.push({ value, source });\n                if (OVERRIDE_PROPERTY_REGEX.test(key)) {\n                    const newDefaultOverride = this.mergeDefaultConfigurationsForOverrideIdentifier(key, value, source, configurationDefaultOverridesForKey.configurationDefaultOverrideValue);\n                    if (!newDefaultOverride) {\n                        continue;\n                    }\n                    configurationDefaultOverridesForKey.configurationDefaultOverrideValue = newDefaultOverride;\n                    this.updateDefaultOverrideProperty(key, newDefaultOverride, source);\n                    overrideIdentifiers.push(...overrideIdentifiersFromKey(key));\n                }\n                else {\n                    const newDefaultOverride = this.mergeDefaultConfigurationsForConfigurationProperty(key, value, source, configurationDefaultOverridesForKey.configurationDefaultOverrideValue);\n                    if (!newDefaultOverride) {\n                        continue;\n                    }\n                    configurationDefaultOverridesForKey.configurationDefaultOverrideValue = newDefaultOverride;\n                    const property = this.configurationProperties[key];\n                    if (property) {\n                        this.updatePropertyDefaultValue(key, property);\n                        this.updateSchema(key, property);\n                    }\n                }\n            }\n        }\n        this.doRegisterOverrideIdentifiers(overrideIdentifiers);\n    }\n    deregisterDefaultConfigurations(defaultConfigurations) {\n        const properties = ( (new Set()));\n        this.doDeregisterDefaultConfigurations(defaultConfigurations, properties);\n        this._onDidSchemaChange.fire();\n        this._onDidUpdateConfiguration.fire({ properties, defaultsOverrides: true });\n    }\n    doDeregisterDefaultConfigurations(defaultConfigurations, bucket) {\n        for (const defaultConfiguration of defaultConfigurations) {\n            const index = this.registeredConfigurationDefaults.indexOf(defaultConfiguration);\n            if (index !== -1) {\n                this.registeredConfigurationDefaults.splice(index, 1);\n            }\n        }\n        for (const { overrides, source } of defaultConfigurations) {\n            for (const key in overrides) {\n                const configurationDefaultOverridesForKey = this.configurationDefaultsOverrides.get(key);\n                if (!configurationDefaultOverridesForKey) {\n                    continue;\n                }\n                const index = configurationDefaultOverridesForKey.configurationDefaultOverrides\n                    .findIndex(configurationDefaultOverride => source ? configurationDefaultOverride.source?.id === source.id : configurationDefaultOverride.value === overrides[key]);\n                if (index === -1) {\n                    continue;\n                }\n                configurationDefaultOverridesForKey.configurationDefaultOverrides.splice(index, 1);\n                if (configurationDefaultOverridesForKey.configurationDefaultOverrides.length === 0) {\n                    this.configurationDefaultsOverrides.delete(key);\n                }\n                if (OVERRIDE_PROPERTY_REGEX.test(key)) {\n                    let configurationDefaultOverrideValue;\n                    for (const configurationDefaultOverride of configurationDefaultOverridesForKey.configurationDefaultOverrides) {\n                        configurationDefaultOverrideValue = this.mergeDefaultConfigurationsForOverrideIdentifier(key, configurationDefaultOverride.value, configurationDefaultOverride.source, configurationDefaultOverrideValue);\n                    }\n                    if (configurationDefaultOverrideValue && !isEmptyObject(configurationDefaultOverrideValue.value)) {\n                        configurationDefaultOverridesForKey.configurationDefaultOverrideValue = configurationDefaultOverrideValue;\n                        this.updateDefaultOverrideProperty(key, configurationDefaultOverrideValue, source);\n                    }\n                    else {\n                        this.configurationDefaultsOverrides.delete(key);\n                        delete this.configurationProperties[key];\n                        delete this.defaultLanguageConfigurationOverridesNode.properties[key];\n                    }\n                }\n                else {\n                    let configurationDefaultOverrideValue;\n                    for (const configurationDefaultOverride of configurationDefaultOverridesForKey.configurationDefaultOverrides) {\n                        configurationDefaultOverrideValue = this.mergeDefaultConfigurationsForConfigurationProperty(key, configurationDefaultOverride.value, configurationDefaultOverride.source, configurationDefaultOverrideValue);\n                    }\n                    configurationDefaultOverridesForKey.configurationDefaultOverrideValue = configurationDefaultOverrideValue;\n                    const property = this.configurationProperties[key];\n                    if (property) {\n                        this.updatePropertyDefaultValue(key, property);\n                        this.updateSchema(key, property);\n                    }\n                }\n                bucket.add(key);\n            }\n        }\n        this.updateOverridePropertyPatternKey();\n    }\n    updateDefaultOverrideProperty(key, newDefaultOverride, source) {\n        const property = {\n            type: 'object',\n            default: newDefaultOverride.value,\n            description: ( localize(\n                477,\n                \"Configure settings to be overridden for the {0} language.\",\n                getLanguageTagSettingPlainKey(key)\n            )),\n            $ref: resourceLanguageSettingsSchemaId,\n            defaultDefaultValue: newDefaultOverride.value,\n            source,\n            defaultValueSource: source\n        };\n        this.configurationProperties[key] = property;\n        this.defaultLanguageConfigurationOverridesNode.properties[key] = property;\n    }\n    mergeDefaultConfigurationsForOverrideIdentifier(overrideIdentifier, configurationValueObject, valueSource, existingDefaultOverride) {\n        const defaultValue = existingDefaultOverride?.value || {};\n        const source = existingDefaultOverride?.source ?? ( (new Map()));\n        if (!(source instanceof Map)) {\n            console.error('objectConfigurationSources is not a Map');\n            return undefined;\n        }\n        for (const propertyKey of ( (Object.keys(configurationValueObject)))) {\n            const propertyDefaultValue = configurationValueObject[propertyKey];\n            const isObjectSetting = isObject(propertyDefaultValue) &&\n                (isUndefined(defaultValue[propertyKey]) || isObject(defaultValue[propertyKey]));\n            if (isObjectSetting) {\n                defaultValue[propertyKey] = { ...(defaultValue[propertyKey] ?? {}), ...propertyDefaultValue };\n                if (valueSource) {\n                    for (const objectKey in propertyDefaultValue) {\n                        source.set(`${propertyKey}.${objectKey}`, valueSource);\n                    }\n                }\n            }\n            else {\n                defaultValue[propertyKey] = propertyDefaultValue;\n                if (valueSource) {\n                    source.set(propertyKey, valueSource);\n                }\n                else {\n                    source.delete(propertyKey);\n                }\n            }\n        }\n        return { value: defaultValue, source };\n    }\n    mergeDefaultConfigurationsForConfigurationProperty(propertyKey, value, valuesSource, existingDefaultOverride) {\n        const property = this.configurationProperties[propertyKey];\n        const existingDefaultValue = existingDefaultOverride?.value ?? property?.defaultDefaultValue;\n        let source = valuesSource;\n        const isObjectSetting = isObject(value) &&\n            (property !== undefined && property.type === 'object' ||\n                property === undefined && (isUndefined(existingDefaultValue) || isObject(existingDefaultValue)));\n        if (isObjectSetting) {\n            source = existingDefaultOverride?.source ?? ( (new Map()));\n            if (!(source instanceof Map)) {\n                console.error('defaultValueSource is not a Map');\n                return undefined;\n            }\n            for (const objectKey in value) {\n                if (valuesSource) {\n                    source.set(`${propertyKey}.${objectKey}`, valuesSource);\n                }\n            }\n            value = { ...(isObject(existingDefaultValue) ? existingDefaultValue : {}), ...value };\n        }\n        return { value, source };\n    }\n    deltaConfiguration(delta) {\n        let defaultsOverrides = false;\n        const properties = ( (new Set()));\n        if (delta.removedDefaults) {\n            this.doDeregisterDefaultConfigurations(delta.removedDefaults, properties);\n            defaultsOverrides = true;\n        }\n        if (delta.addedDefaults) {\n            this.doRegisterDefaultConfigurations(delta.addedDefaults, properties);\n            defaultsOverrides = true;\n        }\n        if (delta.removedConfigurations) {\n            this.doDeregisterConfigurations(delta.removedConfigurations, properties);\n        }\n        if (delta.addedConfigurations) {\n            this.doRegisterConfigurations(delta.addedConfigurations, false, properties);\n        }\n        this._onDidSchemaChange.fire();\n        this._onDidUpdateConfiguration.fire({ properties, defaultsOverrides });\n    }\n    notifyConfigurationSchemaUpdated(...configurations) {\n        this._onDidSchemaChange.fire();\n    }\n    registerOverrideIdentifiers(overrideIdentifiers) {\n        this.doRegisterOverrideIdentifiers(overrideIdentifiers);\n        this._onDidSchemaChange.fire();\n    }\n    doRegisterOverrideIdentifiers(overrideIdentifiers) {\n        for (const overrideIdentifier of overrideIdentifiers) {\n            this.overrideIdentifiers.add(overrideIdentifier);\n        }\n        this.updateOverridePropertyPatternKey();\n    }\n    doRegisterConfigurations(configurations, validate, bucket) {\n        configurations.forEach(configuration => {\n            this.validateAndRegisterProperties(configuration, validate, configuration.extensionInfo, configuration.restrictedProperties, undefined, bucket);\n            this.configurationContributors.push(configuration);\n            this.registerJSONConfiguration(configuration);\n        });\n    }\n    doDeregisterConfigurations(configurations, bucket) {\n        const deregisterConfiguration = (configuration) => {\n            if (configuration.properties) {\n                for (const key in configuration.properties) {\n                    bucket.add(key);\n                    const property = this.configurationProperties[key];\n                    if (property?.policy?.name) {\n                        this.policyConfigurations.delete(property.policy.name);\n                    }\n                    delete this.configurationProperties[key];\n                    this.removeFromSchema(key, configuration.properties[key]);\n                }\n            }\n            configuration.allOf?.forEach(node => deregisterConfiguration(node));\n        };\n        for (const configuration of configurations) {\n            deregisterConfiguration(configuration);\n            const index = this.configurationContributors.indexOf(configuration);\n            if (index !== -1) {\n                this.configurationContributors.splice(index, 1);\n            }\n        }\n    }\n    validateAndRegisterProperties(configuration, validate = true, extensionInfo, restrictedProperties, scope = 3 , bucket) {\n        scope = isUndefinedOrNull(configuration.scope) ? scope : configuration.scope;\n        const properties = configuration.properties;\n        if (properties) {\n            for (const key in properties) {\n                const property = properties[key];\n                if (validate && validateProperty(key, property)) {\n                    delete properties[key];\n                    continue;\n                }\n                property.source = extensionInfo;\n                property.defaultDefaultValue = properties[key].default;\n                this.updatePropertyDefaultValue(key, property);\n                if (OVERRIDE_PROPERTY_REGEX.test(key)) {\n                    property.scope = undefined;\n                }\n                else {\n                    property.scope = isUndefinedOrNull(property.scope) ? scope : property.scope;\n                    property.restricted = isUndefinedOrNull(property.restricted) ? !!restrictedProperties?.includes(key) : property.restricted;\n                }\n                if (properties[key].hasOwnProperty('included') && !properties[key].included) {\n                    this.excludedConfigurationProperties[key] = properties[key];\n                    delete properties[key];\n                    continue;\n                }\n                else {\n                    this.configurationProperties[key] = properties[key];\n                    if (properties[key].policy?.name) {\n                        this.policyConfigurations.set(properties[key].policy.name, key);\n                    }\n                }\n                if (!properties[key].deprecationMessage && properties[key].markdownDeprecationMessage) {\n                    properties[key].deprecationMessage = properties[key].markdownDeprecationMessage;\n                }\n                bucket.add(key);\n            }\n        }\n        const subNodes = configuration.allOf;\n        if (subNodes) {\n            for (const node of subNodes) {\n                this.validateAndRegisterProperties(node, validate, extensionInfo, restrictedProperties, scope, bucket);\n            }\n        }\n    }\n    getConfigurations() {\n        return this.configurationContributors;\n    }\n    getConfigurationProperties() {\n        return this.configurationProperties;\n    }\n    getPolicyConfigurations() {\n        return this.policyConfigurations;\n    }\n    getExcludedConfigurationProperties() {\n        return this.excludedConfigurationProperties;\n    }\n    getRegisteredDefaultConfigurations() {\n        return [...this.registeredConfigurationDefaults];\n    }\n    getConfigurationDefaultsOverrides() {\n        const configurationDefaultsOverrides = ( (new Map()));\n        for (const [key, value] of this.configurationDefaultsOverrides) {\n            if (value.configurationDefaultOverrideValue) {\n                configurationDefaultsOverrides.set(key, value.configurationDefaultOverrideValue);\n            }\n        }\n        return configurationDefaultsOverrides;\n    }\n    registerJSONConfiguration(configuration) {\n        const register = (configuration) => {\n            const properties = configuration.properties;\n            if (properties) {\n                for (const key in properties) {\n                    this.updateSchema(key, properties[key]);\n                }\n            }\n            const subNodes = configuration.allOf;\n            subNodes?.forEach(register);\n        };\n        register(configuration);\n    }\n    updateSchema(key, property) {\n        allSettings.properties[key] = property;\n        switch (property.scope) {\n            case 1 :\n                applicationSettings.properties[key] = property;\n                break;\n            case 2 :\n                machineSettings.properties[key] = property;\n                break;\n            case 6 :\n                machineOverridableSettings.properties[key] = property;\n                break;\n            case 3 :\n                windowSettings.properties[key] = property;\n                break;\n            case 4 :\n                resourceSettings.properties[key] = property;\n                break;\n            case 5 :\n                resourceSettings.properties[key] = property;\n                this.resourceLanguageSettingsSchema.properties[key] = property;\n                break;\n        }\n    }\n    removeFromSchema(key, property) {\n        delete allSettings.properties[key];\n        switch (property.scope) {\n            case 1 :\n                delete applicationSettings.properties[key];\n                break;\n            case 2 :\n                delete machineSettings.properties[key];\n                break;\n            case 6 :\n                delete machineOverridableSettings.properties[key];\n                break;\n            case 3 :\n                delete windowSettings.properties[key];\n                break;\n            case 4 :\n            case 5 :\n                delete resourceSettings.properties[key];\n                delete this.resourceLanguageSettingsSchema.properties[key];\n                break;\n        }\n    }\n    updateOverridePropertyPatternKey() {\n        for (const overrideIdentifier of ( (this.overrideIdentifiers.values()))) {\n            const overrideIdentifierProperty = `[${overrideIdentifier}]`;\n            const resourceLanguagePropertiesSchema = {\n                type: 'object',\n                description: ( localize(478, \"Configure editor settings to be overridden for a language.\")),\n                errorMessage: ( localize(479, \"This setting does not support per-language configuration.\")),\n                $ref: resourceLanguageSettingsSchemaId,\n            };\n            this.updatePropertyDefaultValue(overrideIdentifierProperty, resourceLanguagePropertiesSchema);\n            allSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;\n            applicationSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;\n            machineSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;\n            machineOverridableSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;\n            windowSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;\n            resourceSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;\n        }\n    }\n    registerOverridePropertyPatternKey() {\n        const resourceLanguagePropertiesSchema = {\n            type: 'object',\n            description: ( localize(478, \"Configure editor settings to be overridden for a language.\")),\n            errorMessage: ( localize(479, \"This setting does not support per-language configuration.\")),\n            $ref: resourceLanguageSettingsSchemaId,\n        };\n        allSettings.patternProperties[OVERRIDE_PROPERTY_PATTERN] = resourceLanguagePropertiesSchema;\n        applicationSettings.patternProperties[OVERRIDE_PROPERTY_PATTERN] = resourceLanguagePropertiesSchema;\n        machineSettings.patternProperties[OVERRIDE_PROPERTY_PATTERN] = resourceLanguagePropertiesSchema;\n        machineOverridableSettings.patternProperties[OVERRIDE_PROPERTY_PATTERN] = resourceLanguagePropertiesSchema;\n        windowSettings.patternProperties[OVERRIDE_PROPERTY_PATTERN] = resourceLanguagePropertiesSchema;\n        resourceSettings.patternProperties[OVERRIDE_PROPERTY_PATTERN] = resourceLanguagePropertiesSchema;\n        this._onDidSchemaChange.fire();\n    }\n    updatePropertyDefaultValue(key, property) {\n        const configurationdefaultOverride = this.configurationDefaultsOverrides.get(key)?.configurationDefaultOverrideValue;\n        let defaultValue = undefined;\n        let defaultSource = undefined;\n        if (configurationdefaultOverride\n            && (!property.disallowConfigurationDefault || !configurationdefaultOverride.source)\n        ) {\n            defaultValue = configurationdefaultOverride.value;\n            defaultSource = configurationdefaultOverride.source;\n        }\n        if (isUndefined(defaultValue)) {\n            defaultValue = property.defaultDefaultValue;\n            defaultSource = undefined;\n        }\n        if (isUndefined(defaultValue)) {\n            defaultValue = getDefaultValue(property.type);\n        }\n        property.default = defaultValue;\n        property.defaultValueSource = defaultSource;\n    }\n}\nconst OVERRIDE_IDENTIFIER_PATTERN = `\\\\[([^\\\\]]+)\\\\]`;\nconst OVERRIDE_IDENTIFIER_REGEX = ( (new RegExp(OVERRIDE_IDENTIFIER_PATTERN, 'g')));\nconst OVERRIDE_PROPERTY_PATTERN = `^(${OVERRIDE_IDENTIFIER_PATTERN})+$`;\nconst OVERRIDE_PROPERTY_REGEX = ( (new RegExp(OVERRIDE_PROPERTY_PATTERN)));\nfunction overrideIdentifiersFromKey(key) {\n    const identifiers = [];\n    if (OVERRIDE_PROPERTY_REGEX.test(key)) {\n        let matches = OVERRIDE_IDENTIFIER_REGEX.exec(key);\n        while (matches?.length) {\n            const identifier = matches[1].trim();\n            if (identifier) {\n                identifiers.push(identifier);\n            }\n            matches = OVERRIDE_IDENTIFIER_REGEX.exec(key);\n        }\n    }\n    return distinct(identifiers);\n}\nfunction keyFromOverrideIdentifiers(overrideIdentifiers) {\n    return overrideIdentifiers.reduce((result, overrideIdentifier) => `${result}[${overrideIdentifier}]`, '');\n}\nfunction getDefaultValue(type) {\n    const t = Array.isArray(type) ? type[0] : type;\n    switch (t) {\n        case 'boolean':\n            return false;\n        case 'integer':\n        case 'number':\n            return 0;\n        case 'string':\n            return '';\n        case 'array':\n            return [];\n        case 'object':\n            return {};\n        default:\n            return null;\n    }\n}\nconst configurationRegistry = ( (new ConfigurationRegistry()));\nRegistry.add(Extensions.Configuration, configurationRegistry);\nfunction validateProperty(property, schema) {\n    if (!property.trim()) {\n        return ( localize(480, \"Cannot register an empty property\"));\n    }\n    if (OVERRIDE_PROPERTY_REGEX.test(property)) {\n        return ( localize(\n            481,\n            \"Cannot register '{0}'. This matches property pattern '\\\\\\\\[.*\\\\\\\\]$' for describing language specific editor settings. Use 'configurationDefaults' contribution.\",\n            property\n        ));\n    }\n    if (configurationRegistry.getConfigurationProperties()[property] !== undefined) {\n        return ( localize(\n            482,\n            \"Cannot register '{0}'. This property is already registered.\",\n            property\n        ));\n    }\n    if (schema.policy?.name && configurationRegistry.getPolicyConfigurations().get(schema.policy?.name) !== undefined) {\n        return ( localize(\n            483,\n            \"Cannot register '{0}'. The associated policy {1} is already registered with {2}.\",\n            property,\n            schema.policy?.name,\n            configurationRegistry.getPolicyConfigurations().get(schema.policy?.name)\n        ));\n    }\n    return null;\n}\nfunction getScopes() {\n    const scopes = [];\n    const configurationProperties = configurationRegistry.getConfigurationProperties();\n    for (const key of ( (Object.keys(configurationProperties)))) {\n        scopes.push([key, configurationProperties[key].scope]);\n    }\n    scopes.push(['launch', 4 ]);\n    scopes.push(['task', 4 ]);\n    return scopes;\n}\nfunction getAllConfigurationProperties(configurationNode) {\n    const result = {};\n    for (const configuration of configurationNode) {\n        const properties = configuration.properties;\n        if (isObject(properties)) {\n            for (const key in properties) {\n                result[key] = properties[key];\n            }\n        }\n        if (configuration.allOf) {\n            Object.assign(result, getAllConfigurationProperties(configuration.allOf));\n        }\n    }\n    return result;\n}\nfunction parseScope(scope) {\n    switch (scope) {\n        case 'application':\n            return 1 ;\n        case 'machine':\n            return 2 ;\n        case 'resource':\n            return 4 ;\n        case 'machine-overridable':\n            return 6 ;\n        case 'language-overridable':\n            return 5 ;\n        default:\n            return 3 ;\n    }\n}\nexport { ConfigurationScope, EditPresentationTypes, Extensions, OVERRIDE_PROPERTY_PATTERN, OVERRIDE_PROPERTY_REGEX, allSettings, applicationSettings, configurationDefaultsSchemaId, getAllConfigurationProperties, getDefaultValue, getScopes, keyFromOverrideIdentifiers, machineOverridableSettings, machineSettings, overrideIdentifiersFromKey, parseScope, resourceLanguageSettingsSchemaId, resourceSettings, validateProperty, windowSettings };\n","import { isMacintosh, isLinux, isWindows, isWeb, isEdge, isFirefox, isChrome, isSafari } from '../../../base/common/platform.js';\nimport { isFalsyOrWhitespace } from '../../../base/common/strings.js';\nimport { Scanner } from './scanner.js';\nimport { localize } from '../../../nls.js';\nimport { illegalArgument } from '../../../base/common/errors.js';\nconst CONSTANT_VALUES = ( (new Map()));\nCONSTANT_VALUES.set('false', false);\nCONSTANT_VALUES.set('true', true);\nCONSTANT_VALUES.set('isMac', isMacintosh);\nCONSTANT_VALUES.set('isLinux', isLinux);\nCONSTANT_VALUES.set('isWindows', isWindows);\nCONSTANT_VALUES.set('isWeb', isWeb);\nCONSTANT_VALUES.set('isMacNative', isMacintosh && !isWeb);\nCONSTANT_VALUES.set('isEdge', isEdge);\nCONSTANT_VALUES.set('isFirefox', isFirefox);\nCONSTANT_VALUES.set('isChrome', isChrome);\nCONSTANT_VALUES.set('isSafari', isSafari);\nfunction setConstant(key, value) {\n    if (CONSTANT_VALUES.get(key) !== undefined) {\n        throw illegalArgument('contextkey.setConstant(k, v) invoked with already set constant `k`');\n    }\n    CONSTANT_VALUES.set(key, value);\n}\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst defaultConfig = {\n    regexParsingWithErrorRecovery: true\n};\nconst errorEmptyString = ( localize(484, \"Empty context key expression\"));\nconst hintEmptyString = ( localize(\n    485,\n    \"Did you forget to write an expression? You can also put 'false' or 'true' to always evaluate to false or true, respectively.\"\n));\nconst errorNoInAfterNot = ( localize(486, \"'in' after 'not'.\"));\nconst errorClosingParenthesis = ( localize(487, \"closing parenthesis ')'\"));\nconst errorUnexpectedToken = ( localize(488, \"Unexpected token\"));\nconst hintUnexpectedToken = ( localize(489, \"Did you forget to put && or || before the token?\"));\nconst errorUnexpectedEOF = ( localize(490, \"Unexpected end of expression\"));\nconst hintUnexpectedEOF = ( localize(491, \"Did you forget to put a context key?\"));\nclass Parser {\n    static { this._parseError = ( (new Error())); }\n    get lexingErrors() {\n        return this._scanner.errors;\n    }\n    get parsingErrors() {\n        return this._parsingErrors;\n    }\n    constructor(_config = defaultConfig) {\n        this._config = _config;\n        this._scanner = ( (new Scanner()));\n        this._tokens = [];\n        this._current = 0;\n        this._parsingErrors = [];\n        this._flagsGYRe = /g|y/g;\n    }\n    parse(input) {\n        if (input === '') {\n            this._parsingErrors.push({ message: errorEmptyString, offset: 0, lexeme: '', additionalInfo: hintEmptyString });\n            return undefined;\n        }\n        this._tokens = this._scanner.reset(input).scan();\n        this._current = 0;\n        this._parsingErrors = [];\n        try {\n            const expr = this._expr();\n            if (!this._isAtEnd()) {\n                const peek = this._peek();\n                const additionalInfo = peek.type === 17  ? hintUnexpectedToken : undefined;\n                this._parsingErrors.push({ message: errorUnexpectedToken, offset: peek.offset, lexeme: Scanner.getLexeme(peek), additionalInfo });\n                throw Parser._parseError;\n            }\n            return expr;\n        }\n        catch (e) {\n            if (!(e === Parser._parseError)) {\n                throw e;\n            }\n            return undefined;\n        }\n    }\n    _expr() {\n        return this._or();\n    }\n    _or() {\n        const expr = [this._and()];\n        while (this._matchOne(16 )) {\n            const right = this._and();\n            expr.push(right);\n        }\n        return expr.length === 1 ? expr[0] : ( (ContextKeyExpr.or(...expr)));\n    }\n    _and() {\n        const expr = [this._term()];\n        while (this._matchOne(15 )) {\n            const right = this._term();\n            expr.push(right);\n        }\n        return expr.length === 1 ? expr[0] : ( (ContextKeyExpr.and(...expr)));\n    }\n    _term() {\n        if (this._matchOne(2 )) {\n            const peek = this._peek();\n            switch (peek.type) {\n                case 11 :\n                    this._advance();\n                    return ContextKeyFalseExpr.INSTANCE;\n                case 12 :\n                    this._advance();\n                    return ContextKeyTrueExpr.INSTANCE;\n                case 0 : {\n                    this._advance();\n                    const expr = this._expr();\n                    this._consume(1 , errorClosingParenthesis);\n                    return expr?.negate();\n                }\n                case 17 :\n                    this._advance();\n                    return (\n                         (ContextKeyNotExpr.create(peek.lexeme))\n                    );\n                default:\n                    throw this._errExpectedButGot(`KEY | true | false | '(' expression ')'`, peek);\n            }\n        }\n        return this._primary();\n    }\n    _primary() {\n        const peek = this._peek();\n        switch (peek.type) {\n            case 11 :\n                this._advance();\n                return ContextKeyExpr.true();\n            case 12 :\n                this._advance();\n                return (\n                     (ContextKeyExpr.false())\n                );\n            case 0 : {\n                this._advance();\n                const expr = this._expr();\n                this._consume(1 , errorClosingParenthesis);\n                return expr;\n            }\n            case 17 : {\n                const key = peek.lexeme;\n                this._advance();\n                if (this._matchOne(9 )) {\n                    const expr = this._peek();\n                    if (!this._config.regexParsingWithErrorRecovery) {\n                        this._advance();\n                        if (expr.type !== 10 ) {\n                            throw this._errExpectedButGot(`REGEX`, expr);\n                        }\n                        const regexLexeme = expr.lexeme;\n                        const closingSlashIndex = regexLexeme.lastIndexOf('/');\n                        const flags = closingSlashIndex === regexLexeme.length - 1 ? undefined : this._removeFlagsGY(regexLexeme.substring(closingSlashIndex + 1));\n                        let regexp;\n                        try {\n                            regexp = ( (new RegExp(regexLexeme.substring(1, closingSlashIndex), flags)));\n                        }\n                        catch (e) {\n                            throw this._errExpectedButGot(`REGEX`, expr);\n                        }\n                        return ContextKeyRegexExpr.create(key, regexp);\n                    }\n                    switch (expr.type) {\n                        case 10 :\n                        case 19 : {\n                            const lexemeReconstruction = [expr.lexeme];\n                            this._advance();\n                            let followingToken = this._peek();\n                            let parenBalance = 0;\n                            for (let i = 0; i < expr.lexeme.length; i++) {\n                                if (expr.lexeme.charCodeAt(i) === 40 ) {\n                                    parenBalance++;\n                                }\n                                else if (expr.lexeme.charCodeAt(i) === 41 ) {\n                                    parenBalance--;\n                                }\n                            }\n                            while (!this._isAtEnd() && followingToken.type !== 15  && followingToken.type !== 16 ) {\n                                switch (followingToken.type) {\n                                    case 0 :\n                                        parenBalance++;\n                                        break;\n                                    case 1 :\n                                        parenBalance--;\n                                        break;\n                                    case 10 :\n                                    case 18 :\n                                        for (let i = 0; i < followingToken.lexeme.length; i++) {\n                                            if (followingToken.lexeme.charCodeAt(i) === 40 ) {\n                                                parenBalance++;\n                                            }\n                                            else if (expr.lexeme.charCodeAt(i) === 41 ) {\n                                                parenBalance--;\n                                            }\n                                        }\n                                }\n                                if (parenBalance < 0) {\n                                    break;\n                                }\n                                lexemeReconstruction.push(Scanner.getLexeme(followingToken));\n                                this._advance();\n                                followingToken = this._peek();\n                            }\n                            const regexLexeme = lexemeReconstruction.join('');\n                            const closingSlashIndex = regexLexeme.lastIndexOf('/');\n                            const flags = closingSlashIndex === regexLexeme.length - 1 ? undefined : this._removeFlagsGY(regexLexeme.substring(closingSlashIndex + 1));\n                            let regexp;\n                            try {\n                                regexp = ( (new RegExp(regexLexeme.substring(1, closingSlashIndex), flags)));\n                            }\n                            catch (e) {\n                                throw this._errExpectedButGot(`REGEX`, expr);\n                            }\n                            return (\n                                 (ContextKeyExpr.regex(key, regexp))\n                            );\n                        }\n                        case 18 : {\n                            const serializedValue = expr.lexeme;\n                            this._advance();\n                            let regex = null;\n                            if (!isFalsyOrWhitespace(serializedValue)) {\n                                const start = serializedValue.indexOf('/');\n                                const end = serializedValue.lastIndexOf('/');\n                                if (start !== end && start >= 0) {\n                                    const value = serializedValue.slice(start + 1, end);\n                                    const caseIgnoreFlag = serializedValue[end + 1] === 'i' ? 'i' : '';\n                                    try {\n                                        regex = ( (new RegExp(value, caseIgnoreFlag)));\n                                    }\n                                    catch (_e) {\n                                        throw this._errExpectedButGot(`REGEX`, expr);\n                                    }\n                                }\n                            }\n                            if (regex === null) {\n                                throw this._errExpectedButGot('REGEX', expr);\n                            }\n                            return ContextKeyRegexExpr.create(key, regex);\n                        }\n                        default:\n                            throw this._errExpectedButGot('REGEX', this._peek());\n                    }\n                }\n                if (this._matchOne(14 )) {\n                    this._consume(13 , errorNoInAfterNot);\n                    const right = this._value();\n                    return ContextKeyExpr.notIn(key, right);\n                }\n                const maybeOp = this._peek().type;\n                switch (maybeOp) {\n                    case 3 : {\n                        this._advance();\n                        const right = this._value();\n                        if (this._previous().type === 18 ) {\n                            return (\n                                 (ContextKeyExpr.equals(key, right))\n                            );\n                        }\n                        switch (right) {\n                            case 'true':\n                                return (\n                                     (ContextKeyExpr.has(key))\n                                );\n                            case 'false':\n                                return ContextKeyExpr.not(key);\n                            default:\n                                return (\n                                     (ContextKeyExpr.equals(key, right))\n                                );\n                        }\n                    }\n                    case 4 : {\n                        this._advance();\n                        const right = this._value();\n                        if (this._previous().type === 18 ) {\n                            return (\n                                 (ContextKeyExpr.notEquals(key, right))\n                            );\n                        }\n                        switch (right) {\n                            case 'true':\n                                return ContextKeyExpr.not(key);\n                            case 'false':\n                                return (\n                                     (ContextKeyExpr.has(key))\n                                );\n                            default:\n                                return (\n                                     (ContextKeyExpr.notEquals(key, right))\n                                );\n                        }\n                    }\n                    case 5 :\n                        this._advance();\n                        return ContextKeySmallerExpr.create(key, this._value());\n                    case 6 :\n                        this._advance();\n                        return ContextKeySmallerEqualsExpr.create(key, this._value());\n                    case 7 :\n                        this._advance();\n                        return ContextKeyGreaterExpr.create(key, this._value());\n                    case 8 :\n                        this._advance();\n                        return ContextKeyGreaterEqualsExpr.create(key, this._value());\n                    case 13 :\n                        this._advance();\n                        return ContextKeyExpr.in(key, this._value());\n                    default:\n                        return (\n                             (ContextKeyExpr.has(key))\n                        );\n                }\n            }\n            case 20 :\n                this._parsingErrors.push({ message: errorUnexpectedEOF, offset: peek.offset, lexeme: '', additionalInfo: hintUnexpectedEOF });\n                throw Parser._parseError;\n            default:\n                throw this._errExpectedButGot(`true | false | KEY \\n\\t| KEY '=~' REGEX \\n\\t| KEY ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in') value`, this._peek());\n        }\n    }\n    _value() {\n        const token = this._peek();\n        switch (token.type) {\n            case 17 :\n            case 18 :\n                this._advance();\n                return token.lexeme;\n            case 11 :\n                this._advance();\n                return 'true';\n            case 12 :\n                this._advance();\n                return 'false';\n            case 13 :\n                this._advance();\n                return 'in';\n            default:\n                return '';\n        }\n    }\n    _removeFlagsGY(flags) {\n        return flags.replaceAll(this._flagsGYRe, '');\n    }\n    _previous() {\n        return this._tokens[this._current - 1];\n    }\n    _matchOne(token) {\n        if (this._check(token)) {\n            this._advance();\n            return true;\n        }\n        return false;\n    }\n    _advance() {\n        if (!this._isAtEnd()) {\n            this._current++;\n        }\n        return this._previous();\n    }\n    _consume(type, message) {\n        if (this._check(type)) {\n            return this._advance();\n        }\n        throw this._errExpectedButGot(message, this._peek());\n    }\n    _errExpectedButGot(expected, got, additionalInfo) {\n        const message = ( localize(492, \"Expected: {0}\\nReceived: '{1}'.\", expected, Scanner.getLexeme(got)));\n        const offset = got.offset;\n        const lexeme = Scanner.getLexeme(got);\n        this._parsingErrors.push({ message, offset, lexeme, additionalInfo });\n        return Parser._parseError;\n    }\n    _check(type) {\n        return this._peek().type === type;\n    }\n    _peek() {\n        return this._tokens[this._current];\n    }\n    _isAtEnd() {\n        return this._peek().type === 20 ;\n    }\n}\nclass ContextKeyExpr {\n    static false() {\n        return ContextKeyFalseExpr.INSTANCE;\n    }\n    static true() {\n        return ContextKeyTrueExpr.INSTANCE;\n    }\n    static has(key) {\n        return (\n             (ContextKeyDefinedExpr.create(key))\n        );\n    }\n    static equals(key, value) {\n        return ContextKeyEqualsExpr.create(key, value);\n    }\n    static notEquals(key, value) {\n        return ContextKeyNotEqualsExpr.create(key, value);\n    }\n    static regex(key, value) {\n        return ContextKeyRegexExpr.create(key, value);\n    }\n    static in(key, value) {\n        return ContextKeyInExpr.create(key, value);\n    }\n    static notIn(key, value) {\n        return ContextKeyNotInExpr.create(key, value);\n    }\n    static not(key) {\n        return (\n             (ContextKeyNotExpr.create(key))\n        );\n    }\n    static and(...expr) {\n        return ContextKeyAndExpr.create(expr, null, true);\n    }\n    static or(...expr) {\n        return ContextKeyOrExpr.create(expr, null, true);\n    }\n    static greater(key, value) {\n        return ContextKeyGreaterExpr.create(key, value);\n    }\n    static greaterEquals(key, value) {\n        return ContextKeyGreaterEqualsExpr.create(key, value);\n    }\n    static smaller(key, value) {\n        return ContextKeySmallerExpr.create(key, value);\n    }\n    static smallerEquals(key, value) {\n        return ContextKeySmallerEqualsExpr.create(key, value);\n    }\n    static { this._parser = ( (new Parser({ regexParsingWithErrorRecovery: false }))); }\n    static deserialize(serialized) {\n        if (serialized === undefined || serialized === null) {\n            return undefined;\n        }\n        const expr = this._parser.parse(serialized);\n        return expr;\n    }\n}\nfunction validateWhenClauses(whenClauses) {\n    const parser = ( (new Parser({ regexParsingWithErrorRecovery: false })));\n    return (\n         (whenClauses.map(whenClause => {\n            parser.parse(whenClause);\n            if (parser.lexingErrors.length > 0) {\n                return (\n                     (parser.lexingErrors.map((se) => ({\n                        errorMessage: se.additionalInfo ?\n                            ( localize(493, \"Unexpected token. Hint: {0}\", se.additionalInfo)) :\n                            ( localize(494, \"Unexpected token.\")),\n                        offset: se.offset,\n                        length: se.lexeme.length,\n                    })))\n                );\n            }\n            else if (parser.parsingErrors.length > 0) {\n                return (\n                     (parser.parsingErrors.map((pe) => ({\n                        errorMessage: pe.additionalInfo ? `${pe.message}. ${pe.additionalInfo}` : pe.message,\n                        offset: pe.offset,\n                        length: pe.lexeme.length,\n                    })))\n                );\n            }\n            else {\n                return [];\n            }\n        }))\n    );\n}\nfunction expressionsAreEqualWithConstantSubstitution(a, b) {\n    const aExpr = a ? a.substituteConstants() : undefined;\n    const bExpr = b ? b.substituteConstants() : undefined;\n    if (!aExpr && !bExpr) {\n        return true;\n    }\n    if (!aExpr || !bExpr) {\n        return false;\n    }\n    return aExpr.equals(bExpr);\n}\nfunction cmp(a, b) {\n    return a.cmp(b);\n}\nclass ContextKeyFalseExpr {\n    static { this.INSTANCE = ( (new ContextKeyFalseExpr())); }\n    constructor() {\n        this.type = 0 ;\n    }\n    cmp(other) {\n        return this.type - other.type;\n    }\n    equals(other) {\n        return (other.type === this.type);\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return false;\n    }\n    serialize() {\n        return 'false';\n    }\n    keys() {\n        return [];\n    }\n    map(mapFnc) {\n        return this;\n    }\n    negate() {\n        return ContextKeyTrueExpr.INSTANCE;\n    }\n}\nclass ContextKeyTrueExpr {\n    static { this.INSTANCE = ( (new ContextKeyTrueExpr())); }\n    constructor() {\n        this.type = 1 ;\n    }\n    cmp(other) {\n        return this.type - other.type;\n    }\n    equals(other) {\n        return (other.type === this.type);\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return true;\n    }\n    serialize() {\n        return 'true';\n    }\n    keys() {\n        return [];\n    }\n    map(mapFnc) {\n        return this;\n    }\n    negate() {\n        return ContextKeyFalseExpr.INSTANCE;\n    }\n}\nclass ContextKeyDefinedExpr {\n    static create(key, negated = null) {\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n        }\n        return (\n             (new ContextKeyDefinedExpr(key, negated))\n        );\n    }\n    constructor(key, negated) {\n        this.key = key;\n        this.negated = negated;\n        this.type = 2 ;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp1(this.key, other.key);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n        }\n        return this;\n    }\n    evaluate(context) {\n        return (!!context.getValue(this.key));\n    }\n    serialize() {\n        return this.key;\n    }\n    keys() {\n        return [this.key];\n    }\n    map(mapFnc) {\n        return mapFnc.mapDefined(this.key);\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ( (ContextKeyNotExpr.create(this.key, this)));\n        }\n        return this.negated;\n    }\n}\nclass ContextKeyEqualsExpr {\n    static create(key, value, negated = null) {\n        if (typeof value === 'boolean') {\n            return (value ?  (ContextKeyDefinedExpr.create(key, negated)) :  (ContextKeyNotExpr.create(key, negated)));\n        }\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            const trueValue = constantValue ? 'true' : 'false';\n            return (value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE);\n        }\n        return (\n             (new ContextKeyEqualsExpr(key, value, negated))\n        );\n    }\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 4 ;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            const trueValue = constantValue ? 'true' : 'false';\n            return (this.value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE);\n        }\n        return this;\n    }\n    evaluate(context) {\n        return (context.getValue(this.key) == this.value);\n    }\n    serialize() {\n        return `${this.key} == '${this.value}'`;\n    }\n    keys() {\n        return [this.key];\n    }\n    map(mapFnc) {\n        return mapFnc.mapEquals(this.key, this.value);\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyNotEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nclass ContextKeyInExpr {\n    static create(key, valueKey) {\n        return (\n             (new ContextKeyInExpr(key, valueKey))\n        );\n    }\n    constructor(key, valueKey) {\n        this.key = key;\n        this.valueKey = valueKey;\n        this.type = 10 ;\n        this.negated = null;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.valueKey, other.key, other.valueKey);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.valueKey === other.valueKey);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        const source = context.getValue(this.valueKey);\n        const item = context.getValue(this.key);\n        if (Array.isArray(source)) {\n            return source.includes(item);\n        }\n        if (typeof item === 'string' && typeof source === 'object' && source !== null) {\n            return hasOwnProperty.call(source, item);\n        }\n        return false;\n    }\n    serialize() {\n        return `${this.key} in '${this.valueKey}'`;\n    }\n    keys() {\n        return [this.key, this.valueKey];\n    }\n    map(mapFnc) {\n        return mapFnc.mapIn(this.key, this.valueKey);\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyNotInExpr.create(this.key, this.valueKey);\n        }\n        return this.negated;\n    }\n}\nclass ContextKeyNotInExpr {\n    static create(key, valueKey) {\n        return (\n             (new ContextKeyNotInExpr(key, valueKey))\n        );\n    }\n    constructor(key, valueKey) {\n        this.key = key;\n        this.valueKey = valueKey;\n        this.type = 11 ;\n        this._negated = ContextKeyInExpr.create(key, valueKey);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return this._negated.cmp(other._negated);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return this._negated.equals(other._negated);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return !this._negated.evaluate(context);\n    }\n    serialize() {\n        return `${this.key} not in '${this.valueKey}'`;\n    }\n    keys() {\n        return (\n             (this._negated.keys())\n        );\n    }\n    map(mapFnc) {\n        return mapFnc.mapNotIn(this.key, this.valueKey);\n    }\n    negate() {\n        return this._negated;\n    }\n}\nclass ContextKeyNotEqualsExpr {\n    static create(key, value, negated = null) {\n        if (typeof value === 'boolean') {\n            if (value) {\n                return (\n                     (ContextKeyNotExpr.create(key, negated))\n                );\n            }\n            return (\n                 (ContextKeyDefinedExpr.create(key, negated))\n            );\n        }\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            const falseValue = constantValue ? 'true' : 'false';\n            return (value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return (\n             (new ContextKeyNotEqualsExpr(key, value, negated))\n        );\n    }\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 5 ;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            const falseValue = constantValue ? 'true' : 'false';\n            return (this.value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return this;\n    }\n    evaluate(context) {\n        return (context.getValue(this.key) != this.value);\n    }\n    serialize() {\n        return `${this.key} != '${this.value}'`;\n    }\n    keys() {\n        return [this.key];\n    }\n    map(mapFnc) {\n        return mapFnc.mapNotEquals(this.key, this.value);\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nclass ContextKeyNotExpr {\n    static create(key, negated = null) {\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            return (constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return (\n             (new ContextKeyNotExpr(key, negated))\n        );\n    }\n    constructor(key, negated) {\n        this.key = key;\n        this.negated = negated;\n        this.type = 3 ;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp1(this.key, other.key);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            return (constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return this;\n    }\n    evaluate(context) {\n        return (!context.getValue(this.key));\n    }\n    serialize() {\n        return `!${this.key}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    map(mapFnc) {\n        return mapFnc.mapNot(this.key);\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ( (ContextKeyDefinedExpr.create(this.key, this)));\n        }\n        return this.negated;\n    }\n}\nfunction withFloatOrStr(value, callback) {\n    if (typeof value === 'string') {\n        const n = parseFloat(value);\n        if (!isNaN(n)) {\n            value = n;\n        }\n    }\n    if (typeof value === 'string' || typeof value === 'number') {\n        return callback(value);\n    }\n    return ContextKeyFalseExpr.INSTANCE;\n}\nclass ContextKeyGreaterExpr {\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => ( (new ContextKeyGreaterExpr(key, value, negated))));\n    }\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 12 ;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) > this.value);\n    }\n    serialize() {\n        return `${this.key} > ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    map(mapFnc) {\n        return mapFnc.mapGreater(this.key, this.value);\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeySmallerEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nclass ContextKeyGreaterEqualsExpr {\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => ( (new ContextKeyGreaterEqualsExpr(key, value, negated))));\n    }\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 13 ;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) >= this.value);\n    }\n    serialize() {\n        return `${this.key} >= ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    map(mapFnc) {\n        return mapFnc.mapGreaterEquals(this.key, this.value);\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeySmallerExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nclass ContextKeySmallerExpr {\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => ( (new ContextKeySmallerExpr(key, value, negated))));\n    }\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 14 ;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) < this.value);\n    }\n    serialize() {\n        return `${this.key} < ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    map(mapFnc) {\n        return mapFnc.mapSmaller(this.key, this.value);\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyGreaterEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nclass ContextKeySmallerEqualsExpr {\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => ( (new ContextKeySmallerEqualsExpr(key, value, negated))));\n    }\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 15 ;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) <= this.value);\n    }\n    serialize() {\n        return `${this.key} <= ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    map(mapFnc) {\n        return mapFnc.mapSmallerEquals(this.key, this.value);\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyGreaterExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nclass ContextKeyRegexExpr {\n    static create(key, regexp) {\n        return (\n             (new ContextKeyRegexExpr(key, regexp))\n        );\n    }\n    constructor(key, regexp) {\n        this.key = key;\n        this.regexp = regexp;\n        this.type = 7 ;\n        this.negated = null;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        if (this.key < other.key) {\n            return -1;\n        }\n        if (this.key > other.key) {\n            return 1;\n        }\n        const thisSource = this.regexp ? this.regexp.source : '';\n        const otherSource = other.regexp ? other.regexp.source : '';\n        if (thisSource < otherSource) {\n            return -1;\n        }\n        if (thisSource > otherSource) {\n            return 1;\n        }\n        return 0;\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            const thisSource = this.regexp ? this.regexp.source : '';\n            const otherSource = other.regexp ? other.regexp.source : '';\n            return (this.key === other.key && thisSource === otherSource);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        const value = context.getValue(this.key);\n        return this.regexp ? this.regexp.test(value) : false;\n    }\n    serialize() {\n        const value = this.regexp\n            ? `/${this.regexp.source}/${this.regexp.flags}`\n            : '/invalid/';\n        return `${this.key} =~ ${value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    map(mapFnc) {\n        return mapFnc.mapRegex(this.key, this.regexp);\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyNotRegexExpr.create(this);\n        }\n        return this.negated;\n    }\n}\nclass ContextKeyNotRegexExpr {\n    static create(actual) {\n        return (\n             (new ContextKeyNotRegexExpr(actual))\n        );\n    }\n    constructor(_actual) {\n        this._actual = _actual;\n        this.type = 8 ;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return this._actual.cmp(other._actual);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return this._actual.equals(other._actual);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return !this._actual.evaluate(context);\n    }\n    serialize() {\n        return `!(${this._actual.serialize()})`;\n    }\n    keys() {\n        return (\n             (this._actual.keys())\n        );\n    }\n    map(mapFnc) {\n        return (\n             (new ContextKeyNotRegexExpr( (this._actual.map(mapFnc))))\n        );\n    }\n    negate() {\n        return this._actual;\n    }\n}\nfunction eliminateConstantsInArray(arr) {\n    let newArr = null;\n    for (let i = 0, len = arr.length; i < len; i++) {\n        const newExpr = arr[i].substituteConstants();\n        if (arr[i] !== newExpr) {\n            if (newArr === null) {\n                newArr = [];\n                for (let j = 0; j < i; j++) {\n                    newArr[j] = arr[j];\n                }\n            }\n        }\n        if (newArr !== null) {\n            newArr[i] = newExpr;\n        }\n    }\n    if (newArr === null) {\n        return arr;\n    }\n    return newArr;\n}\nclass ContextKeyAndExpr {\n    static create(_expr, negated, extraRedundantCheck) {\n        return ContextKeyAndExpr._normalizeArr(_expr, negated, extraRedundantCheck);\n    }\n    constructor(expr, negated) {\n        this.expr = expr;\n        this.negated = negated;\n        this.type = 6 ;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        if (this.expr.length < other.expr.length) {\n            return -1;\n        }\n        if (this.expr.length > other.expr.length) {\n            return 1;\n        }\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            const r = cmp(this.expr[i], other.expr[i]);\n            if (r !== 0) {\n                return r;\n            }\n        }\n        return 0;\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            if (this.expr.length !== other.expr.length) {\n                return false;\n            }\n            for (let i = 0, len = this.expr.length; i < len; i++) {\n                if (!this.expr[i].equals(other.expr[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    substituteConstants() {\n        const exprArr = eliminateConstantsInArray(this.expr);\n        if (exprArr === this.expr) {\n            return this;\n        }\n        return ContextKeyAndExpr.create(exprArr, this.negated, false);\n    }\n    evaluate(context) {\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            if (!this.expr[i].evaluate(context)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _normalizeArr(arr, negated, extraRedundantCheck) {\n        const expr = [];\n        let hasTrue = false;\n        for (const e of arr) {\n            if (!e) {\n                continue;\n            }\n            if (e.type === 1 ) {\n                hasTrue = true;\n                continue;\n            }\n            if (e.type === 0 ) {\n                return ContextKeyFalseExpr.INSTANCE;\n            }\n            if (e.type === 6 ) {\n                expr.push(...e.expr);\n                continue;\n            }\n            expr.push(e);\n        }\n        if (expr.length === 0 && hasTrue) {\n            return ContextKeyTrueExpr.INSTANCE;\n        }\n        if (expr.length === 0) {\n            return undefined;\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        expr.sort(cmp);\n        for (let i = 1; i < expr.length; i++) {\n            if (expr[i - 1].equals(expr[i])) {\n                expr.splice(i, 1);\n                i--;\n            }\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        while (expr.length > 1) {\n            const lastElement = expr[expr.length - 1];\n            if (lastElement.type !== 9 ) {\n                break;\n            }\n            expr.pop();\n            const secondToLastElement = expr.pop();\n            const isFinished = (expr.length === 0);\n            const resultElement = ContextKeyOrExpr.create(( (lastElement.expr.map(\n                el => ContextKeyAndExpr.create([el, secondToLastElement], null, extraRedundantCheck)\n            ))), null, isFinished);\n            if (resultElement) {\n                expr.push(resultElement);\n                expr.sort(cmp);\n            }\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        if (extraRedundantCheck) {\n            for (let i = 0; i < expr.length; i++) {\n                for (let j = i + 1; j < expr.length; j++) {\n                    if (( (expr[i].negate())).equals(expr[j])) {\n                        return ContextKeyFalseExpr.INSTANCE;\n                    }\n                }\n            }\n            if (expr.length === 1) {\n                return expr[0];\n            }\n        }\n        return (\n             (new ContextKeyAndExpr(expr, negated))\n        );\n    }\n    serialize() {\n        return ( (this.expr.map(e => e.serialize()))).join(' && ');\n    }\n    keys() {\n        const result = [];\n        for (const expr of this.expr) {\n            result.push(...( (expr.keys())));\n        }\n        return result;\n    }\n    map(mapFnc) {\n        return (\n             (new ContextKeyAndExpr(\n                 (this.expr.map(expr => ( (expr.map(mapFnc))))),\n                null\n            ))\n        );\n    }\n    negate() {\n        if (!this.negated) {\n            const result = [];\n            for (const expr of this.expr) {\n                result.push(( (expr.negate())));\n            }\n            this.negated = ContextKeyOrExpr.create(result, this, true);\n        }\n        return this.negated;\n    }\n}\nclass ContextKeyOrExpr {\n    static create(_expr, negated, extraRedundantCheck) {\n        return ContextKeyOrExpr._normalizeArr(_expr, negated, extraRedundantCheck);\n    }\n    constructor(expr, negated) {\n        this.expr = expr;\n        this.negated = negated;\n        this.type = 9 ;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        if (this.expr.length < other.expr.length) {\n            return -1;\n        }\n        if (this.expr.length > other.expr.length) {\n            return 1;\n        }\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            const r = cmp(this.expr[i], other.expr[i]);\n            if (r !== 0) {\n                return r;\n            }\n        }\n        return 0;\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            if (this.expr.length !== other.expr.length) {\n                return false;\n            }\n            for (let i = 0, len = this.expr.length; i < len; i++) {\n                if (!this.expr[i].equals(other.expr[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    substituteConstants() {\n        const exprArr = eliminateConstantsInArray(this.expr);\n        if (exprArr === this.expr) {\n            return this;\n        }\n        return ContextKeyOrExpr.create(exprArr, this.negated, false);\n    }\n    evaluate(context) {\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            if (this.expr[i].evaluate(context)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    static _normalizeArr(arr, negated, extraRedundantCheck) {\n        let expr = [];\n        let hasFalse = false;\n        if (arr) {\n            for (let i = 0, len = arr.length; i < len; i++) {\n                const e = arr[i];\n                if (!e) {\n                    continue;\n                }\n                if (e.type === 0 ) {\n                    hasFalse = true;\n                    continue;\n                }\n                if (e.type === 1 ) {\n                    return ContextKeyTrueExpr.INSTANCE;\n                }\n                if (e.type === 9 ) {\n                    expr = expr.concat(e.expr);\n                    continue;\n                }\n                expr.push(e);\n            }\n            if (expr.length === 0 && hasFalse) {\n                return ContextKeyFalseExpr.INSTANCE;\n            }\n            expr.sort(cmp);\n        }\n        if (expr.length === 0) {\n            return undefined;\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        for (let i = 1; i < expr.length; i++) {\n            if (expr[i - 1].equals(expr[i])) {\n                expr.splice(i, 1);\n                i--;\n            }\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        if (extraRedundantCheck) {\n            for (let i = 0; i < expr.length; i++) {\n                for (let j = i + 1; j < expr.length; j++) {\n                    if (( (expr[i].negate())).equals(expr[j])) {\n                        return ContextKeyTrueExpr.INSTANCE;\n                    }\n                }\n            }\n            if (expr.length === 1) {\n                return expr[0];\n            }\n        }\n        return (\n             (new ContextKeyOrExpr(expr, negated))\n        );\n    }\n    serialize() {\n        return ( (this.expr.map(e => e.serialize()))).join(' || ');\n    }\n    keys() {\n        const result = [];\n        for (const expr of this.expr) {\n            result.push(...( (expr.keys())));\n        }\n        return result;\n    }\n    map(mapFnc) {\n        return (\n             (new ContextKeyOrExpr(\n                 (this.expr.map(expr => ( (expr.map(mapFnc))))),\n                null\n            ))\n        );\n    }\n    negate() {\n        if (!this.negated) {\n            const result = [];\n            for (const expr of this.expr) {\n                result.push(( (expr.negate())));\n            }\n            while (result.length > 1) {\n                const LEFT = result.shift();\n                const RIGHT = result.shift();\n                const all = [];\n                for (const left of getTerminals(LEFT)) {\n                    for (const right of getTerminals(RIGHT)) {\n                        all.push(ContextKeyAndExpr.create([left, right], null, false));\n                    }\n                }\n                result.unshift(ContextKeyOrExpr.create(all, null, false));\n            }\n            this.negated = ContextKeyOrExpr.create(result, this, true);\n        }\n        return this.negated;\n    }\n}\nclass RawContextKey extends ContextKeyDefinedExpr {\n    static { this._info = []; }\n    static all() {\n        return (\n             (RawContextKey._info.values())\n        );\n    }\n    constructor(key, defaultValue, metaOrHide) {\n        super(key, null);\n        this._defaultValue = defaultValue;\n        if (typeof metaOrHide === 'object') {\n            RawContextKey._info.push({ ...metaOrHide, key });\n        }\n        else if (metaOrHide !== true) {\n            RawContextKey._info.push({ key, description: metaOrHide, type: defaultValue !== null && defaultValue !== undefined ? typeof defaultValue : undefined });\n        }\n    }\n    bindTo(target) {\n        return target.createKey(this.key, this._defaultValue);\n    }\n    getValue(target) {\n        return target.getContextKeyValue(this.key);\n    }\n    toNegated() {\n        return (\n             (this.negate())\n        );\n    }\n    isEqualTo(value) {\n        return ContextKeyEqualsExpr.create(this.key, value);\n    }\n    notEqualsTo(value) {\n        return ContextKeyNotEqualsExpr.create(this.key, value);\n    }\n}\nfunction cmp1(key1, key2) {\n    if (key1 < key2) {\n        return -1;\n    }\n    if (key1 > key2) {\n        return 1;\n    }\n    return 0;\n}\nfunction cmp2(key1, value1, key2, value2) {\n    if (key1 < key2) {\n        return -1;\n    }\n    if (key1 > key2) {\n        return 1;\n    }\n    if (value1 < value2) {\n        return -1;\n    }\n    if (value1 > value2) {\n        return 1;\n    }\n    return 0;\n}\nfunction implies(p, q) {\n    if (p.type === 0  || q.type === 1 ) {\n        return true;\n    }\n    if (p.type === 9 ) {\n        if (q.type === 9 ) {\n            return allElementsIncluded(p.expr, q.expr);\n        }\n        return false;\n    }\n    if (q.type === 9 ) {\n        for (const element of q.expr) {\n            if (implies(p, element)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (p.type === 6 ) {\n        if (q.type === 6 ) {\n            return allElementsIncluded(q.expr, p.expr);\n        }\n        for (const element of p.expr) {\n            if (implies(element, q)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    return p.equals(q);\n}\nfunction allElementsIncluded(p, q) {\n    let pIndex = 0;\n    let qIndex = 0;\n    while (pIndex < p.length && qIndex < q.length) {\n        const cmp = p[pIndex].cmp(q[qIndex]);\n        if (cmp < 0) {\n            return false;\n        }\n        else if (cmp === 0) {\n            pIndex++;\n            qIndex++;\n        }\n        else {\n            qIndex++;\n        }\n    }\n    return (pIndex === p.length);\n}\nfunction getTerminals(node) {\n    if (node.type === 9 ) {\n        return node.expr;\n    }\n    return [node];\n}\nexport { ContextKeyAndExpr, ContextKeyDefinedExpr, ContextKeyEqualsExpr, ContextKeyExpr, ContextKeyFalseExpr, ContextKeyGreaterEqualsExpr, ContextKeyGreaterExpr, ContextKeyInExpr, ContextKeyNotEqualsExpr, ContextKeyNotExpr, ContextKeyNotInExpr, ContextKeyNotRegexExpr, ContextKeyOrExpr, ContextKeyRegexExpr, ContextKeySmallerEqualsExpr, ContextKeySmallerExpr, ContextKeyTrueExpr, Parser, RawContextKey, expressionsAreEqualWithConstantSubstitution, implies, setConstant, validateWhenClauses };\n","import { createDecorator } from '../../instantiation/common/instantiation.js';\nconst IContextKeyService = ( createDecorator('contextKeyService'));\nexport { IContextKeyService };\n","import { illegalState } from '../../../base/common/errors.js';\nimport { localize } from '../../../nls.js';\nfunction hintDidYouMean(...meant) {\n    switch (meant.length) {\n        case 1:\n            return ( localize(1952, \"Did you mean {0}?\", meant[0]));\n        case 2:\n            return ( localize(1953, \"Did you mean {0} or {1}?\", meant[0], meant[1]));\n        case 3:\n            return ( localize(1954, \"Did you mean {0}, {1} or {2}?\", meant[0], meant[1], meant[2]));\n        default:\n            return undefined;\n    }\n}\nconst hintDidYouForgetToOpenOrCloseQuote = ( localize(1955, \"Did you forget to open or close the quote?\"));\nconst hintDidYouForgetToEscapeSlash = ( localize(\n    1956,\n    \"Did you forget to escape the '/' (slash) character? Put two backslashes before it to escape, e.g., '\\\\\\\\/\\'.\"\n));\nclass Scanner {\n    constructor() {\n        this._input = '';\n        this._start = 0;\n        this._current = 0;\n        this._tokens = [];\n        this._errors = [];\n        this.stringRe = /[a-zA-Z0-9_<>\\-\\./\\\\:\\*\\?\\+\\[\\]\\^,#@;\"%\\$\\p{L}-]+/uy;\n    }\n    static getLexeme(token) {\n        switch (token.type) {\n            case 0 :\n                return '(';\n            case 1 :\n                return ')';\n            case 2 :\n                return '!';\n            case 3 :\n                return token.isTripleEq ? '===' : '==';\n            case 4 :\n                return token.isTripleEq ? '!==' : '!=';\n            case 5 :\n                return '<';\n            case 6 :\n                return '<=';\n            case 7 :\n                return '>=';\n            case 8 :\n                return '>=';\n            case 9 :\n                return '=~';\n            case 10 :\n                return token.lexeme;\n            case 11 :\n                return 'true';\n            case 12 :\n                return 'false';\n            case 13 :\n                return 'in';\n            case 14 :\n                return 'not';\n            case 15 :\n                return '&&';\n            case 16 :\n                return '||';\n            case 17 :\n                return token.lexeme;\n            case 18 :\n                return token.lexeme;\n            case 19 :\n                return token.lexeme;\n            case 20 :\n                return 'EOF';\n            default:\n                throw illegalState(`unhandled token type: ${JSON.stringify(token)}; have you forgotten to add a case?`);\n        }\n    }\n    static { this._regexFlags = ( (new Set( (['i', 'g', 's', 'm', 'y', 'u'].map(ch => ch.charCodeAt(0)))))); }\n    static { this._keywords = ( (new Map([\n        ['not', 14 ],\n        ['in', 13 ],\n        ['false', 12 ],\n        ['true', 11 ],\n    ]))); }\n    get errors() {\n        return this._errors;\n    }\n    reset(value) {\n        this._input = value;\n        this._start = 0;\n        this._current = 0;\n        this._tokens = [];\n        this._errors = [];\n        return this;\n    }\n    scan() {\n        while (!this._isAtEnd()) {\n            this._start = this._current;\n            const ch = this._advance();\n            switch (ch) {\n                case 40 :\n                    this._addToken(0 );\n                    break;\n                case 41 :\n                    this._addToken(1 );\n                    break;\n                case 33 :\n                    if (this._match(61 )) {\n                        const isTripleEq = this._match(61 );\n                        this._tokens.push({ type: 4 , offset: this._start, isTripleEq });\n                    }\n                    else {\n                        this._addToken(2 );\n                    }\n                    break;\n                case 39 :\n                    this._quotedString();\n                    break;\n                case 47 :\n                    this._regex();\n                    break;\n                case 61 :\n                    if (this._match(61 )) {\n                        const isTripleEq = this._match(61 );\n                        this._tokens.push({ type: 3 , offset: this._start, isTripleEq });\n                    }\n                    else if (this._match(126 )) {\n                        this._addToken(9 );\n                    }\n                    else {\n                        this._error(hintDidYouMean('==', '=~'));\n                    }\n                    break;\n                case 60 :\n                    this._addToken(this._match(61 ) ? 6  : 5 );\n                    break;\n                case 62 :\n                    this._addToken(this._match(61 ) ? 8  : 7 );\n                    break;\n                case 38 :\n                    if (this._match(38 )) {\n                        this._addToken(15 );\n                    }\n                    else {\n                        this._error(hintDidYouMean('&&'));\n                    }\n                    break;\n                case 124 :\n                    if (this._match(124 )) {\n                        this._addToken(16 );\n                    }\n                    else {\n                        this._error(hintDidYouMean('||'));\n                    }\n                    break;\n                case 32 :\n                case 13 :\n                case 9 :\n                case 10 :\n                case 160 :\n                    break;\n                default:\n                    this._string();\n            }\n        }\n        this._start = this._current;\n        this._addToken(20 );\n        return Array.from(this._tokens);\n    }\n    _match(expected) {\n        if (this._isAtEnd()) {\n            return false;\n        }\n        if (this._input.charCodeAt(this._current) !== expected) {\n            return false;\n        }\n        this._current++;\n        return true;\n    }\n    _advance() {\n        return this._input.charCodeAt(this._current++);\n    }\n    _peek() {\n        return this._isAtEnd() ? 0  : this._input.charCodeAt(this._current);\n    }\n    _addToken(type) {\n        this._tokens.push({ type, offset: this._start });\n    }\n    _error(additional) {\n        const offset = this._start;\n        const lexeme = this._input.substring(this._start, this._current);\n        const errToken = { type: 19 , offset: this._start, lexeme };\n        this._errors.push({ offset, lexeme, additionalInfo: additional });\n        this._tokens.push(errToken);\n    }\n    _string() {\n        this.stringRe.lastIndex = this._start;\n        const match = this.stringRe.exec(this._input);\n        if (match) {\n            this._current = this._start + match[0].length;\n            const lexeme = this._input.substring(this._start, this._current);\n            const keyword = Scanner._keywords.get(lexeme);\n            if (keyword) {\n                this._addToken(keyword);\n            }\n            else {\n                this._tokens.push({ type: 17 , lexeme, offset: this._start });\n            }\n        }\n    }\n    _quotedString() {\n        while (this._peek() !== 39  && !this._isAtEnd()) {\n            this._advance();\n        }\n        if (this._isAtEnd()) {\n            this._error(hintDidYouForgetToOpenOrCloseQuote);\n            return;\n        }\n        this._advance();\n        this._tokens.push({ type: 18 , lexeme: this._input.substring(this._start + 1, this._current - 1), offset: this._start + 1 });\n    }\n    _regex() {\n        let p = this._current;\n        let inEscape = false;\n        let inCharacterClass = false;\n        while (true) {\n            if (p >= this._input.length) {\n                this._current = p;\n                this._error(hintDidYouForgetToEscapeSlash);\n                return;\n            }\n            const ch = this._input.charCodeAt(p);\n            if (inEscape) {\n                inEscape = false;\n            }\n            else if (ch === 47  && !inCharacterClass) {\n                p++;\n                break;\n            }\n            else if (ch === 91 ) {\n                inCharacterClass = true;\n            }\n            else if (ch === 92 ) {\n                inEscape = true;\n            }\n            else if (ch === 93 ) {\n                inCharacterClass = false;\n            }\n            p++;\n        }\n        while (p < this._input.length && ( (Scanner._regexFlags.has(this._input.charCodeAt(p))))) {\n            p++;\n        }\n        this._current = p;\n        const lexeme = this._input.substring(this._start, this._current);\n        this._tokens.push({ type: 10 , lexeme, offset: this._start });\n    }\n    _isAtEnd() {\n        return this._current >= this._input.length;\n    }\n}\nexport { Scanner };\n","import { localize2 } from '../../../nls.js';\nconst EXTENSION_IDENTIFIER_PATTERN = '^([a-z0-9A-Z][a-z0-9-A-Z]*)\\\\.([a-z0-9A-Z][a-z0-9-A-Z]*)$';\nconst EXTENSION_IDENTIFIER_REGEX = ( (new RegExp(EXTENSION_IDENTIFIER_PATTERN)));\nconst WEB_EXTENSION_TAG = '__web_extension';\nconst EXTENSION_INSTALL_SKIP_WALKTHROUGH_CONTEXT = 'skipWalkthrough';\nconst EXTENSION_INSTALL_SOURCE_CONTEXT = 'extensionInstallSource';\nconst EXTENSION_INSTALL_DEP_PACK_CONTEXT = 'dependecyOrPackExtensionInstall';\nfunction TargetPlatformToString(targetPlatform) {\n    switch (targetPlatform) {\n        case \"win32-x64\" : return 'Windows 64 bit';\n        case \"win32-arm64\" : return 'Windows ARM';\n        case \"linux-x64\" : return 'Linux 64 bit';\n        case \"linux-arm64\" : return 'Linux ARM 64';\n        case \"linux-armhf\" : return 'Linux ARM';\n        case \"alpine-x64\" : return 'Alpine Linux 64 bit';\n        case \"alpine-arm64\" : return 'Alpine ARM 64';\n        case \"darwin-x64\" : return 'Mac';\n        case \"darwin-arm64\" : return 'Mac Silicon';\n        case \"web\" : return 'Web';\n        case \"universal\" : return \"universal\" ;\n        case \"unknown\" : return \"unknown\" ;\n        case \"undefined\" : return \"undefined\" ;\n    }\n}\nfunction toTargetPlatform(targetPlatform) {\n    switch (targetPlatform) {\n        case \"win32-x64\" : return \"win32-x64\" ;\n        case \"win32-arm64\" : return \"win32-arm64\" ;\n        case \"linux-x64\" : return \"linux-x64\" ;\n        case \"linux-arm64\" : return \"linux-arm64\" ;\n        case \"linux-armhf\" : return \"linux-armhf\" ;\n        case \"alpine-x64\" : return \"alpine-x64\" ;\n        case \"alpine-arm64\" : return \"alpine-arm64\" ;\n        case \"darwin-x64\" : return \"darwin-x64\" ;\n        case \"darwin-arm64\" : return \"darwin-arm64\" ;\n        case \"web\" : return \"web\" ;\n        case \"universal\" : return \"universal\" ;\n        default: return \"unknown\" ;\n    }\n}\nfunction getTargetPlatform(platform, arch) {\n    switch (platform) {\n        case 3 :\n            if (arch === 'x64') {\n                return \"win32-x64\" ;\n            }\n            if (arch === 'arm64') {\n                return \"win32-arm64\" ;\n            }\n            return \"unknown\" ;\n        case 2 :\n            if (arch === 'x64') {\n                return \"linux-x64\" ;\n            }\n            if (arch === 'arm64') {\n                return \"linux-arm64\" ;\n            }\n            if (arch === 'arm') {\n                return \"linux-armhf\" ;\n            }\n            return \"unknown\" ;\n        case 'alpine':\n            if (arch === 'x64') {\n                return \"alpine-x64\" ;\n            }\n            if (arch === 'arm64') {\n                return \"alpine-arm64\" ;\n            }\n            return \"unknown\" ;\n        case 1 :\n            if (arch === 'x64') {\n                return \"darwin-x64\" ;\n            }\n            if (arch === 'arm64') {\n                return \"darwin-arm64\" ;\n            }\n            return \"unknown\" ;\n        case 0 : return \"web\" ;\n    }\n}\nfunction isNotWebExtensionInWebTargetPlatform(allTargetPlatforms, productTargetPlatform) {\n    return productTargetPlatform === \"web\"  && !allTargetPlatforms.includes(\"web\" );\n}\nfunction isTargetPlatformCompatible(extensionTargetPlatform, allTargetPlatforms, productTargetPlatform) {\n    if (isNotWebExtensionInWebTargetPlatform(allTargetPlatforms, productTargetPlatform)) {\n        return false;\n    }\n    if (extensionTargetPlatform === \"undefined\" ) {\n        return true;\n    }\n    if (extensionTargetPlatform === \"universal\" ) {\n        return true;\n    }\n    if (extensionTargetPlatform === \"unknown\" ) {\n        return false;\n    }\n    if (extensionTargetPlatform === productTargetPlatform) {\n        return true;\n    }\n    return false;\n}\nfunction isIExtensionIdentifier(thing) {\n    return thing\n        && typeof thing === 'object'\n        && typeof thing.id === 'string'\n        && (!thing.uuid || typeof thing.uuid === 'string');\n}\nclass ExtensionGalleryError extends Error {\n    constructor(message, code) {\n        super(message);\n        this.code = code;\n        this.name = code;\n    }\n}\nvar ExtensionSignatureVerificationCode;\n( ((function(ExtensionSignatureVerificationCode) {\n    ExtensionSignatureVerificationCode[\"Success\"] = \"Success\";\n    ExtensionSignatureVerificationCode[\"RequiredArgumentMissing\"] = \"RequiredArgumentMissing\";\n    ExtensionSignatureVerificationCode[\"InvalidArgument\"] = \"InvalidArgument\";\n    ExtensionSignatureVerificationCode[\"PackageIsUnreadable\"] = \"PackageIsUnreadable\";\n    ExtensionSignatureVerificationCode[\"UnhandledException\"] = \"UnhandledException\";\n    ExtensionSignatureVerificationCode[\"SignatureManifestIsMissing\"] = \"SignatureManifestIsMissing\";\n    ExtensionSignatureVerificationCode[\"SignatureManifestIsUnreadable\"] = \"SignatureManifestIsUnreadable\";\n    ExtensionSignatureVerificationCode[\"SignatureIsMissing\"] = \"SignatureIsMissing\";\n    ExtensionSignatureVerificationCode[\"SignatureIsUnreadable\"] = \"SignatureIsUnreadable\";\n    ExtensionSignatureVerificationCode[\"CertificateIsUnreadable\"] = \"CertificateIsUnreadable\";\n    ExtensionSignatureVerificationCode[\"SignatureArchiveIsUnreadable\"] = \"SignatureArchiveIsUnreadable\";\n    ExtensionSignatureVerificationCode[\"FileAlreadyExists\"] = \"FileAlreadyExists\";\n    ExtensionSignatureVerificationCode[\"SignatureArchiveIsInvalidZip\"] = \"SignatureArchiveIsInvalidZip\";\n    ExtensionSignatureVerificationCode[\"SignatureArchiveHasSameSignatureFile\"] = \"SignatureArchiveHasSameSignatureFile\";\n    ExtensionSignatureVerificationCode[\"PackageIntegrityCheckFailed\"] = \"PackageIntegrityCheckFailed\";\n    ExtensionSignatureVerificationCode[\"SignatureIsInvalid\"] = \"SignatureIsInvalid\";\n    ExtensionSignatureVerificationCode[\"SignatureManifestIsInvalid\"] = \"SignatureManifestIsInvalid\";\n    ExtensionSignatureVerificationCode[\"SignatureIntegrityCheckFailed\"] = \"SignatureIntegrityCheckFailed\";\n    ExtensionSignatureVerificationCode[\"EntryIsMissing\"] = \"EntryIsMissing\";\n    ExtensionSignatureVerificationCode[\"EntryIsTampered\"] = \"EntryIsTampered\";\n    ExtensionSignatureVerificationCode[\"Untrusted\"] = \"Untrusted\";\n    ExtensionSignatureVerificationCode[\"CertificateRevoked\"] = \"CertificateRevoked\";\n    ExtensionSignatureVerificationCode[\"SignatureIsNotValid\"] = \"SignatureIsNotValid\";\n    ExtensionSignatureVerificationCode[\"UnknownError\"] = \"UnknownError\";\n    ExtensionSignatureVerificationCode[\"PackageIsInvalidZip\"] = \"PackageIsInvalidZip\";\n    ExtensionSignatureVerificationCode[\"SignatureArchiveHasTooManyEntries\"] = \"SignatureArchiveHasTooManyEntries\";\n})(\n    ExtensionSignatureVerificationCode || (ExtensionSignatureVerificationCode = {})\n)));\nclass ExtensionManagementError extends Error {\n    constructor(message, code) {\n        super(message);\n        this.code = code;\n        this.name = code;\n    }\n}\nconst DISABLED_EXTENSIONS_STORAGE_PATH = 'extensionsIdentifiers/disabled';\nconst ENABLED_EXTENSIONS_STORAGE_PATH = 'extensionsIdentifiers/enabled';\nconst ExtensionsLocalizedLabel = ( localize2(1600, \"Extensions\"));\nconst PreferencesLocalizedLabel = ( localize2(1601, 'Preferences'));\nexport { DISABLED_EXTENSIONS_STORAGE_PATH, ENABLED_EXTENSIONS_STORAGE_PATH, EXTENSION_IDENTIFIER_PATTERN, EXTENSION_IDENTIFIER_REGEX, EXTENSION_INSTALL_DEP_PACK_CONTEXT, EXTENSION_INSTALL_SKIP_WALKTHROUGH_CONTEXT, EXTENSION_INSTALL_SOURCE_CONTEXT, ExtensionGalleryError, ExtensionManagementError, ExtensionSignatureVerificationCode, ExtensionsLocalizedLabel, PreferencesLocalizedLabel, TargetPlatformToString, WEB_EXTENSION_TAG, getTargetPlatform, isIExtensionIdentifier, isNotWebExtensionInWebTargetPlatform, isTargetPlatformCompatible, toTargetPlatform };\n","import { compareIgnoreCase } from '../../../base/common/strings.js';\nimport { getTargetPlatform } from './extensionManagement.js';\nimport { UNDEFINED_PUBLISHER, ExtensionIdentifier } from '../../extensions/common/extensions.js';\nimport { isLinux, platform } from '../../../base/common/platform.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { getErrorMessage } from '../../../base/common/errors.js';\nimport { arch } from '../../../base/common/process.js';\nimport { TelemetryTrustedValue } from '../../telemetry/common/telemetryUtils.js';\nfunction areSameExtensions(a, b) {\n    if (a.uuid && b.uuid) {\n        return a.uuid === b.uuid;\n    }\n    if (a.id === b.id) {\n        return true;\n    }\n    return compareIgnoreCase(a.id, b.id) === 0;\n}\nconst ExtensionKeyRegex = /^([^.]+\\..+)-(\\d+\\.\\d+\\.\\d+)(-(.+))?$/;\nclass ExtensionKey {\n    static create(extension) {\n        const version = extension.manifest ? extension.manifest.version : extension.version;\n        const targetPlatform = extension.manifest ? extension.targetPlatform : extension.properties.targetPlatform;\n        return ( new ExtensionKey(extension.identifier, version, targetPlatform));\n    }\n    static parse(key) {\n        const matches = ExtensionKeyRegex.exec(key);\n        return matches && matches[1] && matches[2] ? ( new ExtensionKey({ id: matches[1] }, matches[2], matches[4] || undefined)) : null;\n    }\n    constructor(identifier, version, targetPlatform = \"undefined\" ) {\n        this.identifier = identifier;\n        this.version = version;\n        this.targetPlatform = targetPlatform;\n        this.id = identifier.id;\n    }\n    toString() {\n        return `${this.id}-${this.version}${this.targetPlatform !== \"undefined\"  ? `-${this.targetPlatform}` : ''}`;\n    }\n    equals(o) {\n        if (!(o instanceof ExtensionKey)) {\n            return false;\n        }\n        return areSameExtensions(this, o) && this.version === o.version && this.targetPlatform === o.targetPlatform;\n    }\n}\nconst EXTENSION_IDENTIFIER_WITH_VERSION_REGEX = /^([^.]+\\..+)@((prerelease)|(\\d+\\.\\d+\\.\\d+(-.*)?))$/;\nfunction getIdAndVersion(id) {\n    const matches = EXTENSION_IDENTIFIER_WITH_VERSION_REGEX.exec(id);\n    if (matches && matches[1]) {\n        return [adoptToGalleryExtensionId(matches[1]), matches[2]];\n    }\n    return [adoptToGalleryExtensionId(id), undefined];\n}\nfunction getExtensionId(publisher, name) {\n    return `${publisher}.${name}`;\n}\nfunction adoptToGalleryExtensionId(id) {\n    return id.toLowerCase();\n}\nfunction getGalleryExtensionId(publisher, name) {\n    return adoptToGalleryExtensionId(getExtensionId(publisher ?? UNDEFINED_PUBLISHER, name));\n}\nfunction groupByExtension(extensions, getExtensionIdentifier) {\n    const byExtension = [];\n    const findGroup = (extension) => {\n        for (const group of byExtension) {\n            if (( group.some(\n                e => areSameExtensions(getExtensionIdentifier(e), getExtensionIdentifier(extension))\n            ))) {\n                return group;\n            }\n        }\n        return null;\n    };\n    for (const extension of extensions) {\n        const group = findGroup(extension);\n        if (group) {\n            group.push(extension);\n        }\n        else {\n            byExtension.push([extension]);\n        }\n    }\n    return byExtension;\n}\nfunction getLocalExtensionTelemetryData(extension) {\n    return {\n        id: extension.identifier.id,\n        name: extension.manifest.name,\n        galleryId: null,\n        publisherId: extension.publisherId,\n        publisherName: extension.manifest.publisher,\n        publisherDisplayName: extension.publisherDisplayName,\n        dependencies: extension.manifest.extensionDependencies && extension.manifest.extensionDependencies.length > 0\n    };\n}\nfunction getGalleryExtensionTelemetryData(extension) {\n    return {\n        id: ( new TelemetryTrustedValue(extension.identifier.id)),\n        name: ( new TelemetryTrustedValue(extension.name)),\n        version: extension.version,\n        galleryId: extension.identifier.uuid,\n        publisherId: extension.publisherId,\n        publisherName: extension.publisher,\n        publisherDisplayName: extension.publisherDisplayName,\n        isPreReleaseVersion: extension.properties.isPreReleaseVersion,\n        dependencies: !!(extension.properties.dependencies && extension.properties.dependencies.length > 0),\n        isSigned: extension.isSigned,\n        ...extension.telemetryData\n    };\n}\nconst BetterMergeId = ( new ExtensionIdentifier('pprice.better-merge'));\nfunction getExtensionDependencies(installedExtensions, extension) {\n    const dependencies = [];\n    const extensions = extension.manifest.extensionDependencies?.slice(0) ?? [];\n    while (extensions.length) {\n        const id = extensions.shift();\n        if (id && dependencies.every(e => !areSameExtensions(e.identifier, { id }))) {\n            const ext = installedExtensions.filter(e => areSameExtensions(e.identifier, { id }));\n            if (ext.length === 1) {\n                dependencies.push(ext[0]);\n                extensions.push(...(ext[0].manifest.extensionDependencies?.slice(0) ?? []));\n            }\n        }\n    }\n    return dependencies;\n}\nasync function isAlpineLinux(fileService, logService) {\n    if (!isLinux) {\n        return false;\n    }\n    let content;\n    try {\n        const fileContent = await fileService.readFile(URI.file('/etc/os-release'));\n        content = ( fileContent.value.toString());\n    }\n    catch (error) {\n        try {\n            const fileContent = await fileService.readFile(URI.file('/usr/lib/os-release'));\n            content = ( fileContent.value.toString());\n        }\n        catch (error) {\n            logService.debug(`Error while getting the os-release file.`, getErrorMessage(error));\n        }\n    }\n    return !!content && (content.match(/^ID=([^\\u001b\\r\\n]*)/m) || [])[1] === 'alpine';\n}\nasync function computeTargetPlatform(fileService, logService) {\n    const alpineLinux = await isAlpineLinux(fileService, logService);\n    const targetPlatform = getTargetPlatform(alpineLinux ? 'alpine' : platform, arch);\n    logService.debug('ComputeTargetPlatform:', targetPlatform);\n    return targetPlatform;\n}\nexport { BetterMergeId, ExtensionKey, adoptToGalleryExtensionId, areSameExtensions, computeTargetPlatform, getExtensionDependencies, getExtensionId, getGalleryExtensionId, getGalleryExtensionTelemetryData, getIdAndVersion, getLocalExtensionTelemetryData, groupByExtension };\n","import { onUnexpectedError } from '../../../base/common/errors.js';\nimport { ExtensionIdentifier } from '../../extensions/common/extensions.js';\nclass ImplicitActivationEventsImpl {\n    constructor() {\n        this._generators = ( new Map());\n        this._cache = ( new WeakMap());\n    }\n    register(extensionPointName, generator) {\n        this._generators.set(extensionPointName, generator);\n    }\n    readActivationEvents(extensionDescription) {\n        if (!( this._cache.has(extensionDescription))) {\n            this._cache.set(extensionDescription, this._readActivationEvents(extensionDescription));\n        }\n        return this._cache.get(extensionDescription);\n    }\n    createActivationEventsMap(extensionDescriptions) {\n        const result = Object.create(null);\n        for (const extensionDescription of extensionDescriptions) {\n            const activationEvents = this.readActivationEvents(extensionDescription);\n            if (activationEvents.length > 0) {\n                result[ExtensionIdentifier.toKey(extensionDescription.identifier)] = activationEvents;\n            }\n        }\n        return result;\n    }\n    _readActivationEvents(desc) {\n        if (typeof desc.main === 'undefined' && typeof desc.browser === 'undefined') {\n            return [];\n        }\n        const activationEvents = (Array.isArray(desc.activationEvents) ? desc.activationEvents.slice(0) : []);\n        for (let i = 0; i < activationEvents.length; i++) {\n            if (activationEvents[i] === 'onUri') {\n                activationEvents[i] = `onUri:${ExtensionIdentifier.toKey(desc.identifier)}`;\n            }\n        }\n        if (!desc.contributes) {\n            return activationEvents;\n        }\n        for (const extPointName in desc.contributes) {\n            const generator = this._generators.get(extPointName);\n            if (!generator) {\n                continue;\n            }\n            const contrib = desc.contributes[extPointName];\n            const contribArr = Array.isArray(contrib) ? contrib : [contrib];\n            try {\n                generator(contribArr, activationEvents);\n            }\n            catch (err) {\n                onUnexpectedError(err);\n            }\n        }\n        return activationEvents;\n    }\n}\nconst ImplicitActivationEvents = ( new ImplicitActivationEventsImpl());\nexport { ImplicitActivationEvents, ImplicitActivationEventsImpl };\n","import { joinPath, isEqualOrParent } from '../../../base/common/resources.js';\nimport Severity$1 from '../../../base/common/severity.js';\nimport { localize } from '../../../nls.js';\nimport { semverExports } from '../../../../../../_virtual/semver.js';\nimport { parseApiProposals } from './extensions.js';\nimport { allApiProposals } from './extensionsApiProposals.js';\nconst VERSION_REGEXP = /^(\\^|>=)?((\\d+)|x)\\.((\\d+)|x)\\.((\\d+)|x)(\\-.*)?$/;\nconst NOT_BEFORE_REGEXP = /^-(\\d{4})(\\d{2})(\\d{2})$/;\nfunction isValidVersionStr(version) {\n    version = version.trim();\n    return (version === '*' || VERSION_REGEXP.test(version));\n}\nfunction parseVersion(version) {\n    if (!isValidVersionStr(version)) {\n        return null;\n    }\n    version = version.trim();\n    if (version === '*') {\n        return {\n            hasCaret: false,\n            hasGreaterEquals: false,\n            majorBase: 0,\n            majorMustEqual: false,\n            minorBase: 0,\n            minorMustEqual: false,\n            patchBase: 0,\n            patchMustEqual: false,\n            preRelease: null\n        };\n    }\n    const m = version.match(VERSION_REGEXP);\n    if (!m) {\n        return null;\n    }\n    return {\n        hasCaret: m[1] === '^',\n        hasGreaterEquals: m[1] === '>=',\n        majorBase: m[2] === 'x' ? 0 : parseInt(m[2], 10),\n        majorMustEqual: (m[2] === 'x' ? false : true),\n        minorBase: m[4] === 'x' ? 0 : parseInt(m[4], 10),\n        minorMustEqual: (m[4] === 'x' ? false : true),\n        patchBase: m[6] === 'x' ? 0 : parseInt(m[6], 10),\n        patchMustEqual: (m[6] === 'x' ? false : true),\n        preRelease: m[8] || null\n    };\n}\nfunction normalizeVersion(version) {\n    if (!version) {\n        return null;\n    }\n    const majorBase = version.majorBase;\n    const majorMustEqual = version.majorMustEqual;\n    const minorBase = version.minorBase;\n    let minorMustEqual = version.minorMustEqual;\n    const patchBase = version.patchBase;\n    let patchMustEqual = version.patchMustEqual;\n    if (version.hasCaret) {\n        if (majorBase === 0) {\n            patchMustEqual = false;\n        }\n        else {\n            minorMustEqual = false;\n            patchMustEqual = false;\n        }\n    }\n    let notBefore = 0;\n    if (version.preRelease) {\n        const match = NOT_BEFORE_REGEXP.exec(version.preRelease);\n        if (match) {\n            const [, year, month, day] = match;\n            notBefore = Date.UTC(Number(year), Number(month) - 1, Number(day));\n        }\n    }\n    return {\n        majorBase: majorBase,\n        majorMustEqual: majorMustEqual,\n        minorBase: minorBase,\n        minorMustEqual: minorMustEqual,\n        patchBase: patchBase,\n        patchMustEqual: patchMustEqual,\n        isMinimum: version.hasGreaterEquals,\n        notBefore,\n    };\n}\nfunction isValidVersion(_inputVersion, _inputDate, _desiredVersion) {\n    let version;\n    if (typeof _inputVersion === 'string') {\n        version = normalizeVersion(parseVersion(_inputVersion));\n    }\n    else {\n        version = _inputVersion;\n    }\n    let productTs;\n    if (_inputDate instanceof Date) {\n        productTs = _inputDate.getTime();\n    }\n    else if (typeof _inputDate === 'string') {\n        productTs = ( (new Date(_inputDate))).getTime();\n    }\n    let desiredVersion;\n    if (typeof _desiredVersion === 'string') {\n        desiredVersion = normalizeVersion(parseVersion(_desiredVersion));\n    }\n    else {\n        desiredVersion = _desiredVersion;\n    }\n    if (!version || !desiredVersion) {\n        return false;\n    }\n    const majorBase = version.majorBase;\n    const minorBase = version.minorBase;\n    const patchBase = version.patchBase;\n    let desiredMajorBase = desiredVersion.majorBase;\n    let desiredMinorBase = desiredVersion.minorBase;\n    let desiredPatchBase = desiredVersion.patchBase;\n    const desiredNotBefore = desiredVersion.notBefore;\n    let majorMustEqual = desiredVersion.majorMustEqual;\n    let minorMustEqual = desiredVersion.minorMustEqual;\n    let patchMustEqual = desiredVersion.patchMustEqual;\n    if (desiredVersion.isMinimum) {\n        if (majorBase > desiredMajorBase) {\n            return true;\n        }\n        if (majorBase < desiredMajorBase) {\n            return false;\n        }\n        if (minorBase > desiredMinorBase) {\n            return true;\n        }\n        if (minorBase < desiredMinorBase) {\n            return false;\n        }\n        if (productTs && productTs < desiredNotBefore) {\n            return false;\n        }\n        return patchBase >= desiredPatchBase;\n    }\n    if (majorBase === 1 && desiredMajorBase === 0 && (!majorMustEqual || !minorMustEqual || !patchMustEqual)) {\n        desiredMajorBase = 1;\n        desiredMinorBase = 0;\n        desiredPatchBase = 0;\n        majorMustEqual = true;\n        minorMustEqual = false;\n        patchMustEqual = false;\n    }\n    if (majorBase < desiredMajorBase) {\n        return false;\n    }\n    if (majorBase > desiredMajorBase) {\n        return (!majorMustEqual);\n    }\n    if (minorBase < desiredMinorBase) {\n        return false;\n    }\n    if (minorBase > desiredMinorBase) {\n        return (!minorMustEqual);\n    }\n    if (patchBase < desiredPatchBase) {\n        return false;\n    }\n    if (patchBase > desiredPatchBase) {\n        return (!patchMustEqual);\n    }\n    if (productTs && productTs < desiredNotBefore) {\n        return false;\n    }\n    return true;\n}\nfunction validateExtensionManifest(productVersion, productDate, extensionLocation, extensionManifest, extensionIsBuiltin, validateApiVersion) {\n    const validations = [];\n    if (typeof extensionManifest.publisher !== 'undefined' && typeof extensionManifest.publisher !== 'string') {\n        validations.push([Severity$1.Error, ( localize(1611, \"property publisher must be of type `string`.\"))]);\n        return validations;\n    }\n    if (typeof extensionManifest.name !== 'string') {\n        validations.push([Severity$1.Error, ( localize(1612, \"property `{0}` is mandatory and must be of type `string`\", 'name'))]);\n        return validations;\n    }\n    if (typeof extensionManifest.version !== 'string') {\n        validations.push([Severity$1.Error, ( localize(\n            1613,\n            \"property `{0}` is mandatory and must be of type `string`\",\n            'version'\n        ))]);\n        return validations;\n    }\n    if (!extensionManifest.engines) {\n        validations.push([Severity$1.Error, ( localize(\n            1614,\n            \"property `{0}` is mandatory and must be of type `object`\",\n            'engines'\n        ))]);\n        return validations;\n    }\n    if (typeof extensionManifest.engines.vscode !== 'string') {\n        validations.push([Severity$1.Error, ( localize(\n            1615,\n            \"property `{0}` is mandatory and must be of type `string`\",\n            'engines.vscode'\n        ))]);\n        return validations;\n    }\n    if (typeof extensionManifest.extensionDependencies !== 'undefined') {\n        if (!isStringArray(extensionManifest.extensionDependencies)) {\n            validations.push([Severity$1.Error, ( localize(\n                1616,\n                \"property `{0}` can be omitted or must be of type `string[]`\",\n                'extensionDependencies'\n            ))]);\n            return validations;\n        }\n    }\n    if (typeof extensionManifest.activationEvents !== 'undefined') {\n        if (!isStringArray(extensionManifest.activationEvents)) {\n            validations.push([Severity$1.Error, ( localize(\n                1617,\n                \"property `{0}` can be omitted or must be of type `string[]`\",\n                'activationEvents'\n            ))]);\n            return validations;\n        }\n        if (typeof extensionManifest.main === 'undefined' && typeof extensionManifest.browser === 'undefined') {\n            validations.push([Severity$1.Error, ( localize(\n                1618,\n                \"property `{0}` should be omitted if the extension doesn't have a `{1}` or `{2}` property.\",\n                'activationEvents',\n                'main',\n                'browser'\n            ))]);\n            return validations;\n        }\n    }\n    if (typeof extensionManifest.extensionKind !== 'undefined') {\n        if (typeof extensionManifest.main === 'undefined') {\n            validations.push([Severity$1.Warning, ( localize(\n                1619,\n                \"property `{0}` can be defined only if property `main` is also defined.\",\n                'extensionKind'\n            ))]);\n        }\n    }\n    if (typeof extensionManifest.main !== 'undefined') {\n        if (typeof extensionManifest.main !== 'string') {\n            validations.push([Severity$1.Error, ( localize(1620, \"property `{0}` can be omitted or must be of type `string`\", 'main'))]);\n            return validations;\n        }\n        else {\n            const mainLocation = joinPath(extensionLocation, extensionManifest.main);\n            if (!isEqualOrParent(mainLocation, extensionLocation)) {\n                validations.push([Severity$1.Warning, ( localize(\n                    1621,\n                    \"Expected `main` ({0}) to be included inside extension's folder ({1}). This might make the extension non-portable.\",\n                    mainLocation.path,\n                    extensionLocation.path\n                ))]);\n            }\n        }\n    }\n    if (typeof extensionManifest.browser !== 'undefined') {\n        if (typeof extensionManifest.browser !== 'string') {\n            validations.push([Severity$1.Error, ( localize(\n                1622,\n                \"property `{0}` can be omitted or must be of type `string`\",\n                'browser'\n            ))]);\n            return validations;\n        }\n        else {\n            const browserLocation = joinPath(extensionLocation, extensionManifest.browser);\n            if (!isEqualOrParent(browserLocation, extensionLocation)) {\n                validations.push([Severity$1.Warning, ( localize(\n                    1623,\n                    \"Expected `browser` ({0}) to be included inside extension's folder ({1}). This might make the extension non-portable.\",\n                    browserLocation.path,\n                    extensionLocation.path\n                ))]);\n            }\n        }\n    }\n    if (!semverExports.valid(extensionManifest.version)) {\n        validations.push([Severity$1.Error, ( localize(1624, \"Extension version is not semver compatible.\"))]);\n        return validations;\n    }\n    const notices = [];\n    const validExtensionVersion = isValidExtensionVersion(productVersion, productDate, extensionManifest, extensionIsBuiltin, notices);\n    if (!validExtensionVersion) {\n        for (const notice of notices) {\n            validations.push([Severity$1.Error, notice]);\n        }\n    }\n    if (validateApiVersion && extensionManifest.enabledApiProposals?.length) {\n        const incompatibleNotices = [];\n        if (!areApiProposalsCompatible([...extensionManifest.enabledApiProposals], incompatibleNotices)) {\n            for (const notice of incompatibleNotices) {\n                validations.push([Severity$1.Error, notice]);\n            }\n        }\n    }\n    return validations;\n}\nfunction isValidExtensionVersion(productVersion, productDate, extensionManifest, extensionIsBuiltin, notices) {\n    if (extensionIsBuiltin || (typeof extensionManifest.main === 'undefined' && typeof extensionManifest.browser === 'undefined')) {\n        return true;\n    }\n    return isVersionValid(productVersion, productDate, extensionManifest.engines.vscode, notices);\n}\nfunction isEngineValid(engine, version, date) {\n    return engine === '*' || isVersionValid(version, date, engine);\n}\nfunction areApiProposalsCompatible(apiProposals, arg1) {\n    if (apiProposals.length === 0) {\n        return true;\n    }\n    const notices = Array.isArray(arg1) ? arg1 : undefined;\n    const productApiProposals = (notices ? undefined : arg1) ?? allApiProposals;\n    const incompatibleProposals = [];\n    const parsedProposals = parseApiProposals(apiProposals);\n    for (const { proposalName, version } of parsedProposals) {\n        const existingProposal = productApiProposals[proposalName];\n        if (!existingProposal) {\n            continue;\n        }\n        if (!version) {\n            continue;\n        }\n        if (existingProposal.version !== version) {\n            incompatibleProposals.push(proposalName);\n        }\n    }\n    if (incompatibleProposals.length) {\n        if (notices) {\n            if (incompatibleProposals.length === 1) {\n                notices.push(( localize(\n                    1625,\n                    \"This extension is using the API proposal '{0}' that is not compatible with the current version of VS Code.\",\n                    incompatibleProposals[0]\n                )));\n            }\n            else {\n                notices.push(( localize(\n                    1626,\n                    \"This extension is using the API proposals {0} and '{1}' that are not compatible with the current version of VS Code.\",\n                    ( (incompatibleProposals.slice(0, incompatibleProposals.length - 1).map(p => `'${p}'`))).join(', '),\n                    incompatibleProposals[incompatibleProposals.length - 1]\n                )));\n            }\n        }\n        return false;\n    }\n    return true;\n}\nfunction isVersionValid(currentVersion, date, requestedVersion, notices = []) {\n    const desiredVersion = normalizeVersion(parseVersion(requestedVersion));\n    if (!desiredVersion) {\n        notices.push(( localize(\n            1627,\n            \"Could not parse `engines.vscode` value {0}. Please use, for example: ^1.22.0, ^1.22.x, etc.\",\n            requestedVersion\n        )));\n        return false;\n    }\n    if (desiredVersion.majorBase === 0) {\n        if (!desiredVersion.majorMustEqual || !desiredVersion.minorMustEqual) {\n            notices.push(( localize(\n                1628,\n                \"Version specified in `engines.vscode` ({0}) is not specific enough. For vscode versions before 1.0.0, please define at a minimum the major and minor desired version. E.g. ^0.10.0, 0.10.x, 0.11.0, etc.\",\n                requestedVersion\n            )));\n            return false;\n        }\n    }\n    else {\n        if (!desiredVersion.majorMustEqual) {\n            notices.push(( localize(\n                1629,\n                \"Version specified in `engines.vscode` ({0}) is not specific enough. For vscode versions after 1.0.0, please define at a minimum the major desired version. E.g. ^1.10.0, 1.10.x, 1.x.x, 2.x.x, etc.\",\n                requestedVersion\n            )));\n            return false;\n        }\n    }\n    if (!isValidVersion(currentVersion, date, desiredVersion)) {\n        notices.push(( localize(\n            1630,\n            \"Extension is not compatible with Code {0}. Extension requires: {1}.\",\n            currentVersion,\n            requestedVersion\n        )));\n        return false;\n    }\n    return true;\n}\nfunction isStringArray(arr) {\n    if (!Array.isArray(arr)) {\n        return false;\n    }\n    for (let i = 0, len = arr.length; i < len; i++) {\n        if (typeof arr[i] !== 'string') {\n            return false;\n        }\n    }\n    return true;\n}\nexport { areApiProposalsCompatible, isEngineValid, isValidExtensionVersion, isValidVersion, isValidVersionStr, normalizeVersion, parseVersion, validateExtensionManifest };\n","import { equalsIgnoreCase } from '../../../base/common/strings.js';\nimport { getRemoteName } from '../../remote/common/remoteHosts.js';\nconst USER_MANIFEST_CACHE_FILE = 'extensions.user.cache';\nconst BUILTIN_MANIFEST_CACHE_FILE = 'extensions.builtin.cache';\nconst UNDEFINED_PUBLISHER = 'undefined_publisher';\nconst ALL_EXTENSION_KINDS = ['ui', 'workspace', 'web'];\nfunction getWorkspaceSupportTypeMessage(supportType) {\n    if (typeof supportType === 'object' && supportType !== null) {\n        if (supportType.supported !== true) {\n            return supportType.description;\n        }\n    }\n    return undefined;\n}\nconst EXTENSION_CATEGORIES = [\n    'AI',\n    'Azure',\n    'Chat',\n    'Data Science',\n    'Debuggers',\n    'Extension Packs',\n    'Education',\n    'Formatters',\n    'Keymaps',\n    'Language Packs',\n    'Linters',\n    'Machine Learning',\n    'Notebooks',\n    'Programming Languages',\n    'SCM Providers',\n    'Snippets',\n    'Testing',\n    'Themes',\n    'Visualization',\n    'Other',\n];\nclass ExtensionIdentifier {\n    constructor(value) {\n        this.value = value;\n        this._lower = value.toLowerCase();\n    }\n    static equals(a, b) {\n        if (typeof a === 'undefined' || a === null) {\n            return (typeof b === 'undefined' || b === null);\n        }\n        if (typeof b === 'undefined' || b === null) {\n            return false;\n        }\n        if (typeof a === 'string' || typeof b === 'string') {\n            const aValue = (typeof a === 'string' ? a : a.value);\n            const bValue = (typeof b === 'string' ? b : b.value);\n            return equalsIgnoreCase(aValue, bValue);\n        }\n        return (a._lower === b._lower);\n    }\n    static toKey(id) {\n        if (typeof id === 'string') {\n            return id.toLowerCase();\n        }\n        return id._lower;\n    }\n}\nclass ExtensionIdentifierSet {\n    get size() {\n        return this._set.size;\n    }\n    constructor(iterable) {\n        this._set = ( new Set());\n        if (iterable) {\n            for (const value of iterable) {\n                this.add(value);\n            }\n        }\n    }\n    add(id) {\n        this._set.add(ExtensionIdentifier.toKey(id));\n    }\n    delete(extensionId) {\n        return this._set.delete(ExtensionIdentifier.toKey(extensionId));\n    }\n    has(id) {\n        return ( this._set.has(ExtensionIdentifier.toKey(id)));\n    }\n}\nclass ExtensionIdentifierMap {\n    constructor() {\n        this._map = ( new Map());\n    }\n    clear() {\n        this._map.clear();\n    }\n    delete(id) {\n        this._map.delete(ExtensionIdentifier.toKey(id));\n    }\n    get(id) {\n        return this._map.get(ExtensionIdentifier.toKey(id));\n    }\n    has(id) {\n        return ( this._map.has(ExtensionIdentifier.toKey(id)));\n    }\n    set(id, value) {\n        this._map.set(ExtensionIdentifier.toKey(id), value);\n    }\n    values() {\n        return ( this._map.values());\n    }\n    forEach(callbackfn) {\n        this._map.forEach(callbackfn);\n    }\n    [Symbol.iterator]() {\n        return this._map[Symbol.iterator]();\n    }\n}\nfunction isApplicationScopedExtension(manifest) {\n    return isLanguagePackExtension(manifest);\n}\nfunction isLanguagePackExtension(manifest) {\n    return manifest.contributes && manifest.contributes.localizations ? manifest.contributes.localizations.length > 0 : false;\n}\nfunction isAuthenticationProviderExtension(manifest) {\n    return manifest.contributes && manifest.contributes.authentication ? manifest.contributes.authentication.length > 0 : false;\n}\nfunction isResolverExtension(manifest, remoteAuthority) {\n    if (remoteAuthority) {\n        const activationEvent = `onResolveRemoteAuthority:${getRemoteName(remoteAuthority)}`;\n        return !!manifest.activationEvents?.includes(activationEvent);\n    }\n    return false;\n}\nfunction parseApiProposals(enabledApiProposals) {\n    return ( enabledApiProposals.map(proposal => {\n        const [proposalName, version] = proposal.split('@');\n        return { proposalName, version: version ? parseInt(version) : undefined };\n    }));\n}\nfunction parseEnabledApiProposalNames(enabledApiProposals) {\n    return ( enabledApiProposals.map(proposal => proposal.split('@')[0]));\n}\nexport { ALL_EXTENSION_KINDS, BUILTIN_MANIFEST_CACHE_FILE, EXTENSION_CATEGORIES, ExtensionIdentifier, ExtensionIdentifierMap, ExtensionIdentifierSet, UNDEFINED_PUBLISHER, USER_MANIFEST_CACHE_FILE, getWorkspaceSupportTypeMessage, isApplicationScopedExtension, isAuthenticationProviderExtension, isLanguagePackExtension, isResolverExtension, parseApiProposals, parseEnabledApiProposalNames };\n","const _allApiProposals = {\n    activeComment: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.activeComment.d.ts',\n    },\n    aiRelatedInformation: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.aiRelatedInformation.d.ts',\n    },\n    aiTextSearchProvider: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.aiTextSearchProvider.d.ts',\n    },\n    aiTextSearchProviderNew: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.aiTextSearchProviderNew.d.ts',\n    },\n    attributableCoverage: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.attributableCoverage.d.ts',\n    },\n    authLearnMore: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.authLearnMore.d.ts',\n    },\n    authSession: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.authSession.d.ts',\n    },\n    canonicalUriProvider: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.canonicalUriProvider.d.ts',\n    },\n    chatParticipantAdditions: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatParticipantAdditions.d.ts',\n    },\n    chatParticipantPrivate: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatParticipantPrivate.d.ts',\n        version: 2\n    },\n    chatProvider: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatProvider.d.ts',\n    },\n    chatTab: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatTab.d.ts',\n    },\n    chatVariableResolver: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatVariableResolver.d.ts',\n    },\n    codeActionAI: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.codeActionAI.d.ts',\n    },\n    codeActionRanges: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.codeActionRanges.d.ts',\n    },\n    codiconDecoration: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.codiconDecoration.d.ts',\n    },\n    commentReactor: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentReactor.d.ts',\n    },\n    commentReveal: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentReveal.d.ts',\n    },\n    commentThreadApplicability: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentThreadApplicability.d.ts',\n    },\n    commentingRangeHint: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentingRangeHint.d.ts',\n    },\n    commentsDraftState: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentsDraftState.d.ts',\n    },\n    contribAccessibilityHelpContent: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribAccessibilityHelpContent.d.ts',\n    },\n    contribChatParticipantDetection: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribChatParticipantDetection.d.ts',\n    },\n    contribCommentEditorActionsMenu: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentEditorActionsMenu.d.ts',\n    },\n    contribCommentPeekContext: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentPeekContext.d.ts',\n    },\n    contribCommentThreadAdditionalMenu: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentThreadAdditionalMenu.d.ts',\n    },\n    contribCommentsViewThreadMenus: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentsViewThreadMenus.d.ts',\n    },\n    contribDebugCreateConfiguration: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribDebugCreateConfiguration.d.ts',\n    },\n    contribDiffEditorGutterToolBarMenus: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribDiffEditorGutterToolBarMenus.d.ts',\n    },\n    contribEditSessions: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribEditSessions.d.ts',\n    },\n    contribEditorContentMenu: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribEditorContentMenu.d.ts',\n    },\n    contribIssueReporter: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribIssueReporter.d.ts',\n    },\n    contribLabelFormatterWorkspaceTooltip: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribLabelFormatterWorkspaceTooltip.d.ts',\n    },\n    contribMenuBarHome: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribMenuBarHome.d.ts',\n    },\n    contribMergeEditorMenus: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribMergeEditorMenus.d.ts',\n    },\n    contribMultiDiffEditorMenus: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribMultiDiffEditorMenus.d.ts',\n    },\n    contribNotebookStaticPreloads: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribNotebookStaticPreloads.d.ts',\n    },\n    contribRemoteHelp: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribRemoteHelp.d.ts',\n    },\n    contribShareMenu: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribShareMenu.d.ts',\n    },\n    contribSourceControlHistoryItemMenu: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlHistoryItemMenu.d.ts',\n    },\n    contribSourceControlHistoryTitleMenu: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlHistoryTitleMenu.d.ts',\n    },\n    contribSourceControlInputBoxMenu: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlInputBoxMenu.d.ts',\n    },\n    contribSourceControlTitleMenu: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlTitleMenu.d.ts',\n    },\n    contribStatusBarItems: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribStatusBarItems.d.ts',\n    },\n    contribViewContainerTitle: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribViewContainerTitle.d.ts',\n    },\n    contribViewsRemote: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribViewsRemote.d.ts',\n    },\n    contribViewsWelcome: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribViewsWelcome.d.ts',\n    },\n    createFileSystemWatcher: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.createFileSystemWatcher.d.ts',\n    },\n    customEditorMove: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.customEditorMove.d.ts',\n    },\n    debugVisualization: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.debugVisualization.d.ts',\n    },\n    defaultChatParticipant: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.defaultChatParticipant.d.ts',\n        version: 2\n    },\n    diffCommand: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.diffCommand.d.ts',\n    },\n    diffContentOptions: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.diffContentOptions.d.ts',\n    },\n    documentFiltersExclusive: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.documentFiltersExclusive.d.ts',\n    },\n    documentPaste: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.documentPaste.d.ts',\n    },\n    editSessionIdentityProvider: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.editSessionIdentityProvider.d.ts',\n    },\n    editorHoverVerbosityLevel: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.editorHoverVerbosityLevel.d.ts',\n    },\n    editorInsets: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.editorInsets.d.ts',\n    },\n    embeddings: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.embeddings.d.ts',\n    },\n    extensionRuntime: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.extensionRuntime.d.ts',\n    },\n    extensionsAny: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.extensionsAny.d.ts',\n    },\n    externalUriOpener: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.externalUriOpener.d.ts',\n    },\n    fileComments: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fileComments.d.ts',\n    },\n    fileSearchProvider: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fileSearchProvider.d.ts',\n    },\n    fileSearchProviderNew: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fileSearchProviderNew.d.ts',\n    },\n    findFiles2: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.findFiles2.d.ts',\n    },\n    findFiles2New: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.findFiles2New.d.ts',\n    },\n    findTextInFiles: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.findTextInFiles.d.ts',\n    },\n    findTextInFilesNew: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.findTextInFilesNew.d.ts',\n    },\n    fsChunks: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fsChunks.d.ts',\n    },\n    idToken: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.idToken.d.ts',\n    },\n    inlineCompletionsAdditions: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.inlineCompletionsAdditions.d.ts',\n    },\n    inlineEdit: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.inlineEdit.d.ts',\n    },\n    interactive: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.interactive.d.ts',\n    },\n    interactiveWindow: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.interactiveWindow.d.ts',\n    },\n    ipc: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.ipc.d.ts',\n    },\n    languageModelSystem: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.languageModelSystem.d.ts',\n    },\n    languageStatusText: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.languageStatusText.d.ts',\n    },\n    lmTools: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.lmTools.d.ts',\n        version: 7\n    },\n    mappedEditsProvider: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.mappedEditsProvider.d.ts',\n    },\n    multiDocumentHighlightProvider: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.multiDocumentHighlightProvider.d.ts',\n    },\n    newSymbolNamesProvider: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.newSymbolNamesProvider.d.ts',\n    },\n    notebookCellExecution: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookCellExecution.d.ts',\n    },\n    notebookCellExecutionState: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookCellExecutionState.d.ts',\n    },\n    notebookControllerAffinityHidden: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookControllerAffinityHidden.d.ts',\n    },\n    notebookDeprecated: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookDeprecated.d.ts',\n    },\n    notebookExecution: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookExecution.d.ts',\n    },\n    notebookKernelSource: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookKernelSource.d.ts',\n    },\n    notebookLiveShare: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookLiveShare.d.ts',\n    },\n    notebookMessaging: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookMessaging.d.ts',\n    },\n    notebookMime: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookMime.d.ts',\n    },\n    notebookReplDocument: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookReplDocument.d.ts',\n    },\n    notebookVariableProvider: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookVariableProvider.d.ts',\n    },\n    portsAttributes: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.portsAttributes.d.ts',\n    },\n    profileContentHandlers: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.profileContentHandlers.d.ts',\n    },\n    quickDiffProvider: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickDiffProvider.d.ts',\n    },\n    quickInputButtonLocation: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickInputButtonLocation.d.ts',\n    },\n    quickPickItemTooltip: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickPickItemTooltip.d.ts',\n    },\n    quickPickSortByLabel: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickPickSortByLabel.d.ts',\n    },\n    resolvers: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.resolvers.d.ts',\n    },\n    scmActionButton: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmActionButton.d.ts',\n    },\n    scmHistoryProvider: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmHistoryProvider.d.ts',\n    },\n    scmMultiDiffEditor: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmMultiDiffEditor.d.ts',\n    },\n    scmSelectedProvider: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmSelectedProvider.d.ts',\n    },\n    scmTextDocument: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmTextDocument.d.ts',\n    },\n    scmValidation: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmValidation.d.ts',\n    },\n    shareProvider: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.shareProvider.d.ts',\n    },\n    showLocal: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.showLocal.d.ts',\n    },\n    speech: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.speech.d.ts',\n    },\n    tabInputMultiDiff: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tabInputMultiDiff.d.ts',\n    },\n    tabInputTextMerge: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tabInputTextMerge.d.ts',\n    },\n    taskPresentationGroup: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.taskPresentationGroup.d.ts',\n    },\n    telemetry: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.telemetry.d.ts',\n    },\n    terminalDataWriteEvent: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalDataWriteEvent.d.ts',\n    },\n    terminalDimensions: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalDimensions.d.ts',\n    },\n    terminalExecuteCommandEvent: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalExecuteCommandEvent.d.ts',\n    },\n    terminalQuickFixProvider: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalQuickFixProvider.d.ts',\n    },\n    terminalSelection: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalSelection.d.ts',\n    },\n    testObserver: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.testObserver.d.ts',\n    },\n    testRelatedCode: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.testRelatedCode.d.ts',\n    },\n    textSearchCompleteNew: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textSearchCompleteNew.d.ts',\n    },\n    textSearchProvider: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textSearchProvider.d.ts',\n    },\n    textSearchProviderNew: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textSearchProviderNew.d.ts',\n    },\n    timeline: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.timeline.d.ts',\n    },\n    tokenInformation: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tokenInformation.d.ts',\n    },\n    treeViewActiveItem: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.treeViewActiveItem.d.ts',\n    },\n    treeViewMarkdownMessage: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.treeViewMarkdownMessage.d.ts',\n    },\n    treeViewReveal: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.treeViewReveal.d.ts',\n    },\n    tunnelFactory: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tunnelFactory.d.ts',\n    },\n    tunnels: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tunnels.d.ts',\n    },\n    workspaceTrust: {\n        proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.workspaceTrust.d.ts',\n    }\n};\nconst allApiProposals = ( Object.freeze(_allApiProposals));\nexport { allApiProposals };\n","import { TernarySearchTree } from '../../../base/common/ternarySearchTree.js';\nimport '../../../base/common/path.js';\nimport '../../../base/common/strings.js';\nimport { isNumber } from '../../../base/common/types.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { localize } from '../../../nls.js';\nimport { isWeb } from '../../../base/common/platform.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { Lazy } from '../../../base/common/lazy.js';\nvar FileType;\n( ((function(FileType) {\n    FileType[FileType[\"Unknown\"] = 0] = \"Unknown\";\n    FileType[FileType[\"File\"] = 1] = \"File\";\n    FileType[FileType[\"Directory\"] = 2] = \"Directory\";\n    FileType[FileType[\"SymbolicLink\"] = 64] = \"SymbolicLink\";\n})(FileType || (FileType = {}))));\nvar FilePermission;\n( ((function(FilePermission) {\n    FilePermission[FilePermission[\"Readonly\"] = 1] = \"Readonly\";\n    FilePermission[FilePermission[\"Locked\"] = 2] = \"Locked\";\n})(FilePermission || (FilePermission = {}))));\nvar FileSystemProviderCapabilities;\n( ((function(FileSystemProviderCapabilities) {\n    FileSystemProviderCapabilities[FileSystemProviderCapabilities[\"None\"] = 0] = \"None\";\n    FileSystemProviderCapabilities[FileSystemProviderCapabilities[\"FileReadWrite\"] = 2] = \"FileReadWrite\";\n    FileSystemProviderCapabilities[FileSystemProviderCapabilities[\"FileOpenReadWriteClose\"] = 4] = \"FileOpenReadWriteClose\";\n    FileSystemProviderCapabilities[FileSystemProviderCapabilities[\"FileReadStream\"] = 16] = \"FileReadStream\";\n    FileSystemProviderCapabilities[FileSystemProviderCapabilities[\"FileFolderCopy\"] = 8] = \"FileFolderCopy\";\n    FileSystemProviderCapabilities[FileSystemProviderCapabilities[\"PathCaseSensitive\"] = 1024] = \"PathCaseSensitive\";\n    FileSystemProviderCapabilities[FileSystemProviderCapabilities[\"Readonly\"] = 2048] = \"Readonly\";\n    FileSystemProviderCapabilities[FileSystemProviderCapabilities[\"Trash\"] = 4096] = \"Trash\";\n    FileSystemProviderCapabilities[FileSystemProviderCapabilities[\"FileWriteUnlock\"] = 8192] = \"FileWriteUnlock\";\n    FileSystemProviderCapabilities[FileSystemProviderCapabilities[\"FileAtomicRead\"] = 16384] = \"FileAtomicRead\";\n    FileSystemProviderCapabilities[FileSystemProviderCapabilities[\"FileAtomicWrite\"] = 32768] = \"FileAtomicWrite\";\n    FileSystemProviderCapabilities[FileSystemProviderCapabilities[\"FileAtomicDelete\"] = 65536] = \"FileAtomicDelete\";\n    FileSystemProviderCapabilities[FileSystemProviderCapabilities[\"FileClone\"] = 131072] = \"FileClone\";\n})(FileSystemProviderCapabilities || (FileSystemProviderCapabilities = {}))));\nfunction hasReadWriteCapability(provider) {\n    return !!((provider.capabilities & 2) );\n}\nfunction hasFileFolderCopyCapability(provider) {\n    return !!((provider.capabilities & 8) );\n}\nfunction hasFileCloneCapability(provider) {\n    return !!((provider.capabilities & 131072) );\n}\nfunction hasOpenReadWriteCloseCapability(provider) {\n    return !!((provider.capabilities & 4) );\n}\nfunction hasFileReadStreamCapability(provider) {\n    return !!((provider.capabilities & 16) );\n}\nfunction hasFileAtomicReadCapability(provider) {\n    if (!hasReadWriteCapability(provider)) {\n        return false;\n    }\n    return !!((provider.capabilities & 16384) );\n}\nfunction hasFileAtomicWriteCapability(provider) {\n    if (!hasReadWriteCapability(provider)) {\n        return false;\n    }\n    return !!((provider.capabilities & 32768) );\n}\nfunction hasFileAtomicDeleteCapability(provider) {\n    return !!((provider.capabilities & 65536) );\n}\nfunction hasReadonlyCapability(provider) {\n    return !!((provider.capabilities & 2048) );\n}\nvar FileSystemProviderErrorCode;\n( ((function(FileSystemProviderErrorCode) {\n    FileSystemProviderErrorCode[\"FileExists\"] = \"EntryExists\";\n    FileSystemProviderErrorCode[\"FileNotFound\"] = \"EntryNotFound\";\n    FileSystemProviderErrorCode[\"FileNotADirectory\"] = \"EntryNotADirectory\";\n    FileSystemProviderErrorCode[\"FileIsADirectory\"] = \"EntryIsADirectory\";\n    FileSystemProviderErrorCode[\"FileExceedsStorageQuota\"] = \"EntryExceedsStorageQuota\";\n    FileSystemProviderErrorCode[\"FileTooLarge\"] = \"EntryTooLarge\";\n    FileSystemProviderErrorCode[\"FileWriteLocked\"] = \"EntryWriteLocked\";\n    FileSystemProviderErrorCode[\"NoPermissions\"] = \"NoPermissions\";\n    FileSystemProviderErrorCode[\"Unavailable\"] = \"Unavailable\";\n    FileSystemProviderErrorCode[\"Unknown\"] = \"Unknown\";\n})(FileSystemProviderErrorCode || (FileSystemProviderErrorCode = {}))));\nclass FileSystemProviderError extends Error {\n    static create(error, code) {\n        const providerError = ( (new FileSystemProviderError( (error.toString()), code)));\n        markAsFileSystemProviderError(providerError, code);\n        return providerError;\n    }\n    constructor(message, code) {\n        super(message);\n        this.code = code;\n    }\n}\nfunction createFileSystemProviderError(error, code) {\n    return FileSystemProviderError.create(error, code);\n}\nfunction ensureFileSystemProviderError(error) {\n    if (!error) {\n        return createFileSystemProviderError(( localize(0, \"Unknown Error\")), FileSystemProviderErrorCode.Unknown);\n    }\n    return error;\n}\nfunction markAsFileSystemProviderError(error, code) {\n    error.name = code ? `${code} (FileSystemError)` : `FileSystemError`;\n    return error;\n}\nfunction toFileSystemProviderErrorCode(error) {\n    if (!error) {\n        return FileSystemProviderErrorCode.Unknown;\n    }\n    if (error instanceof FileSystemProviderError) {\n        return error.code;\n    }\n    const match = /^(.+) \\(FileSystemError\\)$/.exec(error.name);\n    if (!match) {\n        return FileSystemProviderErrorCode.Unknown;\n    }\n    switch (match[1]) {\n        case FileSystemProviderErrorCode.FileExists: return FileSystemProviderErrorCode.FileExists;\n        case FileSystemProviderErrorCode.FileIsADirectory: return FileSystemProviderErrorCode.FileIsADirectory;\n        case FileSystemProviderErrorCode.FileNotADirectory: return FileSystemProviderErrorCode.FileNotADirectory;\n        case FileSystemProviderErrorCode.FileNotFound: return FileSystemProviderErrorCode.FileNotFound;\n        case FileSystemProviderErrorCode.FileTooLarge: return FileSystemProviderErrorCode.FileTooLarge;\n        case FileSystemProviderErrorCode.FileWriteLocked: return FileSystemProviderErrorCode.FileWriteLocked;\n        case FileSystemProviderErrorCode.NoPermissions: return FileSystemProviderErrorCode.NoPermissions;\n        case FileSystemProviderErrorCode.Unavailable: return FileSystemProviderErrorCode.Unavailable;\n    }\n    return FileSystemProviderErrorCode.Unknown;\n}\nfunction toFileOperationResult(error) {\n    if (error instanceof FileOperationError) {\n        return error.fileOperationResult;\n    }\n    switch (toFileSystemProviderErrorCode(error)) {\n        case FileSystemProviderErrorCode.FileNotFound:\n            return 1 ;\n        case FileSystemProviderErrorCode.FileIsADirectory:\n            return 0 ;\n        case FileSystemProviderErrorCode.FileNotADirectory:\n            return 9 ;\n        case FileSystemProviderErrorCode.FileWriteLocked:\n            return 5 ;\n        case FileSystemProviderErrorCode.NoPermissions:\n            return 6 ;\n        case FileSystemProviderErrorCode.FileExists:\n            return 4 ;\n        case FileSystemProviderErrorCode.FileTooLarge:\n            return 7 ;\n        default:\n            return 10 ;\n    }\n}\nclass FileOperationEvent {\n    constructor(resource, operation, target) {\n        this.resource = resource;\n        this.operation = operation;\n        this.target = target;\n    }\n    isOperation(operation) {\n        return this.operation === operation;\n    }\n}\nvar FileChangeType;\n( ((function(FileChangeType) {\n    FileChangeType[FileChangeType[\"UPDATED\"] = 0] = \"UPDATED\";\n    FileChangeType[FileChangeType[\"ADDED\"] = 1] = \"ADDED\";\n    FileChangeType[FileChangeType[\"DELETED\"] = 2] = \"DELETED\";\n})(FileChangeType || (FileChangeType = {}))));\nclass FileChangesEvent {\n    static { this.MIXED_CORRELATION = null; }\n    constructor(changes, ignorePathCasing) {\n        this.ignorePathCasing = ignorePathCasing;\n        this.correlationId = undefined;\n        this.added = ( (new Lazy(() => {\n            const added = TernarySearchTree.forUris(() => this.ignorePathCasing);\n            added.fill(( (this.rawAdded.map(resource => [resource, true]))));\n            return added;\n        })));\n        this.updated = ( (new Lazy(() => {\n            const updated = TernarySearchTree.forUris(() => this.ignorePathCasing);\n            updated.fill(( (this.rawUpdated.map(resource => [resource, true]))));\n            return updated;\n        })));\n        this.deleted = ( (new Lazy(() => {\n            const deleted = TernarySearchTree.forUris(() => this.ignorePathCasing);\n            deleted.fill(( (this.rawDeleted.map(resource => [resource, true]))));\n            return deleted;\n        })));\n        this.rawAdded = [];\n        this.rawUpdated = [];\n        this.rawDeleted = [];\n        for (const change of changes) {\n            switch (change.type) {\n                case 1 :\n                    this.rawAdded.push(change.resource);\n                    break;\n                case 0 :\n                    this.rawUpdated.push(change.resource);\n                    break;\n                case 2 :\n                    this.rawDeleted.push(change.resource);\n                    break;\n            }\n            if (this.correlationId !== FileChangesEvent.MIXED_CORRELATION) {\n                if (typeof change.cId === 'number') {\n                    if (this.correlationId === undefined) {\n                        this.correlationId = change.cId;\n                    }\n                    else if (this.correlationId !== change.cId) {\n                        this.correlationId = FileChangesEvent.MIXED_CORRELATION;\n                    }\n                }\n                else {\n                    if (this.correlationId !== undefined) {\n                        this.correlationId = FileChangesEvent.MIXED_CORRELATION;\n                    }\n                }\n            }\n        }\n    }\n    contains(resource, ...types) {\n        return this.doContains(resource, { includeChildren: false }, ...types);\n    }\n    affects(resource, ...types) {\n        return this.doContains(resource, { includeChildren: true }, ...types);\n    }\n    doContains(resource, options, ...types) {\n        if (!resource) {\n            return false;\n        }\n        const hasTypesFilter = types.length > 0;\n        if (!hasTypesFilter || types.includes(1 )) {\n            if (this.added.value.get(resource)) {\n                return true;\n            }\n            if (options.includeChildren && this.added.value.findSuperstr(resource)) {\n                return true;\n            }\n        }\n        if (!hasTypesFilter || types.includes(0 )) {\n            if (this.updated.value.get(resource)) {\n                return true;\n            }\n            if (options.includeChildren && this.updated.value.findSuperstr(resource)) {\n                return true;\n            }\n        }\n        if (!hasTypesFilter || types.includes(2 )) {\n            if (this.deleted.value.findSubstr(resource) ) {\n                return true;\n            }\n            if (options.includeChildren && this.deleted.value.findSuperstr(resource)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    gotAdded() {\n        return this.rawAdded.length > 0;\n    }\n    gotDeleted() {\n        return this.rawDeleted.length > 0;\n    }\n    gotUpdated() {\n        return this.rawUpdated.length > 0;\n    }\n    correlates(correlationId) {\n        return this.correlationId === correlationId;\n    }\n    hasCorrelation() {\n        return typeof this.correlationId === 'number';\n    }\n}\nclass FileOperationError extends Error {\n    constructor(message, fileOperationResult, options) {\n        super(message);\n        this.fileOperationResult = fileOperationResult;\n        this.options = options;\n    }\n}\nclass TooLargeFileOperationError extends FileOperationError {\n    constructor(message, fileOperationResult, size, options) {\n        super(message, fileOperationResult, options);\n        this.fileOperationResult = fileOperationResult;\n        this.size = size;\n    }\n}\nclass NotModifiedSinceFileOperationError extends FileOperationError {\n    constructor(message, stat, options) {\n        super(message, 2 , options);\n        this.stat = stat;\n    }\n}\nconst AutoSaveConfiguration = {\n    OFF: 'off',\n    AFTER_DELAY: 'afterDelay',\n    ON_FOCUS_CHANGE: 'onFocusChange',\n    ON_WINDOW_CHANGE: 'onWindowChange'\n};\nconst HotExitConfiguration = {\n    OFF: 'off',\n    ON_EXIT: 'onExit',\n    ON_EXIT_AND_WINDOW_CLOSE: 'onExitAndWindowClose'\n};\nconst FILES_ASSOCIATIONS_CONFIG = 'files.associations';\nconst FILES_EXCLUDE_CONFIG = 'files.exclude';\nconst FILES_READONLY_INCLUDE_CONFIG = 'files.readonlyInclude';\nconst FILES_READONLY_EXCLUDE_CONFIG = 'files.readonlyExclude';\nconst FILES_READONLY_FROM_PERMISSIONS_CONFIG = 'files.readonlyFromPermissions';\nvar FileKind;\n( ((function(FileKind) {\n    FileKind[FileKind[\"FILE\"] = 0] = \"FILE\";\n    FileKind[FileKind[\"FOLDER\"] = 1] = \"FOLDER\";\n    FileKind[FileKind[\"ROOT_FOLDER\"] = 2] = \"ROOT_FOLDER\";\n})(FileKind || (FileKind = {}))));\nconst ETAG_DISABLED = '';\nfunction etag(stat) {\n    if (typeof stat.size !== 'number' || typeof stat.mtime !== 'number') {\n        return undefined;\n    }\n    return ( (stat.mtime.toString(29))) + ( (stat.size.toString(31)));\n}\nasync function whenProviderRegistered(file, fileService) {\n    if (fileService.hasProvider(( (URI.from({ scheme: file.scheme }))))) {\n        return;\n    }\n    return (\n         (new Promise(resolve => {\n            const disposable = fileService.onDidChangeFileSystemProviderRegistrations(e => {\n                if (e.scheme === file.scheme && e.added) {\n                    disposable.dispose();\n                    resolve();\n                }\n            });\n        }))\n    );\n}\nclass ByteSize {\n    static { this.KB = 1024; }\n    static { this.MB = ByteSize.KB * ByteSize.KB; }\n    static { this.GB = ByteSize.MB * ByteSize.KB; }\n    static { this.TB = ByteSize.GB * ByteSize.KB; }\n    static formatSize(size) {\n        if (!isNumber(size)) {\n            size = 0;\n        }\n        if (size < ByteSize.KB) {\n            return ( localize(1, \"{0}B\", size.toFixed(0)));\n        }\n        if (size < ByteSize.MB) {\n            return ( localize(2, \"{0}KB\", (size / ByteSize.KB).toFixed(2)));\n        }\n        if (size < ByteSize.GB) {\n            return ( localize(3, \"{0}MB\", (size / ByteSize.MB).toFixed(2)));\n        }\n        if (size < ByteSize.TB) {\n            return ( localize(4, \"{0}GB\", (size / ByteSize.GB).toFixed(2)));\n        }\n        return ( localize(5, \"{0}TB\", (size / ByteSize.TB).toFixed(2)));\n    }\n}\nfunction getLargeFileConfirmationLimit(arg) {\n    const isRemote = typeof arg === 'string' || arg?.scheme === Schemas.vscodeRemote;\n    const isLocal = typeof arg !== 'string' && arg?.scheme === Schemas.file;\n    if (isLocal) {\n        return 1024 * ByteSize.MB;\n    }\n    if (isRemote) {\n        return 10 * ByteSize.MB;\n    }\n    if (isWeb) {\n        return 50 * ByteSize.MB;\n    }\n    return 1024 * ByteSize.MB;\n}\nexport { AutoSaveConfiguration, ByteSize, ETAG_DISABLED, FILES_ASSOCIATIONS_CONFIG, FILES_EXCLUDE_CONFIG, FILES_READONLY_EXCLUDE_CONFIG, FILES_READONLY_FROM_PERMISSIONS_CONFIG, FILES_READONLY_INCLUDE_CONFIG, FileChangeType, FileChangesEvent, FileKind, FileOperationError, FileOperationEvent, FilePermission, FileSystemProviderCapabilities, FileSystemProviderError, FileSystemProviderErrorCode, FileType, HotExitConfiguration, NotModifiedSinceFileOperationError, TooLargeFileOperationError, createFileSystemProviderError, ensureFileSystemProviderError, etag, getLargeFileConfirmationLimit, hasFileAtomicDeleteCapability, hasFileAtomicReadCapability, hasFileAtomicWriteCapability, hasFileCloneCapability, hasFileFolderCopyCapability, hasFileReadStreamCapability, hasOpenReadWriteCloseCapability, hasReadWriteCapability, hasReadonlyCapability, markAsFileSystemProviderError, toFileOperationResult, toFileSystemProviderErrorCode, whenProviderRegistered };\n","import { GLOBSTAR } from '../../../base/common/glob.js';\nimport { Disposable, MutableDisposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport { isAbsolute } from '../../../base/common/path.js';\nimport '../../../base/common/platform.js';\nimport { URI } from '../../../base/common/uri.js';\nimport './files.js';\nclass AbstractWatcherClient extends Disposable {\n    static { this.MAX_RESTARTS = 5; }\n    constructor(onFileChanges, onLogMessage, verboseLogging, options) {\n        super();\n        this.onFileChanges = onFileChanges;\n        this.onLogMessage = onLogMessage;\n        this.verboseLogging = verboseLogging;\n        this.options = options;\n        this.watcherDisposables = this._register(( new MutableDisposable()));\n        this.requests = undefined;\n        this.restartCounter = 0;\n    }\n    init() {\n        const disposables = ( new DisposableStore());\n        this.watcherDisposables.value = disposables;\n        this.watcher = this.createWatcher(disposables);\n        this.watcher.setVerboseLogging(this.verboseLogging);\n        disposables.add(this.watcher.onDidChangeFile(changes => this.onFileChanges(changes)));\n        disposables.add(this.watcher.onDidLogMessage(msg => this.onLogMessage(msg)));\n        disposables.add(this.watcher.onDidError(e => this.onError(e.error, e.request)));\n    }\n    onError(error, failedRequest) {\n        if (this.canRestart(error, failedRequest)) {\n            if (this.restartCounter < AbstractWatcherClient.MAX_RESTARTS && this.requests) {\n                this.error(`restarting watcher after unexpected error: ${error}`);\n                this.restart(this.requests);\n            }\n            else {\n                this.error(`gave up attempting to restart watcher after unexpected error: ${error}`);\n            }\n        }\n        else {\n            this.error(error);\n        }\n    }\n    canRestart(error, failedRequest) {\n        if (!this.options.restartOnError) {\n            return false;\n        }\n        if (failedRequest) {\n            return false;\n        }\n        if (error.indexOf('No space left on device') !== -1 ||\n            error.indexOf('EMFILE') !== -1) {\n            return false;\n        }\n        return true;\n    }\n    restart(requests) {\n        this.restartCounter++;\n        this.init();\n        this.watch(requests);\n    }\n    async watch(requests) {\n        this.requests = requests;\n        await this.watcher?.watch(requests);\n    }\n    async setVerboseLogging(verboseLogging) {\n        this.verboseLogging = verboseLogging;\n        await this.watcher?.setVerboseLogging(verboseLogging);\n    }\n    error(message) {\n        this.onLogMessage({ type: 'error', message: `[File Watcher (${this.options.type})] ${message}` });\n    }\n    trace(message) {\n        this.onLogMessage({ type: 'trace', message: `[File Watcher (${this.options.type})] ${message}` });\n    }\n    dispose() {\n        this.watcher = undefined;\n        return super.dispose();\n    }\n}\nfunction reviveFileChanges(changes) {\n    return ( changes.map(change => ({\n        type: change.type,\n        resource: URI.revive(change.resource),\n        cId: change.cId\n    })));\n}\nfunction normalizeWatcherPattern(path, pattern) {\n    if (typeof pattern === 'string' && !pattern.startsWith(GLOBSTAR) && !isAbsolute(pattern)) {\n        return { base: path, pattern };\n    }\n    return pattern;\n}\nexport { AbstractWatcherClient, normalizeWatcherPattern, reviveFileChanges };\n","class SyncDescriptor {\n    constructor(ctor, staticArguments = [], supportsDelayedInstantiation = false) {\n        this.ctor = ctor;\n        this.staticArguments = staticArguments;\n        this.supportsDelayedInstantiation = supportsDelayedInstantiation;\n    }\n}\nexport { SyncDescriptor };\n","import { SyncDescriptor } from './descriptors.js';\nconst _registry = [];\nfunction registerSingleton(id, ctorOrDescriptor, supportsDelayedInstantiation) {\n    if (!(ctorOrDescriptor instanceof SyncDescriptor)) {\n        ctorOrDescriptor = ( new SyncDescriptor(ctorOrDescriptor, [], Boolean(supportsDelayedInstantiation)));\n    }\n    _registry.push([id, ctorOrDescriptor]);\n}\nfunction getSingletonServiceDescriptors() {\n    return _registry;\n}\nexport { getSingletonServiceDescriptors, registerSingleton };\n","class Node {\n    constructor(key, data) {\n        this.key = key;\n        this.data = data;\n        this.incoming = ( new Map());\n        this.outgoing = ( new Map());\n    }\n}\nclass Graph {\n    constructor(_hashFn) {\n        this._hashFn = _hashFn;\n        this._nodes = ( new Map());\n    }\n    roots() {\n        const ret = [];\n        for (const node of ( this._nodes.values())) {\n            if (node.outgoing.size === 0) {\n                ret.push(node);\n            }\n        }\n        return ret;\n    }\n    insertEdge(from, to) {\n        const fromNode = this.lookupOrInsertNode(from);\n        const toNode = this.lookupOrInsertNode(to);\n        fromNode.outgoing.set(toNode.key, toNode);\n        toNode.incoming.set(fromNode.key, fromNode);\n    }\n    removeNode(data) {\n        const key = this._hashFn(data);\n        this._nodes.delete(key);\n        for (const node of ( this._nodes.values())) {\n            node.outgoing.delete(key);\n            node.incoming.delete(key);\n        }\n    }\n    lookupOrInsertNode(data) {\n        const key = this._hashFn(data);\n        let node = this._nodes.get(key);\n        if (!node) {\n            node = ( new Node(key, data));\n            this._nodes.set(key, node);\n        }\n        return node;\n    }\n    lookup(data) {\n        return this._nodes.get(this._hashFn(data));\n    }\n    isEmpty() {\n        return this._nodes.size === 0;\n    }\n    toString() {\n        const data = [];\n        for (const [key, value] of this._nodes) {\n            data.push(`${key}\\n\\t(-> incoming)[${[...( value.incoming.keys())].join(', ')}]\\n\\t(outgoing ->)[${[...( value.outgoing.keys())].join(',')}]\\n`);\n        }\n        return data.join('\\n');\n    }\n    findCycleSlow() {\n        for (const [id, node] of this._nodes) {\n            const seen = ( new Set([id]));\n            const res = this._findCycle(node, seen);\n            if (res) {\n                return res;\n            }\n        }\n        return undefined;\n    }\n    _findCycle(node, seen) {\n        for (const [id, outgoing] of node.outgoing) {\n            if (( seen.has(id))) {\n                return [...seen, id].join(' -> ');\n            }\n            seen.add(id);\n            const value = this._findCycle(outgoing, seen);\n            if (value) {\n                return value;\n            }\n            seen.delete(id);\n        }\n        return undefined;\n    }\n}\nexport { Graph, Node };\n","var _util;\n( (function(_util) {\n    _util.serviceIds = ( new Map());\n    _util.DI_TARGET = '$di$target';\n    _util.DI_DEPENDENCIES = '$di$dependencies';\n    function getServiceDependencies(ctor) {\n        return ctor[_util.DI_DEPENDENCIES] || [];\n    }\n    _util.getServiceDependencies = getServiceDependencies;\n})(_util || (_util = {})));\nconst IInstantiationService = ( createDecorator('instantiationService'));\nfunction storeServiceDependency(id, target, index) {\n    if (target[_util.DI_TARGET] === target) {\n        target[_util.DI_DEPENDENCIES].push({ id, index });\n    }\n    else {\n        target[_util.DI_DEPENDENCIES] = [{ id, index }];\n        target[_util.DI_TARGET] = target;\n    }\n}\nfunction createDecorator(serviceId) {\n    if (( _util.serviceIds.has(serviceId))) {\n        return _util.serviceIds.get(serviceId);\n    }\n    const id = function (target, key, index) {\n        if (arguments.length !== 3) {\n            throw ( new Error('@IServiceName-decorator can only be used to decorate a parameter'));\n        }\n        storeServiceDependency(id, target, index);\n    };\n    id.toString = () => serviceId;\n    _util.serviceIds.set(serviceId, id);\n    return id;\n}\nfunction refineServiceDecorator(serviceIdentifier) {\n    return serviceIdentifier;\n}\nexport { IInstantiationService, _util, createDecorator, refineServiceDecorator };\n","import { GlobalIdleValue } from '../../../base/common/async.js';\nimport { illegalState } from '../../../base/common/errors.js';\nimport { dispose, isDisposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { SyncDescriptor } from './descriptors.js';\nimport { Graph } from './graph.js';\nimport { IInstantiationService, _util } from './instantiation.js';\nimport { ServiceCollection } from './serviceCollection.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\nconst _enableAllTracing = false;\nclass CyclicDependencyError extends Error {\n    constructor(graph) {\n        super('cyclic dependency between services');\n        this.message = graph.findCycleSlow() ?? `UNABLE to detect cycle, dumping graph: \\n${( graph.toString())}`;\n    }\n}\nclass InstantiationService {\n    constructor(_services = ( new ServiceCollection()), _strict = false, _parent, _enableTracing = _enableAllTracing) {\n        this._services = _services;\n        this._strict = _strict;\n        this._parent = _parent;\n        this._enableTracing = _enableTracing;\n        this._isDisposed = false;\n        this._servicesToMaybeDispose = ( new Set());\n        this._children = ( new Set());\n        this._activeInstantiations = ( new Set());\n        this._services.set(IInstantiationService, this);\n        this._globalGraph = _enableTracing ? _parent?._globalGraph ?? ( new Graph(e => e)) : undefined;\n    }\n    dispose() {\n        if (!this._isDisposed) {\n            this._isDisposed = true;\n            dispose(this._children);\n            this._children.clear();\n            for (const candidate of this._servicesToMaybeDispose) {\n                if (isDisposable(candidate)) {\n                    candidate.dispose();\n                }\n            }\n            this._servicesToMaybeDispose.clear();\n        }\n    }\n    _throwIfDisposed() {\n        if (this._isDisposed) {\n            throw ( new Error('InstantiationService has been disposed'));\n        }\n    }\n    createChild(services, store) {\n        this._throwIfDisposed();\n        const that = this;\n        const result = new (class extends InstantiationService {\n            dispose() {\n                that._children.delete(result);\n                super.dispose();\n            }\n        })(services, this._strict, this, this._enableTracing);\n        this._children.add(result);\n        store?.add(result);\n        return result;\n    }\n    invokeFunction(fn, ...args) {\n        this._throwIfDisposed();\n        const _trace = Trace.traceInvocation(this._enableTracing, fn);\n        let _done = false;\n        try {\n            const accessor = {\n                get: (id) => {\n                    if (_done) {\n                        throw illegalState('service accessor is only valid during the invocation of its target method');\n                    }\n                    const result = this._getOrCreateServiceInstance(id, _trace);\n                    if (!result) {\n                        throw ( new Error(`[invokeFunction] unknown service '${id}'`));\n                    }\n                    return result;\n                }\n            };\n            return fn(accessor, ...args);\n        }\n        finally {\n            _done = true;\n            _trace.stop();\n        }\n    }\n    createInstance(ctorOrDescriptor, ...rest) {\n        this._throwIfDisposed();\n        let _trace;\n        let result;\n        if (ctorOrDescriptor instanceof SyncDescriptor) {\n            _trace = Trace.traceCreation(this._enableTracing, ctorOrDescriptor.ctor);\n            result = this._createInstance(ctorOrDescriptor.ctor, ctorOrDescriptor.staticArguments.concat(rest), _trace);\n        }\n        else {\n            _trace = Trace.traceCreation(this._enableTracing, ctorOrDescriptor);\n            result = this._createInstance(ctorOrDescriptor, rest, _trace);\n        }\n        _trace.stop();\n        return result;\n    }\n    _createInstance(ctor, args = [], _trace) {\n        const serviceDependencies = _util.getServiceDependencies(ctor).sort((a, b) => a.index - b.index);\n        const serviceArgs = [];\n        for (const dependency of serviceDependencies) {\n            const service = this._getOrCreateServiceInstance(dependency.id, _trace);\n            if (!service) {\n                this._throwIfStrict(`[createInstance] ${ctor.name} depends on UNKNOWN service ${dependency.id}.`, false);\n            }\n            serviceArgs.push(service);\n        }\n        const firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : args.length;\n        if (args.length !== firstServiceArgPos) {\n            console.trace(`[createInstance] First service dependency of ${ctor.name} at position ${firstServiceArgPos + 1} conflicts with ${args.length} static arguments`);\n            const delta = firstServiceArgPos - args.length;\n            if (delta > 0) {\n                args = args.concat(( new Array(delta)));\n            }\n            else {\n                args = args.slice(0, firstServiceArgPos);\n            }\n        }\n        return Reflect.construct(ctor, args.concat(serviceArgs));\n    }\n    _setCreatedServiceInstance(id, instance) {\n        if (this._services.get(id) instanceof SyncDescriptor) {\n            this._services.set(id, instance);\n        }\n        else if (this._parent) {\n            this._parent._setCreatedServiceInstance(id, instance);\n        }\n        else {\n            throw ( new Error('illegalState - setting UNKNOWN service instance'));\n        }\n    }\n    _getServiceInstanceOrDescriptor(id) {\n        const instanceOrDesc = this._services.get(id);\n        if (!instanceOrDesc && this._parent) {\n            return this._parent._getServiceInstanceOrDescriptor(id);\n        }\n        else {\n            return instanceOrDesc;\n        }\n    }\n    _getOrCreateServiceInstance(id, _trace) {\n        if (this._globalGraph && this._globalGraphImplicitDependency) {\n            this._globalGraph.insertEdge(this._globalGraphImplicitDependency, String(id));\n        }\n        const thing = this._getServiceInstanceOrDescriptor(id);\n        if (thing instanceof SyncDescriptor) {\n            return this._safeCreateAndCacheServiceInstance(id, thing, _trace.branch(id, true));\n        }\n        else {\n            _trace.branch(id, false);\n            return thing;\n        }\n    }\n    _safeCreateAndCacheServiceInstance(id, desc, _trace) {\n        if (( this._activeInstantiations.has(id))) {\n            throw ( new Error(`illegal state - RECURSIVELY instantiating service '${id}'`));\n        }\n        this._activeInstantiations.add(id);\n        try {\n            return this._createAndCacheServiceInstance(id, desc, _trace);\n        }\n        finally {\n            this._activeInstantiations.delete(id);\n        }\n    }\n    _createAndCacheServiceInstance(id, desc, _trace) {\n        const graph = ( new Graph(data => ( data.id.toString())));\n        let cycleCount = 0;\n        const stack = [{ id, desc, _trace }];\n        const seen = ( new Set());\n        while (stack.length) {\n            const item = stack.pop();\n            if (( seen.has(String(item.id)))) {\n                continue;\n            }\n            seen.add(String(item.id));\n            graph.lookupOrInsertNode(item);\n            if (cycleCount++ > 1000) {\n                throw ( new CyclicDependencyError(graph));\n            }\n            for (const dependency of _util.getServiceDependencies(item.desc.ctor)) {\n                const instanceOrDesc = this._getServiceInstanceOrDescriptor(dependency.id);\n                if (!instanceOrDesc) {\n                    this._throwIfStrict(`[createInstance] ${id} depends on ${dependency.id} which is NOT registered.`, true);\n                }\n                this._globalGraph?.insertEdge(String(item.id), String(dependency.id));\n                if (instanceOrDesc instanceof SyncDescriptor) {\n                    const d = { id: dependency.id, desc: instanceOrDesc, _trace: item._trace.branch(dependency.id, true) };\n                    if (!graph.lookup(d)) {\n                        stack.push(d);\n                    }\n                    graph.insertEdge(item, d);\n                }\n            }\n        }\n        while (true) {\n            const roots = graph.roots();\n            if (roots.length === 0) {\n                if (!graph.isEmpty()) {\n                    throw ( new CyclicDependencyError(graph));\n                }\n                break;\n            }\n            for (const { data } of roots) {\n                const instanceOrDesc = this._getServiceInstanceOrDescriptor(data.id);\n                if (instanceOrDesc instanceof SyncDescriptor) {\n                    const instance = this._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);\n                    this._setCreatedServiceInstance(data.id, instance);\n                }\n                graph.removeNode(data);\n            }\n        }\n        return this._getServiceInstanceOrDescriptor(id);\n    }\n    _createServiceInstanceWithOwner(id, ctor, args = [], supportsDelayedInstantiation, _trace) {\n        if (this._services.get(id) instanceof SyncDescriptor) {\n            return this._createServiceInstance(id, ctor, args, supportsDelayedInstantiation, _trace, this._servicesToMaybeDispose);\n        }\n        else if (this._parent) {\n            return this._parent._createServiceInstanceWithOwner(id, ctor, args, supportsDelayedInstantiation, _trace);\n        }\n        else {\n            throw ( new Error(`illegalState - creating UNKNOWN service instance ${ctor.name}`));\n        }\n    }\n    _createServiceInstance(id, ctor, args = [], supportsDelayedInstantiation, _trace, disposeBucket) {\n        if (!supportsDelayedInstantiation) {\n            const result = this._createInstance(ctor, args, _trace);\n            disposeBucket.add(result);\n            return result;\n        }\n        else {\n            const child = ( new InstantiationService(undefined, this._strict, this, this._enableTracing));\n            child._globalGraphImplicitDependency = String(id);\n            const earlyListeners = ( new Map());\n            const idle = ( new GlobalIdleValue(() => {\n                const result = child._createInstance(ctor, args, _trace);\n                for (const [key, values] of earlyListeners) {\n                    const candidate = result[key];\n                    if (typeof candidate === 'function') {\n                        for (const value of values) {\n                            value.disposable = candidate.apply(result, value.listener);\n                        }\n                    }\n                }\n                earlyListeners.clear();\n                disposeBucket.add(result);\n                return result;\n            }));\n            return ( new Proxy(Object.create(null), {\n                get(target, key) {\n                    if (!idle.isInitialized) {\n                        if (typeof key === 'string' && (key.startsWith('onDid') || key.startsWith('onWill'))) {\n                            let list = earlyListeners.get(key);\n                            if (!list) {\n                                list = ( new LinkedList());\n                                earlyListeners.set(key, list);\n                            }\n                            const event = (callback, thisArg, disposables) => {\n                                if (idle.isInitialized) {\n                                    return idle.value[key](callback, thisArg, disposables);\n                                }\n                                else {\n                                    const entry = { listener: [callback, thisArg, disposables], disposable: undefined };\n                                    const rm = list.push(entry);\n                                    const result = toDisposable(() => {\n                                        rm();\n                                        entry.disposable?.dispose();\n                                    });\n                                    return result;\n                                }\n                            };\n                            return event;\n                        }\n                    }\n                    if (key in target) {\n                        return target[key];\n                    }\n                    const obj = idle.value;\n                    let prop = obj[key];\n                    if (typeof prop !== 'function') {\n                        return prop;\n                    }\n                    prop = prop.bind(obj);\n                    target[key] = prop;\n                    return prop;\n                },\n                set(_target, p, value) {\n                    idle.value[p] = value;\n                    return true;\n                },\n                getPrototypeOf(_target) {\n                    return ctor.prototype;\n                }\n            }));\n        }\n    }\n    _throwIfStrict(msg, printWarning) {\n        if (printWarning) {\n            console.warn(msg);\n        }\n        if (this._strict) {\n            throw ( new Error(msg));\n        }\n    }\n}\nclass Trace {\n    static { this.all = ( new Set()); }\n    static { this._None = new (class extends Trace {\n        constructor() { super(0 , null); }\n        stop() { }\n        branch() { return this; }\n    }); }\n    static traceInvocation(_enableTracing, ctor) {\n        return !_enableTracing ? Trace._None : ( new Trace(2 , ctor.name || ( new Error()).stack.split('\\n').slice(3, 4).join('\\n')));\n    }\n    static traceCreation(_enableTracing, ctor) {\n        return !_enableTracing ? Trace._None : ( new Trace(1 , ctor.name));\n    }\n    static { this._totals = 0; }\n    constructor(type, name) {\n        this.type = type;\n        this.name = name;\n        this._start = Date.now();\n        this._dep = [];\n    }\n    branch(id, first) {\n        const child = ( new Trace(3 , ( id.toString())));\n        this._dep.push([id, first, child]);\n        return child;\n    }\n    stop() {\n        const dur = Date.now() - this._start;\n        Trace._totals += dur;\n        let causedCreation = false;\n        function printChild(n, trace) {\n            const res = [];\n            const prefix = ( new Array(n + 1)).join('\\t');\n            for (const [id, first, child] of trace._dep) {\n                if (first && child) {\n                    causedCreation = true;\n                    res.push(`${prefix}CREATES -> ${id}`);\n                    const nested = printChild(n + 1, child);\n                    if (nested) {\n                        res.push(nested);\n                    }\n                }\n                else {\n                    res.push(`${prefix}uses -> ${id}`);\n                }\n            }\n            return res.join('\\n');\n        }\n        const lines = [\n            `${this.type === 1  ? 'CREATE' : 'CALL'} ${this.name}`,\n            `${printChild(1, this)}`,\n            `DONE, took ${dur.toFixed(2)}ms (grand total ${Trace._totals.toFixed(2)}ms)`\n        ];\n        if (dur > 2 || causedCreation) {\n            Trace.all.add(lines.join('\\n'));\n        }\n    }\n}\nexport { InstantiationService, Trace };\n","class ServiceCollection {\n    constructor(...entries) {\n        this._entries = ( new Map());\n        for (const [id, service] of entries) {\n            this.set(id, service);\n        }\n    }\n    set(id, instanceOrDescriptor) {\n        const result = this._entries.get(id);\n        this._entries.set(id, instanceOrDescriptor);\n        return result;\n    }\n    has(id) {\n        return ( this._entries.has(id));\n    }\n    get(id) {\n        return this._entries.get(id);\n    }\n}\nexport { ServiceCollection };\n","import { Emitter } from '../../../base/common/event.js';\nimport { getCompressedContent } from '../../../base/common/jsonSchema.js';\nimport { Registry } from '../../registry/common/platform.js';\nconst Extensions = {\n    JSONContribution: 'base.contributions.json'\n};\nfunction normalizeId(id) {\n    if (id.length > 0 && id.charAt(id.length - 1) === '#') {\n        return id.substring(0, id.length - 1);\n    }\n    return id;\n}\nclass JSONContributionRegistry {\n    constructor() {\n        this._onDidChangeSchema = ( new Emitter());\n        this.onDidChangeSchema = this._onDidChangeSchema.event;\n        this.schemasById = {};\n    }\n    registerSchema(uri, unresolvedSchemaContent) {\n        this.schemasById[normalizeId(uri)] = unresolvedSchemaContent;\n        this._onDidChangeSchema.fire(uri);\n    }\n    notifySchemaChanged(uri) {\n        this._onDidChangeSchema.fire(uri);\n    }\n    getSchemaContributions() {\n        return {\n            schemas: this.schemasById,\n        };\n    }\n    getSchemaContent(uri) {\n        const schema = this.schemasById[uri];\n        return schema ? getCompressedContent(schema) : undefined;\n    }\n    hasSchemaContent(uri) {\n        return !!this.schemasById[uri];\n    }\n}\nconst jsonContributionRegistry = ( new JSONContributionRegistry());\nRegistry.add(Extensions.JSONContribution, jsonContributionRegistry);\nexport { Extensions };\n","import { localize } from '../../../nls.js';\nimport { toErrorMessage } from '../../../base/common/errorMessage.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { hash } from '../../../base/common/hash.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { ResourceMap } from '../../../base/common/map.js';\nimport '../../../base/common/platform.js';\nimport { joinPath } from '../../../base/common/resources.js';\nimport { isNumber, isString } from '../../../base/common/types.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { RawContextKey } from '../../contextkey/common/contextkey.js';\nfunction isLogLevel(thing) {\n    return isNumber(thing);\n}\nvar LogLevel;\n( ((function(LogLevel) {\n    LogLevel[LogLevel[\"Off\"] = 0] = \"Off\";\n    LogLevel[LogLevel[\"Trace\"] = 1] = \"Trace\";\n    LogLevel[LogLevel[\"Debug\"] = 2] = \"Debug\";\n    LogLevel[LogLevel[\"Info\"] = 3] = \"Info\";\n    LogLevel[LogLevel[\"Warning\"] = 4] = \"Warning\";\n    LogLevel[LogLevel[\"Error\"] = 5] = \"Error\";\n})(LogLevel || (LogLevel = {}))));\nconst DEFAULT_LOG_LEVEL = LogLevel.Info;\nfunction log(logger, level, message) {\n    switch (level) {\n        case LogLevel.Trace:\n            logger.trace(message);\n            break;\n        case LogLevel.Debug:\n            logger.debug(message);\n            break;\n        case LogLevel.Info:\n            logger.info(message);\n            break;\n        case LogLevel.Warning:\n            logger.warn(message);\n            break;\n        case LogLevel.Error:\n            logger.error(message);\n            break;\n        case LogLevel.Off:  break;\n        default: throw ( (new Error(`Invalid log level ${level}`)));\n    }\n}\nfunction format(args, verbose = false) {\n    let result = '';\n    for (let i = 0; i < args.length; i++) {\n        let a = args[i];\n        if (a instanceof Error) {\n            a = toErrorMessage(a, verbose);\n        }\n        if (typeof a === 'object') {\n            try {\n                a = JSON.stringify(a);\n            }\n            catch (e) { }\n        }\n        result += (i > 0 ? ' ' : '') + a;\n    }\n    return result;\n}\nclass AbstractLogger extends Disposable {\n    constructor() {\n        super(...arguments);\n        this.level = DEFAULT_LOG_LEVEL;\n        this._onDidChangeLogLevel = this._register(( (new Emitter())));\n        this.onDidChangeLogLevel = this._onDidChangeLogLevel.event;\n    }\n    setLevel(level) {\n        if (this.level !== level) {\n            this.level = level;\n            this._onDidChangeLogLevel.fire(this.level);\n        }\n    }\n    getLevel() {\n        return this.level;\n    }\n    checkLogLevel(level) {\n        return this.level !== LogLevel.Off && this.level <= level;\n    }\n}\nclass AbstractMessageLogger extends AbstractLogger {\n    constructor(logAlways) {\n        super();\n        this.logAlways = logAlways;\n    }\n    checkLogLevel(level) {\n        return this.logAlways || super.checkLogLevel(level);\n    }\n    trace(message, ...args) {\n        if (this.checkLogLevel(LogLevel.Trace)) {\n            this.log(LogLevel.Trace, format([message, ...args], true));\n        }\n    }\n    debug(message, ...args) {\n        if (this.checkLogLevel(LogLevel.Debug)) {\n            this.log(LogLevel.Debug, format([message, ...args]));\n        }\n    }\n    info(message, ...args) {\n        if (this.checkLogLevel(LogLevel.Info)) {\n            this.log(LogLevel.Info, format([message, ...args]));\n        }\n    }\n    warn(message, ...args) {\n        if (this.checkLogLevel(LogLevel.Warning)) {\n            this.log(LogLevel.Warning, format([message, ...args]));\n        }\n    }\n    error(message, ...args) {\n        if (this.checkLogLevel(LogLevel.Error)) {\n            if (message instanceof Error) {\n                const array = Array.prototype.slice.call(arguments);\n                array[0] = message.stack;\n                this.log(LogLevel.Error, format(array));\n            }\n            else {\n                this.log(LogLevel.Error, format([message, ...args]));\n            }\n        }\n    }\n    flush() { }\n}\nclass ConsoleLogger extends AbstractLogger {\n    constructor(logLevel = DEFAULT_LOG_LEVEL, useColors = true) {\n        super();\n        this.useColors = useColors;\n        this.setLevel(logLevel);\n    }\n    trace(message, ...args) {\n        if (this.checkLogLevel(LogLevel.Trace)) {\n            if (this.useColors) {\n                console.log('%cTRACE', 'color: #888', message, ...args);\n            }\n            else {\n                console.log(message, ...args);\n            }\n        }\n    }\n    debug(message, ...args) {\n        if (this.checkLogLevel(LogLevel.Debug)) {\n            if (this.useColors) {\n                console.log('%cDEBUG', 'background: #eee; color: #888', message, ...args);\n            }\n            else {\n                console.log(message, ...args);\n            }\n        }\n    }\n    info(message, ...args) {\n        if (this.checkLogLevel(LogLevel.Info)) {\n            if (this.useColors) {\n                console.log('%c INFO', 'color: #33f', message, ...args);\n            }\n            else {\n                console.log(message, ...args);\n            }\n        }\n    }\n    warn(message, ...args) {\n        if (this.checkLogLevel(LogLevel.Warning)) {\n            if (this.useColors) {\n                console.log('%c WARN', 'color: #993', message, ...args);\n            }\n            else {\n                console.log(message, ...args);\n            }\n        }\n    }\n    error(message, ...args) {\n        if (this.checkLogLevel(LogLevel.Error)) {\n            if (this.useColors) {\n                console.log('%c  ERR', 'color: #f33', message, ...args);\n            }\n            else {\n                console.error(message, ...args);\n            }\n        }\n    }\n    flush() {\n    }\n}\nclass MultiplexLogger extends AbstractLogger {\n    constructor(loggers) {\n        super();\n        this.loggers = loggers;\n        if (loggers.length) {\n            this.setLevel(loggers[0].getLevel());\n        }\n    }\n    setLevel(level) {\n        for (const logger of this.loggers) {\n            logger.setLevel(level);\n        }\n        super.setLevel(level);\n    }\n    trace(message, ...args) {\n        for (const logger of this.loggers) {\n            logger.trace(message, ...args);\n        }\n    }\n    debug(message, ...args) {\n        for (const logger of this.loggers) {\n            logger.debug(message, ...args);\n        }\n    }\n    info(message, ...args) {\n        for (const logger of this.loggers) {\n            logger.info(message, ...args);\n        }\n    }\n    warn(message, ...args) {\n        for (const logger of this.loggers) {\n            logger.warn(message, ...args);\n        }\n    }\n    error(message, ...args) {\n        for (const logger of this.loggers) {\n            logger.error(message, ...args);\n        }\n    }\n    flush() {\n        for (const logger of this.loggers) {\n            logger.flush();\n        }\n    }\n    dispose() {\n        for (const logger of this.loggers) {\n            logger.dispose();\n        }\n        super.dispose();\n    }\n}\nclass AbstractLoggerService extends Disposable {\n    constructor(logLevel, logsHome, loggerResources) {\n        super();\n        this.logLevel = logLevel;\n        this.logsHome = logsHome;\n        this._loggers = ( (new ResourceMap()));\n        this._onDidChangeLoggers = this._register(( (new Emitter())));\n        this.onDidChangeLoggers = this._onDidChangeLoggers.event;\n        this._onDidChangeLogLevel = this._register(( (new Emitter())));\n        this.onDidChangeLogLevel = this._onDidChangeLogLevel.event;\n        this._onDidChangeVisibility = this._register(( (new Emitter())));\n        this.onDidChangeVisibility = this._onDidChangeVisibility.event;\n        if (loggerResources) {\n            for (const loggerResource of loggerResources) {\n                this._loggers.set(loggerResource.resource, { logger: undefined, info: loggerResource });\n            }\n        }\n    }\n    getLoggerEntry(resourceOrId) {\n        if (isString(resourceOrId)) {\n            return [...( (this._loggers.values()))].find(logger => logger.info.id === resourceOrId);\n        }\n        return this._loggers.get(resourceOrId);\n    }\n    getLogger(resourceOrId) {\n        return this.getLoggerEntry(resourceOrId)?.logger;\n    }\n    createLogger(idOrResource, options) {\n        const resource = this.toResource(idOrResource);\n        const id = isString(idOrResource) ? idOrResource : (options?.id ?? ( (hash(( (resource.toString()))).toString(16))));\n        let logger = this._loggers.get(resource)?.logger;\n        const logLevel = options?.logLevel === 'always' ? LogLevel.Trace : options?.logLevel;\n        if (!logger) {\n            logger = this.doCreateLogger(resource, logLevel ?? this.getLogLevel(resource) ?? this.logLevel, { ...options, id });\n        }\n        const loggerEntry = {\n            logger,\n            info: { resource, id, logLevel, name: options?.name, hidden: options?.hidden, extensionId: options?.extensionId, when: options?.when }\n        };\n        this.registerLogger(loggerEntry.info);\n        this._loggers.set(resource, loggerEntry);\n        return logger;\n    }\n    toResource(idOrResource) {\n        return isString(idOrResource) ? joinPath(this.logsHome, `${idOrResource}.log`) : idOrResource;\n    }\n    setLogLevel(arg1, arg2) {\n        if (URI.isUri(arg1)) {\n            const resource = arg1;\n            const logLevel = arg2;\n            const logger = this._loggers.get(resource);\n            if (logger && logLevel !== logger.info.logLevel) {\n                logger.info.logLevel = logLevel === this.logLevel ? undefined : logLevel;\n                logger.logger?.setLevel(logLevel);\n                this._loggers.set(logger.info.resource, logger);\n                this._onDidChangeLogLevel.fire([resource, logLevel]);\n            }\n        }\n        else {\n            this.logLevel = arg1;\n            for (const [resource, logger] of this._loggers.entries()) {\n                if (this._loggers.get(resource)?.info.logLevel === undefined) {\n                    logger.logger?.setLevel(this.logLevel);\n                }\n            }\n            this._onDidChangeLogLevel.fire(this.logLevel);\n        }\n    }\n    setVisibility(resourceOrId, visibility) {\n        const logger = this.getLoggerEntry(resourceOrId);\n        if (logger && visibility !== !logger.info.hidden) {\n            logger.info.hidden = !visibility;\n            this._loggers.set(logger.info.resource, logger);\n            this._onDidChangeVisibility.fire([logger.info.resource, visibility]);\n        }\n    }\n    getLogLevel(resource) {\n        let logLevel;\n        if (resource) {\n            logLevel = this._loggers.get(resource)?.info.logLevel;\n        }\n        return logLevel ?? this.logLevel;\n    }\n    registerLogger(resource) {\n        const existing = this._loggers.get(resource.resource);\n        if (existing) {\n            if (existing.info.hidden !== resource.hidden) {\n                this.setVisibility(resource.resource, !resource.hidden);\n            }\n        }\n        else {\n            this._loggers.set(resource.resource, { info: resource, logger: undefined });\n            this._onDidChangeLoggers.fire({ added: [resource], removed: [] });\n        }\n    }\n    deregisterLogger(resource) {\n        const existing = this._loggers.get(resource);\n        if (existing) {\n            if (existing.logger) {\n                existing.logger.dispose();\n            }\n            this._loggers.delete(resource);\n            this._onDidChangeLoggers.fire({ added: [], removed: [existing.info] });\n        }\n    }\n    *getRegisteredLoggers() {\n        for (const entry of ( (this._loggers.values()))) {\n            yield entry.info;\n        }\n    }\n    getRegisteredLogger(resource) {\n        return this._loggers.get(resource)?.info;\n    }\n    dispose() {\n        this._loggers.forEach(logger => logger.logger?.dispose());\n        this._loggers.clear();\n        super.dispose();\n    }\n}\nclass NullLogger {\n    constructor() {\n        this.onDidChangeLogLevel = ( (new Emitter())).event;\n    }\n    setLevel(level) { }\n    getLevel() { return LogLevel.Info; }\n    trace(message, ...args) { }\n    debug(message, ...args) { }\n    info(message, ...args) { }\n    warn(message, ...args) { }\n    error(message, ...args) { }\n    critical(message, ...args) { }\n    dispose() { }\n    flush() { }\n}\nclass NullLogService extends NullLogger {\n}\nfunction getLogLevel(environmentService) {\n    if (environmentService.verbose) {\n        return LogLevel.Trace;\n    }\n    if (typeof environmentService.logLevel === 'string') {\n        const logLevel = parseLogLevel(environmentService.logLevel.toLowerCase());\n        if (logLevel !== undefined) {\n            return logLevel;\n        }\n    }\n    return DEFAULT_LOG_LEVEL;\n}\nfunction LogLevelToString(logLevel) {\n    switch (logLevel) {\n        case LogLevel.Trace: return 'trace';\n        case LogLevel.Debug: return 'debug';\n        case LogLevel.Info: return 'info';\n        case LogLevel.Warning: return 'warn';\n        case LogLevel.Error: return 'error';\n        case LogLevel.Off: return 'off';\n    }\n}\nfunction LogLevelToLocalizedString(logLevel) {\n    switch (logLevel) {\n        case LogLevel.Trace: return { original: 'Trace', value: ( localize(69, \"Trace\")) };\n        case LogLevel.Debug: return { original: 'Debug', value: ( localize(70, \"Debug\")) };\n        case LogLevel.Info: return { original: 'Info', value: ( localize(71, \"Info\")) };\n        case LogLevel.Warning: return { original: 'Warning', value: ( localize(72, \"Warning\")) };\n        case LogLevel.Error: return { original: 'Error', value: ( localize(73, \"Error\")) };\n        case LogLevel.Off: return { original: 'Off', value: ( localize(74, \"Off\")) };\n    }\n}\nfunction parseLogLevel(logLevel) {\n    switch (logLevel) {\n        case 'trace':\n            return LogLevel.Trace;\n        case 'debug':\n            return LogLevel.Debug;\n        case 'info':\n            return LogLevel.Info;\n        case 'warn':\n            return LogLevel.Warning;\n        case 'error':\n            return LogLevel.Error;\n        case 'critical':\n            return LogLevel.Error;\n        case 'off':\n            return LogLevel.Off;\n    }\n    return undefined;\n}\nconst CONTEXT_LOG_LEVEL = ( (new RawContextKey('logLevel', LogLevelToString(LogLevel.Info))));\nexport { AbstractLogger, AbstractLoggerService, AbstractMessageLogger, CONTEXT_LOG_LEVEL, ConsoleLogger, DEFAULT_LOG_LEVEL, LogLevel, LogLevelToLocalizedString, LogLevelToString, MultiplexLogger, NullLogService, NullLogger, getLogLevel, isLogLevel, log, parseLogLevel };\n","import { createDecorator } from '../../instantiation/common/instantiation.js';\nconst ILogService = ( createDecorator('logService'));\nconst ILoggerService = ( createDecorator('loggerService'));\nexport { ILogService, ILoggerService };\n","import { Disposable } from '../../../base/common/lifecycle.js';\nimport { MultiplexLogger } from './log.js';\nclass LogService extends Disposable {\n    constructor(primaryLogger, otherLoggers = []) {\n        super();\n        this.logger = ( new MultiplexLogger([primaryLogger, ...otherLoggers]));\n        this._register(primaryLogger.onDidChangeLogLevel(level => this.setLevel(level)));\n    }\n    get onDidChangeLogLevel() {\n        return this.logger.onDidChangeLogLevel;\n    }\n    setLevel(level) {\n        this.logger.setLevel(level);\n    }\n    getLevel() {\n        return this.logger.getLevel();\n    }\n    trace(message, ...args) {\n        this.logger.trace(message, ...args);\n    }\n    debug(message, ...args) {\n        this.logger.debug(message, ...args);\n    }\n    info(message, ...args) {\n        this.logger.info(message, ...args);\n    }\n    warn(message, ...args) {\n        this.logger.warn(message, ...args);\n    }\n    error(message, ...args) {\n        this.logger.error(message, ...args);\n    }\n    flush() {\n        this.logger.flush();\n    }\n}\nexport { LogService };\n","import Severity$1 from '../../../base/common/severity.js';\nimport { localize } from '../../../nls.js';\nvar MarkerSeverity;\n( ((function(MarkerSeverity) {\n    MarkerSeverity[MarkerSeverity[\"Hint\"] = 1] = \"Hint\";\n    MarkerSeverity[MarkerSeverity[\"Info\"] = 2] = \"Info\";\n    MarkerSeverity[MarkerSeverity[\"Warning\"] = 4] = \"Warning\";\n    MarkerSeverity[MarkerSeverity[\"Error\"] = 8] = \"Error\";\n})(MarkerSeverity || (MarkerSeverity = {}))));\n( ((function(MarkerSeverity) {\n    function compare(a, b) {\n        return b - a;\n    }\n    MarkerSeverity.compare = compare;\n    const _displayStrings = Object.create(null);\n    _displayStrings[MarkerSeverity.Error] = ( localize(4781, \"Error\"));\n    _displayStrings[MarkerSeverity.Warning] = ( localize(4782, \"Warning\"));\n    _displayStrings[MarkerSeverity.Info] = ( localize(4783, \"Info\"));\n    function toString(a) {\n        return _displayStrings[a] || '';\n    }\n    MarkerSeverity.toString = toString;\n    function fromSeverity(severity) {\n        switch (severity) {\n            case Severity$1.Error: return MarkerSeverity.Error;\n            case Severity$1.Warning: return MarkerSeverity.Warning;\n            case Severity$1.Info: return MarkerSeverity.Info;\n            case Severity$1.Ignore: return MarkerSeverity.Hint;\n        }\n    }\n    MarkerSeverity.fromSeverity = fromSeverity;\n    function toSeverity(severity) {\n        switch (severity) {\n            case MarkerSeverity.Error: return Severity$1.Error;\n            case MarkerSeverity.Warning: return Severity$1.Warning;\n            case MarkerSeverity.Info: return Severity$1.Info;\n            case MarkerSeverity.Hint: return Severity$1.Ignore;\n        }\n    }\n    MarkerSeverity.toSeverity = toSeverity;\n})(MarkerSeverity || (MarkerSeverity = {}))));\nvar IMarkerData;\n( ((function(IMarkerData) {\n    const emptyString = '';\n    function makeKey(markerData) {\n        return makeKeyOptionalMessage(markerData, true);\n    }\n    IMarkerData.makeKey = makeKey;\n    function makeKeyOptionalMessage(markerData, useMessage) {\n        const result = [emptyString];\n        if (markerData.source) {\n            result.push(markerData.source.replace('', '\\\\'));\n        }\n        else {\n            result.push(emptyString);\n        }\n        if (markerData.code) {\n            if (typeof markerData.code === 'string') {\n                result.push(markerData.code.replace('', '\\\\'));\n            }\n            else {\n                result.push(markerData.code.value.replace('', '\\\\'));\n            }\n        }\n        else {\n            result.push(emptyString);\n        }\n        if (markerData.severity !== undefined && markerData.severity !== null) {\n            result.push(( (MarkerSeverity.toString(markerData.severity))));\n        }\n        else {\n            result.push(emptyString);\n        }\n        if (markerData.message && useMessage) {\n            result.push(markerData.message.replace('', '\\\\'));\n        }\n        else {\n            result.push(emptyString);\n        }\n        if (markerData.startLineNumber !== undefined && markerData.startLineNumber !== null) {\n            result.push(( (markerData.startLineNumber.toString())));\n        }\n        else {\n            result.push(emptyString);\n        }\n        if (markerData.startColumn !== undefined && markerData.startColumn !== null) {\n            result.push(( (markerData.startColumn.toString())));\n        }\n        else {\n            result.push(emptyString);\n        }\n        if (markerData.endLineNumber !== undefined && markerData.endLineNumber !== null) {\n            result.push(( (markerData.endLineNumber.toString())));\n        }\n        else {\n            result.push(emptyString);\n        }\n        if (markerData.endColumn !== undefined && markerData.endColumn !== null) {\n            result.push(( (markerData.endColumn.toString())));\n        }\n        else {\n            result.push(emptyString);\n        }\n        result.push(emptyString);\n        return result.join('');\n    }\n    IMarkerData.makeKeyOptionalMessage = makeKeyOptionalMessage;\n})(IMarkerData || (IMarkerData = {}))));\nexport { IMarkerData, MarkerSeverity };\n","import { Event } from '../../../base/common/event.js';\nexport { default as Severity } from '../../../base/common/severity.js';\nvar NotificationPriority;\n( (function(NotificationPriority) {\n    NotificationPriority[NotificationPriority[\"DEFAULT\"] = 0] = \"DEFAULT\";\n    NotificationPriority[NotificationPriority[\"SILENT\"] = 1] = \"SILENT\";\n    NotificationPriority[NotificationPriority[\"URGENT\"] = 2] = \"URGENT\";\n})(NotificationPriority || (NotificationPriority = {})));\nvar NeverShowAgainScope;\n( (function(NeverShowAgainScope) {\n    NeverShowAgainScope[NeverShowAgainScope[\"WORKSPACE\"] = 0] = \"WORKSPACE\";\n    NeverShowAgainScope[NeverShowAgainScope[\"PROFILE\"] = 1] = \"PROFILE\";\n    NeverShowAgainScope[NeverShowAgainScope[\"APPLICATION\"] = 2] = \"APPLICATION\";\n})(NeverShowAgainScope || (NeverShowAgainScope = {})));\nfunction isNotificationSource(thing) {\n    if (thing) {\n        const candidate = thing;\n        return typeof candidate.id === 'string' && typeof candidate.label === 'string';\n    }\n    return false;\n}\nvar NotificationsFilter;\n( (function(NotificationsFilter) {\n    NotificationsFilter[NotificationsFilter[\"OFF\"] = 0] = \"OFF\";\n    NotificationsFilter[NotificationsFilter[\"ERROR\"] = 1] = \"ERROR\";\n})(NotificationsFilter || (NotificationsFilter = {})));\nclass NoOpNotification {\n    constructor() {\n        this.progress = ( new NoOpProgress());\n        this.onDidClose = Event.None;\n        this.onDidChangeVisibility = Event.None;\n    }\n    updateSeverity(severity) { }\n    updateMessage(message) { }\n    updateActions(actions) { }\n    close() { }\n}\nclass NoOpProgress {\n    infinite() { }\n    done() { }\n    total(value) { }\n    worked(value) { }\n}\nexport { NeverShowAgainScope, NoOpNotification, NoOpProgress, NotificationPriority, NotificationsFilter, isNotificationSource };\n","const productSchemaId = 'vscode://schemas/vscode-product';\nexport { productSchemaId };\n","import { createDecorator } from '../../instantiation/common/instantiation.js';\nconst IProductService = ( createDecorator('productService'));\nexport { IProductService };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { DeferredPromise } from '../../../base/common/async.js';\nimport { CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { Disposable, DisposableStore, toDisposable } from '../../../base/common/lifecycle.js';\nimport { IProgressService } from './progress.service.js';\nconst emptyProgressRunner = ( Object.freeze({\n    total() { },\n    worked() { },\n    done() { }\n}));\nclass Progress {\n    static { this.None = ( Object.freeze({ report() { } })); }\n    get value() { return this._value; }\n    constructor(callback) {\n        this.callback = callback;\n    }\n    report(item) {\n        this._value = item;\n        this.callback(this._value);\n    }\n}\nlet UnmanagedProgress = class UnmanagedProgress extends Disposable {\n    constructor(options, progressService) {\n        super();\n        this.deferred = ( new DeferredPromise());\n        progressService.withProgress(options, reporter => {\n            this.reporter = reporter;\n            if (this.lastStep) {\n                reporter.report(this.lastStep);\n            }\n            return this.deferred.p;\n        });\n        this._register(toDisposable(() => this.deferred.complete()));\n    }\n    report(step) {\n        if (this.reporter) {\n            this.reporter.report(step);\n        }\n        else {\n            this.lastStep = step;\n        }\n    }\n};\nUnmanagedProgress = ( __decorate([\n    ( __param(1, IProgressService))\n], UnmanagedProgress));\nclass LongRunningOperation extends Disposable {\n    constructor(progressIndicator) {\n        super();\n        this.progressIndicator = progressIndicator;\n        this.currentOperationId = 0;\n        this.currentOperationDisposables = this._register(( new DisposableStore()));\n    }\n    start(progressDelay) {\n        this.stop();\n        const newOperationId = ++this.currentOperationId;\n        const newOperationToken = ( new CancellationTokenSource());\n        this.currentProgressTimeout = setTimeout(() => {\n            if (newOperationId === this.currentOperationId) {\n                this.currentProgressRunner = this.progressIndicator.show(true);\n            }\n        }, progressDelay);\n        this.currentOperationDisposables.add(toDisposable(() => clearTimeout(this.currentProgressTimeout)));\n        this.currentOperationDisposables.add(toDisposable(() => newOperationToken.cancel()));\n        this.currentOperationDisposables.add(toDisposable(() => this.currentProgressRunner ? this.currentProgressRunner.done() : undefined));\n        return {\n            id: newOperationId,\n            token: newOperationToken.token,\n            stop: () => this.doStop(newOperationId),\n            isCurrent: () => this.currentOperationId === newOperationId\n        };\n    }\n    stop() {\n        this.doStop(this.currentOperationId);\n    }\n    doStop(operationId) {\n        if (this.currentOperationId === operationId) {\n            this.currentOperationDisposables.clear();\n        }\n    }\n}\nexport { LongRunningOperation, Progress, UnmanagedProgress, emptyProgressRunner };\n","import { createDecorator } from '../../instantiation/common/instantiation.js';\nconst IProgressService = ( createDecorator('progressService'));\nconst IEditorProgressService = ( createDecorator('editorProgressService'));\nexport { IEditorProgressService, IProgressService };\n","import { ok } from '../../../base/common/assert.js';\nimport { isString, isObject } from '../../../base/common/types.js';\nclass RegistryImpl {\n    constructor() {\n        this.data = ( new Map());\n    }\n    add(id, data) {\n        ok(isString(id));\n        ok(isObject(data));\n        ok(!( this.data.has(id)), 'There is already an extension with this id');\n        this.data.set(id, data);\n    }\n    knows(id) {\n        return ( this.data.has(id));\n    }\n    as(id) {\n        return this.data.get(id) || null;\n    }\n}\nconst Registry = ( new RegistryImpl());\nexport { Registry };\n","import { ErrorNoTelemetry } from '../../../base/common/errors.js';\nclass ManagedRemoteConnection {\n    constructor(id) {\n        this.id = id;\n        this.type = 1 ;\n    }\n    toString() {\n        return `Managed(${this.id})`;\n    }\n}\nclass WebSocketRemoteConnection {\n    constructor(host, port) {\n        this.host = host;\n        this.port = port;\n        this.type = 0 ;\n    }\n    toString() {\n        return `WebSocket(${this.host}:${this.port})`;\n    }\n}\nvar RemoteAuthorityResolverErrorCode;\n( (function(RemoteAuthorityResolverErrorCode) {\n    RemoteAuthorityResolverErrorCode[\"Unknown\"] = \"Unknown\";\n    RemoteAuthorityResolverErrorCode[\"NotAvailable\"] = \"NotAvailable\";\n    RemoteAuthorityResolverErrorCode[\"TemporarilyNotAvailable\"] = \"TemporarilyNotAvailable\";\n    RemoteAuthorityResolverErrorCode[\"NoResolverFound\"] = \"NoResolverFound\";\n    RemoteAuthorityResolverErrorCode[\"InvalidAuthority\"] = \"InvalidAuthority\";\n})(\n    RemoteAuthorityResolverErrorCode || (RemoteAuthorityResolverErrorCode = {})\n));\nclass RemoteAuthorityResolverError extends ErrorNoTelemetry {\n    static isNotAvailable(err) {\n        return (err instanceof RemoteAuthorityResolverError) && err._code === RemoteAuthorityResolverErrorCode.NotAvailable;\n    }\n    static isTemporarilyNotAvailable(err) {\n        return (err instanceof RemoteAuthorityResolverError) && err._code === RemoteAuthorityResolverErrorCode.TemporarilyNotAvailable;\n    }\n    static isNoResolverFound(err) {\n        return (err instanceof RemoteAuthorityResolverError) && err._code === RemoteAuthorityResolverErrorCode.NoResolverFound;\n    }\n    static isInvalidAuthority(err) {\n        return (err instanceof RemoteAuthorityResolverError) && err._code === RemoteAuthorityResolverErrorCode.InvalidAuthority;\n    }\n    static isHandled(err) {\n        return (err instanceof RemoteAuthorityResolverError) && err.isHandled;\n    }\n    constructor(message, code = RemoteAuthorityResolverErrorCode.Unknown, detail) {\n        super(message);\n        this._message = message;\n        this._code = code;\n        this._detail = detail;\n        this.isHandled = (code === RemoteAuthorityResolverErrorCode.NotAvailable) && detail === true;\n        Object.setPrototypeOf(this, RemoteAuthorityResolverError.prototype);\n    }\n}\nfunction getRemoteAuthorityPrefix(remoteAuthority) {\n    const plusIndex = remoteAuthority.indexOf('+');\n    if (plusIndex === -1) {\n        return remoteAuthority;\n    }\n    return remoteAuthority.substring(0, plusIndex);\n}\nexport { ManagedRemoteConnection, RemoteAuthorityResolverError, RemoteAuthorityResolverErrorCode, WebSocketRemoteConnection, getRemoteAuthorityPrefix };\n","import { Schemas } from '../../../base/common/network.js';\nfunction getRemoteAuthority(uri) {\n    return uri.scheme === Schemas.vscodeRemote ? uri.authority : undefined;\n}\nfunction getRemoteName(authority) {\n    if (!authority) {\n        return undefined;\n    }\n    const pos = authority.indexOf('+');\n    if (pos < 0) {\n        return authority;\n    }\n    return authority.substr(0, pos);\n}\nfunction parseAuthorityWithOptionalPort(authority, defaultPort) {\n    let { host, port } = parseAuthority(authority);\n    if (typeof port === 'undefined') {\n        port = defaultPort;\n    }\n    return { host, port };\n}\nfunction parseAuthority(authority) {\n    const m1 = authority.match(/^(\\[[0-9a-z:]+\\]):(\\d+)$/);\n    if (m1) {\n        return { host: m1[1], port: parseInt(m1[2], 10) };\n    }\n    const m2 = authority.match(/^(\\[[0-9a-z:]+\\])$/);\n    if (m2) {\n        return { host: m2[1], port: undefined };\n    }\n    const m3 = authority.match(/(.*):(\\d+)$/);\n    if (m3) {\n        return { host: m3[1], port: parseInt(m3[2], 10) };\n    }\n    return { host: authority, port: undefined };\n}\nexport { getRemoteAuthority, getRemoteName, parseAuthorityWithOptionalPort };\n","import { streamToBuffer } from '../../../base/common/buffer.js';\nimport { getErrorMessage } from '../../../base/common/errors.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { localize } from '../../../nls.js';\nimport { Extensions } from '../../configuration/common/configurationRegistry.js';\nimport { Registry } from '../../registry/common/platform.js';\nclass LoggableHeaders {\n    constructor(original) {\n        this.original = original;\n    }\n    toJSON() {\n        if (!this.headers) {\n            const headers = Object.create(null);\n            for (const key in this.original) {\n                if (key.toLowerCase() === 'authorization' || key.toLowerCase() === 'proxy-authorization') {\n                    headers[key] = '*****';\n                }\n                else {\n                    headers[key] = this.original[key];\n                }\n            }\n            this.headers = headers;\n        }\n        return this.headers;\n    }\n}\nclass AbstractRequestService extends Disposable {\n    constructor(logService) {\n        super();\n        this.logService = logService;\n        this.counter = 0;\n    }\n    async logAndRequest(options, request) {\n        const prefix = `[network] #${++this.counter}: ${options.url}`;\n        this.logService.trace(`${prefix} - begin`, options.type, ( (new LoggableHeaders(options.headers ?? {}))));\n        try {\n            const result = await request();\n            this.logService.trace(`${prefix} - end`, options.type, result.res.statusCode, result.res.headers);\n            return result;\n        }\n        catch (error) {\n            this.logService.error(`${prefix} - error`, options.type, getErrorMessage(error));\n            throw error;\n        }\n    }\n}\nfunction isSuccess(context) {\n    return (context.res.statusCode && context.res.statusCode >= 200 && context.res.statusCode < 300) || context.res.statusCode === 1223;\n}\nfunction hasNoContent(context) {\n    return context.res.statusCode === 204;\n}\nasync function asText(context) {\n    if (hasNoContent(context)) {\n        return null;\n    }\n    const buffer = await streamToBuffer(context.stream);\n    return (\n         (buffer.toString())\n    );\n}\nasync function asTextOrError(context) {\n    if (!isSuccess(context)) {\n        throw ( (new Error('Server returned ' + context.res.statusCode)));\n    }\n    return asText(context);\n}\nasync function asJson(context) {\n    if (!isSuccess(context)) {\n        throw ( (new Error('Server returned ' + context.res.statusCode)));\n    }\n    if (hasNoContent(context)) {\n        return null;\n    }\n    const buffer = await streamToBuffer(context.stream);\n    const str = ( (buffer.toString()));\n    try {\n        return JSON.parse(str);\n    }\n    catch (err) {\n        err.message += ':\\n' + str;\n        throw err;\n    }\n}\nlet proxyConfiguration;\nfunction registerProxyConfigurations(scope) {\n    const configurationRegistry = ( (Registry.as(Extensions.Configuration)));\n    const oldProxyConfiguration = proxyConfiguration;\n    proxyConfiguration = {\n        id: 'http',\n        order: 15,\n        title: ( localize(4560, \"HTTP\")),\n        type: 'object',\n        scope,\n        properties: {\n            'http.proxy': {\n                type: 'string',\n                pattern: '^(https?|socks|socks4a?|socks5h?)://([^:]*(:[^@]*)?@)?([^:]+|\\\\[[:0-9a-fA-F]+\\\\])(:\\\\d+)?/?$|^$',\n                markdownDescription: ( localize(\n                    4561,\n                    \"The proxy setting to use. If not set, will be inherited from the `http_proxy` and `https_proxy` environment variables.\"\n                )),\n                restricted: true\n            },\n            'http.proxyStrictSSL': {\n                type: 'boolean',\n                default: true,\n                description: ( localize(\n                    4562,\n                    \"Controls whether the proxy server certificate should be verified against the list of supplied CAs.\"\n                )),\n                restricted: true\n            },\n            'http.proxyKerberosServicePrincipal': {\n                type: 'string',\n                markdownDescription: ( localize(\n                    4563,\n                    \"Overrides the principal service name for Kerberos authentication with the HTTP proxy. A default based on the proxy hostname is used when this is not set.\"\n                )),\n                restricted: true\n            },\n            'http.noProxy': {\n                type: 'array',\n                items: { type: 'string' },\n                markdownDescription: ( localize(\n                    4564,\n                    \"Specifies domain names for which proxy settings should be ignored for HTTP/HTTPS requests.\"\n                )),\n                restricted: true\n            },\n            'http.proxyAuthorization': {\n                type: ['null', 'string'],\n                default: null,\n                markdownDescription: ( localize(\n                    4565,\n                    \"The value to send as the `Proxy-Authorization` header for every network request.\"\n                )),\n                restricted: true\n            },\n            'http.proxySupport': {\n                type: 'string',\n                enum: ['off', 'on', 'fallback', 'override'],\n                enumDescriptions: [\n                    ( localize(4566, \"Disable proxy support for extensions.\")),\n                    ( localize(4567, \"Enable proxy support for extensions.\")),\n                    ( localize(\n                        4568,\n                        \"Enable proxy support for extensions, fall back to request options, when no proxy found.\"\n                    )),\n                    ( localize(4569, \"Enable proxy support for extensions, override request options.\")),\n                ],\n                default: 'override',\n                description: ( localize(4570, \"Use the proxy support for extensions.\")),\n                restricted: true\n            },\n            'http.systemCertificates': {\n                type: 'boolean',\n                default: true,\n                description: ( localize(\n                    4571,\n                    \"Controls whether CA certificates should be loaded from the OS. (On Windows and macOS, a reload of the window is required after turning this off.)\"\n                )),\n                restricted: true\n            },\n            'http.experimental.systemCertificatesV2': {\n                type: 'boolean',\n                tags: ['experimental'],\n                default: false,\n                description: ( localize(\n                    4572,\n                    \"Controls whether experimental loading of CA certificates from the OS should be enabled. This uses a more general approach than the default implemenation.\"\n                )),\n                restricted: true\n            },\n            'http.electronFetch': {\n                type: 'boolean',\n                default: false,\n                description: ( localize(\n                    4573,\n                    \"Controls whether use of Electron's fetch implementation instead of Node.js' should be enabled. All local extensions will get Electron's fetch implementation for the global fetch API.\"\n                )),\n                restricted: true\n            }\n        }\n    };\n    configurationRegistry.updateConfigurations({ add: [proxyConfiguration], remove: oldProxyConfiguration ? [oldProxyConfiguration] : [] });\n}\nregisterProxyConfigurations(1 );\nexport { AbstractRequestService, asJson, asText, asTextOrError, hasNoContent, isSuccess };\n","import { createDecorator } from '../../instantiation/common/instantiation.js';\nconst IRequestService = ( createDecorator('requestService'));\nexport { IRequestService };\n","import { createDecorator } from '../../instantiation/common/instantiation.js';\nconst IStorageService = ( createDecorator('storageService'));\nexport { IStorageService };\n","const firstSessionDateStorageKey = 'telemetry.firstSessionDate';\nconst TELEMETRY_SETTING_ID = 'telemetry.telemetryLevel';\nconst TELEMETRY_CRASH_REPORTER_SETTING_ID = 'telemetry.enableCrashReporter';\nconst TELEMETRY_OLD_SETTING_ID = 'telemetry.enableTelemetry';\nexport { TELEMETRY_CRASH_REPORTER_SETTING_ID, TELEMETRY_OLD_SETTING_ID, TELEMETRY_SETTING_ID, firstSessionDateStorageKey };\n","import { cloneAndChange } from '../../../base/common/objects.js';\nimport { getRemoteName } from '../../remote/common/remoteHosts.js';\nimport '../../../base/common/platform.js';\nimport '../../../base/common/process.js';\nimport { TELEMETRY_SETTING_ID, TELEMETRY_CRASH_REPORTER_SETTING_ID, TELEMETRY_OLD_SETTING_ID } from './telemetry.js';\nclass TelemetryTrustedValue {\n    constructor(value) {\n        this.value = value;\n        this.isTrustedTelemetryValue = true;\n    }\n}\nclass NullEndpointTelemetryService {\n    async publicLog(_endpoint, _eventName, _data) {\n    }\n    async publicLogError(_endpoint, _errorEventName, _data) {\n    }\n}\nconst telemetryLogId = 'telemetry';\nconst extensionTelemetryLogChannelId = 'extensionTelemetryLog';\nfunction supportsTelemetry(productService, environmentService) {\n    if (!environmentService.isBuilt && !environmentService.disableTelemetry) {\n        return true;\n    }\n    return !(environmentService.disableTelemetry || !productService.enableTelemetry);\n}\nfunction isLoggingOnly(productService, environmentService) {\n    if (environmentService.extensionTestsLocationURI) {\n        return true;\n    }\n    if (environmentService.isBuilt) {\n        return false;\n    }\n    if (environmentService.disableTelemetry) {\n        return false;\n    }\n    if (productService.enableTelemetry && productService.aiConfig?.ariaKey) {\n        return false;\n    }\n    return true;\n}\nfunction getTelemetryLevel(configurationService) {\n    const newConfig = configurationService.getValue(TELEMETRY_SETTING_ID);\n    const crashReporterConfig = configurationService.getValue(TELEMETRY_CRASH_REPORTER_SETTING_ID);\n    const oldConfig = configurationService.getValue(TELEMETRY_OLD_SETTING_ID);\n    if (oldConfig === false || crashReporterConfig === false) {\n        return 0 ;\n    }\n    switch (newConfig ?? \"all\" ) {\n        case \"all\" :\n            return 3 ;\n        case \"error\" :\n            return 2 ;\n        case \"crash\" :\n            return 1 ;\n        case \"off\" :\n            return 0 ;\n    }\n}\nconst telemetryAllowedAuthorities = ( new Set(\n    ['ssh-remote', 'dev-container', 'attached-container', 'wsl', 'tunnel', 'codespaces', 'amlext']\n));\nfunction cleanRemoteAuthority(remoteAuthority) {\n    if (!remoteAuthority) {\n        return 'none';\n    }\n    const remoteName = getRemoteName(remoteAuthority);\n    return ( telemetryAllowedAuthorities.has(remoteName)) ? remoteName : 'other';\n}\nfunction anonymizeFilePaths(stack, cleanupPatterns) {\n    if (!stack || (!stack.includes('/') && !stack.includes('\\\\'))) {\n        return stack;\n    }\n    let updatedStack = stack;\n    const cleanUpIndexes = [];\n    for (const regexp of cleanupPatterns) {\n        while (true) {\n            const result = regexp.exec(stack);\n            if (!result) {\n                break;\n            }\n            cleanUpIndexes.push([result.index, regexp.lastIndex]);\n        }\n    }\n    const nodeModulesRegex = /^[\\\\\\/]?(node_modules|node_modules\\.asar)[\\\\\\/]/;\n    const fileRegex = /(file:\\/\\/)?([a-zA-Z]:(\\\\\\\\|\\\\|\\/)|(\\\\\\\\|\\\\|\\/))?([\\w-\\._]+(\\\\\\\\|\\\\|\\/))+[\\w-\\._]*/g;\n    let lastIndex = 0;\n    updatedStack = '';\n    while (true) {\n        const result = fileRegex.exec(stack);\n        if (!result) {\n            break;\n        }\n        const overlappingRange = ( cleanUpIndexes.some(([start, end]) => result.index < end && start < fileRegex.lastIndex));\n        if (!nodeModulesRegex.test(result[0]) && !overlappingRange) {\n            updatedStack += stack.substring(lastIndex, result.index) + '<REDACTED: user-file-path>';\n            lastIndex = fileRegex.lastIndex;\n        }\n    }\n    if (lastIndex < stack.length) {\n        updatedStack += stack.substr(lastIndex);\n    }\n    return updatedStack;\n}\nfunction removePropertiesWithPossibleUserInfo(property) {\n    if (!property) {\n        return property;\n    }\n    const userDataRegexes = [\n        { label: 'Google API Key', regex: /AIza[A-Za-z0-9_\\\\\\-]{35}/ },\n        { label: 'Slack Token', regex: /xox[pbar]\\-[A-Za-z0-9]/ },\n        { label: 'GitHub Token', regex: /(gh[psuro]_[a-zA-Z0-9]{36}|github_pat_[a-zA-Z0-9]{22}_[a-zA-Z0-9]{59})/ },\n        { label: 'Generic Secret', regex: /(key|token|sig|secret|signature|password|passwd|pwd|android:value)[^a-zA-Z0-9]/i },\n        { label: 'CLI Credentials', regex: /((login|psexec|(certutil|psexec)\\.exe).{1,50}(\\s-u(ser(name)?)?\\s+.{3,100})?\\s-(admin|user|vm|root)?p(ass(word)?)?\\s+[\"']?[^$\\-\\/\\s]|(^|[\\s\\r\\n\\\\])net(\\.exe)?.{1,5}(user\\s+|share\\s+\\/user:| user -? secrets ? set) \\s + [^ $\\s \\/])/ },\n        { label: 'Email', regex: /@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-]+/ }\n    ];\n    for (const secretRegex of userDataRegexes) {\n        if (secretRegex.regex.test(property)) {\n            return `<REDACTED: ${secretRegex.label}>`;\n        }\n    }\n    return property;\n}\nfunction cleanData(data, cleanUpPatterns) {\n    return cloneAndChange(data, value => {\n        if (value instanceof TelemetryTrustedValue || Object.hasOwnProperty.call(value, 'isTrustedTelemetryValue')) {\n            return value.value;\n        }\n        if (typeof value === 'string') {\n            let updatedProperty = value.replaceAll('%20', ' ');\n            updatedProperty = anonymizeFilePaths(updatedProperty, cleanUpPatterns);\n            for (const regexp of cleanUpPatterns) {\n                updatedProperty = updatedProperty.replace(regexp, '');\n            }\n            updatedProperty = removePropertiesWithPossibleUserInfo(updatedProperty);\n            return updatedProperty;\n        }\n        return undefined;\n    });\n}\nexport { NullEndpointTelemetryService, TelemetryTrustedValue, cleanData, cleanRemoteAuthority, extensionTelemetryLogChannelId, getTelemetryLevel, isLoggingOnly, supportsTelemetry, telemetryLogId };\n","function serializeEnvironmentVariableCollection(collection) {\n    return [...collection.entries()];\n}\nfunction serializeEnvironmentDescriptionMap(descriptionMap) {\n    return descriptionMap ? [...descriptionMap.entries()] : [];\n}\nfunction deserializeEnvironmentVariableCollection(serializedCollection) {\n    return ( new Map(serializedCollection));\n}\nfunction deserializeEnvironmentDescriptionMap(serializableEnvironmentDescription) {\n    return ( new Map(serializableEnvironmentDescription ?? []));\n}\nfunction serializeEnvironmentVariableCollections(collections) {\n    return ( Array.from(collections.entries()).map(e => {\n        return [e[0], serializeEnvironmentVariableCollection(e[1].map), serializeEnvironmentDescriptionMap(e[1].descriptionMap)];\n    }));\n}\nfunction deserializeEnvironmentVariableCollections(serializedCollection) {\n    return ( new Map(( serializedCollection.map(e => {\n        return [e[0], { map: deserializeEnvironmentVariableCollection(e[1]), descriptionMap: deserializeEnvironmentDescriptionMap(e[2]) }];\n    }))));\n}\nexport { deserializeEnvironmentDescriptionMap, deserializeEnvironmentVariableCollection, deserializeEnvironmentVariableCollections, serializeEnvironmentDescriptionMap, serializeEnvironmentVariableCollection, serializeEnvironmentVariableCollections };\n","class TerminalDataBufferer {\n    constructor(_callback) {\n        this._callback = _callback;\n        this._terminalBufferMap = ( new Map());\n    }\n    dispose() {\n        for (const buffer of ( this._terminalBufferMap.values())) {\n            buffer.dispose();\n        }\n    }\n    startBuffering(id, event, throttleBy = 5) {\n        const disposable = event((e) => {\n            const data = (typeof e === 'string' ? e : e.data);\n            let buffer = this._terminalBufferMap.get(id);\n            if (buffer) {\n                buffer.data.push(data);\n                return;\n            }\n            const timeoutId = setTimeout(() => this.flushBuffer(id), throttleBy);\n            buffer = {\n                data: [data],\n                timeoutId: timeoutId,\n                dispose: () => {\n                    clearTimeout(timeoutId);\n                    this.flushBuffer(id);\n                    disposable.dispose();\n                }\n            };\n            this._terminalBufferMap.set(id, buffer);\n        });\n        return disposable;\n    }\n    stopBuffering(id) {\n        const buffer = this._terminalBufferMap.get(id);\n        buffer?.dispose();\n    }\n    flushBuffer(id) {\n        const buffer = this._terminalBufferMap.get(id);\n        if (buffer) {\n            this._terminalBufferMap.delete(id);\n            this._callback(id, buffer.data.join(''));\n        }\n    }\n}\nexport { TerminalDataBufferer };\n","import { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Codicon } from '../../../base/common/codicons.js';\nimport { getCodiconFontCharacters } from '../../../base/common/codiconsUtil.js';\nimport { ThemeIcon } from '../../../base/common/themables.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { isString } from '../../../base/common/types.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { localize } from '../../../nls.js';\nimport { Extensions as Extensions$1 } from '../../jsonschemas/common/jsonContributionRegistry.js';\nimport { Registry } from '../../registry/common/platform.js';\nconst Extensions = {\n    IconContribution: 'base.contributions.icons'\n};\nvar IconFontDefinition;\n( ((function(IconFontDefinition) {\n    function toJSONObject(iconFont) {\n        return {\n            weight: iconFont.weight,\n            style: iconFont.style,\n            src: ( (iconFont.src.map(\n                s => ({ format: s.format, location: ( (s.location.toString())) })\n            )))\n        };\n    }\n    IconFontDefinition.toJSONObject = toJSONObject;\n    function fromJSONObject(json) {\n        const stringOrUndef = (s) => isString(s) ? s : undefined;\n        if (json && Array.isArray(json.src) && json.src.every((s) => isString(s.format) && isString(s.location))) {\n            return {\n                weight: stringOrUndef(json.weight),\n                style: stringOrUndef(json.style),\n                src: ( (json.src.map(\n                    (s) => ({ format: s.format, location: ( (URI.parse(s.location))) })\n                )))\n            };\n        }\n        return undefined;\n    }\n    IconFontDefinition.fromJSONObject = fromJSONObject;\n})(IconFontDefinition || (IconFontDefinition = {}))));\nclass IconRegistry {\n    constructor() {\n        this._onDidChange = ( (new Emitter()));\n        this.onDidChange = this._onDidChange.event;\n        this.iconSchema = {\n            definitions: {\n                icons: {\n                    type: 'object',\n                    properties: {\n                        fontId: { type: 'string', description: ( localize(\n                            4149,\n                            'The id of the font to use. If not set, the font that is defined first is used.'\n                        )) },\n                        fontCharacter: { type: 'string', description: ( localize(4150, 'The font character associated with the icon definition.')) }\n                    },\n                    additionalProperties: false,\n                    defaultSnippets: [{ body: { fontCharacter: '\\\\\\\\e030' } }]\n                }\n            },\n            type: 'object',\n            properties: {}\n        };\n        this.iconReferenceSchema = { type: 'string', pattern: `^${ThemeIcon.iconNameExpression}$`, enum: [], enumDescriptions: [] };\n        this.iconsById = {};\n        this.iconFontsById = {};\n    }\n    registerIcon(id, defaults, description, deprecationMessage) {\n        const existing = this.iconsById[id];\n        if (existing) {\n            if (description && !existing.description) {\n                existing.description = description;\n                this.iconSchema.properties[id].markdownDescription = `${description} $(${id})`;\n                const enumIndex = this.iconReferenceSchema.enum.indexOf(id);\n                if (enumIndex !== -1) {\n                    this.iconReferenceSchema.enumDescriptions[enumIndex] = description;\n                }\n                this._onDidChange.fire();\n            }\n            return existing;\n        }\n        const iconContribution = { id, description, defaults, deprecationMessage };\n        this.iconsById[id] = iconContribution;\n        const propertySchema = { $ref: '#/definitions/icons' };\n        if (deprecationMessage) {\n            propertySchema.deprecationMessage = deprecationMessage;\n        }\n        if (description) {\n            propertySchema.markdownDescription = `${description}: $(${id})`;\n        }\n        this.iconSchema.properties[id] = propertySchema;\n        this.iconReferenceSchema.enum.push(id);\n        this.iconReferenceSchema.enumDescriptions.push(description || '');\n        this._onDidChange.fire();\n        return { id };\n    }\n    deregisterIcon(id) {\n        delete this.iconsById[id];\n        delete this.iconSchema.properties[id];\n        const index = this.iconReferenceSchema.enum.indexOf(id);\n        if (index !== -1) {\n            this.iconReferenceSchema.enum.splice(index, 1);\n            this.iconReferenceSchema.enumDescriptions.splice(index, 1);\n        }\n        this._onDidChange.fire();\n    }\n    getIcons() {\n        return (\n             (( (Object.keys(this.iconsById))).map(id => this.iconsById[id]))\n        );\n    }\n    getIcon(id) {\n        return this.iconsById[id];\n    }\n    getIconSchema() {\n        return this.iconSchema;\n    }\n    getIconReferenceSchema() {\n        return this.iconReferenceSchema;\n    }\n    registerIconFont(id, definition) {\n        const existing = this.iconFontsById[id];\n        if (existing) {\n            return existing;\n        }\n        this.iconFontsById[id] = definition;\n        this._onDidChange.fire();\n        return definition;\n    }\n    deregisterIconFont(id) {\n        delete this.iconFontsById[id];\n    }\n    getIconFont(id) {\n        return this.iconFontsById[id];\n    }\n    toString() {\n        const sorter = (i1, i2) => {\n            return i1.id.localeCompare(i2.id);\n        };\n        const classNames = (i) => {\n            while (ThemeIcon.isThemeIcon(i.defaults)) {\n                i = this.iconsById[i.defaults.id];\n            }\n            return `codicon codicon-${i ? i.id : ''}`;\n        };\n        const reference = [];\n        reference.push(`| preview     | identifier                        | default codicon ID                | description`);\n        reference.push(`| ----------- | --------------------------------- | --------------------------------- | --------------------------------- |`);\n        const contributions = ( (( (Object.keys(this.iconsById))).map(key => this.iconsById[key])));\n        for (const i of contributions.filter(i => !!i.description).sort(sorter)) {\n            reference.push(`|<i class=\"${classNames(i)}\"></i>|${i.id}|${ThemeIcon.isThemeIcon(i.defaults) ? i.defaults.id : i.id}|${i.description || ''}|`);\n        }\n        reference.push(`| preview     | identifier                        `);\n        reference.push(`| ----------- | --------------------------------- |`);\n        for (const i of contributions.filter(i => !ThemeIcon.isThemeIcon(i.defaults)).sort(sorter)) {\n            reference.push(`|<i class=\"${classNames(i)}\"></i>|${i.id}|`);\n        }\n        return reference.join('\\n');\n    }\n}\nconst iconRegistry = ( (new IconRegistry()));\nRegistry.add(Extensions.IconContribution, iconRegistry);\nfunction registerIcon(id, defaults, description, deprecationMessage) {\n    return iconRegistry.registerIcon(id, defaults, description, deprecationMessage);\n}\nfunction getIconRegistry() {\n    return iconRegistry;\n}\nfunction initialize() {\n    const codiconFontCharacters = getCodiconFontCharacters();\n    for (const icon in codiconFontCharacters) {\n        const fontCharacter = '\\\\' + ( (codiconFontCharacters[icon].toString(16)));\n        iconRegistry.registerIcon(icon, { fontCharacter });\n    }\n}\ninitialize();\nconst iconsSchemaId = 'vscode://schemas/icons';\nconst schemaRegistry = ( Registry.as(Extensions$1.JSONContribution));\nschemaRegistry.registerSchema(iconsSchemaId, iconRegistry.getIconSchema());\nconst delayer = ( (new RunOnceScheduler(() => schemaRegistry.notifySchemaChanged(iconsSchemaId), 200)));\niconRegistry.onDidChange(() => {\n    if (!delayer.isScheduled()) {\n        delayer.schedule();\n    }\n});\nconst widgetClose = registerIcon('widget-close', Codicon.close, ( localize(4151, 'Icon for the close action in widgets.')));\nconst gotoPreviousLocation = registerIcon('goto-previous-location', Codicon.arrowUp, ( localize(4152, 'Icon for goto previous editor location.')));\nconst gotoNextLocation = registerIcon('goto-next-location', Codicon.arrowDown, ( localize(4153, 'Icon for goto next editor location.')));\nconst syncing = ThemeIcon.modify(Codicon.sync, 'spin');\nconst spinningLoading = ThemeIcon.modify(Codicon.loading, 'spin');\nexport { Extensions, IconFontDefinition, getIconRegistry, gotoNextLocation, gotoPreviousLocation, iconsSchemaId, registerIcon, spinningLoading, syncing, widgetClose };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport '../../../base/common/path.js';\nimport '../../../base/common/platform.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.service.js';\nimport { ILogService } from '../../log/common/log.service.js';\nvar TunnelProtocol;\n( (function(TunnelProtocol) {\n    TunnelProtocol[\"Http\"] = \"http\";\n    TunnelProtocol[\"Https\"] = \"https\";\n})(TunnelProtocol || (TunnelProtocol = {})));\nvar TunnelPrivacyId;\n( (function(TunnelPrivacyId) {\n    TunnelPrivacyId[\"ConstantPrivate\"] = \"constantPrivate\";\n    TunnelPrivacyId[\"Private\"] = \"private\";\n    TunnelPrivacyId[\"Public\"] = \"public\";\n})(TunnelPrivacyId || (TunnelPrivacyId = {})));\nfunction isTunnelProvider(addressOrTunnelProvider) {\n    return !!addressOrTunnelProvider.forwardPort;\n}\nvar ProvidedOnAutoForward;\n( (function(ProvidedOnAutoForward) {\n    ProvidedOnAutoForward[ProvidedOnAutoForward[\"Notify\"] = 1] = \"Notify\";\n    ProvidedOnAutoForward[ProvidedOnAutoForward[\"OpenBrowser\"] = 2] = \"OpenBrowser\";\n    ProvidedOnAutoForward[ProvidedOnAutoForward[\"OpenPreview\"] = 3] = \"OpenPreview\";\n    ProvidedOnAutoForward[ProvidedOnAutoForward[\"Silent\"] = 4] = \"Silent\";\n    ProvidedOnAutoForward[ProvidedOnAutoForward[\"Ignore\"] = 5] = \"Ignore\";\n    ProvidedOnAutoForward[ProvidedOnAutoForward[\"OpenBrowserOnce\"] = 6] = \"OpenBrowserOnce\";\n})(ProvidedOnAutoForward || (ProvidedOnAutoForward = {})));\nfunction extractLocalHostUriMetaDataForPortMapping(uri) {\n    if (uri.scheme !== 'http' && uri.scheme !== 'https') {\n        return undefined;\n    }\n    const localhostMatch = /^(localhost|127\\.0\\.0\\.1|0\\.0\\.0\\.0):(\\d+)$/.exec(uri.authority);\n    if (!localhostMatch) {\n        return undefined;\n    }\n    return {\n        address: localhostMatch[1],\n        port: +localhostMatch[2],\n    };\n}\nconst LOCALHOST_ADDRESSES = ['localhost', '127.0.0.1', '0:0:0:0:0:0:0:1', '::1'];\nfunction isLocalhost(host) {\n    return LOCALHOST_ADDRESSES.indexOf(host) >= 0;\n}\nconst ALL_INTERFACES_ADDRESSES = ['0.0.0.0', '0:0:0:0:0:0:0:0', '::'];\nfunction isAllInterfaces(host) {\n    return ALL_INTERFACES_ADDRESSES.indexOf(host) >= 0;\n}\nclass DisposableTunnel {\n    constructor(remoteAddress, localAddress, _dispose) {\n        this.remoteAddress = remoteAddress;\n        this.localAddress = localAddress;\n        this._dispose = _dispose;\n        this._onDispose = ( new Emitter());\n        this.onDidDispose = this._onDispose.event;\n    }\n    dispose() {\n        this._onDispose.fire();\n        return this._dispose();\n    }\n}\nlet AbstractTunnelService = class AbstractTunnelService extends Disposable {\n    constructor(logService, configurationService) {\n        super();\n        this.logService = logService;\n        this.configurationService = configurationService;\n        this._onTunnelOpened = ( new Emitter());\n        this.onTunnelOpened = this._onTunnelOpened.event;\n        this._onTunnelClosed = ( new Emitter());\n        this.onTunnelClosed = this._onTunnelClosed.event;\n        this._onAddedTunnelProvider = ( new Emitter());\n        this.onAddedTunnelProvider = this._onAddedTunnelProvider.event;\n        this._tunnels = ( new Map());\n        this._canElevate = false;\n        this._canChangeProtocol = true;\n        this._privacyOptions = [];\n        this._factoryInProgress = ( new Set());\n    }\n    get hasTunnelProvider() {\n        return !!this._tunnelProvider;\n    }\n    get defaultTunnelHost() {\n        const settingValue = this.configurationService.getValue('remote.localPortHost');\n        return (!settingValue || settingValue === 'localhost') ? '127.0.0.1' : '0.0.0.0';\n    }\n    setTunnelProvider(provider) {\n        this._tunnelProvider = provider;\n        if (!provider) {\n            this._canElevate = false;\n            this._privacyOptions = [];\n            this._onAddedTunnelProvider.fire();\n            return {\n                dispose: () => { }\n            };\n        }\n        this._onAddedTunnelProvider.fire();\n        return {\n            dispose: () => {\n                this._tunnelProvider = undefined;\n                this._canElevate = false;\n                this._privacyOptions = [];\n            }\n        };\n    }\n    setTunnelFeatures(features) {\n        this._canElevate = features.elevation;\n        this._privacyOptions = features.privacyOptions;\n        this._canChangeProtocol = features.protocol;\n    }\n    get canChangeProtocol() {\n        return this._canChangeProtocol;\n    }\n    get canElevate() {\n        return this._canElevate;\n    }\n    get canChangePrivacy() {\n        return this._privacyOptions.length > 0;\n    }\n    get privacyOptions() {\n        return this._privacyOptions;\n    }\n    get tunnels() {\n        return this.getTunnels();\n    }\n    async getTunnels() {\n        const tunnels = [];\n        const tunnelArray = Array.from(( this._tunnels.values()));\n        for (const portMap of tunnelArray) {\n            const portArray = Array.from(( portMap.values()));\n            for (const x of portArray) {\n                const tunnelValue = await x.value;\n                if (tunnelValue && (typeof tunnelValue !== 'string')) {\n                    tunnels.push(tunnelValue);\n                }\n            }\n        }\n        return tunnels;\n    }\n    async dispose() {\n        super.dispose();\n        for (const portMap of ( this._tunnels.values())) {\n            for (const { value } of ( portMap.values())) {\n                await value.then(tunnel => typeof tunnel !== 'string' ? tunnel?.dispose() : undefined);\n            }\n            portMap.clear();\n        }\n        this._tunnels.clear();\n    }\n    setEnvironmentTunnel(remoteHost, remotePort, localAddress, privacy, protocol) {\n        this.addTunnelToMap(remoteHost, remotePort, Promise.resolve({\n            tunnelRemoteHost: remoteHost,\n            tunnelRemotePort: remotePort,\n            localAddress,\n            privacy,\n            protocol,\n            dispose: () => Promise.resolve()\n        }));\n    }\n    async getExistingTunnel(remoteHost, remotePort) {\n        if (isAllInterfaces(remoteHost) || isLocalhost(remoteHost)) {\n            remoteHost = LOCALHOST_ADDRESSES[0];\n        }\n        const existing = this.getTunnelFromMap(remoteHost, remotePort);\n        if (existing) {\n            ++existing.refcount;\n            return existing.value;\n        }\n        return undefined;\n    }\n    openTunnel(addressProvider, remoteHost, remotePort, localHost, localPort, elevateIfNeeded = false, privacy, protocol) {\n        this.logService.trace(`ForwardedPorts: (TunnelService) openTunnel request for ${remoteHost}:${remotePort} on local port ${localPort}.`);\n        const addressOrTunnelProvider = this._tunnelProvider ?? addressProvider;\n        if (!addressOrTunnelProvider) {\n            return undefined;\n        }\n        if (!remoteHost) {\n            remoteHost = 'localhost';\n        }\n        if (!localHost) {\n            localHost = this.defaultTunnelHost;\n        }\n        if (this._tunnelProvider && ( this._factoryInProgress.has(remotePort))) {\n            this.logService.debug(`ForwardedPorts: (TunnelService) Another call to create a tunnel with the same address has occurred before the last one completed. This call will be ignored.`);\n            return;\n        }\n        const resolvedTunnel = this.retainOrCreateTunnel(addressOrTunnelProvider, remoteHost, remotePort, localHost, localPort, elevateIfNeeded, privacy, protocol);\n        if (!resolvedTunnel) {\n            this.logService.trace(`ForwardedPorts: (TunnelService) Tunnel was not created.`);\n            return resolvedTunnel;\n        }\n        return resolvedTunnel.then(tunnel => {\n            if (!tunnel) {\n                this.logService.trace('ForwardedPorts: (TunnelService) New tunnel is undefined.');\n                this.removeEmptyOrErrorTunnelFromMap(remoteHost, remotePort);\n                return undefined;\n            }\n            else if (typeof tunnel === 'string') {\n                this.logService.trace('ForwardedPorts: (TunnelService) The tunnel provider returned an error when creating the tunnel.');\n                this.removeEmptyOrErrorTunnelFromMap(remoteHost, remotePort);\n                return tunnel;\n            }\n            this.logService.trace('ForwardedPorts: (TunnelService) New tunnel established.');\n            const newTunnel = this.makeTunnel(tunnel);\n            if (tunnel.tunnelRemoteHost !== remoteHost || tunnel.tunnelRemotePort !== remotePort) {\n                this.logService.warn('ForwardedPorts: (TunnelService) Created tunnel does not match requirements of requested tunnel. Host or port mismatch.');\n            }\n            if (privacy && tunnel.privacy !== privacy) {\n                this.logService.warn('ForwardedPorts: (TunnelService) Created tunnel does not match requirements of requested tunnel. Privacy mismatch.');\n            }\n            this._onTunnelOpened.fire(newTunnel);\n            return newTunnel;\n        });\n    }\n    makeTunnel(tunnel) {\n        return {\n            tunnelRemotePort: tunnel.tunnelRemotePort,\n            tunnelRemoteHost: tunnel.tunnelRemoteHost,\n            tunnelLocalPort: tunnel.tunnelLocalPort,\n            localAddress: tunnel.localAddress,\n            privacy: tunnel.privacy,\n            protocol: tunnel.protocol,\n            dispose: async () => {\n                this.logService.trace(`ForwardedPorts: (TunnelService) dispose request for ${tunnel.tunnelRemoteHost}:${tunnel.tunnelRemotePort} `);\n                const existingHost = this._tunnels.get(tunnel.tunnelRemoteHost);\n                if (existingHost) {\n                    const existing = existingHost.get(tunnel.tunnelRemotePort);\n                    if (existing) {\n                        existing.refcount--;\n                        await this.tryDisposeTunnel(tunnel.tunnelRemoteHost, tunnel.tunnelRemotePort, existing);\n                    }\n                }\n            }\n        };\n    }\n    async tryDisposeTunnel(remoteHost, remotePort, tunnel) {\n        if (tunnel.refcount <= 0) {\n            this.logService.trace(`ForwardedPorts: (TunnelService) Tunnel is being disposed ${remoteHost}:${remotePort}.`);\n            const disposePromise = tunnel.value.then(async (tunnel) => {\n                if (tunnel && (typeof tunnel !== 'string')) {\n                    await tunnel.dispose(true);\n                    this._onTunnelClosed.fire({ host: tunnel.tunnelRemoteHost, port: tunnel.tunnelRemotePort });\n                }\n            });\n            if (( this._tunnels.has(remoteHost))) {\n                this._tunnels.get(remoteHost).delete(remotePort);\n            }\n            return disposePromise;\n        }\n    }\n    async closeTunnel(remoteHost, remotePort) {\n        this.logService.trace(`ForwardedPorts: (TunnelService) close request for ${remoteHost}:${remotePort} `);\n        const portMap = this._tunnels.get(remoteHost);\n        if (portMap && ( portMap.has(remotePort))) {\n            const value = portMap.get(remotePort);\n            value.refcount = 0;\n            await this.tryDisposeTunnel(remoteHost, remotePort, value);\n        }\n    }\n    addTunnelToMap(remoteHost, remotePort, tunnel) {\n        if (!( this._tunnels.has(remoteHost))) {\n            this._tunnels.set(remoteHost, ( new Map()));\n        }\n        this._tunnels.get(remoteHost).set(remotePort, { refcount: 1, value: tunnel });\n    }\n    async removeEmptyOrErrorTunnelFromMap(remoteHost, remotePort) {\n        const hostMap = this._tunnels.get(remoteHost);\n        if (hostMap) {\n            const tunnel = hostMap.get(remotePort);\n            const tunnelResult = tunnel ? await tunnel.value : undefined;\n            if (!tunnelResult || (typeof tunnelResult === 'string')) {\n                hostMap.delete(remotePort);\n            }\n            if (hostMap.size === 0) {\n                this._tunnels.delete(remoteHost);\n            }\n        }\n    }\n    getTunnelFromMap(remoteHost, remotePort) {\n        const hosts = [remoteHost];\n        if (isLocalhost(remoteHost)) {\n            hosts.push(...LOCALHOST_ADDRESSES);\n            hosts.push(...ALL_INTERFACES_ADDRESSES);\n        }\n        else if (isAllInterfaces(remoteHost)) {\n            hosts.push(...ALL_INTERFACES_ADDRESSES);\n        }\n        const existingPortMaps = ( hosts.map(host => this._tunnels.get(host)));\n        for (const map of existingPortMaps) {\n            const existingTunnel = map?.get(remotePort);\n            if (existingTunnel) {\n                return existingTunnel;\n            }\n        }\n        return undefined;\n    }\n    canTunnel(uri) {\n        return !!extractLocalHostUriMetaDataForPortMapping(uri);\n    }\n    createWithProvider(tunnelProvider, remoteHost, remotePort, localPort, elevateIfNeeded, privacy, protocol) {\n        this.logService.trace(`ForwardedPorts: (TunnelService) Creating tunnel with provider ${remoteHost}:${remotePort} on local port ${localPort}.`);\n        const key = remotePort;\n        this._factoryInProgress.add(key);\n        const preferredLocalPort = localPort === undefined ? remotePort : localPort;\n        const creationInfo = { elevationRequired: elevateIfNeeded ? this.isPortPrivileged(preferredLocalPort) : false };\n        const tunnelOptions = { remoteAddress: { host: remoteHost, port: remotePort }, localAddressPort: localPort, privacy, public: privacy ? (privacy !== TunnelPrivacyId.Private) : undefined, protocol };\n        const tunnel = tunnelProvider.forwardPort(tunnelOptions, creationInfo);\n        if (tunnel) {\n            this.addTunnelToMap(remoteHost, remotePort, tunnel);\n            tunnel.finally(() => {\n                this.logService.trace('ForwardedPorts: (TunnelService) Tunnel created by provider.');\n                this._factoryInProgress.delete(key);\n            });\n        }\n        else {\n            this._factoryInProgress.delete(key);\n        }\n        return tunnel;\n    }\n};\nAbstractTunnelService = ( __decorate([\n    ( __param(0, ILogService)),\n    ( __param(1, IConfigurationService))\n], AbstractTunnelService));\nexport { ALL_INTERFACES_ADDRESSES, AbstractTunnelService, DisposableTunnel, LOCALHOST_ADDRESSES, ProvidedOnAutoForward, TunnelPrivacyId, TunnelProtocol, extractLocalHostUriMetaDataForPortMapping, isAllInterfaces, isLocalhost, isTunnelProvider };\n","import { createDecorator } from '../../instantiation/common/instantiation.js';\nconst IUriIdentityService = ( createDecorator('IUriIdentityService'));\nexport { IUriIdentityService };\n","import { createDecorator } from '../../instantiation/common/instantiation.js';\nconst IUserDataProfilesService = ( createDecorator('IUserDataProfilesService'));\nexport { IUserDataProfilesService };\n","var EditSessionIdentityMatch;\n( (function(EditSessionIdentityMatch) {\n    EditSessionIdentityMatch[EditSessionIdentityMatch[\"Complete\"] = 100] = \"Complete\";\n    EditSessionIdentityMatch[EditSessionIdentityMatch[\"Partial\"] = 50] = \"Partial\";\n    EditSessionIdentityMatch[EditSessionIdentityMatch[\"None\"] = 0] = \"None\";\n})(EditSessionIdentityMatch || (EditSessionIdentityMatch = {})));\nexport { EditSessionIdentityMatch };\n","import { localize } from '../../../nls.js';\nimport { basename, extname } from '../../../base/common/path.js';\nimport { TernarySearchTree } from '../../../base/common/ternarySearchTree.js';\nimport { joinPath, extname as extname$1, basenameOrAuthority, extUriBiasedIgnorePathCase } from '../../../base/common/resources.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { Schemas } from '../../../base/common/network.js';\nfunction isSingleFolderWorkspaceIdentifier(obj) {\n    const singleFolderIdentifier = obj;\n    return typeof singleFolderIdentifier?.id === 'string' && URI.isUri(singleFolderIdentifier.uri);\n}\nfunction isEmptyWorkspaceIdentifier(obj) {\n    const emptyWorkspaceIdentifier = obj;\n    return typeof emptyWorkspaceIdentifier?.id === 'string'\n        && !isSingleFolderWorkspaceIdentifier(obj)\n        && !isWorkspaceIdentifier(obj);\n}\nconst UNKNOWN_EMPTY_WINDOW_WORKSPACE = { id: 'empty-window' };\nfunction toWorkspaceIdentifier(arg0, isExtensionDevelopment) {\n    if (typeof arg0 === 'string' || typeof arg0 === 'undefined') {\n        if (typeof arg0 === 'string') {\n            return {\n                id: basename(arg0)\n            };\n        }\n        return UNKNOWN_EMPTY_WINDOW_WORKSPACE;\n    }\n    const workspace = arg0;\n    if (workspace.configuration) {\n        return {\n            id: workspace.id,\n            configPath: workspace.configuration\n        };\n    }\n    if (workspace.folders.length === 1) {\n        return {\n            id: workspace.id,\n            uri: workspace.folders[0].uri\n        };\n    }\n    return {\n        id: workspace.id\n    };\n}\nfunction isWorkspaceIdentifier(obj) {\n    const workspaceIdentifier = obj;\n    return typeof workspaceIdentifier?.id === 'string' && URI.isUri(workspaceIdentifier.configPath);\n}\nfunction isWorkspace(thing) {\n    const candidate = thing;\n    return !!(candidate && typeof candidate === 'object'\n        && typeof candidate.id === 'string'\n        && Array.isArray(candidate.folders));\n}\nfunction isWorkspaceFolder(thing) {\n    const candidate = thing;\n    return !!(candidate && typeof candidate === 'object'\n        && URI.isUri(candidate.uri)\n        && typeof candidate.name === 'string'\n        && typeof candidate.toResource === 'function');\n}\nlet Workspace$1 = class Workspace {\n    constructor(_id, folders, _transient, _configuration, _ignorePathCasing) {\n        this._id = _id;\n        this._transient = _transient;\n        this._configuration = _configuration;\n        this._ignorePathCasing = _ignorePathCasing;\n        this._foldersMap = TernarySearchTree.forUris(this._ignorePathCasing, () => true);\n        this.folders = folders;\n    }\n    update(workspace) {\n        this._id = workspace.id;\n        this._configuration = workspace.configuration;\n        this._transient = workspace.transient;\n        this._ignorePathCasing = workspace._ignorePathCasing;\n        this.folders = workspace.folders;\n    }\n    get folders() {\n        return this._folders;\n    }\n    set folders(folders) {\n        this._folders = folders;\n        this.updateFoldersMap();\n    }\n    get id() {\n        return this._id;\n    }\n    get transient() {\n        return this._transient;\n    }\n    get configuration() {\n        return this._configuration;\n    }\n    set configuration(configuration) {\n        this._configuration = configuration;\n    }\n    getFolder(resource) {\n        if (!resource) {\n            return null;\n        }\n        return this._foldersMap.findSubstr(resource) || null;\n    }\n    updateFoldersMap() {\n        this._foldersMap = TernarySearchTree.forUris(this._ignorePathCasing, () => true);\n        for (const folder of this.folders) {\n            this._foldersMap.set(folder.uri, folder);\n        }\n    }\n    toJSON() {\n        return { id: this.id, folders: this.folders, transient: this.transient, configuration: this.configuration };\n    }\n};\nclass WorkspaceFolder {\n    constructor(data,\n    raw) {\n        this.raw = raw;\n        this.uri = data.uri;\n        this.index = data.index;\n        this.name = data.name;\n    }\n    toResource(relativePath) {\n        return joinPath(this.uri, relativePath);\n    }\n    toJSON() {\n        return { uri: this.uri, name: this.name, index: this.index };\n    }\n}\nfunction toWorkspaceFolder(resource) {\n    return (\n         (new WorkspaceFolder(\n            { uri: resource, index: 0, name: basenameOrAuthority(resource) },\n            { uri: ( (resource.toString())) }\n        ))\n    );\n}\nconst WORKSPACE_EXTENSION = 'code-workspace';\nconst WORKSPACE_SUFFIX = `.${WORKSPACE_EXTENSION}`;\nconst WORKSPACE_FILTER = [{ name: ( localize(714, \"Code Workspace\")), extensions: [WORKSPACE_EXTENSION] }];\nconst UNTITLED_WORKSPACE_NAME = 'workspace.json';\nfunction isUntitledWorkspace(path, environmentService) {\n    return extUriBiasedIgnorePathCase.isEqualOrParent(path, environmentService.untitledWorkspacesHome);\n}\nfunction isTemporaryWorkspace(arg1) {\n    let path;\n    if (URI.isUri(arg1)) {\n        path = arg1;\n    }\n    else {\n        path = arg1.configuration;\n    }\n    return path?.scheme === Schemas.tmp;\n}\nconst STANDALONE_EDITOR_WORKSPACE_ID = '4064f6ec-cb38-4ad0-af64-ee6467e63c82';\nfunction isStandaloneEditorWorkspace(workspace) {\n    return workspace.id === STANDALONE_EDITOR_WORKSPACE_ID;\n}\nfunction isSavedWorkspace(path, environmentService) {\n    return !isUntitledWorkspace(path, environmentService) && !isTemporaryWorkspace(path);\n}\nfunction hasWorkspaceFileExtension(path) {\n    const ext = (typeof path === 'string') ? extname(path) : extname$1(path);\n    return ext === WORKSPACE_SUFFIX;\n}\nexport { STANDALONE_EDITOR_WORKSPACE_ID, UNKNOWN_EMPTY_WINDOW_WORKSPACE, UNTITLED_WORKSPACE_NAME, WORKSPACE_EXTENSION, WORKSPACE_FILTER, WORKSPACE_SUFFIX, Workspace$1 as Workspace, WorkspaceFolder, hasWorkspaceFileExtension, isEmptyWorkspaceIdentifier, isSavedWorkspace, isSingleFolderWorkspaceIdentifier, isStandaloneEditorWorkspace, isTemporaryWorkspace, isUntitledWorkspace, isWorkspace, isWorkspaceFolder, isWorkspaceIdentifier, toWorkspaceFolder, toWorkspaceIdentifier };\n","import { createDecorator } from '../../instantiation/common/instantiation.js';\nconst IWorkspaceContextService = ( createDecorator('contextService'));\nexport { IWorkspaceContextService };\n","class Cache {\n    static { this.enableDebugLogging = false; }\n    constructor(id) {\n        this.id = id;\n        this._data = ( new Map());\n        this._idPool = 1;\n    }\n    add(item) {\n        const id = this._idPool++;\n        this._data.set(id, item);\n        this.logDebugInfo();\n        return id;\n    }\n    get(pid, id) {\n        return ( this._data.has(pid)) ? this._data.get(pid)[id] : undefined;\n    }\n    delete(id) {\n        this._data.delete(id);\n        this.logDebugInfo();\n    }\n    logDebugInfo() {\n        if (!Cache.enableDebugLogging) {\n            return;\n        }\n        console.log(`${this.id} cache size - ${this._data.size}`);\n    }\n}\nexport { Cache };\n","import { CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { CancellationError, ReadonlyError, onUnexpectedExternalError } from '../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { combinedDisposable } from '../../../base/common/lifecycle.js';\nimport { matchesScheme, Schemas } from '../../../base/common/network.js';\nimport Severity$1 from '../../../base/common/severity.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { TextEditorCursorStyle } from '../../../editor/common/config/editorOptions.js';\nimport { targetsNotebooks, score } from '../../../editor/common/languageSelector.js';\nimport { IndentAction } from '../../../editor/common/languages/languageConfiguration.js';\nimport { OverviewRulerLane } from '../../../editor/common/model.js';\nimport { ExtensionIdentifierSet } from '../../../platform/extensions/common/extensions.js';\nimport { FileType, FilePermission } from '../../../platform/files/common/files.js';\nimport { LogLevel } from '../../../platform/log/common/log.js';\nimport { ILoggerService, ILogService } from '../../../platform/log/common/log.service.js';\nimport { getRemoteName } from '../../../platform/remote/common/remoteHosts.js';\nimport { TelemetryTrustedValue } from '../../../platform/telemetry/common/telemetryUtils.js';\nimport { EditSessionIdentityMatch } from '../../../platform/workspace/common/editSessions.js';\nimport { ExtHostContext, MainContext, CandidatePortSource } from './extHost.protocol.js';\nimport { ExtHostRelatedInformation } from './extHostAiRelatedInformation.js';\nimport { ExtHostApiCommands } from './extHostApiCommands.js';\nimport { IExtHostApiDeprecationService } from './extHostApiDeprecationService.js';\nimport { IExtHostAuthentication } from './extHostAuthentication.js';\nimport { ExtHostBulkEdits } from './extHostBulkEdits.js';\nimport { ExtHostChatAgents2 } from './extHostChatAgents2.js';\nimport { ExtHostChatVariables } from './extHostChatVariables.js';\nimport { ExtHostClipboard } from './extHostClipboard.js';\nimport { ExtHostEditorInsets } from './extHostCodeInsets.js';\nimport { IExtHostCommands } from './extHostCommands.js';\nimport { createExtHostComments } from './extHostComments.js';\nimport { IExtHostConfiguration } from './extHostConfiguration.js';\nimport { ExtHostCustomEditors } from './extHostCustomEditors.js';\nimport { IExtHostDebugService } from './extHostDebugService.js';\nimport { IExtHostDecorations } from './extHostDecorations.js';\nimport { ExtHostDiagnostics } from './extHostDiagnostics.js';\nimport { ExtHostDialogs } from './extHostDialogs.js';\nimport { ExtHostDocumentContentProvider } from './extHostDocumentContentProviders.js';\nimport { ExtHostDocumentSaveParticipant } from './extHostDocumentSaveParticipant.js';\nimport { ExtHostDocuments } from './extHostDocuments.js';\nimport { IExtHostDocumentsAndEditors } from './extHostDocumentsAndEditors.js';\nimport { IExtHostEditorTabs } from './extHostEditorTabs.js';\nimport { ExtHostEmbeddings } from './extHostEmbedding.js';\nimport { ExtHostAiEmbeddingVector } from './extHostEmbeddingVector.js';\nimport { IExtHostExtensionService, Extension } from './extHostExtensionService.js';\nimport { ExtHostFileSystem } from './extHostFileSystem.js';\nimport { IExtHostConsumerFileSystem } from './extHostFileSystemConsumer.js';\nimport { ExtHostFileSystemEventService } from './extHostFileSystemEventService.js';\nimport { IExtHostFileSystemInfo } from './extHostFileSystemInfo.js';\nimport { IExtHostInitDataService } from './extHostInitDataService.js';\nimport { ExtHostInteractive } from './extHostInteractive.js';\nimport { ExtHostLabelService } from './extHostLabelService.js';\nimport { ExtHostLanguageFeatures } from './extHostLanguageFeatures.js';\nimport { ExtHostLanguageModelTools } from './extHostLanguageModelTools.js';\nimport { IExtHostLanguageModels } from './extHostLanguageModels.js';\nimport { ExtHostLanguages } from './extHostLanguages.js';\nimport { IExtHostLocalizationService } from './extHostLocalizationService.js';\nimport { IExtHostManagedSockets } from './extHostManagedSockets.js';\nimport { ExtHostMessageService } from './extHostMessageService.js';\nimport { ExtHostNotebookController } from './extHostNotebook.js';\nimport { ExtHostNotebookDocumentSaveParticipant } from './extHostNotebookDocumentSaveParticipant.js';\nimport { ExtHostNotebookDocuments } from './extHostNotebookDocuments.js';\nimport { ExtHostNotebookEditors } from './extHostNotebookEditors.js';\nimport { ExtHostNotebookKernels } from './extHostNotebookKernels.js';\nimport { ExtHostNotebookRenderers } from './extHostNotebookRenderers.js';\nimport { IExtHostOutputService } from './extHostOutput.js';\nimport { ExtHostProfileContentHandlers } from './extHostProfileContentHandler.js';\nimport { ExtHostProgress } from './extHostProgress.js';\nimport { ExtHostQuickDiff } from './extHostQuickDiff.js';\nimport { createExtHostQuickOpen } from './extHostQuickOpen.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\nimport { ExtHostSCM } from './extHostSCM.js';\nimport { IExtHostSearch } from './extHostSearch.js';\nimport { IExtHostSecretState } from './extHostSecretState.js';\nimport { ExtHostShare } from './extHostShare.js';\nimport { ExtHostSpeech } from './extHostSpeech.js';\nimport { ExtHostStatusBar } from './extHostStatusBar.js';\nimport { IExtHostStorage } from './extHostStorage.js';\nimport { IExtensionStoragePaths } from './extHostStoragePaths.js';\nimport { IExtHostTask } from './extHostTask.js';\nimport { IExtHostTelemetry, isNewAppInstall, ExtHostTelemetryLogger } from './extHostTelemetry.js';\nimport { IExtHostTerminalService } from './extHostTerminalService.js';\nimport { IExtHostTerminalShellIntegration } from './extHostTerminalShellIntegration.js';\nimport { IExtHostTesting } from './extHostTesting.js';\nimport { ExtHostEditors } from './extHostTextEditors.js';\nimport { ExtHostTheming } from './extHostTheming.js';\nimport { ExtHostTimeline } from './extHostTimeline.js';\nimport { ExtHostTreeViews } from './extHostTreeViews.js';\nimport { IExtHostTunnelService } from './extHostTunnelService.js';\nimport { LanguageSelector } from './extHostTypeConverters.js';\nimport { Breakpoint, TerminalOutputAnchor, ChatResultFeedbackKind, ChatVariableLevel, ChatCompletionItem, CallHierarchyIncomingCall, CallHierarchyItem, CallHierarchyOutgoingCall, CodeAction, CodeActionKind, CodeActionTriggerKind, CodeLens, Color, ColorInformation, ColorPresentation, ColorThemeKind, CommentMode, CommentState, CommentThreadCollapsibleState, CommentThreadState, CommentThreadApplicability, CommentThreadFocus, CompletionItem, CompletionItemKind, CompletionItemTag, CompletionList, CompletionTriggerKind, ConfigurationTarget, CustomExecution, DebugAdapterExecutable, DebugAdapterInlineImplementation, DebugAdapterNamedPipeServer, DebugAdapterServer, DebugConsoleMode, DebugVisualization, DecorationRangeBehavior, Diagnostic, DiagnosticRelatedInformation, DiagnosticSeverity, DiagnosticTag, Disposable, DocumentHighlight, DocumentHighlightKind, MultiDocumentHighlight, DocumentLink, DocumentSymbol, EndOfLine, EnvironmentVariableMutatorType, EvaluatableExpression, InlineValueText, InlineValueVariableLookup, InlineValueEvaluatableExpression, InlineCompletionTriggerKind, ExtensionKind, ExtensionMode, ExternalUriOpenerPriority, FileChangeType, FileDecoration, FileSystemError, FoldingRange, FoldingRangeKind, FunctionBreakpoint, InlineSuggestion, InlineSuggestionList, Hover, VerboseHover, HoverVerbosityAction, Location, MarkdownString, ParameterInformation, PortAutoForwardAction, Position, ProcessExecution, ProgressLocation, QuickInputButtonLocation, QuickInputButtons, Range, RelativePattern, Selection, SelectionRange, SemanticTokens, SemanticTokensBuilder, SemanticTokensEdit, SemanticTokensEdits, SemanticTokensLegend, ShellExecution, ShellQuoting, SignatureHelp, SignatureHelpTriggerKind, SignatureInformation, SnippetString, SourceBreakpoint, StandardTokenType, StatusBarAlignment, SymbolInformation, SymbolKind, SymbolTag, Task, TaskGroup, TaskPanelKind, TaskRevealKind, TaskScope, TerminalLink, TerminalQuickFixCommand, TerminalQuickFixOpener, TerminalLocation, TerminalProfile, TerminalExitReason, TerminalShellExecutionCommandLineConfidence, TextDocumentSaveReason, TextEdit, SnippetTextEdit, TextEditorLineNumbersStyle, TextEditorRevealType, TextEditorSelectionChangeKind, SyntaxTokenType, TextDocumentChangeReason, ThemeColor, ThemeIcon, TreeItem, TreeItemCheckboxState, TreeItemCollapsibleState, TypeHierarchyItem, ViewColumn, WorkspaceEdit, DocumentPasteTriggerKind, DocumentDropEdit, DocumentDropOrPasteEditKind, DocumentPasteEdit, InlayHint, InlayHintLabelPart, InlayHintKind, RemoteAuthorityResolverError, ResolvedAuthority, ManagedResolvedAuthority, SourceControlInputBoxValidationType, ExtensionRuntime, TimelineItem, NotebookRange, NotebookCellKind, NotebookCellExecutionState, NotebookCellData, NotebookData, NotebookRendererScript, NotebookCellStatusBarAlignment, NotebookEditorRevealType, NotebookCellOutput, NotebookCellOutputItem, NotebookCellStatusBarItem, NotebookControllerAffinity, NotebookControllerAffinity2, NotebookEdit, NotebookKernelSourceAction, NotebookVariablesRequestKind, PortAttributes, LinkedEditingRanges, TestResultState, TestRunRequest, TestMessage, TestMessageStackFrame, TestTag, TestRunProfileKind, DataTransfer, DataTransferItem, TestCoverageCount, FileCoverage, StatementCoverage, BranchCoverage, DeclarationCoverage, WorkspaceTrustState, LanguageStatusSeverity, QuickPickItemKind, InputBoxValidationSeverity, TextTabInput, TextDiffTabInput, TextMergeTabInput, CustomEditorTabInput, NotebookEditorTabInput, NotebookDiffEditorTabInput, WebviewEditorTabInput, TerminalEditorTabInput, InteractiveWindowInput, ChatEditorTabInput, TextMultiDiffTabInput, InteractiveSessionVoteDirection, ChatCopyKind, InteractiveEditorResponseFeedbackKind, DebugStackFrame, DebugThread, RelatedInformationType, SpeechToTextStatus, TextToSpeechStatus, PartialAcceptTriggerKind, KeywordRecognitionStatus, ChatResponseMarkdownPart, ChatResponseFileTreePart, ChatResponseAnchorPart, ChatResponseProgressPart, ChatResponseProgressPart2, ChatResponseReferencePart, ChatResponseCodeCitationPart, ChatResponseCodeblockUriPart, ChatResponseWarningPart, ChatResponseTextEditPart, ChatResponseMarkdownWithVulnerabilitiesPart, ChatResponseCommandButtonPart, ChatResponseDetectedParticipantPart, ChatResponseConfirmationPart, ChatResponseMovePart, ChatResponseReferencePartStatusKind, ChatRequestTurn, ChatResponseTurn, ChatLocation, ChatRequestEditorData, ChatRequestNotebookData, LanguageModelChatMessageRole, LanguageModelChatMessage, LanguageModelToolResultPart, LanguageModelTextPart, LanguageModelToolCallPart, LanguageModelError, NewSymbolName, NewSymbolNameTag, NewSymbolNameTriggerKind, InlineEdit, InlineEditTriggerKind } from './extHostTypes.js';\nimport { ExtHostUriOpeners } from './extHostUriOpener.js';\nimport { IURITransformerService } from './extHostUriTransformerService.js';\nimport { ExtHostUrls } from './extHostUrls.js';\nimport { ExtHostWebviews } from './extHostWebview.js';\nimport { ExtHostWebviewPanels } from './extHostWebviewPanels.js';\nimport { ExtHostWebviewViews } from './extHostWebviewView.js';\nimport { IExtHostWindow } from './extHostWindow.js';\nimport { IExtHostWorkspace } from './extHostWorkspace.js';\nimport { DebugConfigurationProviderTriggerKind } from '../../contrib/debug/common/debug.js';\nimport { UIKind } from '../../services/extensions/common/extensionHostProtocol.js';\nimport { checkProposedApiEnabled, isProposedApiEnabled } from '../../services/extensions/common/extensions.js';\nimport { TextSearchCompleteMessageType, ExcludeSettingOptions, TextSearchContextNew, TextSearchMatchNew } from '../../services/search/common/searchExtTypes.js';\nimport { ExtHostCodeMapper } from './extHostCodeMapper.js';\nfunction createApiFactoryAndRegisterActors(accessor) {\n    const initData = accessor.get(IExtHostInitDataService);\n    const extHostFileSystemInfo = accessor.get(IExtHostFileSystemInfo);\n    const extHostConsumerFileSystem = accessor.get(IExtHostConsumerFileSystem);\n    const extensionService = accessor.get(IExtHostExtensionService);\n    const extHostWorkspace = accessor.get(IExtHostWorkspace);\n    const extHostTelemetry = accessor.get(IExtHostTelemetry);\n    const extHostConfiguration = accessor.get(IExtHostConfiguration);\n    const uriTransformer = accessor.get(IURITransformerService);\n    const rpcProtocol = accessor.get(IExtHostRpcService);\n    const extHostStorage = accessor.get(IExtHostStorage);\n    const extensionStoragePaths = accessor.get(IExtensionStoragePaths);\n    const extHostLoggerService = accessor.get(ILoggerService);\n    const extHostLogService = accessor.get(ILogService);\n    const extHostTunnelService = accessor.get(IExtHostTunnelService);\n    const extHostApiDeprecation = accessor.get(IExtHostApiDeprecationService);\n    const extHostWindow = accessor.get(IExtHostWindow);\n    const extHostSecretState = accessor.get(IExtHostSecretState);\n    const extHostEditorTabs = accessor.get(IExtHostEditorTabs);\n    const extHostManagedSockets = accessor.get(IExtHostManagedSockets);\n    const extHostAuthentication = accessor.get(IExtHostAuthentication);\n    const extHostLanguageModels = accessor.get(IExtHostLanguageModels);\n    rpcProtocol.set(ExtHostContext.ExtHostFileSystemInfo, extHostFileSystemInfo);\n    rpcProtocol.set(ExtHostContext.ExtHostLogLevelServiceShape, extHostLoggerService);\n    rpcProtocol.set(ExtHostContext.ExtHostWorkspace, extHostWorkspace);\n    rpcProtocol.set(ExtHostContext.ExtHostConfiguration, extHostConfiguration);\n    rpcProtocol.set(ExtHostContext.ExtHostExtensionService, extensionService);\n    rpcProtocol.set(ExtHostContext.ExtHostStorage, extHostStorage);\n    rpcProtocol.set(ExtHostContext.ExtHostTunnelService, extHostTunnelService);\n    rpcProtocol.set(ExtHostContext.ExtHostWindow, extHostWindow);\n    rpcProtocol.set(ExtHostContext.ExtHostSecretState, extHostSecretState);\n    rpcProtocol.set(ExtHostContext.ExtHostTelemetry, extHostTelemetry);\n    rpcProtocol.set(ExtHostContext.ExtHostEditorTabs, extHostEditorTabs);\n    rpcProtocol.set(ExtHostContext.ExtHostManagedSockets, extHostManagedSockets);\n    rpcProtocol.set(ExtHostContext.ExtHostAuthentication, extHostAuthentication);\n    rpcProtocol.set(ExtHostContext.ExtHostChatProvider, extHostLanguageModels);\n    const extHostDecorations = rpcProtocol.set(ExtHostContext.ExtHostDecorations, accessor.get(IExtHostDecorations));\n    const extHostDocumentsAndEditors = rpcProtocol.set(ExtHostContext.ExtHostDocumentsAndEditors, accessor.get(IExtHostDocumentsAndEditors));\n    const extHostCommands = rpcProtocol.set(ExtHostContext.ExtHostCommands, accessor.get(IExtHostCommands));\n    const extHostTerminalService = rpcProtocol.set(ExtHostContext.ExtHostTerminalService, accessor.get(IExtHostTerminalService));\n    const extHostTerminalShellIntegration = rpcProtocol.set(ExtHostContext.ExtHostTerminalShellIntegration, accessor.get(IExtHostTerminalShellIntegration));\n    const extHostDebugService = rpcProtocol.set(ExtHostContext.ExtHostDebugService, accessor.get(IExtHostDebugService));\n    const extHostSearch = rpcProtocol.set(ExtHostContext.ExtHostSearch, accessor.get(IExtHostSearch));\n    const extHostTask = rpcProtocol.set(ExtHostContext.ExtHostTask, accessor.get(IExtHostTask));\n    const extHostOutputService = rpcProtocol.set(ExtHostContext.ExtHostOutputService, accessor.get(IExtHostOutputService));\n    const extHostLocalization = rpcProtocol.set(ExtHostContext.ExtHostLocalization, accessor.get(IExtHostLocalizationService));\n    const extHostUrls = rpcProtocol.set(ExtHostContext.ExtHostUrls, ( new ExtHostUrls(rpcProtocol)));\n    const extHostDocuments = rpcProtocol.set(ExtHostContext.ExtHostDocuments, ( new ExtHostDocuments(rpcProtocol, extHostDocumentsAndEditors)));\n    const extHostDocumentContentProviders = rpcProtocol.set(ExtHostContext.ExtHostDocumentContentProviders, ( new ExtHostDocumentContentProvider(rpcProtocol, extHostDocumentsAndEditors, extHostLogService)));\n    const extHostDocumentSaveParticipant = rpcProtocol.set(ExtHostContext.ExtHostDocumentSaveParticipant, ( new ExtHostDocumentSaveParticipant(extHostLogService, extHostDocuments, ( rpcProtocol.getProxy(MainContext.MainThreadBulkEdits)))));\n    const extHostNotebook = rpcProtocol.set(ExtHostContext.ExtHostNotebook, ( new ExtHostNotebookController(\n        rpcProtocol,\n        extHostCommands,\n        extHostDocumentsAndEditors,\n        extHostDocuments,\n        extHostConsumerFileSystem,\n        extHostSearch,\n        extHostLogService\n    )));\n    const extHostNotebookDocuments = rpcProtocol.set(ExtHostContext.ExtHostNotebookDocuments, ( new ExtHostNotebookDocuments(extHostNotebook)));\n    const extHostNotebookEditors = rpcProtocol.set(ExtHostContext.ExtHostNotebookEditors, ( new ExtHostNotebookEditors(extHostLogService, extHostNotebook)));\n    const extHostNotebookKernels = rpcProtocol.set(ExtHostContext.ExtHostNotebookKernels, ( new ExtHostNotebookKernels(rpcProtocol, initData, extHostNotebook, extHostCommands, extHostLogService)));\n    const extHostNotebookRenderers = rpcProtocol.set(ExtHostContext.ExtHostNotebookRenderers, ( new ExtHostNotebookRenderers(rpcProtocol, extHostNotebook)));\n    const extHostNotebookDocumentSaveParticipant = rpcProtocol.set(ExtHostContext.ExtHostNotebookDocumentSaveParticipant, ( new ExtHostNotebookDocumentSaveParticipant(extHostLogService, extHostNotebook, ( rpcProtocol.getProxy(MainContext.MainThreadBulkEdits)))));\n    const extHostEditors = rpcProtocol.set(ExtHostContext.ExtHostEditors, ( new ExtHostEditors(rpcProtocol, extHostDocumentsAndEditors)));\n    const extHostTreeViews = rpcProtocol.set(ExtHostContext.ExtHostTreeViews, ( new ExtHostTreeViews(( rpcProtocol.getProxy(MainContext.MainThreadTreeViews)), extHostCommands, extHostLogService)));\n    const extHostEditorInsets = rpcProtocol.set(ExtHostContext.ExtHostEditorInsets, ( new ExtHostEditorInsets(( rpcProtocol.getProxy(MainContext.MainThreadEditorInsets)), extHostEditors, initData.remote)));\n    const extHostDiagnostics = rpcProtocol.set(ExtHostContext.ExtHostDiagnostics, ( new ExtHostDiagnostics(\n        rpcProtocol,\n        extHostLogService,\n        extHostFileSystemInfo,\n        extHostDocumentsAndEditors\n    )));\n    const extHostLanguages = rpcProtocol.set(ExtHostContext.ExtHostLanguages, ( new ExtHostLanguages(rpcProtocol, extHostDocuments, extHostCommands.converter, uriTransformer)));\n    const extHostLanguageFeatures = rpcProtocol.set(ExtHostContext.ExtHostLanguageFeatures, ( new ExtHostLanguageFeatures(\n        rpcProtocol,\n        uriTransformer,\n        extHostDocuments,\n        extHostCommands,\n        extHostDiagnostics,\n        extHostLogService,\n        extHostApiDeprecation,\n        extHostTelemetry\n    )));\n    const extHostCodeMapper = rpcProtocol.set(ExtHostContext.ExtHostCodeMapper, ( new ExtHostCodeMapper(rpcProtocol)));\n    const extHostFileSystem = rpcProtocol.set(ExtHostContext.ExtHostFileSystem, ( new ExtHostFileSystem(rpcProtocol, extHostLanguageFeatures)));\n    const extHostFileSystemEvent = rpcProtocol.set(ExtHostContext.ExtHostFileSystemEventService, ( new ExtHostFileSystemEventService(rpcProtocol, extHostLogService, extHostDocumentsAndEditors)));\n    const extHostQuickOpen = rpcProtocol.set(ExtHostContext.ExtHostQuickOpen, createExtHostQuickOpen(rpcProtocol, extHostWorkspace, extHostCommands));\n    const extHostSCM = rpcProtocol.set(ExtHostContext.ExtHostSCM, ( new ExtHostSCM(rpcProtocol, extHostCommands, extHostDocuments, extHostLogService)));\n    const extHostQuickDiff = rpcProtocol.set(ExtHostContext.ExtHostQuickDiff, ( new ExtHostQuickDiff(rpcProtocol, uriTransformer)));\n    const extHostShare = rpcProtocol.set(ExtHostContext.ExtHostShare, ( new ExtHostShare(rpcProtocol, uriTransformer)));\n    const extHostComment = rpcProtocol.set(ExtHostContext.ExtHostComments, createExtHostComments(rpcProtocol, extHostCommands, extHostDocuments));\n    const extHostProgress = rpcProtocol.set(ExtHostContext.ExtHostProgress, ( new ExtHostProgress(( rpcProtocol.getProxy(MainContext.MainThreadProgress)))));\n    const extHostLabelService = rpcProtocol.set(ExtHostContext.ExtHostLabelService, ( new ExtHostLabelService(rpcProtocol)));\n    const extHostTheming = rpcProtocol.set(ExtHostContext.ExtHostTheming, ( new ExtHostTheming(rpcProtocol)));\n    const extHostTimeline = rpcProtocol.set(ExtHostContext.ExtHostTimeline, ( new ExtHostTimeline(rpcProtocol, extHostCommands)));\n    const extHostWebviews = rpcProtocol.set(ExtHostContext.ExtHostWebviews, ( new ExtHostWebviews(\n        rpcProtocol,\n        initData.remote,\n        extHostWorkspace,\n        extHostLogService,\n        extHostApiDeprecation\n    )));\n    const extHostWebviewPanels = rpcProtocol.set(ExtHostContext.ExtHostWebviewPanels, ( new ExtHostWebviewPanels(rpcProtocol, extHostWebviews, extHostWorkspace)));\n    const extHostCustomEditors = rpcProtocol.set(ExtHostContext.ExtHostCustomEditors, ( new ExtHostCustomEditors(\n        rpcProtocol,\n        extHostDocuments,\n        extensionStoragePaths,\n        extHostWebviews,\n        extHostWebviewPanels\n    )));\n    const extHostWebviewViews = rpcProtocol.set(ExtHostContext.ExtHostWebviewViews, ( new ExtHostWebviewViews(rpcProtocol, extHostWebviews)));\n    const extHostTesting = rpcProtocol.set(ExtHostContext.ExtHostTesting, accessor.get(IExtHostTesting));\n    const extHostUriOpeners = rpcProtocol.set(ExtHostContext.ExtHostUriOpeners, ( new ExtHostUriOpeners(rpcProtocol)));\n    const extHostProfileContentHandlers = rpcProtocol.set(ExtHostContext.ExtHostProfileContentHandlers, ( new ExtHostProfileContentHandlers(rpcProtocol)));\n    rpcProtocol.set(ExtHostContext.ExtHostInteractive, ( new ExtHostInteractive(\n        rpcProtocol,\n        extHostNotebook,\n        extHostDocumentsAndEditors,\n        extHostCommands,\n        extHostLogService\n    )));\n    const extHostChatAgents2 = rpcProtocol.set(ExtHostContext.ExtHostChatAgents2, ( new ExtHostChatAgents2(\n        rpcProtocol,\n        extHostLogService,\n        extHostCommands,\n        extHostDocuments,\n        extHostLanguageModels\n    )));\n    const extHostChatVariables = rpcProtocol.set(ExtHostContext.ExtHostChatVariables, ( new ExtHostChatVariables(rpcProtocol)));\n    const extHostLanguageModelTools = rpcProtocol.set(ExtHostContext.ExtHostLanguageModelTools, ( new ExtHostLanguageModelTools(rpcProtocol)));\n    const extHostAiRelatedInformation = rpcProtocol.set(ExtHostContext.ExtHostAiRelatedInformation, ( new ExtHostRelatedInformation(rpcProtocol)));\n    const extHostAiEmbeddingVector = rpcProtocol.set(ExtHostContext.ExtHostAiEmbeddingVector, ( new ExtHostAiEmbeddingVector(rpcProtocol)));\n    const extHostStatusBar = rpcProtocol.set(ExtHostContext.ExtHostStatusBar, ( new ExtHostStatusBar(rpcProtocol, extHostCommands.converter)));\n    const extHostSpeech = rpcProtocol.set(ExtHostContext.ExtHostSpeech, ( new ExtHostSpeech(rpcProtocol)));\n    const extHostEmbeddings = rpcProtocol.set(ExtHostContext.ExtHostEmbeddings, ( new ExtHostEmbeddings(rpcProtocol)));\n    const expected = ( Object.values(ExtHostContext));\n    rpcProtocol.assertRegistered(expected);\n    const extHostBulkEdits = ( new ExtHostBulkEdits(rpcProtocol, extHostDocumentsAndEditors));\n    const extHostClipboard = ( new ExtHostClipboard(rpcProtocol));\n    const extHostMessageService = ( new ExtHostMessageService(rpcProtocol, extHostLogService));\n    const extHostDialogs = ( new ExtHostDialogs(rpcProtocol));\n    ExtHostApiCommands.register(extHostCommands);\n    return function (extension, extensionInfo, configProvider) {\n        function _asExtensionEvent(actual) {\n            return (listener, thisArgs, disposables) => {\n                const handle = actual(e => {\n                    try {\n                        listener.call(thisArgs, e);\n                    }\n                    catch (err) {\n                        onUnexpectedExternalError(( new Error(\n                            `[ExtensionListenerError] Extension '${extension.identifier.value}' FAILED to handle event: ${( err.toString())}`,\n                            { cause: err }\n                        )));\n                        extHostTelemetry.onExtensionError(extension.identifier, err);\n                    }\n                });\n                disposables?.push(handle);\n                return handle;\n            };\n        }\n        const checkSelector = ( (function() {\n            let done = !extension.isUnderDevelopment;\n            function informOnce() {\n                if (!done) {\n                    extHostLogService.info(`Extension '${extension.identifier.value}' uses a document selector without scheme. Learn more about this: https://go.microsoft.com/fwlink/?linkid=872305`);\n                    done = true;\n                }\n            }\n            return function perform(selector) {\n                if (Array.isArray(selector)) {\n                    selector.forEach(perform);\n                }\n                else if (typeof selector === 'string') {\n                    informOnce();\n                }\n                else {\n                    const filter = selector;\n                    if (typeof filter.scheme === 'undefined') {\n                        informOnce();\n                    }\n                    if (typeof filter.exclusive === 'boolean') {\n                        checkProposedApiEnabled(extension, 'documentFiltersExclusive');\n                    }\n                }\n                return selector;\n            };\n        })());\n        const authentication = {\n            getSession(providerId, scopes, options) {\n                if (typeof options?.forceNewSession === 'object' && options.forceNewSession.learnMore) {\n                    checkProposedApiEnabled(extension, 'authLearnMore');\n                }\n                return extHostAuthentication.getSession(extension, providerId, scopes, options);\n            },\n            getAccounts(providerId) {\n                return extHostAuthentication.getAccounts(providerId);\n            },\n            async hasSession(providerId, scopes) {\n                checkProposedApiEnabled(extension, 'authSession');\n                return !!(await extHostAuthentication.getSession(extension, providerId, scopes, { silent: true }));\n            },\n            get onDidChangeSessions() {\n                return _asExtensionEvent(extHostAuthentication.getExtensionScopedSessionsEvent(extension.identifier.value));\n            },\n            registerAuthenticationProvider(id, label, provider, options) {\n                return extHostAuthentication.registerAuthenticationProvider(id, label, provider, options);\n            }\n        };\n        const commands = {\n            registerCommand(id, command, thisArgs) {\n                return extHostCommands.registerCommand(true, id, command, thisArgs, undefined, extension);\n            },\n            registerTextEditorCommand(id, callback, thisArg) {\n                return extHostCommands.registerCommand(true, id, (...args) => {\n                    const activeTextEditor = extHostEditors.getActiveTextEditor();\n                    if (!activeTextEditor) {\n                        extHostLogService.warn('Cannot execute ' + id + ' because there is no active text editor.');\n                        return undefined;\n                    }\n                    return activeTextEditor.edit((edit) => {\n                        callback.apply(thisArg, [activeTextEditor, edit, ...args]);\n                    }).then((result) => {\n                        if (!result) {\n                            extHostLogService.warn('Edits from command ' + id + ' were not applied.');\n                        }\n                    }, (err) => {\n                        extHostLogService.warn('An error occurred while running command ' + id, err);\n                    });\n                }, undefined, undefined, extension);\n            },\n            registerDiffInformationCommand: (id, callback, thisArg) => {\n                checkProposedApiEnabled(extension, 'diffCommand');\n                return extHostCommands.registerCommand(true, id, async (...args) => {\n                    const activeTextEditor = extHostDocumentsAndEditors.activeEditor(true);\n                    if (!activeTextEditor) {\n                        extHostLogService.warn('Cannot execute ' + id + ' because there is no active text editor.');\n                        return undefined;\n                    }\n                    const diff = await extHostEditors.getDiffInformation(activeTextEditor.id);\n                    callback.apply(thisArg, [diff, ...args]);\n                }, undefined, undefined, extension);\n            },\n            executeCommand(id, ...args) {\n                return extHostCommands.executeCommand(id, ...args);\n            },\n            getCommands(filterInternal = false) {\n                return extHostCommands.getCommands(filterInternal);\n            }\n        };\n        const env = {\n            get machineId() { return initData.telemetryInfo.machineId; },\n            get sessionId() { return initData.telemetryInfo.sessionId; },\n            get language() { return initData.environment.appLanguage; },\n            get appName() { return initData.environment.appName; },\n            get appRoot() { return initData.environment.appRoot?.fsPath ?? ''; },\n            get appHost() { return initData.environment.appHost; },\n            get uriScheme() { return initData.environment.appUriScheme; },\n            get clipboard() { return extHostClipboard.value; },\n            get shell() {\n                return extHostTerminalService.getDefaultShell(false);\n            },\n            get onDidChangeShell() {\n                return _asExtensionEvent(extHostTerminalService.onDidChangeShell);\n            },\n            get isTelemetryEnabled() {\n                return extHostTelemetry.getTelemetryConfiguration();\n            },\n            get onDidChangeTelemetryEnabled() {\n                return _asExtensionEvent(extHostTelemetry.onDidChangeTelemetryEnabled);\n            },\n            get telemetryConfiguration() {\n                checkProposedApiEnabled(extension, 'telemetry');\n                return extHostTelemetry.getTelemetryDetails();\n            },\n            get onDidChangeTelemetryConfiguration() {\n                checkProposedApiEnabled(extension, 'telemetry');\n                return _asExtensionEvent(extHostTelemetry.onDidChangeTelemetryConfiguration);\n            },\n            get isNewAppInstall() {\n                return isNewAppInstall(initData.telemetryInfo.firstSessionDate);\n            },\n            createTelemetryLogger(sender, options) {\n                ExtHostTelemetryLogger.validateSender(sender);\n                return extHostTelemetry.instantiateLogger(extension, sender, options);\n            },\n            openExternal(uri, options) {\n                return extHostWindow.openUri(uri, {\n                    allowTunneling: !!initData.remote.authority,\n                    allowContributedOpeners: options?.allowContributedOpeners,\n                });\n            },\n            async asExternalUri(uri) {\n                if (uri.scheme === initData.environment.appUriScheme) {\n                    return extHostUrls.createAppUri(uri);\n                }\n                try {\n                    return await extHostWindow.asExternalUri(uri, { allowTunneling: !!initData.remote.authority });\n                }\n                catch (err) {\n                    if (matchesScheme(uri, Schemas.http) || matchesScheme(uri, Schemas.https)) {\n                        return uri;\n                    }\n                    throw err;\n                }\n            },\n            get remoteName() {\n                return getRemoteName(initData.remote.authority);\n            },\n            get remoteAuthority() {\n                checkProposedApiEnabled(extension, 'resolvers');\n                return initData.remote.authority;\n            },\n            get uiKind() {\n                return initData.uiKind;\n            },\n            get logLevel() {\n                return extHostLogService.getLevel();\n            },\n            get onDidChangeLogLevel() {\n                return _asExtensionEvent(extHostLogService.onDidChangeLogLevel);\n            },\n            get appQuality() {\n                checkProposedApiEnabled(extension, 'resolvers');\n                return initData.quality;\n            },\n            get appCommit() {\n                checkProposedApiEnabled(extension, 'resolvers');\n                return initData.commit;\n            },\n        };\n        const tests = {\n            createTestController(provider, label, refreshHandler) {\n                return extHostTesting.createTestController(extension, provider, label, refreshHandler);\n            },\n            createTestObserver() {\n                checkProposedApiEnabled(extension, 'testObserver');\n                return extHostTesting.createTestObserver();\n            },\n            runTests(provider) {\n                checkProposedApiEnabled(extension, 'testObserver');\n                return extHostTesting.runTests(provider);\n            },\n            registerTestFollowupProvider(provider) {\n                checkProposedApiEnabled(extension, 'testObserver');\n                return extHostTesting.registerTestFollowupProvider(provider);\n            },\n            get onDidChangeTestResults() {\n                checkProposedApiEnabled(extension, 'testObserver');\n                return _asExtensionEvent(extHostTesting.onResultsChanged);\n            },\n            get testResults() {\n                checkProposedApiEnabled(extension, 'testObserver');\n                return extHostTesting.results;\n            },\n        };\n        const extensionKind = initData.remote.isRemote\n            ? ExtensionKind.Workspace\n            : ExtensionKind.UI;\n        const extensions = {\n            getExtension(extensionId, includeFromDifferentExtensionHosts) {\n                if (!isProposedApiEnabled(extension, 'extensionsAny')) {\n                    includeFromDifferentExtensionHosts = false;\n                }\n                const mine = extensionInfo.mine.getExtensionDescription(extensionId);\n                if (mine) {\n                    return ( new Extension(extensionService, extension.identifier, mine, extensionKind, false));\n                }\n                if (includeFromDifferentExtensionHosts) {\n                    const foreign = extensionInfo.all.getExtensionDescription(extensionId);\n                    if (foreign) {\n                        return ( new Extension(\n                            extensionService,\n                            extension.identifier,\n                            foreign,\n                            extensionKind ,\n                            true\n                        ));\n                    }\n                }\n                return undefined;\n            },\n            get all() {\n                const result = [];\n                for (const desc of extensionInfo.mine.getAllExtensionDescriptions()) {\n                    result.push(( new Extension(extensionService, extension.identifier, desc, extensionKind, false)));\n                }\n                return result;\n            },\n            get allAcrossExtensionHosts() {\n                checkProposedApiEnabled(extension, 'extensionsAny');\n                const local = ( new ExtensionIdentifierSet(( extensionInfo.mine.getAllExtensionDescriptions().map(desc => desc.identifier))));\n                const result = [];\n                for (const desc of extensionInfo.all.getAllExtensionDescriptions()) {\n                    const isFromDifferentExtensionHost = !( local.has(desc.identifier));\n                    result.push(( new Extension(\n                        extensionService,\n                        extension.identifier,\n                        desc,\n                        extensionKind ,\n                        isFromDifferentExtensionHost\n                    )));\n                }\n                return result;\n            },\n            get onDidChange() {\n                if (isProposedApiEnabled(extension, 'extensionsAny')) {\n                    return _asExtensionEvent(Event.any(extensionInfo.mine.onDidChange, extensionInfo.all.onDidChange));\n                }\n                return _asExtensionEvent(extensionInfo.mine.onDidChange);\n            }\n        };\n        const languages = {\n            createDiagnosticCollection(name) {\n                return extHostDiagnostics.createDiagnosticCollection(extension.identifier, name);\n            },\n            get onDidChangeDiagnostics() {\n                return _asExtensionEvent(extHostDiagnostics.onDidChangeDiagnostics);\n            },\n            getDiagnostics: (resource) => {\n                return extHostDiagnostics.getDiagnostics(resource);\n            },\n            getLanguages() {\n                return extHostLanguages.getLanguages();\n            },\n            setTextDocumentLanguage(document, languageId) {\n                return extHostLanguages.changeLanguage(document.uri, languageId);\n            },\n            match(selector, document) {\n                const interalSelector = LanguageSelector.from(selector);\n                let notebook;\n                if (targetsNotebooks(interalSelector)) {\n                    notebook = extHostNotebook.notebookDocuments.find(value => value.apiNotebook.getCells().find(c => c.document === document))?.apiNotebook;\n                }\n                return score(interalSelector, document.uri, document.languageId, true, notebook?.uri, notebook?.notebookType);\n            },\n            registerCodeActionsProvider(selector, provider, metadata) {\n                return extHostLanguageFeatures.registerCodeActionProvider(extension, checkSelector(selector), provider, metadata);\n            },\n            registerDocumentPasteEditProvider(selector, provider, metadata) {\n                checkProposedApiEnabled(extension, 'documentPaste');\n                return extHostLanguageFeatures.registerDocumentPasteEditProvider(extension, checkSelector(selector), provider, metadata);\n            },\n            registerCodeLensProvider(selector, provider) {\n                return extHostLanguageFeatures.registerCodeLensProvider(extension, checkSelector(selector), provider);\n            },\n            registerDefinitionProvider(selector, provider) {\n                return extHostLanguageFeatures.registerDefinitionProvider(extension, checkSelector(selector), provider);\n            },\n            registerDeclarationProvider(selector, provider) {\n                return extHostLanguageFeatures.registerDeclarationProvider(extension, checkSelector(selector), provider);\n            },\n            registerImplementationProvider(selector, provider) {\n                return extHostLanguageFeatures.registerImplementationProvider(extension, checkSelector(selector), provider);\n            },\n            registerTypeDefinitionProvider(selector, provider) {\n                return extHostLanguageFeatures.registerTypeDefinitionProvider(extension, checkSelector(selector), provider);\n            },\n            registerHoverProvider(selector, provider) {\n                return extHostLanguageFeatures.registerHoverProvider(extension, checkSelector(selector), provider, extension.identifier);\n            },\n            registerEvaluatableExpressionProvider(selector, provider) {\n                return extHostLanguageFeatures.registerEvaluatableExpressionProvider(extension, checkSelector(selector), provider, extension.identifier);\n            },\n            registerInlineValuesProvider(selector, provider) {\n                return extHostLanguageFeatures.registerInlineValuesProvider(extension, checkSelector(selector), provider, extension.identifier);\n            },\n            registerDocumentHighlightProvider(selector, provider) {\n                return extHostLanguageFeatures.registerDocumentHighlightProvider(extension, checkSelector(selector), provider);\n            },\n            registerMultiDocumentHighlightProvider(selector, provider) {\n                return extHostLanguageFeatures.registerMultiDocumentHighlightProvider(extension, checkSelector(selector), provider);\n            },\n            registerLinkedEditingRangeProvider(selector, provider) {\n                return extHostLanguageFeatures.registerLinkedEditingRangeProvider(extension, checkSelector(selector), provider);\n            },\n            registerReferenceProvider(selector, provider) {\n                return extHostLanguageFeatures.registerReferenceProvider(extension, checkSelector(selector), provider);\n            },\n            registerRenameProvider(selector, provider) {\n                return extHostLanguageFeatures.registerRenameProvider(extension, checkSelector(selector), provider);\n            },\n            registerNewSymbolNamesProvider(selector, provider) {\n                checkProposedApiEnabled(extension, 'newSymbolNamesProvider');\n                return extHostLanguageFeatures.registerNewSymbolNamesProvider(extension, checkSelector(selector), provider);\n            },\n            registerDocumentSymbolProvider(selector, provider, metadata) {\n                return extHostLanguageFeatures.registerDocumentSymbolProvider(extension, checkSelector(selector), provider, metadata);\n            },\n            registerWorkspaceSymbolProvider(provider) {\n                return extHostLanguageFeatures.registerWorkspaceSymbolProvider(extension, provider);\n            },\n            registerDocumentFormattingEditProvider(selector, provider) {\n                return extHostLanguageFeatures.registerDocumentFormattingEditProvider(extension, checkSelector(selector), provider);\n            },\n            registerDocumentRangeFormattingEditProvider(selector, provider) {\n                return extHostLanguageFeatures.registerDocumentRangeFormattingEditProvider(extension, checkSelector(selector), provider);\n            },\n            registerOnTypeFormattingEditProvider(selector, provider, firstTriggerCharacter, ...moreTriggerCharacters) {\n                return extHostLanguageFeatures.registerOnTypeFormattingEditProvider(extension, checkSelector(selector), provider, [firstTriggerCharacter].concat(moreTriggerCharacters));\n            },\n            registerDocumentSemanticTokensProvider(selector, provider, legend) {\n                return extHostLanguageFeatures.registerDocumentSemanticTokensProvider(extension, checkSelector(selector), provider, legend);\n            },\n            registerDocumentRangeSemanticTokensProvider(selector, provider, legend) {\n                return extHostLanguageFeatures.registerDocumentRangeSemanticTokensProvider(extension, checkSelector(selector), provider, legend);\n            },\n            registerSignatureHelpProvider(selector, provider, firstItem, ...remaining) {\n                if (typeof firstItem === 'object') {\n                    return extHostLanguageFeatures.registerSignatureHelpProvider(extension, checkSelector(selector), provider, firstItem);\n                }\n                return extHostLanguageFeatures.registerSignatureHelpProvider(extension, checkSelector(selector), provider, typeof firstItem === 'undefined' ? [] : [firstItem, ...remaining]);\n            },\n            registerCompletionItemProvider(selector, provider, ...triggerCharacters) {\n                return extHostLanguageFeatures.registerCompletionItemProvider(extension, checkSelector(selector), provider, triggerCharacters);\n            },\n            registerInlineCompletionItemProvider(selector, provider, metadata) {\n                if (provider.handleDidShowCompletionItem) {\n                    checkProposedApiEnabled(extension, 'inlineCompletionsAdditions');\n                }\n                if (provider.handleDidPartiallyAcceptCompletionItem) {\n                    checkProposedApiEnabled(extension, 'inlineCompletionsAdditions');\n                }\n                if (metadata) {\n                    checkProposedApiEnabled(extension, 'inlineCompletionsAdditions');\n                }\n                return extHostLanguageFeatures.registerInlineCompletionsProvider(extension, checkSelector(selector), provider, metadata);\n            },\n            registerInlineEditProvider(selector, provider) {\n                checkProposedApiEnabled(extension, 'inlineEdit');\n                return extHostLanguageFeatures.registerInlineEditProvider(extension, checkSelector(selector), provider);\n            },\n            registerDocumentLinkProvider(selector, provider) {\n                return extHostLanguageFeatures.registerDocumentLinkProvider(extension, checkSelector(selector), provider);\n            },\n            registerColorProvider(selector, provider) {\n                return extHostLanguageFeatures.registerColorProvider(extension, checkSelector(selector), provider);\n            },\n            registerFoldingRangeProvider(selector, provider) {\n                return extHostLanguageFeatures.registerFoldingRangeProvider(extension, checkSelector(selector), provider);\n            },\n            registerSelectionRangeProvider(selector, provider) {\n                return extHostLanguageFeatures.registerSelectionRangeProvider(extension, selector, provider);\n            },\n            registerCallHierarchyProvider(selector, provider) {\n                return extHostLanguageFeatures.registerCallHierarchyProvider(extension, selector, provider);\n            },\n            registerTypeHierarchyProvider(selector, provider) {\n                return extHostLanguageFeatures.registerTypeHierarchyProvider(extension, selector, provider);\n            },\n            setLanguageConfiguration: (language, configuration) => {\n                return extHostLanguageFeatures.setLanguageConfiguration(extension, language, configuration);\n            },\n            getTokenInformationAtPosition(doc, pos) {\n                checkProposedApiEnabled(extension, 'tokenInformation');\n                return extHostLanguages.tokenAtPosition(doc, pos);\n            },\n            registerInlayHintsProvider(selector, provider) {\n                return extHostLanguageFeatures.registerInlayHintsProvider(extension, selector, provider);\n            },\n            createLanguageStatusItem(id, selector) {\n                return extHostLanguages.createLanguageStatusItem(extension, id, selector);\n            },\n            registerDocumentDropEditProvider(selector, provider, metadata) {\n                return extHostLanguageFeatures.registerDocumentOnDropEditProvider(extension, selector, provider, isProposedApiEnabled(extension, 'documentPaste') ? metadata : undefined);\n            }\n        };\n        const window = {\n            get activeTextEditor() {\n                return extHostEditors.getActiveTextEditor();\n            },\n            get visibleTextEditors() {\n                return extHostEditors.getVisibleTextEditors();\n            },\n            get activeTerminal() {\n                return extHostTerminalService.activeTerminal;\n            },\n            get terminals() {\n                return extHostTerminalService.terminals;\n            },\n            async showTextDocument(documentOrUri, columnOrOptions, preserveFocus) {\n                if (URI.isUri(documentOrUri) && documentOrUri.scheme === Schemas.vscodeRemote && !documentOrUri.authority) {\n                    extHostApiDeprecation.report('workspace.showTextDocument', extension, `A URI of 'vscode-remote' scheme requires an authority.`);\n                }\n                const document = await (URI.isUri(documentOrUri)\n                    ? Promise.resolve(workspace.openTextDocument(documentOrUri))\n                    : Promise.resolve(documentOrUri));\n                return extHostEditors.showTextDocument(document, columnOrOptions, preserveFocus);\n            },\n            createTextEditorDecorationType(options) {\n                return extHostEditors.createTextEditorDecorationType(extension, options);\n            },\n            onDidChangeActiveTextEditor(listener, thisArg, disposables) {\n                return _asExtensionEvent(extHostEditors.onDidChangeActiveTextEditor)(listener, thisArg, disposables);\n            },\n            onDidChangeVisibleTextEditors(listener, thisArg, disposables) {\n                return _asExtensionEvent(extHostEditors.onDidChangeVisibleTextEditors)(listener, thisArg, disposables);\n            },\n            onDidChangeTextEditorSelection(listener, thisArgs, disposables) {\n                return _asExtensionEvent(extHostEditors.onDidChangeTextEditorSelection)(listener, thisArgs, disposables);\n            },\n            onDidChangeTextEditorOptions(listener, thisArgs, disposables) {\n                return _asExtensionEvent(extHostEditors.onDidChangeTextEditorOptions)(listener, thisArgs, disposables);\n            },\n            onDidChangeTextEditorVisibleRanges(listener, thisArgs, disposables) {\n                return _asExtensionEvent(extHostEditors.onDidChangeTextEditorVisibleRanges)(listener, thisArgs, disposables);\n            },\n            onDidChangeTextEditorViewColumn(listener, thisArg, disposables) {\n                return _asExtensionEvent(extHostEditors.onDidChangeTextEditorViewColumn)(listener, thisArg, disposables);\n            },\n            onDidCloseTerminal(listener, thisArg, disposables) {\n                return _asExtensionEvent(extHostTerminalService.onDidCloseTerminal)(listener, thisArg, disposables);\n            },\n            onDidOpenTerminal(listener, thisArg, disposables) {\n                return _asExtensionEvent(extHostTerminalService.onDidOpenTerminal)(listener, thisArg, disposables);\n            },\n            onDidChangeActiveTerminal(listener, thisArg, disposables) {\n                return _asExtensionEvent(extHostTerminalService.onDidChangeActiveTerminal)(listener, thisArg, disposables);\n            },\n            onDidChangeTerminalDimensions(listener, thisArg, disposables) {\n                checkProposedApiEnabled(extension, 'terminalDimensions');\n                return _asExtensionEvent(extHostTerminalService.onDidChangeTerminalDimensions)(listener, thisArg, disposables);\n            },\n            onDidChangeTerminalState(listener, thisArg, disposables) {\n                return _asExtensionEvent(extHostTerminalService.onDidChangeTerminalState)(listener, thisArg, disposables);\n            },\n            onDidWriteTerminalData(listener, thisArg, disposables) {\n                checkProposedApiEnabled(extension, 'terminalDataWriteEvent');\n                return _asExtensionEvent(extHostTerminalService.onDidWriteTerminalData)(listener, thisArg, disposables);\n            },\n            onDidExecuteTerminalCommand(listener, thisArg, disposables) {\n                checkProposedApiEnabled(extension, 'terminalExecuteCommandEvent');\n                return _asExtensionEvent(extHostTerminalService.onDidExecuteTerminalCommand)(listener, thisArg, disposables);\n            },\n            onDidChangeTerminalShellIntegration(listener, thisArg, disposables) {\n                return _asExtensionEvent(extHostTerminalShellIntegration.onDidChangeTerminalShellIntegration)(listener, thisArg, disposables);\n            },\n            onDidStartTerminalShellExecution(listener, thisArg, disposables) {\n                return _asExtensionEvent(extHostTerminalShellIntegration.onDidStartTerminalShellExecution)(listener, thisArg, disposables);\n            },\n            onDidEndTerminalShellExecution(listener, thisArg, disposables) {\n                return _asExtensionEvent(extHostTerminalShellIntegration.onDidEndTerminalShellExecution)(listener, thisArg, disposables);\n            },\n            get state() {\n                return extHostWindow.getState();\n            },\n            onDidChangeWindowState(listener, thisArg, disposables) {\n                return _asExtensionEvent(extHostWindow.onDidChangeWindowState)(listener, thisArg, disposables);\n            },\n            showInformationMessage(message, ...rest) {\n                return extHostMessageService.showMessage(extension, Severity$1.Info, message, rest[0], rest.slice(1));\n            },\n            showWarningMessage(message, ...rest) {\n                return extHostMessageService.showMessage(extension, Severity$1.Warning, message, rest[0], rest.slice(1));\n            },\n            showErrorMessage(message, ...rest) {\n                return extHostMessageService.showMessage(extension, Severity$1.Error, message, rest[0], rest.slice(1));\n            },\n            showQuickPick(items, options, token) {\n                return extHostQuickOpen.showQuickPick(extension, items, options, token);\n            },\n            showWorkspaceFolderPick(options) {\n                return extHostQuickOpen.showWorkspaceFolderPick(options);\n            },\n            showInputBox(options, token) {\n                return extHostQuickOpen.showInput(options, token);\n            },\n            showOpenDialog(options) {\n                return extHostDialogs.showOpenDialog(extension, options);\n            },\n            showSaveDialog(options) {\n                return extHostDialogs.showSaveDialog(options);\n            },\n            createStatusBarItem(alignmentOrId, priorityOrAlignment, priorityArg) {\n                let id;\n                let alignment;\n                let priority;\n                if (typeof alignmentOrId === 'string') {\n                    id = alignmentOrId;\n                    alignment = priorityOrAlignment;\n                    priority = priorityArg;\n                }\n                else {\n                    alignment = alignmentOrId;\n                    priority = priorityOrAlignment;\n                }\n                return extHostStatusBar.createStatusBarEntry(extension, id, alignment, priority);\n            },\n            setStatusBarMessage(text, timeoutOrThenable) {\n                return extHostStatusBar.setStatusBarMessage(text, timeoutOrThenable);\n            },\n            withScmProgress(task) {\n                extHostApiDeprecation.report('window.withScmProgress', extension, `Use 'withProgress' instead.`);\n                return extHostProgress.withProgress(extension, { location: ProgressLocation.SourceControl }, (progress, token) => task({ report(n) { } }));\n            },\n            withProgress(options, task) {\n                return extHostProgress.withProgress(extension, options, task);\n            },\n            createOutputChannel(name, options) {\n                return extHostOutputService.createOutputChannel(name, options, extension);\n            },\n            createWebviewPanel(viewType, title, showOptions, options) {\n                return extHostWebviewPanels.createWebviewPanel(extension, viewType, title, showOptions, options);\n            },\n            createWebviewTextEditorInset(editor, line, height, options) {\n                checkProposedApiEnabled(extension, 'editorInsets');\n                return extHostEditorInsets.createWebviewEditorInset(editor, line, height, options, extension);\n            },\n            createTerminal(nameOrOptions, shellPath, shellArgs) {\n                if (typeof nameOrOptions === 'object') {\n                    if ('pty' in nameOrOptions) {\n                        return extHostTerminalService.createExtensionTerminal(nameOrOptions);\n                    }\n                    return extHostTerminalService.createTerminalFromOptions(nameOrOptions);\n                }\n                return extHostTerminalService.createTerminal(nameOrOptions, shellPath, shellArgs);\n            },\n            registerTerminalLinkProvider(provider) {\n                return extHostTerminalService.registerLinkProvider(provider);\n            },\n            registerTerminalProfileProvider(id, provider) {\n                return extHostTerminalService.registerProfileProvider(extension, id, provider);\n            },\n            registerTerminalQuickFixProvider(id, provider) {\n                checkProposedApiEnabled(extension, 'terminalQuickFixProvider');\n                return extHostTerminalService.registerTerminalQuickFixProvider(id, extension.identifier.value, provider);\n            },\n            registerTreeDataProvider(viewId, treeDataProvider) {\n                return extHostTreeViews.registerTreeDataProvider(viewId, treeDataProvider, extension);\n            },\n            createTreeView(viewId, options) {\n                return extHostTreeViews.createTreeView(viewId, options, extension);\n            },\n            registerWebviewPanelSerializer: (viewType, serializer) => {\n                return extHostWebviewPanels.registerWebviewPanelSerializer(extension, viewType, serializer);\n            },\n            registerCustomEditorProvider: (viewType, provider, options = {}) => {\n                return extHostCustomEditors.registerCustomEditorProvider(extension, viewType, provider, options);\n            },\n            registerFileDecorationProvider(provider) {\n                return extHostDecorations.registerFileDecorationProvider(provider, extension);\n            },\n            registerUriHandler(handler) {\n                return extHostUrls.registerUriHandler(extension, handler);\n            },\n            createQuickPick() {\n                return extHostQuickOpen.createQuickPick(extension);\n            },\n            createInputBox() {\n                return extHostQuickOpen.createInputBox(extension);\n            },\n            get activeColorTheme() {\n                return extHostTheming.activeColorTheme;\n            },\n            onDidChangeActiveColorTheme(listener, thisArg, disposables) {\n                return _asExtensionEvent(extHostTheming.onDidChangeActiveColorTheme)(listener, thisArg, disposables);\n            },\n            registerWebviewViewProvider(viewId, provider, options) {\n                return extHostWebviewViews.registerWebviewViewProvider(extension, viewId, provider, options?.webviewOptions);\n            },\n            get activeNotebookEditor() {\n                return extHostNotebook.activeNotebookEditor;\n            },\n            onDidChangeActiveNotebookEditor(listener, thisArgs, disposables) {\n                return _asExtensionEvent(extHostNotebook.onDidChangeActiveNotebookEditor)(listener, thisArgs, disposables);\n            },\n            get visibleNotebookEditors() {\n                return extHostNotebook.visibleNotebookEditors;\n            },\n            get onDidChangeVisibleNotebookEditors() {\n                return _asExtensionEvent(extHostNotebook.onDidChangeVisibleNotebookEditors);\n            },\n            onDidChangeNotebookEditorSelection(listener, thisArgs, disposables) {\n                return _asExtensionEvent(extHostNotebookEditors.onDidChangeNotebookEditorSelection)(listener, thisArgs, disposables);\n            },\n            onDidChangeNotebookEditorVisibleRanges(listener, thisArgs, disposables) {\n                return _asExtensionEvent(extHostNotebookEditors.onDidChangeNotebookEditorVisibleRanges)(listener, thisArgs, disposables);\n            },\n            showNotebookDocument(document, options) {\n                return extHostNotebook.showNotebookDocument(document, options);\n            },\n            registerExternalUriOpener(id, opener, metadata) {\n                checkProposedApiEnabled(extension, 'externalUriOpener');\n                return extHostUriOpeners.registerExternalUriOpener(extension.identifier, id, opener, metadata);\n            },\n            registerProfileContentHandler(id, handler) {\n                checkProposedApiEnabled(extension, 'profileContentHandlers');\n                return extHostProfileContentHandlers.registerProfileContentHandler(extension, id, handler);\n            },\n            registerQuickDiffProvider(selector, quickDiffProvider, label, rootUri) {\n                checkProposedApiEnabled(extension, 'quickDiffProvider');\n                return extHostQuickDiff.registerQuickDiffProvider(checkSelector(selector), quickDiffProvider, label, rootUri);\n            },\n            get tabGroups() {\n                return extHostEditorTabs.tabGroups;\n            },\n            registerShareProvider(selector, provider) {\n                checkProposedApiEnabled(extension, 'shareProvider');\n                return extHostShare.registerShareProvider(checkSelector(selector), provider);\n            }\n        };\n        const workspace = {\n            get rootPath() {\n                extHostApiDeprecation.report('workspace.rootPath', extension, `Please use 'workspace.workspaceFolders' instead. More details: https://aka.ms/vscode-eliminating-rootpath`);\n                return extHostWorkspace.getPath();\n            },\n            set rootPath(value) {\n                throw new ReadonlyError('rootPath');\n            },\n            getWorkspaceFolder(resource) {\n                return extHostWorkspace.getWorkspaceFolder(resource);\n            },\n            get workspaceFolders() {\n                return extHostWorkspace.getWorkspaceFolders();\n            },\n            get name() {\n                return extHostWorkspace.name;\n            },\n            set name(value) {\n                throw new ReadonlyError('name');\n            },\n            get workspaceFile() {\n                return extHostWorkspace.workspaceFile;\n            },\n            set workspaceFile(value) {\n                throw new ReadonlyError('workspaceFile');\n            },\n            updateWorkspaceFolders: (index, deleteCount, ...workspaceFoldersToAdd) => {\n                return extHostWorkspace.updateWorkspaceFolders(extension, index, deleteCount || 0, ...workspaceFoldersToAdd);\n            },\n            onDidChangeWorkspaceFolders: function (listener, thisArgs, disposables) {\n                return _asExtensionEvent(extHostWorkspace.onDidChangeWorkspace)(listener, thisArgs, disposables);\n            },\n            asRelativePath: (pathOrUri, includeWorkspace) => {\n                return extHostWorkspace.getRelativePath(pathOrUri, includeWorkspace);\n            },\n            findFiles: (include, exclude, maxResults, token) => {\n                return extHostWorkspace.findFiles(include, exclude, maxResults, extension.identifier, token);\n            },\n            findFiles2: (filePattern, options, token) => {\n                checkProposedApiEnabled(extension, 'findFiles2');\n                return extHostWorkspace.findFiles2(filePattern, options, extension.identifier, token);\n            },\n            findFiles2New: (filePattern, options, token) => {\n                checkProposedApiEnabled(extension, 'findFiles2New');\n                return extHostWorkspace.findFiles2New(filePattern, options, extension.identifier, token);\n            },\n            findTextInFiles: (query, optionsOrCallback, callbackOrToken, token) => {\n                checkProposedApiEnabled(extension, 'findTextInFiles');\n                let options;\n                let callback;\n                if (typeof optionsOrCallback === 'object') {\n                    options = optionsOrCallback;\n                    callback = callbackOrToken;\n                }\n                else {\n                    options = {};\n                    callback = optionsOrCallback;\n                    token = callbackOrToken;\n                }\n                return extHostWorkspace.findTextInFiles(query, options || {}, callback, extension.identifier, token);\n            },\n            findTextInFilesNew: (query, options, token) => {\n                checkProposedApiEnabled(extension, 'findTextInFilesNew');\n                checkProposedApiEnabled(extension, 'textSearchProviderNew');\n                return extHostWorkspace.findTextInFilesNew(query, options, extension.identifier, token);\n            },\n            save: (uri) => {\n                return extHostWorkspace.save(uri);\n            },\n            saveAs: (uri) => {\n                return extHostWorkspace.saveAs(uri);\n            },\n            saveAll: (includeUntitled) => {\n                return extHostWorkspace.saveAll(includeUntitled);\n            },\n            applyEdit(edit, metadata) {\n                return extHostBulkEdits.applyWorkspaceEdit(edit, extension, metadata);\n            },\n            createFileSystemWatcher: (pattern, optionsOrIgnoreCreate, ignoreChange, ignoreDelete) => {\n                let options = undefined;\n                if (optionsOrIgnoreCreate && typeof optionsOrIgnoreCreate !== 'boolean') {\n                    checkProposedApiEnabled(extension, 'createFileSystemWatcher');\n                    options = {\n                        ...optionsOrIgnoreCreate,\n                        correlate: true\n                    };\n                }\n                else {\n                    options = {\n                        ignoreCreateEvents: Boolean(optionsOrIgnoreCreate),\n                        ignoreChangeEvents: Boolean(ignoreChange),\n                        ignoreDeleteEvents: Boolean(ignoreDelete),\n                        correlate: false\n                    };\n                }\n                return extHostFileSystemEvent.createFileSystemWatcher(extHostWorkspace, configProvider, extension, pattern, options);\n            },\n            get textDocuments() {\n                return ( extHostDocuments.getAllDocumentData().map(data => data.document));\n            },\n            set textDocuments(value) {\n                throw new ReadonlyError('textDocuments');\n            },\n            openTextDocument(uriOrFileNameOrOptions) {\n                let uriPromise;\n                const options = uriOrFileNameOrOptions;\n                if (typeof uriOrFileNameOrOptions === 'string') {\n                    uriPromise = Promise.resolve(URI.file(uriOrFileNameOrOptions));\n                }\n                else if (URI.isUri(uriOrFileNameOrOptions)) {\n                    uriPromise = Promise.resolve(uriOrFileNameOrOptions);\n                }\n                else if (!options || typeof options === 'object') {\n                    uriPromise = extHostDocuments.createDocumentData(options);\n                }\n                else {\n                    throw ( new Error('illegal argument - uriOrFileNameOrOptions'));\n                }\n                return uriPromise.then(uri => {\n                    extHostLogService.trace(`openTextDocument from ${extension.identifier}`);\n                    if (uri.scheme === Schemas.vscodeRemote && !uri.authority) {\n                        extHostApiDeprecation.report('workspace.openTextDocument', extension, `A URI of 'vscode-remote' scheme requires an authority.`);\n                    }\n                    return extHostDocuments.ensureDocumentData(uri).then(documentData => {\n                        return documentData.document;\n                    });\n                });\n            },\n            onDidOpenTextDocument: (listener, thisArgs, disposables) => {\n                return _asExtensionEvent(extHostDocuments.onDidAddDocument)(listener, thisArgs, disposables);\n            },\n            onDidCloseTextDocument: (listener, thisArgs, disposables) => {\n                return _asExtensionEvent(extHostDocuments.onDidRemoveDocument)(listener, thisArgs, disposables);\n            },\n            onDidChangeTextDocument: (listener, thisArgs, disposables) => {\n                return _asExtensionEvent(extHostDocuments.onDidChangeDocument)(listener, thisArgs, disposables);\n            },\n            onDidSaveTextDocument: (listener, thisArgs, disposables) => {\n                return _asExtensionEvent(extHostDocuments.onDidSaveDocument)(listener, thisArgs, disposables);\n            },\n            onWillSaveTextDocument: (listener, thisArgs, disposables) => {\n                return _asExtensionEvent(extHostDocumentSaveParticipant.getOnWillSaveTextDocumentEvent(extension))(listener, thisArgs, disposables);\n            },\n            get notebookDocuments() {\n                return ( extHostNotebook.notebookDocuments.map(d => d.apiNotebook));\n            },\n            async openNotebookDocument(uriOrType, content) {\n                let uri;\n                if (URI.isUri(uriOrType)) {\n                    uri = uriOrType;\n                    await extHostNotebook.openNotebookDocument(uriOrType);\n                }\n                else if (typeof uriOrType === 'string') {\n                    uri = URI.revive(await extHostNotebook.createNotebookDocument({ viewType: uriOrType, content }));\n                }\n                else {\n                    throw ( new Error('Invalid arguments'));\n                }\n                return extHostNotebook.getNotebookDocument(uri).apiNotebook;\n            },\n            onDidSaveNotebookDocument(listener, thisArg, disposables) {\n                return _asExtensionEvent(extHostNotebookDocuments.onDidSaveNotebookDocument)(listener, thisArg, disposables);\n            },\n            onDidChangeNotebookDocument(listener, thisArg, disposables) {\n                return _asExtensionEvent(extHostNotebookDocuments.onDidChangeNotebookDocument)(listener, thisArg, disposables);\n            },\n            onWillSaveNotebookDocument(listener, thisArg, disposables) {\n                return _asExtensionEvent(extHostNotebookDocumentSaveParticipant.getOnWillSaveNotebookDocumentEvent(extension))(listener, thisArg, disposables);\n            },\n            get onDidOpenNotebookDocument() {\n                return _asExtensionEvent(extHostNotebook.onDidOpenNotebookDocument);\n            },\n            get onDidCloseNotebookDocument() {\n                return _asExtensionEvent(extHostNotebook.onDidCloseNotebookDocument);\n            },\n            registerNotebookSerializer(viewType, serializer, options, registration) {\n                return extHostNotebook.registerNotebookSerializer(extension, viewType, serializer, options, isProposedApiEnabled(extension, 'notebookLiveShare') ? registration : undefined);\n            },\n            onDidChangeConfiguration: (listener, thisArgs, disposables) => {\n                return _asExtensionEvent(configProvider.onDidChangeConfiguration)(listener, thisArgs, disposables);\n            },\n            getConfiguration(section, scope) {\n                scope = arguments.length === 1 ? undefined : scope;\n                return configProvider.getConfiguration(section, scope, extension);\n            },\n            registerTextDocumentContentProvider(scheme, provider) {\n                return extHostDocumentContentProviders.registerTextDocumentContentProvider(scheme, provider);\n            },\n            registerTaskProvider: (type, provider) => {\n                extHostApiDeprecation.report('window.registerTaskProvider', extension, `Use the corresponding function on the 'tasks' namespace instead`);\n                return extHostTask.registerTaskProvider(extension, type, provider);\n            },\n            registerFileSystemProvider(scheme, provider, options) {\n                return combinedDisposable(extHostFileSystem.registerFileSystemProvider(extension, scheme, provider, options), extHostConsumerFileSystem.addFileSystemProvider(scheme, provider, options));\n            },\n            get fs() {\n                return extHostConsumerFileSystem.value;\n            },\n            registerFileSearchProvider: (scheme, provider) => {\n                checkProposedApiEnabled(extension, 'fileSearchProvider');\n                return extHostSearch.registerFileSearchProviderOld(scheme, provider);\n            },\n            registerTextSearchProvider: (scheme, provider) => {\n                checkProposedApiEnabled(extension, 'textSearchProvider');\n                return extHostSearch.registerTextSearchProviderOld(scheme, provider);\n            },\n            registerAITextSearchProvider: (scheme, provider) => {\n                checkProposedApiEnabled(extension, 'aiTextSearchProvider');\n                checkProposedApiEnabled(extension, 'textSearchProvider');\n                return extHostSearch.registerAITextSearchProviderOld(scheme, provider);\n            },\n            registerFileSearchProviderNew: (scheme, provider) => {\n                checkProposedApiEnabled(extension, 'fileSearchProviderNew');\n                return extHostSearch.registerFileSearchProvider(scheme, provider);\n            },\n            registerTextSearchProviderNew: (scheme, provider) => {\n                checkProposedApiEnabled(extension, 'textSearchProviderNew');\n                return extHostSearch.registerTextSearchProvider(scheme, provider);\n            },\n            registerAITextSearchProviderNew: (scheme, provider) => {\n                checkProposedApiEnabled(extension, 'aiTextSearchProviderNew');\n                checkProposedApiEnabled(extension, 'textSearchProviderNew');\n                return extHostSearch.registerAITextSearchProvider(scheme, provider);\n            },\n            registerRemoteAuthorityResolver: (authorityPrefix, resolver) => {\n                checkProposedApiEnabled(extension, 'resolvers');\n                return extensionService.registerRemoteAuthorityResolver(authorityPrefix, resolver);\n            },\n            registerResourceLabelFormatter: (formatter) => {\n                checkProposedApiEnabled(extension, 'resolvers');\n                return extHostLabelService.$registerResourceLabelFormatter(formatter);\n            },\n            getRemoteExecServer: (authority) => {\n                checkProposedApiEnabled(extension, 'resolvers');\n                return extensionService.getRemoteExecServer(authority);\n            },\n            onDidCreateFiles: (listener, thisArg, disposables) => {\n                return _asExtensionEvent(extHostFileSystemEvent.onDidCreateFile)(listener, thisArg, disposables);\n            },\n            onDidDeleteFiles: (listener, thisArg, disposables) => {\n                return _asExtensionEvent(extHostFileSystemEvent.onDidDeleteFile)(listener, thisArg, disposables);\n            },\n            onDidRenameFiles: (listener, thisArg, disposables) => {\n                return _asExtensionEvent(extHostFileSystemEvent.onDidRenameFile)(listener, thisArg, disposables);\n            },\n            onWillCreateFiles: (listener, thisArg, disposables) => {\n                return _asExtensionEvent(extHostFileSystemEvent.getOnWillCreateFileEvent(extension))(listener, thisArg, disposables);\n            },\n            onWillDeleteFiles: (listener, thisArg, disposables) => {\n                return _asExtensionEvent(extHostFileSystemEvent.getOnWillDeleteFileEvent(extension))(listener, thisArg, disposables);\n            },\n            onWillRenameFiles: (listener, thisArg, disposables) => {\n                return _asExtensionEvent(extHostFileSystemEvent.getOnWillRenameFileEvent(extension))(listener, thisArg, disposables);\n            },\n            openTunnel: (forward) => {\n                checkProposedApiEnabled(extension, 'tunnels');\n                return extHostTunnelService.openTunnel(extension, forward).then(value => {\n                    if (!value) {\n                        throw ( new Error('cannot open tunnel'));\n                    }\n                    return value;\n                });\n            },\n            get tunnels() {\n                checkProposedApiEnabled(extension, 'tunnels');\n                return extHostTunnelService.getTunnels();\n            },\n            onDidChangeTunnels: (listener, thisArg, disposables) => {\n                checkProposedApiEnabled(extension, 'tunnels');\n                return _asExtensionEvent(extHostTunnelService.onDidChangeTunnels)(listener, thisArg, disposables);\n            },\n            registerPortAttributesProvider: (portSelector, provider) => {\n                checkProposedApiEnabled(extension, 'portsAttributes');\n                return extHostTunnelService.registerPortsAttributesProvider(portSelector, provider);\n            },\n            registerTunnelProvider: (tunnelProvider, information) => {\n                checkProposedApiEnabled(extension, 'tunnelFactory');\n                return extHostTunnelService.registerTunnelProvider(tunnelProvider, information);\n            },\n            registerTimelineProvider: (scheme, provider) => {\n                checkProposedApiEnabled(extension, 'timeline');\n                return extHostTimeline.registerTimelineProvider(scheme, provider, extension.identifier, extHostCommands.converter);\n            },\n            get isTrusted() {\n                return extHostWorkspace.trusted;\n            },\n            requestWorkspaceTrust: (options) => {\n                checkProposedApiEnabled(extension, 'workspaceTrust');\n                return extHostWorkspace.requestWorkspaceTrust(options);\n            },\n            onDidGrantWorkspaceTrust: (listener, thisArgs, disposables) => {\n                return _asExtensionEvent(extHostWorkspace.onDidGrantWorkspaceTrust)(listener, thisArgs, disposables);\n            },\n            registerEditSessionIdentityProvider: (scheme, provider) => {\n                checkProposedApiEnabled(extension, 'editSessionIdentityProvider');\n                return extHostWorkspace.registerEditSessionIdentityProvider(scheme, provider);\n            },\n            onWillCreateEditSessionIdentity: (listener, thisArgs, disposables) => {\n                checkProposedApiEnabled(extension, 'editSessionIdentityProvider');\n                return _asExtensionEvent(extHostWorkspace.getOnWillCreateEditSessionIdentityEvent(extension))(listener, thisArgs, disposables);\n            },\n            registerCanonicalUriProvider: (scheme, provider) => {\n                checkProposedApiEnabled(extension, 'canonicalUriProvider');\n                return extHostWorkspace.registerCanonicalUriProvider(scheme, provider);\n            },\n            getCanonicalUri: (uri, options, token) => {\n                checkProposedApiEnabled(extension, 'canonicalUriProvider');\n                return extHostWorkspace.provideCanonicalUri(uri, options, token);\n            }\n        };\n        const scm = {\n            get inputBox() {\n                extHostApiDeprecation.report('scm.inputBox', extension, `Use 'SourceControl.inputBox' instead`);\n                return extHostSCM.getLastInputBox(extension);\n            },\n            createSourceControl(id, label, rootUri) {\n                return extHostSCM.createSourceControl(extension, id, label, rootUri);\n            }\n        };\n        const comments = {\n            createCommentController(id, label) {\n                return extHostComment.createCommentController(extension, id, label);\n            }\n        };\n        const debug = {\n            get activeDebugSession() {\n                return extHostDebugService.activeDebugSession;\n            },\n            get activeDebugConsole() {\n                return extHostDebugService.activeDebugConsole;\n            },\n            get breakpoints() {\n                return extHostDebugService.breakpoints;\n            },\n            get activeStackItem() {\n                return extHostDebugService.activeStackItem;\n            },\n            registerDebugVisualizationProvider(id, provider) {\n                checkProposedApiEnabled(extension, 'debugVisualization');\n                return extHostDebugService.registerDebugVisualizationProvider(extension, id, provider);\n            },\n            registerDebugVisualizationTreeProvider(id, provider) {\n                checkProposedApiEnabled(extension, 'debugVisualization');\n                return extHostDebugService.registerDebugVisualizationTree(extension, id, provider);\n            },\n            onDidStartDebugSession(listener, thisArg, disposables) {\n                return _asExtensionEvent(extHostDebugService.onDidStartDebugSession)(listener, thisArg, disposables);\n            },\n            onDidTerminateDebugSession(listener, thisArg, disposables) {\n                return _asExtensionEvent(extHostDebugService.onDidTerminateDebugSession)(listener, thisArg, disposables);\n            },\n            onDidChangeActiveDebugSession(listener, thisArg, disposables) {\n                return _asExtensionEvent(extHostDebugService.onDidChangeActiveDebugSession)(listener, thisArg, disposables);\n            },\n            onDidReceiveDebugSessionCustomEvent(listener, thisArg, disposables) {\n                return _asExtensionEvent(extHostDebugService.onDidReceiveDebugSessionCustomEvent)(listener, thisArg, disposables);\n            },\n            onDidChangeBreakpoints(listener, thisArgs, disposables) {\n                return _asExtensionEvent(extHostDebugService.onDidChangeBreakpoints)(listener, thisArgs, disposables);\n            },\n            onDidChangeActiveStackItem(listener, thisArg, disposables) {\n                return _asExtensionEvent(extHostDebugService.onDidChangeActiveStackItem)(listener, thisArg, disposables);\n            },\n            registerDebugConfigurationProvider(debugType, provider, triggerKind) {\n                return extHostDebugService.registerDebugConfigurationProvider(debugType, provider, triggerKind || DebugConfigurationProviderTriggerKind.Initial);\n            },\n            registerDebugAdapterDescriptorFactory(debugType, factory) {\n                return extHostDebugService.registerDebugAdapterDescriptorFactory(extension, debugType, factory);\n            },\n            registerDebugAdapterTrackerFactory(debugType, factory) {\n                return extHostDebugService.registerDebugAdapterTrackerFactory(debugType, factory);\n            },\n            startDebugging(folder, nameOrConfig, parentSessionOrOptions) {\n                if (!parentSessionOrOptions || (typeof parentSessionOrOptions === 'object' && 'configuration' in parentSessionOrOptions)) {\n                    return extHostDebugService.startDebugging(folder, nameOrConfig, { parentSession: parentSessionOrOptions });\n                }\n                return extHostDebugService.startDebugging(folder, nameOrConfig, parentSessionOrOptions || {});\n            },\n            stopDebugging(session) {\n                return extHostDebugService.stopDebugging(session);\n            },\n            addBreakpoints(breakpoints) {\n                return extHostDebugService.addBreakpoints(breakpoints);\n            },\n            removeBreakpoints(breakpoints) {\n                return extHostDebugService.removeBreakpoints(breakpoints);\n            },\n            asDebugSourceUri(source, session) {\n                return extHostDebugService.asDebugSourceUri(source, session);\n            }\n        };\n        const tasks = {\n            registerTaskProvider: (type, provider) => {\n                return extHostTask.registerTaskProvider(extension, type, provider);\n            },\n            fetchTasks: (filter) => {\n                return extHostTask.fetchTasks(filter);\n            },\n            executeTask: (task) => {\n                return extHostTask.executeTask(extension, task);\n            },\n            get taskExecutions() {\n                return extHostTask.taskExecutions;\n            },\n            onDidStartTask: (listeners, thisArgs, disposables) => {\n                return _asExtensionEvent(extHostTask.onDidStartTask)(listeners, thisArgs, disposables);\n            },\n            onDidEndTask: (listeners, thisArgs, disposables) => {\n                return _asExtensionEvent(extHostTask.onDidEndTask)(listeners, thisArgs, disposables);\n            },\n            onDidStartTaskProcess: (listeners, thisArgs, disposables) => {\n                return _asExtensionEvent(extHostTask.onDidStartTaskProcess)(listeners, thisArgs, disposables);\n            },\n            onDidEndTaskProcess: (listeners, thisArgs, disposables) => {\n                return _asExtensionEvent(extHostTask.onDidEndTaskProcess)(listeners, thisArgs, disposables);\n            }\n        };\n        const notebooks = {\n            createNotebookController(id, notebookType, label, handler, rendererScripts) {\n                return extHostNotebookKernels.createNotebookController(extension, id, notebookType, label, handler, isProposedApiEnabled(extension, 'notebookMessaging') ? rendererScripts : undefined);\n            },\n            registerNotebookCellStatusBarItemProvider: (notebookType, provider) => {\n                return extHostNotebook.registerNotebookCellStatusBarItemProvider(extension, notebookType, provider);\n            },\n            createRendererMessaging(rendererId) {\n                return extHostNotebookRenderers.createRendererMessaging(extension, rendererId);\n            },\n            createNotebookControllerDetectionTask(notebookType) {\n                checkProposedApiEnabled(extension, 'notebookKernelSource');\n                return extHostNotebookKernels.createNotebookControllerDetectionTask(extension, notebookType);\n            },\n            registerKernelSourceActionProvider(notebookType, provider) {\n                checkProposedApiEnabled(extension, 'notebookKernelSource');\n                return extHostNotebookKernels.registerKernelSourceActionProvider(extension, notebookType, provider);\n            },\n            onDidChangeNotebookCellExecutionState(listener, thisArgs, disposables) {\n                checkProposedApiEnabled(extension, 'notebookCellExecutionState');\n                return _asExtensionEvent(extHostNotebookKernels.onDidChangeNotebookCellExecutionState)(listener, thisArgs, disposables);\n            }\n        };\n        const l10n = {\n            t(...params) {\n                if (typeof params[0] === 'string') {\n                    const key = params.shift();\n                    const argsFormatted = !params || typeof params[0] !== 'object' ? params : params[0];\n                    return extHostLocalization.getMessage(extension.identifier.value, { message: key, args: argsFormatted });\n                }\n                return extHostLocalization.getMessage(extension.identifier.value, params[0]);\n            },\n            get bundle() {\n                return extHostLocalization.getBundle(extension.identifier.value);\n            },\n            get uri() {\n                return extHostLocalization.getBundleUri(extension.identifier.value);\n            }\n        };\n        const interactive = {\n            transferActiveChat(toWorkspace) {\n                checkProposedApiEnabled(extension, 'interactive');\n                return extHostChatAgents2.transferActiveChat(toWorkspace);\n            }\n        };\n        const ai = {\n            getRelatedInformation(query, types) {\n                checkProposedApiEnabled(extension, 'aiRelatedInformation');\n                return extHostAiRelatedInformation.getRelatedInformation(extension, query, types);\n            },\n            registerRelatedInformationProvider(type, provider) {\n                checkProposedApiEnabled(extension, 'aiRelatedInformation');\n                return extHostAiRelatedInformation.registerRelatedInformationProvider(extension, type, provider);\n            },\n            registerEmbeddingVectorProvider(model, provider) {\n                checkProposedApiEnabled(extension, 'aiRelatedInformation');\n                return extHostAiEmbeddingVector.registerEmbeddingVectorProvider(extension, model, provider);\n            }\n        };\n        const chat = {\n            registerChatResponseProvider(id, provider, metadata) {\n                checkProposedApiEnabled(extension, 'chatProvider');\n                return extHostLanguageModels.registerLanguageModel(extension, id, provider, metadata);\n            },\n            registerChatVariableResolver(id, name, userDescription, modelDescription, isSlow, resolver, fullName, icon) {\n                checkProposedApiEnabled(extension, 'chatVariableResolver');\n                return extHostChatVariables.registerVariableResolver(extension, id, name, userDescription, modelDescription, isSlow, resolver, fullName, icon?.id);\n            },\n            registerMappedEditsProvider(selector, provider) {\n                checkProposedApiEnabled(extension, 'mappedEditsProvider');\n                return extHostLanguageFeatures.registerMappedEditsProvider(extension, selector, provider);\n            },\n            registerMappedEditsProvider2(provider) {\n                checkProposedApiEnabled(extension, 'mappedEditsProvider');\n                return extHostCodeMapper.registerMappedEditsProvider(extension, provider);\n            },\n            createChatParticipant(id, handler) {\n                return extHostChatAgents2.createChatAgent(extension, id, handler);\n            },\n            createDynamicChatParticipant(id, dynamicProps, handler) {\n                checkProposedApiEnabled(extension, 'chatParticipantPrivate');\n                return extHostChatAgents2.createDynamicChatAgent(extension, id, dynamicProps, handler);\n            },\n            registerChatParticipantDetectionProvider(provider) {\n                checkProposedApiEnabled(extension, 'chatParticipantAdditions');\n                return extHostChatAgents2.registerChatParticipantDetectionProvider(extension, provider);\n            },\n        };\n        const lm = {\n            selectChatModels: (selector) => {\n                return extHostLanguageModels.selectLanguageModels(extension, selector ?? {});\n            },\n            onDidChangeChatModels: (listener, thisArgs, disposables) => {\n                return extHostLanguageModels.onDidChangeProviders(listener, thisArgs, disposables);\n            },\n            registerChatModelProvider: (id, provider, metadata) => {\n                checkProposedApiEnabled(extension, 'chatProvider');\n                return extHostLanguageModels.registerLanguageModel(extension, id, provider, metadata);\n            },\n            get embeddingModels() {\n                checkProposedApiEnabled(extension, 'embeddings');\n                return extHostEmbeddings.embeddingsModels;\n            },\n            onDidChangeEmbeddingModels: (listener, thisArgs, disposables) => {\n                checkProposedApiEnabled(extension, 'embeddings');\n                return extHostEmbeddings.onDidChange(listener, thisArgs, disposables);\n            },\n            registerEmbeddingsProvider(embeddingsModel, provider) {\n                checkProposedApiEnabled(extension, 'embeddings');\n                return extHostEmbeddings.registerEmbeddingsProvider(extension, embeddingsModel, provider);\n            },\n            async computeEmbeddings(embeddingsModel, input, token) {\n                checkProposedApiEnabled(extension, 'embeddings');\n                if (typeof input === 'string') {\n                    return extHostEmbeddings.computeEmbeddings(embeddingsModel, input, token);\n                }\n                else {\n                    return extHostEmbeddings.computeEmbeddings(embeddingsModel, input, token);\n                }\n            },\n            registerTool(toolId, tool) {\n                checkProposedApiEnabled(extension, 'lmTools');\n                return extHostLanguageModelTools.registerTool(extension, toolId, tool);\n            },\n            invokeTool(toolId, parameters, token) {\n                checkProposedApiEnabled(extension, 'lmTools');\n                return extHostLanguageModelTools.invokeTool(toolId, parameters, token);\n            },\n            get tools() {\n                checkProposedApiEnabled(extension, 'lmTools');\n                return extHostLanguageModelTools.tools;\n            },\n        };\n        const speech = {\n            registerSpeechProvider(id, provider) {\n                checkProposedApiEnabled(extension, 'speech');\n                return extHostSpeech.registerProvider(extension.identifier, id, provider);\n            }\n        };\n        return {\n            version: initData.version,\n            ai,\n            authentication,\n            commands,\n            comments,\n            chat,\n            debug,\n            env,\n            extensions,\n            interactive,\n            l10n,\n            languages,\n            lm,\n            notebooks,\n            scm,\n            speech,\n            tasks,\n            tests,\n            window,\n            workspace,\n            Breakpoint: Breakpoint,\n            TerminalOutputAnchor: TerminalOutputAnchor,\n            ChatResultFeedbackKind: ChatResultFeedbackKind,\n            ChatVariableLevel: ChatVariableLevel,\n            ChatCompletionItem: ChatCompletionItem,\n            CallHierarchyIncomingCall: CallHierarchyIncomingCall,\n            CallHierarchyItem: CallHierarchyItem,\n            CallHierarchyOutgoingCall: CallHierarchyOutgoingCall,\n            CancellationError: CancellationError,\n            CancellationTokenSource: CancellationTokenSource,\n            CandidatePortSource: CandidatePortSource,\n            CodeAction: CodeAction,\n            CodeActionKind: CodeActionKind,\n            CodeActionTriggerKind: CodeActionTriggerKind,\n            CodeLens: CodeLens,\n            Color: Color,\n            ColorInformation: ColorInformation,\n            ColorPresentation: ColorPresentation,\n            ColorThemeKind: ColorThemeKind,\n            CommentMode: CommentMode,\n            CommentState: CommentState,\n            CommentThreadCollapsibleState: CommentThreadCollapsibleState,\n            CommentThreadState: CommentThreadState,\n            CommentThreadApplicability: CommentThreadApplicability,\n            CommentThreadFocus: CommentThreadFocus,\n            CompletionItem: CompletionItem,\n            CompletionItemKind: CompletionItemKind,\n            CompletionItemTag: CompletionItemTag,\n            CompletionList: CompletionList,\n            CompletionTriggerKind: CompletionTriggerKind,\n            ConfigurationTarget: ConfigurationTarget,\n            CustomExecution: CustomExecution,\n            DebugAdapterExecutable: DebugAdapterExecutable,\n            DebugAdapterInlineImplementation: DebugAdapterInlineImplementation,\n            DebugAdapterNamedPipeServer: DebugAdapterNamedPipeServer,\n            DebugAdapterServer: DebugAdapterServer,\n            DebugConfigurationProviderTriggerKind: DebugConfigurationProviderTriggerKind,\n            DebugConsoleMode: DebugConsoleMode,\n            DebugVisualization: DebugVisualization,\n            DecorationRangeBehavior: DecorationRangeBehavior,\n            Diagnostic: Diagnostic,\n            DiagnosticRelatedInformation: DiagnosticRelatedInformation,\n            DiagnosticSeverity: DiagnosticSeverity,\n            DiagnosticTag: DiagnosticTag,\n            Disposable: Disposable,\n            DocumentHighlight: DocumentHighlight,\n            DocumentHighlightKind: DocumentHighlightKind,\n            MultiDocumentHighlight: MultiDocumentHighlight,\n            DocumentLink: DocumentLink,\n            DocumentSymbol: DocumentSymbol,\n            EndOfLine: EndOfLine,\n            EnvironmentVariableMutatorType: EnvironmentVariableMutatorType,\n            EvaluatableExpression: EvaluatableExpression,\n            InlineValueText: InlineValueText,\n            InlineValueVariableLookup: InlineValueVariableLookup,\n            InlineValueEvaluatableExpression: InlineValueEvaluatableExpression,\n            InlineCompletionTriggerKind: InlineCompletionTriggerKind,\n            EventEmitter: Emitter,\n            ExtensionKind: ExtensionKind,\n            ExtensionMode: ExtensionMode,\n            ExternalUriOpenerPriority: ExternalUriOpenerPriority,\n            FileChangeType: FileChangeType,\n            FileDecoration: FileDecoration,\n            FileDecoration2: FileDecoration,\n            FileSystemError: FileSystemError,\n            FileType: FileType,\n            FilePermission: FilePermission,\n            FoldingRange: FoldingRange,\n            FoldingRangeKind: FoldingRangeKind,\n            FunctionBreakpoint: FunctionBreakpoint,\n            InlineCompletionItem: InlineSuggestion,\n            InlineCompletionList: InlineSuggestionList,\n            Hover: Hover,\n            VerboseHover: VerboseHover,\n            HoverVerbosityAction: HoverVerbosityAction,\n            IndentAction: IndentAction,\n            Location: Location,\n            MarkdownString: MarkdownString,\n            OverviewRulerLane: OverviewRulerLane,\n            ParameterInformation: ParameterInformation,\n            PortAutoForwardAction: PortAutoForwardAction,\n            Position: Position,\n            ProcessExecution: ProcessExecution,\n            ProgressLocation: ProgressLocation,\n            QuickInputButtonLocation: QuickInputButtonLocation,\n            QuickInputButtons: QuickInputButtons,\n            Range: Range,\n            RelativePattern: RelativePattern,\n            Selection: Selection,\n            SelectionRange: SelectionRange,\n            SemanticTokens: SemanticTokens,\n            SemanticTokensBuilder: SemanticTokensBuilder,\n            SemanticTokensEdit: SemanticTokensEdit,\n            SemanticTokensEdits: SemanticTokensEdits,\n            SemanticTokensLegend: SemanticTokensLegend,\n            ShellExecution: ShellExecution,\n            ShellQuoting: ShellQuoting,\n            SignatureHelp: SignatureHelp,\n            SignatureHelpTriggerKind: SignatureHelpTriggerKind,\n            SignatureInformation: SignatureInformation,\n            SnippetString: SnippetString,\n            SourceBreakpoint: SourceBreakpoint,\n            StandardTokenType: StandardTokenType,\n            StatusBarAlignment: StatusBarAlignment,\n            SymbolInformation: SymbolInformation,\n            SymbolKind: SymbolKind,\n            SymbolTag: SymbolTag,\n            Task: Task,\n            TaskGroup: TaskGroup,\n            TaskPanelKind: TaskPanelKind,\n            TaskRevealKind: TaskRevealKind,\n            TaskScope: TaskScope,\n            TerminalLink: TerminalLink,\n            TerminalQuickFixTerminalCommand: TerminalQuickFixCommand,\n            TerminalQuickFixOpener: TerminalQuickFixOpener,\n            TerminalLocation: TerminalLocation,\n            TerminalProfile: TerminalProfile,\n            TerminalExitReason: TerminalExitReason,\n            TerminalShellExecutionCommandLineConfidence: TerminalShellExecutionCommandLineConfidence,\n            TextDocumentSaveReason: TextDocumentSaveReason,\n            TextEdit: TextEdit,\n            SnippetTextEdit: SnippetTextEdit,\n            TextEditorCursorStyle: TextEditorCursorStyle,\n            TextEditorLineNumbersStyle: TextEditorLineNumbersStyle,\n            TextEditorRevealType: TextEditorRevealType,\n            TextEditorSelectionChangeKind: TextEditorSelectionChangeKind,\n            SyntaxTokenType: SyntaxTokenType,\n            TextDocumentChangeReason: TextDocumentChangeReason,\n            ThemeColor: ThemeColor,\n            ThemeIcon: ThemeIcon,\n            TreeItem: TreeItem,\n            TreeItemCheckboxState: TreeItemCheckboxState,\n            TreeItemCollapsibleState: TreeItemCollapsibleState,\n            TypeHierarchyItem: TypeHierarchyItem,\n            UIKind: UIKind,\n            Uri: URI,\n            ViewColumn: ViewColumn,\n            WorkspaceEdit: WorkspaceEdit,\n            DocumentPasteTriggerKind: DocumentPasteTriggerKind,\n            DocumentDropEdit: DocumentDropEdit,\n            DocumentDropOrPasteEditKind: DocumentDropOrPasteEditKind,\n            DocumentPasteEdit: DocumentPasteEdit,\n            InlayHint: InlayHint,\n            InlayHintLabelPart: InlayHintLabelPart,\n            InlayHintKind: InlayHintKind,\n            RemoteAuthorityResolverError: RemoteAuthorityResolverError,\n            ResolvedAuthority: ResolvedAuthority,\n            ManagedResolvedAuthority: ManagedResolvedAuthority,\n            SourceControlInputBoxValidationType: SourceControlInputBoxValidationType,\n            ExtensionRuntime: ExtensionRuntime,\n            TimelineItem: TimelineItem,\n            NotebookRange: NotebookRange,\n            NotebookCellKind: NotebookCellKind,\n            NotebookCellExecutionState: NotebookCellExecutionState,\n            NotebookCellData: NotebookCellData,\n            NotebookData: NotebookData,\n            NotebookRendererScript: NotebookRendererScript,\n            NotebookCellStatusBarAlignment: NotebookCellStatusBarAlignment,\n            NotebookEditorRevealType: NotebookEditorRevealType,\n            NotebookCellOutput: NotebookCellOutput,\n            NotebookCellOutputItem: NotebookCellOutputItem,\n            NotebookCellStatusBarItem: NotebookCellStatusBarItem,\n            NotebookControllerAffinity: NotebookControllerAffinity,\n            NotebookControllerAffinity2: NotebookControllerAffinity2,\n            NotebookEdit: NotebookEdit,\n            NotebookKernelSourceAction: NotebookKernelSourceAction,\n            NotebookVariablesRequestKind: NotebookVariablesRequestKind,\n            PortAttributes: PortAttributes,\n            LinkedEditingRanges: LinkedEditingRanges,\n            TestResultState: TestResultState,\n            TestRunRequest: TestRunRequest,\n            TestMessage: TestMessage,\n            TestMessageStackFrame: TestMessageStackFrame,\n            TestTag: TestTag,\n            TestRunProfileKind: TestRunProfileKind,\n            TextSearchCompleteMessageType: TextSearchCompleteMessageType,\n            DataTransfer: DataTransfer,\n            DataTransferItem: DataTransferItem,\n            TestCoverageCount: TestCoverageCount,\n            FileCoverage: FileCoverage,\n            FileCoverage2: FileCoverage,\n            StatementCoverage: StatementCoverage,\n            BranchCoverage: BranchCoverage,\n            DeclarationCoverage: DeclarationCoverage,\n            WorkspaceTrustState: WorkspaceTrustState,\n            LanguageStatusSeverity: LanguageStatusSeverity,\n            QuickPickItemKind: QuickPickItemKind,\n            InputBoxValidationSeverity: InputBoxValidationSeverity,\n            TabInputText: TextTabInput,\n            TabInputTextDiff: TextDiffTabInput,\n            TabInputTextMerge: TextMergeTabInput,\n            TabInputCustom: CustomEditorTabInput,\n            TabInputNotebook: NotebookEditorTabInput,\n            TabInputNotebookDiff: NotebookDiffEditorTabInput,\n            TabInputWebview: WebviewEditorTabInput,\n            TabInputTerminal: TerminalEditorTabInput,\n            TabInputInteractiveWindow: InteractiveWindowInput,\n            TabInputChat: ChatEditorTabInput,\n            TabInputTextMultiDiff: TextMultiDiffTabInput,\n            TelemetryTrustedValue: TelemetryTrustedValue,\n            LogLevel: LogLevel,\n            EditSessionIdentityMatch: EditSessionIdentityMatch,\n            InteractiveSessionVoteDirection: InteractiveSessionVoteDirection,\n            ChatCopyKind: ChatCopyKind,\n            InteractiveEditorResponseFeedbackKind: InteractiveEditorResponseFeedbackKind,\n            DebugStackFrame: DebugStackFrame,\n            DebugThread: DebugThread,\n            RelatedInformationType: RelatedInformationType,\n            SpeechToTextStatus: SpeechToTextStatus,\n            TextToSpeechStatus: TextToSpeechStatus,\n            PartialAcceptTriggerKind: PartialAcceptTriggerKind,\n            KeywordRecognitionStatus: KeywordRecognitionStatus,\n            ChatResponseMarkdownPart: ChatResponseMarkdownPart,\n            ChatResponseFileTreePart: ChatResponseFileTreePart,\n            ChatResponseAnchorPart: ChatResponseAnchorPart,\n            ChatResponseProgressPart: ChatResponseProgressPart,\n            ChatResponseProgressPart2: ChatResponseProgressPart2,\n            ChatResponseReferencePart: ChatResponseReferencePart,\n            ChatResponseReferencePart2: ChatResponseReferencePart,\n            ChatResponseCodeCitationPart: ChatResponseCodeCitationPart,\n            ChatResponseCodeblockUriPart: ChatResponseCodeblockUriPart,\n            ChatResponseWarningPart: ChatResponseWarningPart,\n            ChatResponseTextEditPart: ChatResponseTextEditPart,\n            ChatResponseMarkdownWithVulnerabilitiesPart: ChatResponseMarkdownWithVulnerabilitiesPart,\n            ChatResponseCommandButtonPart: ChatResponseCommandButtonPart,\n            ChatResponseDetectedParticipantPart: ChatResponseDetectedParticipantPart,\n            ChatResponseConfirmationPart: ChatResponseConfirmationPart,\n            ChatResponseMovePart: ChatResponseMovePart,\n            ChatResponseReferencePartStatusKind: ChatResponseReferencePartStatusKind,\n            ChatRequestTurn: ChatRequestTurn,\n            ChatResponseTurn: ChatResponseTurn,\n            ChatLocation: ChatLocation,\n            ChatRequestEditorData: ChatRequestEditorData,\n            ChatRequestNotebookData: ChatRequestNotebookData,\n            LanguageModelChatMessageRole: LanguageModelChatMessageRole,\n            LanguageModelChatMessage: LanguageModelChatMessage,\n            LanguageModelChatMessageToolResultPart: LanguageModelToolResultPart,\n            LanguageModelChatResponseTextPart: LanguageModelTextPart,\n            LanguageModelChatResponseToolCallPart: LanguageModelToolCallPart,\n            LanguageModelError: LanguageModelError,\n            NewSymbolName: NewSymbolName,\n            NewSymbolNameTag: NewSymbolNameTag,\n            NewSymbolNameTriggerKind: NewSymbolNameTriggerKind,\n            InlineEdit: InlineEdit,\n            InlineEditTriggerKind: InlineEditTriggerKind,\n            ExcludeSettingOptions: ExcludeSettingOptions,\n            TextSearchContextNew: TextSearchContextNew,\n            TextSearchMatchNew: TextSearchMatchNew,\n            TextSearchCompleteMessageTypeNew: TextSearchCompleteMessageType,\n        };\n    };\n}\nexport { createApiFactoryAndRegisterActors };\n","import { registerSingleton } from '../../../platform/instantiation/common/extensions.js';\nimport { ExtHostOutputService, IExtHostOutputService } from './extHostOutput.js';\nimport { ExtHostWorkspace, IExtHostWorkspace } from './extHostWorkspace.js';\nimport { ExtHostDecorations, IExtHostDecorations } from './extHostDecorations.js';\nimport { ExtHostConfiguration, IExtHostConfiguration } from './extHostConfiguration.js';\nimport { ExtHostCommands, IExtHostCommands } from './extHostCommands.js';\nimport { ExtHostDocumentsAndEditors, IExtHostDocumentsAndEditors } from './extHostDocumentsAndEditors.js';\nimport { WorkerExtHostTerminalService, IExtHostTerminalService } from './extHostTerminalService.js';\nimport { WorkerExtHostTask, IExtHostTask } from './extHostTask.js';\nimport { WorkerExtHostDebugService, IExtHostDebugService } from './extHostDebugService.js';\nimport { ExtHostSearch, IExtHostSearch } from './extHostSearch.js';\nimport { ExtHostStorage, IExtHostStorage } from './extHostStorage.js';\nimport { ExtHostTunnelService, IExtHostTunnelService } from './extHostTunnelService.js';\nimport { ExtHostApiDeprecationService, IExtHostApiDeprecationService } from './extHostApiDeprecationService.js';\nimport { ExtHostWindow, IExtHostWindow } from './extHostWindow.js';\nimport { ExtHostConsumerFileSystem, IExtHostConsumerFileSystem } from './extHostFileSystemConsumer.js';\nimport { ExtHostFileSystemInfo, IExtHostFileSystemInfo } from './extHostFileSystemInfo.js';\nimport { ExtHostSecretState, IExtHostSecretState } from './extHostSecretState.js';\nimport { ExtHostTelemetry, IExtHostTelemetry } from './extHostTelemetry.js';\nimport { ExtHostEditorTabs, IExtHostEditorTabs } from './extHostEditorTabs.js';\nimport { ExtHostLoggerService } from './extHostLoggerService.js';\nimport { ILoggerService } from '../../../platform/log/common/log.service.js';\nimport { ExtHostVariableResolverProviderService, IExtHostVariableResolverProvider } from './extHostVariableResolverService.js';\nimport { ExtHostLocalizationService, IExtHostLocalizationService } from './extHostLocalizationService.js';\nimport { ExtHostManagedSockets, IExtHostManagedSockets } from './extHostManagedSockets.js';\nimport { ExtHostAuthentication, IExtHostAuthentication } from './extHostAuthentication.js';\nimport { ExtHostLanguageModels, IExtHostLanguageModels } from './extHostLanguageModels.js';\nimport { ExtHostTerminalShellIntegration, IExtHostTerminalShellIntegration } from './extHostTerminalShellIntegration.js';\nimport { ExtHostTesting, IExtHostTesting } from './extHostTesting.js';\nregisterSingleton(IExtHostLocalizationService, ExtHostLocalizationService, 1 );\nregisterSingleton(ILoggerService, ExtHostLoggerService, 1 );\nregisterSingleton(IExtHostApiDeprecationService, ExtHostApiDeprecationService, 1 );\nregisterSingleton(IExtHostCommands, ExtHostCommands, 0 );\nregisterSingleton(IExtHostAuthentication, ExtHostAuthentication, 0 );\nregisterSingleton(IExtHostLanguageModels, ExtHostLanguageModels, 0 );\nregisterSingleton(IExtHostConfiguration, ExtHostConfiguration, 0 );\nregisterSingleton(IExtHostConsumerFileSystem, ExtHostConsumerFileSystem, 0 );\nregisterSingleton(IExtHostTesting, ExtHostTesting, 0 );\nregisterSingleton(IExtHostDebugService, WorkerExtHostDebugService, 0 );\nregisterSingleton(IExtHostDecorations, ExtHostDecorations, 0 );\nregisterSingleton(IExtHostDocumentsAndEditors, ExtHostDocumentsAndEditors, 0 );\nregisterSingleton(IExtHostManagedSockets, ExtHostManagedSockets, 0 );\nregisterSingleton(IExtHostFileSystemInfo, ExtHostFileSystemInfo, 0 );\nregisterSingleton(IExtHostOutputService, ExtHostOutputService, 1 );\nregisterSingleton(IExtHostSearch, ExtHostSearch, 0 );\nregisterSingleton(IExtHostStorage, ExtHostStorage, 0 );\nregisterSingleton(IExtHostTask, WorkerExtHostTask, 0 );\nregisterSingleton(IExtHostTerminalService, WorkerExtHostTerminalService, 0 );\nregisterSingleton(IExtHostTerminalShellIntegration, ExtHostTerminalShellIntegration, 0 );\nregisterSingleton(IExtHostTunnelService, ExtHostTunnelService, 0 );\nregisterSingleton(IExtHostWindow, ExtHostWindow, 0 );\nregisterSingleton(IExtHostWorkspace, ExtHostWorkspace, 0 );\nregisterSingleton(IExtHostSecretState, ExtHostSecretState, 0 );\nregisterSingleton(IExtHostTelemetry, ExtHostTelemetry, 0 );\nregisterSingleton(IExtHostEditorTabs, ExtHostEditorTabs, 0 );\nregisterSingleton(IExtHostVariableResolverProvider, ExtHostVariableResolverProviderService, 0 );\n","import { createProxyIdentifier } from '../../services/extensions/common/proxyIdentifier.js';\nvar TextEditorRevealType;\n( (function(TextEditorRevealType) {\n    TextEditorRevealType[TextEditorRevealType[\"Default\"] = 0] = \"Default\";\n    TextEditorRevealType[TextEditorRevealType[\"InCenter\"] = 1] = \"InCenter\";\n    TextEditorRevealType[TextEditorRevealType[\"InCenterIfOutsideViewport\"] = 2] = \"InCenterIfOutsideViewport\";\n    TextEditorRevealType[TextEditorRevealType[\"AtTop\"] = 3] = \"AtTop\";\n})(TextEditorRevealType || (TextEditorRevealType = {})));\nvar NotebookEditorRevealType;\n( (function(NotebookEditorRevealType) {\n    NotebookEditorRevealType[NotebookEditorRevealType[\"Default\"] = 0] = \"Default\";\n    NotebookEditorRevealType[NotebookEditorRevealType[\"InCenter\"] = 1] = \"InCenter\";\n    NotebookEditorRevealType[NotebookEditorRevealType[\"InCenterIfOutsideViewport\"] = 2] = \"InCenterIfOutsideViewport\";\n    NotebookEditorRevealType[NotebookEditorRevealType[\"AtTop\"] = 3] = \"AtTop\";\n})(NotebookEditorRevealType || (NotebookEditorRevealType = {})));\nvar CandidatePortSource;\n( (function(CandidatePortSource) {\n    CandidatePortSource[CandidatePortSource[\"None\"] = 0] = \"None\";\n    CandidatePortSource[CandidatePortSource[\"Process\"] = 1] = \"Process\";\n    CandidatePortSource[CandidatePortSource[\"Output\"] = 2] = \"Output\";\n    CandidatePortSource[CandidatePortSource[\"Hybrid\"] = 3] = \"Hybrid\";\n})(CandidatePortSource || (CandidatePortSource = {})));\nconst MainContext = {\n    MainThreadAuthentication: ( createProxyIdentifier('MainThreadAuthentication')),\n    MainThreadBulkEdits: ( createProxyIdentifier('MainThreadBulkEdits')),\n    MainThreadLanguageModels: ( createProxyIdentifier('MainThreadLanguageModels')),\n    MainThreadEmbeddings: ( createProxyIdentifier('MainThreadEmbeddings')),\n    MainThreadChatAgents2: ( createProxyIdentifier('MainThreadChatAgents2')),\n    MainThreadCodeMapper: ( createProxyIdentifier('MainThreadCodeMapper')),\n    MainThreadChatVariables: ( createProxyIdentifier('MainThreadChatVariables')),\n    MainThreadLanguageModelTools: ( createProxyIdentifier('MainThreadChatSkills')),\n    MainThreadClipboard: ( createProxyIdentifier('MainThreadClipboard')),\n    MainThreadCommands: ( createProxyIdentifier('MainThreadCommands')),\n    MainThreadComments: ( createProxyIdentifier('MainThreadComments')),\n    MainThreadConfiguration: ( createProxyIdentifier('MainThreadConfiguration')),\n    MainThreadConsole: ( createProxyIdentifier('MainThreadConsole')),\n    MainThreadDebugService: ( createProxyIdentifier('MainThreadDebugService')),\n    MainThreadDecorations: ( createProxyIdentifier('MainThreadDecorations')),\n    MainThreadDiagnostics: ( createProxyIdentifier('MainThreadDiagnostics')),\n    MainThreadDialogs: ( createProxyIdentifier('MainThreadDiaglogs')),\n    MainThreadDocuments: ( createProxyIdentifier('MainThreadDocuments')),\n    MainThreadDocumentContentProviders: ( createProxyIdentifier('MainThreadDocumentContentProviders')),\n    MainThreadTextEditors: ( createProxyIdentifier('MainThreadTextEditors')),\n    MainThreadEditorInsets: ( createProxyIdentifier('MainThreadEditorInsets')),\n    MainThreadEditorTabs: ( createProxyIdentifier('MainThreadEditorTabs')),\n    MainThreadErrors: ( createProxyIdentifier('MainThreadErrors')),\n    MainThreadTreeViews: ( createProxyIdentifier('MainThreadTreeViews')),\n    MainThreadDownloadService: ( createProxyIdentifier('MainThreadDownloadService')),\n    MainThreadLanguageFeatures: ( createProxyIdentifier('MainThreadLanguageFeatures')),\n    MainThreadLanguages: ( createProxyIdentifier('MainThreadLanguages')),\n    MainThreadLogger: ( createProxyIdentifier('MainThreadLogger')),\n    MainThreadMessageService: ( createProxyIdentifier('MainThreadMessageService')),\n    MainThreadOutputService: ( createProxyIdentifier('MainThreadOutputService')),\n    MainThreadProgress: ( createProxyIdentifier('MainThreadProgress')),\n    MainThreadQuickDiff: ( createProxyIdentifier('MainThreadQuickDiff')),\n    MainThreadQuickOpen: ( createProxyIdentifier('MainThreadQuickOpen')),\n    MainThreadStatusBar: ( createProxyIdentifier('MainThreadStatusBar')),\n    MainThreadSecretState: ( createProxyIdentifier('MainThreadSecretState')),\n    MainThreadStorage: ( createProxyIdentifier('MainThreadStorage')),\n    MainThreadSpeech: ( createProxyIdentifier('MainThreadSpeechProvider')),\n    MainThreadTelemetry: ( createProxyIdentifier('MainThreadTelemetry')),\n    MainThreadTerminalService: ( createProxyIdentifier('MainThreadTerminalService')),\n    MainThreadTerminalShellIntegration: ( createProxyIdentifier('MainThreadTerminalShellIntegration')),\n    MainThreadWebviews: ( createProxyIdentifier('MainThreadWebviews')),\n    MainThreadWebviewPanels: ( createProxyIdentifier('MainThreadWebviewPanels')),\n    MainThreadWebviewViews: ( createProxyIdentifier('MainThreadWebviewViews')),\n    MainThreadCustomEditors: ( createProxyIdentifier('MainThreadCustomEditors')),\n    MainThreadUrls: ( createProxyIdentifier('MainThreadUrls')),\n    MainThreadUriOpeners: ( createProxyIdentifier('MainThreadUriOpeners')),\n    MainThreadProfileContentHandlers: ( createProxyIdentifier('MainThreadProfileContentHandlers')),\n    MainThreadWorkspace: ( createProxyIdentifier('MainThreadWorkspace')),\n    MainThreadFileSystem: ( createProxyIdentifier('MainThreadFileSystem')),\n    MainThreadFileSystemEventService: ( createProxyIdentifier('MainThreadFileSystemEventService')),\n    MainThreadExtensionService: ( createProxyIdentifier('MainThreadExtensionService')),\n    MainThreadSCM: ( createProxyIdentifier('MainThreadSCM')),\n    MainThreadSearch: ( createProxyIdentifier('MainThreadSearch')),\n    MainThreadShare: ( createProxyIdentifier('MainThreadShare')),\n    MainThreadTask: ( createProxyIdentifier('MainThreadTask')),\n    MainThreadWindow: ( createProxyIdentifier('MainThreadWindow')),\n    MainThreadLabelService: ( createProxyIdentifier('MainThreadLabelService')),\n    MainThreadNotebook: ( createProxyIdentifier('MainThreadNotebook')),\n    MainThreadNotebookDocuments: ( createProxyIdentifier('MainThreadNotebookDocumentsShape')),\n    MainThreadNotebookEditors: ( createProxyIdentifier('MainThreadNotebookEditorsShape')),\n    MainThreadNotebookKernels: ( createProxyIdentifier('MainThreadNotebookKernels')),\n    MainThreadNotebookRenderers: ( createProxyIdentifier('MainThreadNotebookRenderers')),\n    MainThreadInteractive: ( createProxyIdentifier('MainThreadInteractive')),\n    MainThreadTheming: ( createProxyIdentifier('MainThreadTheming')),\n    MainThreadTunnelService: ( createProxyIdentifier('MainThreadTunnelService')),\n    MainThreadManagedSockets: ( createProxyIdentifier('MainThreadManagedSockets')),\n    MainThreadTimeline: ( createProxyIdentifier('MainThreadTimeline')),\n    MainThreadTesting: ( createProxyIdentifier('MainThreadTesting')),\n    MainThreadLocalization: ( createProxyIdentifier('MainThreadLocalizationShape')),\n    MainThreadAiRelatedInformation: ( createProxyIdentifier('MainThreadAiRelatedInformation')),\n    MainThreadAiEmbeddingVector: ( createProxyIdentifier('MainThreadAiEmbeddingVector'))\n};\nconst ExtHostContext = {\n    ExtHostCodeMapper: ( createProxyIdentifier('ExtHostCodeMapper')),\n    ExtHostCommands: ( createProxyIdentifier('ExtHostCommands')),\n    ExtHostConfiguration: ( createProxyIdentifier('ExtHostConfiguration')),\n    ExtHostDiagnostics: ( createProxyIdentifier('ExtHostDiagnostics')),\n    ExtHostDebugService: ( createProxyIdentifier('ExtHostDebugService')),\n    ExtHostDecorations: ( createProxyIdentifier('ExtHostDecorations')),\n    ExtHostDocumentsAndEditors: ( createProxyIdentifier('ExtHostDocumentsAndEditors')),\n    ExtHostDocuments: ( createProxyIdentifier('ExtHostDocuments')),\n    ExtHostDocumentContentProviders: ( createProxyIdentifier('ExtHostDocumentContentProviders')),\n    ExtHostDocumentSaveParticipant: ( createProxyIdentifier('ExtHostDocumentSaveParticipant')),\n    ExtHostEditors: ( createProxyIdentifier('ExtHostEditors')),\n    ExtHostTreeViews: ( createProxyIdentifier('ExtHostTreeViews')),\n    ExtHostFileSystem: ( createProxyIdentifier('ExtHostFileSystem')),\n    ExtHostFileSystemInfo: ( createProxyIdentifier('ExtHostFileSystemInfo')),\n    ExtHostFileSystemEventService: ( createProxyIdentifier('ExtHostFileSystemEventService')),\n    ExtHostLanguages: ( createProxyIdentifier('ExtHostLanguages')),\n    ExtHostLanguageFeatures: ( createProxyIdentifier('ExtHostLanguageFeatures')),\n    ExtHostQuickOpen: ( createProxyIdentifier('ExtHostQuickOpen')),\n    ExtHostQuickDiff: ( createProxyIdentifier('ExtHostQuickDiff')),\n    ExtHostStatusBar: ( createProxyIdentifier('ExtHostStatusBar')),\n    ExtHostShare: ( createProxyIdentifier('ExtHostShare')),\n    ExtHostExtensionService: ( createProxyIdentifier('ExtHostExtensionService')),\n    ExtHostLogLevelServiceShape: ( createProxyIdentifier('ExtHostLogLevelServiceShape')),\n    ExtHostTerminalService: ( createProxyIdentifier('ExtHostTerminalService')),\n    ExtHostTerminalShellIntegration: ( createProxyIdentifier('ExtHostTerminalShellIntegration')),\n    ExtHostSCM: ( createProxyIdentifier('ExtHostSCM')),\n    ExtHostSearch: ( createProxyIdentifier('ExtHostSearch')),\n    ExtHostTask: ( createProxyIdentifier('ExtHostTask')),\n    ExtHostWorkspace: ( createProxyIdentifier('ExtHostWorkspace')),\n    ExtHostWindow: ( createProxyIdentifier('ExtHostWindow')),\n    ExtHostWebviews: ( createProxyIdentifier('ExtHostWebviews')),\n    ExtHostWebviewPanels: ( createProxyIdentifier('ExtHostWebviewPanels')),\n    ExtHostCustomEditors: ( createProxyIdentifier('ExtHostCustomEditors')),\n    ExtHostWebviewViews: ( createProxyIdentifier('ExtHostWebviewViews')),\n    ExtHostEditorInsets: ( createProxyIdentifier('ExtHostEditorInsets')),\n    ExtHostEditorTabs: ( createProxyIdentifier('ExtHostEditorTabs')),\n    ExtHostProgress: ( createProxyIdentifier('ExtHostProgress')),\n    ExtHostComments: ( createProxyIdentifier('ExtHostComments')),\n    ExtHostSecretState: ( createProxyIdentifier('ExtHostSecretState')),\n    ExtHostStorage: ( createProxyIdentifier('ExtHostStorage')),\n    ExtHostUrls: ( createProxyIdentifier('ExtHostUrls')),\n    ExtHostUriOpeners: ( createProxyIdentifier('ExtHostUriOpeners')),\n    ExtHostProfileContentHandlers: ( createProxyIdentifier('ExtHostProfileContentHandlers')),\n    ExtHostOutputService: ( createProxyIdentifier('ExtHostOutputService')),\n    ExtHostLabelService: ( createProxyIdentifier('ExtHostLabelService')),\n    ExtHostNotebook: ( createProxyIdentifier('ExtHostNotebook')),\n    ExtHostNotebookDocuments: ( createProxyIdentifier('ExtHostNotebookDocuments')),\n    ExtHostNotebookEditors: ( createProxyIdentifier('ExtHostNotebookEditors')),\n    ExtHostNotebookKernels: ( createProxyIdentifier('ExtHostNotebookKernels')),\n    ExtHostNotebookRenderers: ( createProxyIdentifier('ExtHostNotebookRenderers')),\n    ExtHostNotebookDocumentSaveParticipant: ( createProxyIdentifier('ExtHostNotebookDocumentSaveParticipant')),\n    ExtHostInteractive: ( createProxyIdentifier('ExtHostInteractive')),\n    ExtHostChatAgents2: ( createProxyIdentifier('ExtHostChatAgents')),\n    ExtHostChatVariables: ( createProxyIdentifier('ExtHostChatVariables')),\n    ExtHostLanguageModelTools: ( createProxyIdentifier('ExtHostChatSkills')),\n    ExtHostChatProvider: ( createProxyIdentifier('ExtHostChatProvider')),\n    ExtHostSpeech: ( createProxyIdentifier('ExtHostSpeech')),\n    ExtHostEmbeddings: ( createProxyIdentifier('ExtHostEmbeddings')),\n    ExtHostAiRelatedInformation: ( createProxyIdentifier('ExtHostAiRelatedInformation')),\n    ExtHostAiEmbeddingVector: ( createProxyIdentifier('ExtHostAiEmbeddingVector')),\n    ExtHostTheming: ( createProxyIdentifier('ExtHostTheming')),\n    ExtHostTunnelService: ( createProxyIdentifier('ExtHostTunnelService')),\n    ExtHostManagedSockets: ( createProxyIdentifier('ExtHostManagedSockets')),\n    ExtHostAuthentication: ( createProxyIdentifier('ExtHostAuthentication')),\n    ExtHostTimeline: ( createProxyIdentifier('ExtHostTimeline')),\n    ExtHostTesting: ( createProxyIdentifier('ExtHostTesting')),\n    ExtHostTelemetry: ( createProxyIdentifier('ExtHostTelemetry')),\n    ExtHostLocalization: ( createProxyIdentifier('ExtHostLocalization'))\n};\nexport { CandidatePortSource, ExtHostContext, MainContext, NotebookEditorRevealType, TextEditorRevealType };\n","import { MainContext } from './extHost.protocol.js';\nimport { Disposable } from './extHostTypes.js';\nclass ExtHostRelatedInformation {\n    constructor(mainContext) {\n        this._relatedInformationProviders = ( new Map());\n        this._nextHandle = 0;\n        this._proxy = ( mainContext.getProxy(MainContext.MainThreadAiRelatedInformation));\n    }\n    async $provideAiRelatedInformation(handle, query, token) {\n        if (this._relatedInformationProviders.size === 0) {\n            throw ( new Error('No related information providers registered'));\n        }\n        const provider = this._relatedInformationProviders.get(handle);\n        if (!provider) {\n            throw ( new Error('related information provider not found'));\n        }\n        const result = (await provider.provideRelatedInformation(query, token)) ?? [];\n        return result;\n    }\n    getRelatedInformation(extension, query, types) {\n        return this._proxy.$getAiRelatedInformation(query, types);\n    }\n    registerRelatedInformationProvider(extension, type, provider) {\n        const handle = this._nextHandle;\n        this._nextHandle++;\n        this._relatedInformationProviders.set(handle, provider);\n        this._proxy.$registerAiRelatedInformationProvider(handle, type);\n        return ( new Disposable(() => {\n            this._proxy.$unregisterAiRelatedInformationProvider(handle);\n            this._relatedInformationProviders.delete(handle);\n        }));\n    }\n}\nexport { ExtHostRelatedInformation };\n","import { isFalsyOrEmpty } from '../../../base/common/arrays.js';\nimport { matchesSomeScheme, Schemas } from '../../../base/common/network.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { isLocationLink } from '../../../editor/common/languages.js';\nimport { decodeSemanticTokensDto } from '../../../editor/common/services/semanticTokensDto.js';\nimport { validateWhenClauses } from '../../../platform/contextkey/common/contextkey.js';\nimport { ApiCommand, ApiCommandArgument, ApiCommandResult } from './extHostCommands.js';\nimport { Position as Position$1, Range, WorkspaceSymbol, CallHierarchyItem, CallHierarchyIncomingCall, CallHierarchyOutgoingCall, WorkspaceEdit, DocumentLink, CompletionItem, SignatureHelp, Selection as Selection$1, Color, ColorPresentation, InlayHint, FoldingRange, InlineValueContext, InlineValue, ViewColumn, TextEditorOpenOptions, TypeHierarchyItem, MappedEditsContext, DefinitionLink, location, DocumentHighlight, SymbolKind, TextEdit, Hover, NotebookExclusiveDocumentPattern } from './extHostTypeConverters.js';\nimport { Position, SelectionRange, SemanticTokensLegend, SemanticTokens, CompletionList, Range as Range$1, Selection, ColorInformation, Color as Color$1, SymbolInformation, Location, CodeLens, CodeAction, CodeActionKind } from './extHostTypes.js';\nconst newCommands = [\n    (\n    new ApiCommand(\n        'vscode.executeDocumentHighlights',\n        '_executeDocumentHighlights',\n        'Execute document highlight provider.',\n        [ApiCommandArgument.Uri, ApiCommandArgument.Position],\n        ( new ApiCommandResult(\n            'A promise that resolves to an array of DocumentHighlight-instances.',\n            tryMapWith(DocumentHighlight.to)\n        ))\n    )),\n    (\n    new ApiCommand(\n        'vscode.executeDocumentSymbolProvider',\n        '_executeDocumentSymbolProvider',\n        'Execute document symbol provider.',\n        [ApiCommandArgument.Uri],\n        ( new ApiCommandResult(\n            'A promise that resolves to an array of SymbolInformation and DocumentSymbol instances.',\n            (value, apiArgs) => {\n                if (isFalsyOrEmpty(value)) {\n                    return undefined;\n                }\n                class MergedInfo extends SymbolInformation {\n                    static to(symbol) {\n                        const res = ( new MergedInfo(\n                            symbol.name,\n                            SymbolKind.to(symbol.kind),\n                            symbol.containerName || '',\n                            new Location(apiArgs[0], Range.to(symbol.range))\n                        ));\n                        res.detail = symbol.detail;\n                        res.range = res.location.range;\n                        res.selectionRange = Range.to(symbol.selectionRange);\n                        res.children = symbol.children ? ( symbol.children.map(MergedInfo.to)) : [];\n                        return res;\n                    }\n                }\n                return ( value.map(MergedInfo.to));\n            }\n        ))\n    )),\n    (\n    new ApiCommand(\n        'vscode.executeFormatDocumentProvider',\n        '_executeFormatDocumentProvider',\n        'Execute document format provider.',\n        [ApiCommandArgument.Uri, ( new ApiCommandArgument('options', 'Formatting options', _ => true, v => v))],\n        ( new ApiCommandResult(\n            'A promise that resolves to an array of TextEdits.',\n            tryMapWith(TextEdit.to)\n        ))\n    )),\n    ( new ApiCommand(\n        'vscode.executeFormatRangeProvider',\n        '_executeFormatRangeProvider',\n        'Execute range format provider.',\n        [ApiCommandArgument.Uri, ApiCommandArgument.Range, ( new ApiCommandArgument('options', 'Formatting options', _ => true, v => v))],\n        ( new ApiCommandResult(\n            'A promise that resolves to an array of TextEdits.',\n            tryMapWith(TextEdit.to)\n        ))\n    )),\n    ( new ApiCommand(\n        'vscode.executeFormatOnTypeProvider',\n        '_executeFormatOnTypeProvider',\n        'Execute format on type provider.',\n        [ApiCommandArgument.Uri, ApiCommandArgument.Position, ( new ApiCommandArgument('ch', 'Trigger character', v => typeof v === 'string', v => v)), ( new ApiCommandArgument('options', 'Formatting options', _ => true, v => v))],\n        ( new ApiCommandResult(\n            'A promise that resolves to an array of TextEdits.',\n            tryMapWith(TextEdit.to)\n        ))\n    )),\n    (\n    new ApiCommand(\n        'vscode.executeDefinitionProvider',\n        '_executeDefinitionProvider',\n        'Execute all definition providers.',\n        [ApiCommandArgument.Uri, ApiCommandArgument.Position],\n        ( new ApiCommandResult(\n            'A promise that resolves to an array of Location or LocationLink instances.',\n            mapLocationOrLocationLink\n        ))\n    )),\n    ( new ApiCommand(\n        'vscode.experimental.executeDefinitionProvider_recursive',\n        '_executeDefinitionProvider_recursive',\n        'Execute all definition providers.',\n        [ApiCommandArgument.Uri, ApiCommandArgument.Position],\n        ( new ApiCommandResult(\n            'A promise that resolves to an array of Location or LocationLink instances.',\n            mapLocationOrLocationLink\n        ))\n    )),\n    ( new ApiCommand(\n        'vscode.executeTypeDefinitionProvider',\n        '_executeTypeDefinitionProvider',\n        'Execute all type definition providers.',\n        [ApiCommandArgument.Uri, ApiCommandArgument.Position],\n        ( new ApiCommandResult(\n            'A promise that resolves to an array of Location or LocationLink instances.',\n            mapLocationOrLocationLink\n        ))\n    )),\n    ( new ApiCommand(\n        'vscode.experimental.executeTypeDefinitionProvider_recursive',\n        '_executeTypeDefinitionProvider_recursive',\n        'Execute all type definition providers.',\n        [ApiCommandArgument.Uri, ApiCommandArgument.Position],\n        ( new ApiCommandResult(\n            'A promise that resolves to an array of Location or LocationLink instances.',\n            mapLocationOrLocationLink\n        ))\n    )),\n    ( new ApiCommand(\n        'vscode.executeDeclarationProvider',\n        '_executeDeclarationProvider',\n        'Execute all declaration providers.',\n        [ApiCommandArgument.Uri, ApiCommandArgument.Position],\n        ( new ApiCommandResult(\n            'A promise that resolves to an array of Location or LocationLink instances.',\n            mapLocationOrLocationLink\n        ))\n    )),\n    ( new ApiCommand(\n        'vscode.experimental.executeDeclarationProvider_recursive',\n        '_executeDeclarationProvider_recursive',\n        'Execute all declaration providers.',\n        [ApiCommandArgument.Uri, ApiCommandArgument.Position],\n        ( new ApiCommandResult(\n            'A promise that resolves to an array of Location or LocationLink instances.',\n            mapLocationOrLocationLink\n        ))\n    )),\n    ( new ApiCommand(\n        'vscode.executeImplementationProvider',\n        '_executeImplementationProvider',\n        'Execute all implementation providers.',\n        [ApiCommandArgument.Uri, ApiCommandArgument.Position],\n        ( new ApiCommandResult(\n            'A promise that resolves to an array of Location or LocationLink instances.',\n            mapLocationOrLocationLink\n        ))\n    )),\n    ( new ApiCommand(\n        'vscode.experimental.executeImplementationProvider_recursive',\n        '_executeImplementationProvider_recursive',\n        'Execute all implementation providers.',\n        [ApiCommandArgument.Uri, ApiCommandArgument.Position],\n        ( new ApiCommandResult(\n            'A promise that resolves to an array of Location or LocationLink instances.',\n            mapLocationOrLocationLink\n        ))\n    )),\n    ( new ApiCommand(\n        'vscode.executeReferenceProvider',\n        '_executeReferenceProvider',\n        'Execute all reference providers.',\n        [ApiCommandArgument.Uri, ApiCommandArgument.Position],\n        ( new ApiCommandResult(\n            'A promise that resolves to an array of Location-instances.',\n            tryMapWith(location.to)\n        ))\n    )),\n    ( new ApiCommand(\n        'vscode.experimental.executeReferenceProvider',\n        '_executeReferenceProvider_recursive',\n        'Execute all reference providers.',\n        [ApiCommandArgument.Uri, ApiCommandArgument.Position],\n        ( new ApiCommandResult(\n            'A promise that resolves to an array of Location-instances.',\n            tryMapWith(location.to)\n        ))\n    )),\n    (\n    new ApiCommand(\n        'vscode.executeHoverProvider',\n        '_executeHoverProvider',\n        'Execute all hover providers.',\n        [ApiCommandArgument.Uri, ApiCommandArgument.Position],\n        ( new ApiCommandResult(\n            'A promise that resolves to an array of Hover-instances.',\n            tryMapWith(Hover.to)\n        ))\n    )),\n    ( new ApiCommand(\n        'vscode.experimental.executeHoverProvider_recursive',\n        '_executeHoverProvider_recursive',\n        'Execute all hover providers.',\n        [ApiCommandArgument.Uri, ApiCommandArgument.Position],\n        ( new ApiCommandResult(\n            'A promise that resolves to an array of Hover-instances.',\n            tryMapWith(Hover.to)\n        ))\n    )),\n    (\n    new ApiCommand(\n        'vscode.executeSelectionRangeProvider',\n        '_executeSelectionRangeProvider',\n        'Execute selection range provider.',\n        [ApiCommandArgument.Uri, ( new ApiCommandArgument(\n            'position',\n            'A position in a text document',\n            v => Array.isArray(v) && v.every(v => Position.isPosition(v)),\n            v => ( v.map(Position$1.from))\n        ))],\n        ( new ApiCommandResult('A promise that resolves to an array of ranges.', result => {\n            return ( result.map(ranges => {\n                let node;\n                for (const range of ranges.reverse()) {\n                    node = new SelectionRange(Range.to(range), node);\n                }\n                return node;\n            }));\n        }))\n    )),\n    (\n    new ApiCommand(\n        'vscode.executeWorkspaceSymbolProvider',\n        '_executeWorkspaceSymbolProvider',\n        'Execute all workspace symbol providers.',\n        [ApiCommandArgument.String.with('query', 'Search string')],\n        ( new ApiCommandResult(\n            'A promise that resolves to an array of SymbolInformation-instances.',\n            value => {\n                return ( value.map(WorkspaceSymbol.to));\n            }\n        ))\n    )),\n    (\n    new ApiCommand(\n        'vscode.prepareCallHierarchy',\n        '_executePrepareCallHierarchy',\n        'Prepare call hierarchy at a position inside a document',\n        [ApiCommandArgument.Uri, ApiCommandArgument.Position],\n        ( new ApiCommandResult(\n            'A promise that resolves to an array of CallHierarchyItem-instances',\n            v => ( v.map(CallHierarchyItem.to))\n        ))\n    )),\n    ( new ApiCommand(\n        'vscode.provideIncomingCalls',\n        '_executeProvideIncomingCalls',\n        'Compute incoming calls for an item',\n        [ApiCommandArgument.CallHierarchyItem],\n        ( new ApiCommandResult(\n            'A promise that resolves to an array of CallHierarchyIncomingCall-instances',\n            v => ( v.map(CallHierarchyIncomingCall.to))\n        ))\n    )),\n    ( new ApiCommand(\n        'vscode.provideOutgoingCalls',\n        '_executeProvideOutgoingCalls',\n        'Compute outgoing calls for an item',\n        [ApiCommandArgument.CallHierarchyItem],\n        ( new ApiCommandResult(\n            'A promise that resolves to an array of CallHierarchyOutgoingCall-instances',\n            v => ( v.map(CallHierarchyOutgoingCall.to))\n        ))\n    )),\n    (\n    new ApiCommand(\n        'vscode.prepareRename',\n        '_executePrepareRename',\n        'Execute the prepareRename of rename provider.',\n        [ApiCommandArgument.Uri, ApiCommandArgument.Position],\n        ( new ApiCommandResult('A promise that resolves to a range and placeholder text.', value => {\n            if (!value) {\n                return undefined;\n            }\n            return {\n                range: Range.to(value.range),\n                placeholder: value.text\n            };\n        }))\n    )),\n    ( new ApiCommand(\n        'vscode.executeDocumentRenameProvider',\n        '_executeDocumentRenameProvider',\n        'Execute rename provider.',\n        [ApiCommandArgument.Uri, ApiCommandArgument.Position, ApiCommandArgument.String.with('newName', 'The new symbol name')],\n        ( new ApiCommandResult('A promise that resolves to a WorkspaceEdit.', value => {\n            if (!value) {\n                return undefined;\n            }\n            if (value.rejectReason) {\n                throw ( new Error(value.rejectReason));\n            }\n            return WorkspaceEdit.to(value);\n        }))\n    )),\n    (\n    new ApiCommand(\n        'vscode.executeLinkProvider',\n        '_executeLinkProvider',\n        'Execute document link provider.',\n        [ApiCommandArgument.Uri, ApiCommandArgument.Number.with('linkResolveCount', 'Number of links that should be resolved, only when links are unresolved.').optional()],\n        ( new ApiCommandResult(\n            'A promise that resolves to an array of DocumentLink-instances.',\n            value => ( value.map(DocumentLink.to))\n        ))\n    )),\n    (\n    new ApiCommand(\n        'vscode.provideDocumentSemanticTokensLegend',\n        '_provideDocumentSemanticTokensLegend',\n        'Provide semantic tokens legend for a document',\n        [ApiCommandArgument.Uri],\n        ( new ApiCommandResult('A promise that resolves to SemanticTokensLegend.', value => {\n            if (!value) {\n                return undefined;\n            }\n            return new SemanticTokensLegend(value.tokenTypes, value.tokenModifiers);\n        }))\n    )),\n    ( new ApiCommand(\n        'vscode.provideDocumentSemanticTokens',\n        '_provideDocumentSemanticTokens',\n        'Provide semantic tokens for a document',\n        [ApiCommandArgument.Uri],\n        ( new ApiCommandResult('A promise that resolves to SemanticTokens.', value => {\n            if (!value) {\n                return undefined;\n            }\n            const semanticTokensDto = decodeSemanticTokensDto(value);\n            if (semanticTokensDto.type !== 'full') {\n                return undefined;\n            }\n            return new SemanticTokens(semanticTokensDto.data, undefined);\n        }))\n    )),\n    ( new ApiCommand(\n        'vscode.provideDocumentRangeSemanticTokensLegend',\n        '_provideDocumentRangeSemanticTokensLegend',\n        'Provide semantic tokens legend for a document range',\n        [ApiCommandArgument.Uri, ApiCommandArgument.Range.optional()],\n        ( new ApiCommandResult('A promise that resolves to SemanticTokensLegend.', value => {\n            if (!value) {\n                return undefined;\n            }\n            return new SemanticTokensLegend(value.tokenTypes, value.tokenModifiers);\n        }))\n    )),\n    ( new ApiCommand(\n        'vscode.provideDocumentRangeSemanticTokens',\n        '_provideDocumentRangeSemanticTokens',\n        'Provide semantic tokens for a document range',\n        [ApiCommandArgument.Uri, ApiCommandArgument.Range],\n        ( new ApiCommandResult('A promise that resolves to SemanticTokens.', value => {\n            if (!value) {\n                return undefined;\n            }\n            const semanticTokensDto = decodeSemanticTokensDto(value);\n            if (semanticTokensDto.type !== 'full') {\n                return undefined;\n            }\n            return new SemanticTokens(semanticTokensDto.data, undefined);\n        }))\n    )),\n    (\n    new ApiCommand(\n        'vscode.executeCompletionItemProvider',\n        '_executeCompletionItemProvider',\n        'Execute completion item provider.',\n        [\n            ApiCommandArgument.Uri,\n            ApiCommandArgument.Position,\n            ApiCommandArgument.String.with('triggerCharacter', 'Trigger completion when the user types the character, like `,` or `(`').optional(),\n            ApiCommandArgument.Number.with('itemResolveCount', 'Number of completions to resolve (too large numbers slow down completions)').optional()\n        ],\n        ( new ApiCommandResult(\n            'A promise that resolves to a CompletionList-instance.',\n            (value, _args, converter) => {\n                if (!value) {\n                    return new CompletionList([]);\n                }\n                const items = ( value.suggestions.map(suggestion => CompletionItem.to(suggestion, converter)));\n                return new CompletionList(items, value.incomplete);\n            }\n        ))\n    )),\n    (\n    new ApiCommand(\n        'vscode.executeSignatureHelpProvider',\n        '_executeSignatureHelpProvider',\n        'Execute signature help provider.',\n        [ApiCommandArgument.Uri, ApiCommandArgument.Position, ApiCommandArgument.String.with('triggerCharacter', 'Trigger signature help when the user types the character, like `,` or `(`').optional()],\n        ( new ApiCommandResult('A promise that resolves to SignatureHelp.', value => {\n            if (value) {\n                return SignatureHelp.to(value);\n            }\n            return undefined;\n        }))\n    )),\n    (\n    new ApiCommand(\n        'vscode.executeCodeLensProvider',\n        '_executeCodeLensProvider',\n        'Execute code lens provider.',\n        [ApiCommandArgument.Uri, ApiCommandArgument.Number.with('itemResolveCount', 'Number of lenses that should be resolved and returned. Will only return resolved lenses, will impact performance)').optional()],\n        ( new ApiCommandResult(\n            'A promise that resolves to an array of CodeLens-instances.',\n            (value, _args, converter) => {\n                return tryMapWith(item => {\n                    return new CodeLens(Range.to(item.range), item.command && converter.fromInternal(item.command));\n                })(value);\n            }\n        ))\n    )),\n    (\n    new ApiCommand(\n        'vscode.executeCodeActionProvider',\n        '_executeCodeActionProvider',\n        'Execute code action provider.',\n        [\n            ApiCommandArgument.Uri,\n            ( new ApiCommandArgument(\n                'rangeOrSelection',\n                'Range in a text document. Some refactoring provider requires Selection object.',\n                v => Range$1.isRange(v),\n                v => Selection.isSelection(v) ? Selection$1.from(v) : Range.from(v)\n            )),\n            ApiCommandArgument.String.with('kind', 'Code action kind to return code actions for').optional(),\n            ApiCommandArgument.Number.with('itemResolveCount', 'Number of code actions to resolve (too large numbers slow down code actions)').optional()\n        ],\n        ( new ApiCommandResult(\n            'A promise that resolves to an array of Command-instances.',\n            (value, _args, converter) => {\n                return tryMapWith((codeAction) => {\n                    if (codeAction._isSynthetic) {\n                        if (!codeAction.command) {\n                            throw ( new Error('Synthetic code actions must have a command'));\n                        }\n                        return converter.fromInternal(codeAction.command);\n                    }\n                    else {\n                        const ret = new CodeAction(codeAction.title, codeAction.kind ? new CodeActionKind(codeAction.kind) : undefined);\n                        if (codeAction.edit) {\n                            ret.edit = WorkspaceEdit.to(codeAction.edit);\n                        }\n                        if (codeAction.command) {\n                            ret.command = converter.fromInternal(codeAction.command);\n                        }\n                        ret.isPreferred = codeAction.isPreferred;\n                        return ret;\n                    }\n                })(value);\n            }\n        ))\n    )),\n    (\n    new ApiCommand(\n        'vscode.executeDocumentColorProvider',\n        '_executeDocumentColorProvider',\n        'Execute document color provider.',\n        [ApiCommandArgument.Uri],\n        ( new ApiCommandResult(\n            'A promise that resolves to an array of ColorInformation objects.',\n            result => {\n                if (result) {\n                    return ( result.map(\n                        ci => new ColorInformation(Range.to(ci.range), Color.to(ci.color))\n                    ));\n                }\n                return [];\n            }\n        ))\n    )),\n    ( new ApiCommand(\n        'vscode.executeColorPresentationProvider',\n        '_executeColorPresentationProvider',\n        'Execute color presentation provider.',\n        [\n            ( new ApiCommandArgument(\n                'color',\n                'The color to show and insert',\n                v => v instanceof Color$1,\n                Color.from\n            )),\n            ( new ApiCommandArgument(\n                'context',\n                'Context object with uri and range',\n                _v => true,\n                v => ({ uri: v.uri, range: Range.from(v.range) })\n            )),\n        ],\n        ( new ApiCommandResult(\n            'A promise that resolves to an array of ColorPresentation objects.',\n            result => {\n                if (result) {\n                    return ( result.map(ColorPresentation.to));\n                }\n                return [];\n            }\n        ))\n    )),\n    (\n    new ApiCommand(\n        'vscode.executeInlayHintProvider',\n        '_executeInlayHintProvider',\n        'Execute inlay hints provider',\n        [ApiCommandArgument.Uri, ApiCommandArgument.Range],\n        ( new ApiCommandResult(\n            'A promise that resolves to an array of Inlay objects',\n            (result, args, converter) => {\n                return ( result.map(InlayHint.to.bind(undefined, converter)));\n            }\n        ))\n    )),\n    (\n    new ApiCommand(\n        'vscode.executeFoldingRangeProvider',\n        '_executeFoldingRangeProvider',\n        'Execute folding range provider',\n        [ApiCommandArgument.Uri],\n        ( new ApiCommandResult(\n            'A promise that resolves to an array of FoldingRange objects',\n            (result, args) => {\n                if (result) {\n                    return ( result.map(FoldingRange.to));\n                }\n                return undefined;\n            }\n        ))\n    )),\n    (\n    new ApiCommand(\n        'vscode.resolveNotebookContentProviders',\n        '_resolveNotebookContentProvider',\n        'Resolve Notebook Content Providers',\n        [\n        ],\n        ( new ApiCommandResult(\n            'A promise that resolves to an array of NotebookContentProvider static info objects.',\n            tryMapWith(item => {\n                return {\n                    viewType: item.viewType,\n                    displayName: item.displayName,\n                    options: {\n                        transientOutputs: item.options.transientOutputs,\n                        transientCellMetadata: item.options.transientCellMetadata,\n                        transientDocumentMetadata: item.options.transientDocumentMetadata\n                    },\n                    filenamePattern: ( item.filenamePattern.map(pattern => NotebookExclusiveDocumentPattern.to(pattern)))\n                };\n            })\n        ))\n    )),\n    (\n    new ApiCommand(\n        'vscode.executeInlineValueProvider',\n        '_executeInlineValueProvider',\n        'Execute inline value provider',\n        [\n            ApiCommandArgument.Uri,\n            ApiCommandArgument.Range,\n            ( new ApiCommandArgument(\n                'context',\n                'An InlineValueContext',\n                v => v && typeof v.frameId === 'number' && v.stoppedLocation instanceof Range$1,\n                v => InlineValueContext.from(v)\n            ))\n        ],\n        ( new ApiCommandResult('A promise that resolves to an array of InlineValue objects', result => {\n            return ( result.map(InlineValue.to));\n        }))\n    )),\n    (\n    new ApiCommand(\n        'vscode.open',\n        '_workbench.open',\n        'Opens the provided resource in the editor. Can be a text or binary file, or an http(s) URL. If you need more control over the options for opening a text file, use vscode.window.showTextDocument instead.',\n        [\n            ( new ApiCommandArgument(\n                'uriOrString',\n                'Uri-instance or string (only http/https)',\n                v => URI.isUri(v) || (typeof v === 'string' && matchesSomeScheme(v, Schemas.http, Schemas.https)),\n                v => v\n            )),\n            ( new ApiCommandArgument(\n                'columnOrOptions',\n                'Either the column in which to open or editor options, see vscode.TextDocumentShowOptions',\n                v => v === undefined || typeof v === 'number' || typeof v === 'object',\n                v => !v ? v : typeof v === 'number' ? [ViewColumn.from(v), undefined] : [ViewColumn.from(v.viewColumn), TextEditorOpenOptions.from(v)]\n            )).optional(),\n            ApiCommandArgument.String.with('label', '').optional()\n        ],\n        ApiCommandResult.Void\n    )),\n    ( new ApiCommand(\n        'vscode.openWith',\n        '_workbench.openWith',\n        'Opens the provided resource with a specific editor.',\n        [\n            ApiCommandArgument.Uri.with('resource', 'Resource to open'),\n            ApiCommandArgument.String.with('viewId', 'Custom editor view id. This should be the viewType string for custom editors or the notebookType string for notebooks. Use \\'default\\' to use VS Code\\'s default text editor'),\n            ( new ApiCommandArgument(\n                'columnOrOptions',\n                'Either the column in which to open or editor options, see vscode.TextDocumentShowOptions',\n                v => v === undefined || typeof v === 'number' || typeof v === 'object',\n                v => !v ? v : typeof v === 'number' ? [ViewColumn.from(v), undefined] : [ViewColumn.from(v.viewColumn), TextEditorOpenOptions.from(v)]\n            )).optional()\n        ],\n        ApiCommandResult.Void\n    )),\n    ( new ApiCommand(\n        'vscode.diff',\n        '_workbench.diff',\n        'Opens the provided resources in the diff editor to compare their contents.',\n        [\n            ApiCommandArgument.Uri.with('left', 'Left-hand side resource of the diff editor'),\n            ApiCommandArgument.Uri.with('right', 'Right-hand side resource of the diff editor'),\n            ApiCommandArgument.String.with('title', 'Human readable title for the diff editor').optional(),\n            ( new ApiCommandArgument(\n                'columnOrOptions',\n                'Either the column in which to open or editor options, see vscode.TextDocumentShowOptions',\n                v => v === undefined || typeof v === 'object',\n                v => v && [ViewColumn.from(v.viewColumn), TextEditorOpenOptions.from(v)]\n            )).optional(),\n        ],\n        ApiCommandResult.Void\n    )),\n    ( new ApiCommand(\n        'vscode.changes',\n        '_workbench.changes',\n        'Opens a list of resources in the changes editor to compare their contents.',\n        [\n            ApiCommandArgument.String.with('title', 'Human readable title for the changes editor'),\n            ( new ApiCommandArgument('resourceList', 'List of resources to compare', resources => {\n                for (const resource of resources) {\n                    if (resource.length !== 3) {\n                        return false;\n                    }\n                    const [label, left, right] = resource;\n                    if (!URI.isUri(label) ||\n                        (!URI.isUri(left) && left !== undefined && left !== null) ||\n                        (!URI.isUri(right) && right !== undefined && right !== null)) {\n                        return false;\n                    }\n                }\n                return true;\n            }, v => v))\n        ],\n        ApiCommandResult.Void\n    )),\n    (\n    new ApiCommand(\n        'vscode.prepareTypeHierarchy',\n        '_executePrepareTypeHierarchy',\n        'Prepare type hierarchy at a position inside a document',\n        [ApiCommandArgument.Uri, ApiCommandArgument.Position],\n        ( new ApiCommandResult(\n            'A promise that resolves to an array of TypeHierarchyItem-instances',\n            v => ( v.map(TypeHierarchyItem.to))\n        ))\n    )),\n    ( new ApiCommand(\n        'vscode.provideSupertypes',\n        '_executeProvideSupertypes',\n        'Compute supertypes for an item',\n        [ApiCommandArgument.TypeHierarchyItem],\n        ( new ApiCommandResult(\n            'A promise that resolves to an array of TypeHierarchyItem-instances',\n            v => ( v.map(TypeHierarchyItem.to))\n        ))\n    )),\n    ( new ApiCommand(\n        'vscode.provideSubtypes',\n        '_executeProvideSubtypes',\n        'Compute subtypes for an item',\n        [ApiCommandArgument.TypeHierarchyItem],\n        ( new ApiCommandResult(\n            'A promise that resolves to an array of TypeHierarchyItem-instances',\n            v => ( v.map(TypeHierarchyItem.to))\n        ))\n    )),\n    (\n    new ApiCommand(\n        'vscode.revealTestInExplorer',\n        '_revealTestInExplorer',\n        'Reveals a test instance in the explorer',\n        [ApiCommandArgument.TestItem],\n        ApiCommandResult.Void\n    )),\n    (\n    new ApiCommand(\n        'vscode.experimental.editSession.continue',\n        '_workbench.editSessions.actions.continueEditSession',\n        'Continue the current edit session in a different workspace',\n        [ApiCommandArgument.Uri.with('workspaceUri', 'The target workspace to continue the current edit session in')],\n        ApiCommandResult.Void\n    )),\n    (\n    new ApiCommand(\n        'setContext',\n        '_setContext',\n        'Set a custom context key value that can be used in when clauses.',\n        [\n            ApiCommandArgument.String.with('name', 'The context key name'),\n            ( new ApiCommandArgument('value', 'The context key value', () => true, v => v)),\n        ],\n        ApiCommandResult.Void\n    )),\n    (\n    new ApiCommand(\n        'vscode.executeMappedEditsProvider',\n        '_executeMappedEditsProvider',\n        'Execute Mapped Edits Provider',\n        [\n            ApiCommandArgument.Uri,\n            ApiCommandArgument.StringArray,\n            ( new ApiCommandArgument(\n                'MappedEditsContext',\n                'Mapped Edits Context',\n                (v) => MappedEditsContext.is(v),\n                (v) => MappedEditsContext.from(v)\n            ))\n        ],\n        ( new ApiCommandResult('A promise that resolves to a workspace edit or null', (value) => {\n            return value ? WorkspaceEdit.to(value) : null;\n        }))\n    )),\n    (\n    new ApiCommand(\n        'vscode.editorChat.start',\n        'inlineChat.start',\n        'Invoke a new editor chat session',\n        [( new ApiCommandArgument('Run arguments', '', _v => true, v => {\n                if (!v) {\n                    return undefined;\n                }\n                return {\n                    initialRange: v.initialRange ? Range.from(v.initialRange) : undefined,\n                    initialSelection: Selection.isSelection(v.initialSelection) ? Selection$1.from(v.initialSelection) : undefined,\n                    message: v.message,\n                    autoSend: v.autoSend,\n                    position: v.position ? Position$1.from(v.position) : undefined,\n                };\n            }))],\n        ApiCommandResult.Void\n    ))\n];\nclass ExtHostApiCommands {\n    static register(commands) {\n        newCommands.forEach(commands.registerApiCommand, commands);\n        this._registerValidateWhenClausesCommand(commands);\n    }\n    static _registerValidateWhenClausesCommand(commands) {\n        commands.registerCommand(false, '_validateWhenClauses', validateWhenClauses);\n    }\n}\nfunction tryMapWith(f) {\n    return (value) => {\n        if (Array.isArray(value)) {\n            return ( value.map(f));\n        }\n        return undefined;\n    };\n}\nfunction mapLocationOrLocationLink(values) {\n    if (!Array.isArray(values)) {\n        return undefined;\n    }\n    const result = [];\n    for (const item of values) {\n        if (isLocationLink(item)) {\n            result.push(DefinitionLink.to(item));\n        }\n        else {\n            result.push(location.to(item));\n        }\n    }\n    return result;\n}\nexport { ExtHostApiCommands };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { ILogService } from '../../../platform/log/common/log.service.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\nconst IExtHostApiDeprecationService = ( createDecorator('IExtHostApiDeprecationService'));\nlet ExtHostApiDeprecationService = class ExtHostApiDeprecationService {\n    constructor(rpc, _extHostLogService) {\n        this._extHostLogService = _extHostLogService;\n        this._reportedUsages = ( new Set());\n        this._telemetryShape = ( rpc.getProxy(MainContext.MainThreadTelemetry));\n    }\n    report(apiId, extension, migrationSuggestion) {\n        const key = this.getUsageKey(apiId, extension);\n        if (( this._reportedUsages.has(key))) {\n            return;\n        }\n        this._reportedUsages.add(key);\n        if (extension.isUnderDevelopment) {\n            this._extHostLogService.warn(`[Deprecation Warning] '${apiId}' is deprecated. ${migrationSuggestion}`);\n        }\n        this._telemetryShape.$publicLog2('extHostDeprecatedApiUsage', {\n            extensionId: extension.identifier.value,\n            apiId: apiId,\n        });\n    }\n    getUsageKey(apiId, extension) {\n        return `${apiId}-${extension.identifier.value}`;\n    }\n};\nExtHostApiDeprecationService = ( __decorate([\n    ( __param(0, IExtHostRpcService)),\n    ( __param(1, ILogService))\n], ExtHostApiDeprecationService));\nexport { ExtHostApiDeprecationService, IExtHostApiDeprecationService };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { Disposable } from './extHostTypes.js';\nimport { ExtensionIdentifier } from '../../../platform/extensions/common/extensions.js';\nimport { INTERNAL_AUTH_PROVIDER_PREFIX } from '../../services/authentication/common/authentication.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\nconst IExtHostAuthentication = ( createDecorator('IExtHostAuthentication'));\nlet ExtHostAuthentication = class ExtHostAuthentication {\n    constructor(extHostRpc) {\n        this._authenticationProviders = ( new Map());\n        this._onDidChangeSessions = ( new Emitter());\n        this._getSessionTaskSingler = ( new TaskSingler());\n        this._proxy = ( extHostRpc.getProxy(MainContext.MainThreadAuthentication));\n    }\n    getExtensionScopedSessionsEvent(extensionId) {\n        const normalizedExtensionId = extensionId.toLowerCase();\n        return Event.chain(this._onDidChangeSessions.event, ($) => ( $\n            .filter(e => !e.extensionIdFilter || e.extensionIdFilter.includes(normalizedExtensionId))\n            .map(e => ({ provider: e.provider }))));\n    }\n    async getSession(requestingExtension, providerId, scopes, options = {}) {\n        const extensionId = ExtensionIdentifier.toKey(requestingExtension.identifier);\n        const sortedScopes = [...scopes].sort().join(' ');\n        return await this._getSessionTaskSingler.getOrCreate(`${extensionId} ${providerId} ${sortedScopes}`, async () => {\n            await this._proxy.$ensureProvider(providerId);\n            const extensionName = requestingExtension.displayName || requestingExtension.name;\n            return this._proxy.$getSession(providerId, scopes, extensionId, extensionName, options);\n        });\n    }\n    async getAccounts(providerId) {\n        await this._proxy.$ensureProvider(providerId);\n        return await this._proxy.$getAccounts(providerId);\n    }\n    async removeSession(providerId, sessionId) {\n        const providerData = this._authenticationProviders.get(providerId);\n        if (!providerData) {\n            return this._proxy.$removeSession(providerId, sessionId);\n        }\n        return providerData.provider.removeSession(sessionId);\n    }\n    registerAuthenticationProvider(id, label, provider, options) {\n        if (this._authenticationProviders.get(id)) {\n            throw ( new Error(`An authentication provider with id '${id}' is already registered.`));\n        }\n        this._authenticationProviders.set(id, { label, provider, options: options ?? { supportsMultipleAccounts: false } });\n        const listener = provider.onDidChangeSessions(e => this._proxy.$sendDidChangeSessions(id, e));\n        this._proxy.$registerAuthenticationProvider(id, label, options?.supportsMultipleAccounts ?? false);\n        return ( new Disposable(() => {\n            listener.dispose();\n            this._authenticationProviders.delete(id);\n            this._proxy.$unregisterAuthenticationProvider(id);\n        }));\n    }\n    async $createSession(providerId, scopes, options) {\n        const providerData = this._authenticationProviders.get(providerId);\n        if (providerData) {\n            return await providerData.provider.createSession(scopes, options);\n        }\n        throw ( new Error(`Unable to find authentication provider with handle: ${providerId}`));\n    }\n    async $removeSession(providerId, sessionId) {\n        const providerData = this._authenticationProviders.get(providerId);\n        if (providerData) {\n            return await providerData.provider.removeSession(sessionId);\n        }\n        throw ( new Error(`Unable to find authentication provider with handle: ${providerId}`));\n    }\n    async $getSessions(providerId, scopes, options) {\n        const providerData = this._authenticationProviders.get(providerId);\n        if (providerData) {\n            return await providerData.provider.getSessions(scopes, options);\n        }\n        throw ( new Error(`Unable to find authentication provider with handle: ${providerId}`));\n    }\n    $onDidChangeAuthenticationSessions(id, label, extensionIdFilter) {\n        if (!id.startsWith(INTERNAL_AUTH_PROVIDER_PREFIX)) {\n            this._onDidChangeSessions.fire({ provider: { id, label }, extensionIdFilter });\n        }\n        return Promise.resolve();\n    }\n};\nExtHostAuthentication = ( __decorate([\n    ( __param(0, IExtHostRpcService))\n], ExtHostAuthentication));\nclass TaskSingler {\n    constructor() {\n        this._inFlightPromises = ( new Map());\n    }\n    getOrCreate(key, promiseFactory) {\n        const inFlight = this._inFlightPromises.get(key);\n        if (inFlight) {\n            return inFlight;\n        }\n        const promise = promiseFactory().finally(() => this._inFlightPromises.delete(key));\n        this._inFlightPromises.set(key, promise);\n        return promise;\n    }\n}\nexport { ExtHostAuthentication, IExtHostAuthentication };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\nimport { WorkspaceEdit } from './extHostTypeConverters.js';\nimport { SerializableObjectWithBuffers } from '../../services/extensions/common/proxyIdentifier.js';\nlet ExtHostBulkEdits = class ExtHostBulkEdits {\n    constructor(extHostRpc, extHostDocumentsAndEditors) {\n        this._proxy = ( extHostRpc.getProxy(MainContext.MainThreadBulkEdits));\n        this._versionInformationProvider = {\n            getTextDocumentVersion: uri => extHostDocumentsAndEditors.getDocument(uri)?.version,\n            getNotebookDocumentVersion: () => undefined\n        };\n    }\n    applyWorkspaceEdit(edit, extension, metadata) {\n        const dto = ( new SerializableObjectWithBuffers(WorkspaceEdit.from(edit, this._versionInformationProvider)));\n        return this._proxy.$tryApplyWorkspaceEdit(dto, undefined, metadata?.isRefactoring ?? false);\n    }\n};\nExtHostBulkEdits = ( __decorate([\n    ( __param(0, IExtHostRpcService))\n], ExtHostBulkEdits));\nexport { ExtHostBulkEdits };\n","import { coalesce } from '../../../base/common/arrays.js';\nimport { raceCancellation } from '../../../base/common/async.js';\nimport { toErrorMessage } from '../../../base/common/errorMessage.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Iterable } from '../../../base/common/iterator.js';\nimport { Disposable, DisposableMap, toDisposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport { revive } from '../../../base/common/marshalling.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { ThemeIcon } from '../../../base/common/themables.js';\nimport { assertType } from '../../../base/common/types.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { ExtensionIdentifier } from '../../../platform/extensions/common/extensions.js';\nimport { ChatAgentLocation } from '../../contrib/chat/common/chatAgents.js';\nimport { ChatAgentVoteDirection } from '../../contrib/chat/common/chatService.js';\nimport { isProposedApiEnabled, checkProposedApiEnabled } from '../../services/extensions/common/extensions.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { ChatAgentRequest, ChatLocation, Selection, Range, ChatAgentResult, ChatFollowup, ChatAgentUserActionEvent, ChatAgentCompletionItem, ChatResponseMarkdownPart as ChatResponseMarkdownPart$1, ChatResponseMarkdownWithVulnerabilitiesPart as ChatResponseMarkdownWithVulnerabilitiesPart$1, ChatResponseCodeblockUriPart, ChatResponseFilesPart, ChatResponseAnchorPart, ChatResponseCommandButtonPart, ChatTask, ChatResponseProgressPart, ChatResponseWarningPart as ChatResponseWarningPart$1, ChatResponseReferencePart, ChatResponseCodeCitationPart, ChatResponseTextEditPart, ChatResponseDetectedParticipantPart, ChatResponseConfirmationPart, ChatResponsePart, ChatLanguageModelToolReference, MarkdownString, ChatTaskResult, ChatPromptReference } from './extHostTypeConverters.js';\nimport { ChatRequestEditorData, LanguageModelError, ChatResponseTurn, ChatResponseMarkdownPart, ChatResponseMarkdownWithVulnerabilitiesPart, ChatResponseWarningPart, ChatResponseTextEditPart as ChatResponseTextEditPart$1, ChatResponseDetectedParticipantPart as ChatResponseDetectedParticipantPart$1, ChatResponseConfirmationPart as ChatResponseConfirmationPart$1, ChatResponseCodeCitationPart as ChatResponseCodeCitationPart$1, ChatResponseMovePart, ChatResponseProgressPart2, ChatResponseReferencePart as ChatResponseReferencePart$1, ChatRequestNotebookData, ChatRequestTurn, ChatResultFeedbackKind, ChatResponseCodeblockUriPart as ChatResponseCodeblockUriPart$1, ChatResponseFileTreePart, ChatResponseAnchorPart as ChatResponseAnchorPart$1, ChatResponseCommandButtonPart as ChatResponseCommandButtonPart$1, ThemeIcon as ThemeIcon$1, MarkdownString as MarkdownString$1 } from './extHostTypes.js';\nclass ChatAgentResponseStream {\n    constructor(_extension, _request, _proxy, _commandsConverter, _sessionDisposables) {\n        this._extension = _extension;\n        this._request = _request;\n        this._proxy = _proxy;\n        this._commandsConverter = _commandsConverter;\n        this._sessionDisposables = _sessionDisposables;\n        this._stopWatch = StopWatch.create(false);\n        this._isClosed = false;\n    }\n    close() {\n        this._isClosed = true;\n    }\n    get timings() {\n        return {\n            firstProgress: this._firstProgress,\n            totalElapsed: this._stopWatch.elapsed()\n        };\n    }\n    get apiObject() {\n        if (!this._apiObject) {\n            const that = this;\n            this._stopWatch.reset();\n            function throwIfDone(source) {\n                if (that._isClosed) {\n                    const err = ( new Error('Response stream has been closed'));\n                    Error.captureStackTrace(err, source);\n                    throw err;\n                }\n            }\n            const _report = (progress, task) => {\n                if (typeof this._firstProgress === 'undefined' && (progress.kind === 'markdownContent' || progress.kind === 'markdownVuln')) {\n                    this._firstProgress = this._stopWatch.elapsed();\n                }\n                if (task) {\n                    const progressReporterPromise = this._proxy.$handleProgressChunk(this._request.requestId, progress);\n                    const progressReporter = {\n                        report: (p) => {\n                            progressReporterPromise?.then((handle) => {\n                                if (handle) {\n                                    if (MarkdownString$1.isMarkdownString(p.value)) {\n                                        this._proxy.$handleProgressChunk(this._request.requestId, ChatResponseWarningPart$1.from(p), handle);\n                                    }\n                                    else {\n                                        this._proxy.$handleProgressChunk(this._request.requestId, ChatResponseReferencePart.from(p), handle);\n                                    }\n                                }\n                            });\n                        }\n                    };\n                    Promise.all([progressReporterPromise, task?.(progressReporter)]).then(([handle, res]) => {\n                        if (handle !== undefined) {\n                            this._proxy.$handleProgressChunk(this._request.requestId, ChatTaskResult.from(res), handle);\n                        }\n                    });\n                }\n                else {\n                    this._proxy.$handleProgressChunk(this._request.requestId, progress);\n                }\n            };\n            this._apiObject = {\n                markdown(value) {\n                    throwIfDone(this.markdown);\n                    const part = new ChatResponseMarkdownPart(value);\n                    const dto = ChatResponseMarkdownPart$1.from(part);\n                    _report(dto);\n                    return this;\n                },\n                markdownWithVulnerabilities(value, vulnerabilities) {\n                    throwIfDone(this.markdown);\n                    if (vulnerabilities) {\n                        checkProposedApiEnabled(that._extension, 'chatParticipantAdditions');\n                    }\n                    const part = new ChatResponseMarkdownWithVulnerabilitiesPart(value, vulnerabilities);\n                    const dto = ChatResponseMarkdownWithVulnerabilitiesPart$1.from(part);\n                    _report(dto);\n                    return this;\n                },\n                codeblockUri(value) {\n                    throwIfDone(this.codeblockUri);\n                    checkProposedApiEnabled(that._extension, 'chatParticipantAdditions');\n                    const part = new ChatResponseCodeblockUriPart$1(value);\n                    const dto = ChatResponseCodeblockUriPart.from(part);\n                    _report(dto);\n                    return this;\n                },\n                filetree(value, baseUri) {\n                    throwIfDone(this.filetree);\n                    const part = new ChatResponseFileTreePart(value, baseUri);\n                    const dto = ChatResponseFilesPart.from(part);\n                    _report(dto);\n                    return this;\n                },\n                anchor(value, title) {\n                    throwIfDone(this.anchor);\n                    const part = new ChatResponseAnchorPart$1(value, title);\n                    const dto = ChatResponseAnchorPart.from(part);\n                    _report(dto);\n                    return this;\n                },\n                button(value) {\n                    throwIfDone(this.anchor);\n                    const part = new ChatResponseCommandButtonPart$1(value);\n                    const dto = ChatResponseCommandButtonPart.from(part, that._commandsConverter, that._sessionDisposables);\n                    _report(dto);\n                    return this;\n                },\n                progress(value, task) {\n                    throwIfDone(this.progress);\n                    const part = new ChatResponseProgressPart2(value, task);\n                    const dto = task ? ChatTask.from(part) : ChatResponseProgressPart.from(part);\n                    _report(dto, task);\n                    return this;\n                },\n                warning(value) {\n                    throwIfDone(this.progress);\n                    checkProposedApiEnabled(that._extension, 'chatParticipantAdditions');\n                    const part = new ChatResponseWarningPart(value);\n                    const dto = ChatResponseWarningPart$1.from(part);\n                    _report(dto);\n                    return this;\n                },\n                reference(value, iconPath) {\n                    return this.reference2(value, iconPath);\n                },\n                reference2(value, iconPath, options) {\n                    throwIfDone(this.reference);\n                    if (typeof value === 'object' && 'variableName' in value) {\n                        checkProposedApiEnabled(that._extension, 'chatParticipantAdditions');\n                    }\n                    if (typeof value === 'object' && 'variableName' in value && !value.value) {\n                        const matchingVarData = that._request.variables.variables.find(v => v.name === value.variableName);\n                        if (matchingVarData) {\n                            let references;\n                            if (matchingVarData.references?.length) {\n                                references = ( matchingVarData.references.map(r => ({\n                                    kind: 'reference',\n                                    reference: { variableName: value.variableName, value: r.reference }\n                                })));\n                            }\n                            else {\n                                const part = new ChatResponseReferencePart$1(value, iconPath, options);\n                                const dto = ChatResponseReferencePart.from(part);\n                                references = [dto];\n                            }\n                            references.forEach(r => _report(r));\n                            return this;\n                        }\n                    }\n                    else {\n                        const part = new ChatResponseReferencePart$1(value, iconPath, options);\n                        const dto = ChatResponseReferencePart.from(part);\n                        _report(dto);\n                    }\n                    return this;\n                },\n                codeCitation(value, license, snippet) {\n                    throwIfDone(this.codeCitation);\n                    checkProposedApiEnabled(that._extension, 'chatParticipantAdditions');\n                    const part = new ChatResponseCodeCitationPart$1(value, license, snippet);\n                    const dto = ChatResponseCodeCitationPart.from(part);\n                    _report(dto);\n                },\n                textEdit(target, edits) {\n                    throwIfDone(this.textEdit);\n                    checkProposedApiEnabled(that._extension, 'chatParticipantAdditions');\n                    const part = new ChatResponseTextEditPart$1(target, edits);\n                    const dto = ChatResponseTextEditPart.from(part);\n                    _report(dto);\n                    return this;\n                },\n                detectedParticipant(participant, command) {\n                    throwIfDone(this.detectedParticipant);\n                    checkProposedApiEnabled(that._extension, 'chatParticipantAdditions');\n                    const part = new ChatResponseDetectedParticipantPart$1(participant, command);\n                    const dto = ChatResponseDetectedParticipantPart.from(part);\n                    _report(dto);\n                    return this;\n                },\n                confirmation(title, message, data, buttons) {\n                    throwIfDone(this.confirmation);\n                    checkProposedApiEnabled(that._extension, 'chatParticipantAdditions');\n                    const part = new ChatResponseConfirmationPart$1(title, message, data, buttons);\n                    const dto = ChatResponseConfirmationPart.from(part);\n                    _report(dto);\n                    return this;\n                },\n                push(part) {\n                    throwIfDone(this.push);\n                    if (part instanceof ChatResponseTextEditPart$1 ||\n                        part instanceof ChatResponseMarkdownWithVulnerabilitiesPart ||\n                        part instanceof ChatResponseDetectedParticipantPart$1 ||\n                        part instanceof ChatResponseWarningPart ||\n                        part instanceof ChatResponseConfirmationPart$1 ||\n                        part instanceof ChatResponseCodeCitationPart$1 ||\n                        part instanceof ChatResponseMovePart ||\n                        part instanceof ChatResponseProgressPart2) {\n                        checkProposedApiEnabled(that._extension, 'chatParticipantAdditions');\n                    }\n                    if (part instanceof ChatResponseReferencePart$1) {\n                        this.reference2(part.value, part.iconPath, part.options);\n                    }\n                    else if (part instanceof ChatResponseProgressPart2) {\n                        const dto = part.task ? ChatTask.from(part) : ChatResponseProgressPart.from(part);\n                        _report(dto, part.task);\n                    }\n                    else {\n                        const dto = ChatResponsePart.from(part, that._commandsConverter, that._sessionDisposables);\n                        _report(dto);\n                    }\n                    return this;\n                },\n            };\n        }\n        return this._apiObject;\n    }\n}\nclass ExtHostChatAgents2 extends Disposable {\n    static { this._idPool = 0; }\n    static { this._participantDetectionProviderIdPool = 0; }\n    constructor(mainContext, _logService, _commands, _documents, _languageModels) {\n        super();\n        this._logService = _logService;\n        this._commands = _commands;\n        this._documents = _documents;\n        this._languageModels = _languageModels;\n        this._agents = ( new Map());\n        this._participantDetectionProviders = ( new Map());\n        this._sessionDisposables = this._register(( new DisposableMap()));\n        this._completionDisposables = this._register(( new DisposableMap()));\n        this._proxy = ( mainContext.getProxy(MainContext.MainThreadChatAgents2));\n    }\n    transferActiveChat(newWorkspace) {\n        this._proxy.$transferActiveChatSession(newWorkspace);\n    }\n    createChatAgent(extension, id, handler) {\n        const handle = ExtHostChatAgents2._idPool++;\n        const agent = ( new ExtHostChatAgent(extension, id, this._proxy, handle, handler));\n        this._agents.set(handle, agent);\n        this._proxy.$registerAgent(handle, extension.identifier, id, {}, undefined);\n        return agent.apiAgent;\n    }\n    createDynamicChatAgent(extension, id, dynamicProps, handler) {\n        const handle = ExtHostChatAgents2._idPool++;\n        const agent = ( new ExtHostChatAgent(extension, id, this._proxy, handle, handler));\n        this._agents.set(handle, agent);\n        this._proxy.$registerAgent(handle, extension.identifier, id, { isSticky: true }, dynamicProps);\n        return agent.apiAgent;\n    }\n    registerChatParticipantDetectionProvider(extension, provider) {\n        const handle = ExtHostChatAgents2._participantDetectionProviderIdPool++;\n        this._participantDetectionProviders.set(handle, ( new ExtHostParticipantDetector(extension, provider)));\n        this._proxy.$registerChatParticipantDetectionProvider(handle);\n        return toDisposable(() => {\n            this._participantDetectionProviders.delete(handle);\n            this._proxy.$unregisterChatParticipantDetectionProvider(handle);\n        });\n    }\n    async $detectChatParticipant(handle, requestDto, context, options, token) {\n        const { request, location, history } = await this._createRequest(requestDto, context);\n        const detector = this._participantDetectionProviders.get(handle);\n        if (!detector) {\n            return undefined;\n        }\n        const extRequest = ChatAgentRequest.to(request, location);\n        if (request.userSelectedModelId && isProposedApiEnabled(detector.extension, 'chatParticipantAdditions')) {\n            extRequest.userSelectedModel = await this._languageModels.getLanguageModelByIdentifier(detector.extension, request.userSelectedModelId);\n        }\n        return detector.provider.provideParticipantDetection(extRequest, { history }, { participants: options.participants, location: ChatLocation.to(options.location) }, token);\n    }\n    async _createRequest(requestDto, context) {\n        const request = revive(requestDto);\n        const convertedHistory = await this.prepareHistoryTurns(request.agentId, context);\n        let location;\n        if (request.locationData?.type === ChatAgentLocation.Editor) {\n            const document = this._documents.getDocument(request.locationData.document);\n            location = new ChatRequestEditorData(document, Selection.to(request.locationData.selection), Range.to(request.locationData.wholeRange));\n        }\n        else if (request.locationData?.type === ChatAgentLocation.Notebook) {\n            const cell = this._documents.getDocument(request.locationData.sessionInputUri);\n            location = new ChatRequestNotebookData(cell);\n        }\n        else ;\n        return { request, location, history: convertedHistory };\n    }\n    async $invokeAgent(handle, requestDto, context, token) {\n        const agent = this._agents.get(handle);\n        if (!agent) {\n            throw ( new Error(\n                `[CHAT](${handle}) CANNOT invoke agent because the agent is not registered`\n            ));\n        }\n        let stream;\n        try {\n            const { request, location, history } = await this._createRequest(requestDto, context);\n            let sessionDisposables = this._sessionDisposables.get(request.sessionId);\n            if (!sessionDisposables) {\n                sessionDisposables = ( new DisposableStore());\n                this._sessionDisposables.set(request.sessionId, sessionDisposables);\n            }\n            stream = ( new ChatAgentResponseStream(\n                agent.extension,\n                request,\n                this._proxy,\n                this._commands.converter,\n                sessionDisposables\n            ));\n            const extRequest = ChatAgentRequest.to(request, location);\n            if (request.userSelectedModelId && isProposedApiEnabled(agent.extension, 'chatParticipantAdditions')) {\n                extRequest.userSelectedModel = await this._languageModels.getLanguageModelByIdentifier(agent.extension, request.userSelectedModelId);\n            }\n            const task = agent.invoke(extRequest, { history }, stream.apiObject, token);\n            return await raceCancellation(Promise.resolve(task).then((result) => {\n                if (result?.metadata) {\n                    try {\n                        JSON.stringify(result.metadata);\n                    }\n                    catch (err) {\n                        const msg = `result.metadata MUST be JSON.stringify-able. Got error: ${err.message}`;\n                        this._logService.error(`[${agent.extension.identifier.value}] [@${agent.id}] ${msg}`, agent.extension);\n                        return { errorDetails: { message: msg }, timings: stream?.timings, nextQuestion: result.nextQuestion };\n                    }\n                }\n                let errorDetails;\n                if (result?.errorDetails) {\n                    errorDetails = {\n                        ...result.errorDetails,\n                        responseIsIncomplete: true\n                    };\n                }\n                if (errorDetails?.responseIsRedacted) {\n                    checkProposedApiEnabled(agent.extension, 'chatParticipantPrivate');\n                }\n                return { errorDetails, timings: stream?.timings, metadata: result?.metadata, nextQuestion: result?.nextQuestion };\n            }), token);\n        }\n        catch (e) {\n            this._logService.error(e, agent.extension);\n            if (e instanceof LanguageModelError && e.cause) {\n                e = e.cause;\n            }\n            return { errorDetails: { message: toErrorMessage(e), responseIsIncomplete: true } };\n        }\n        finally {\n            stream?.close();\n        }\n    }\n    async prepareHistoryTurns(agentId, context) {\n        const res = [];\n        for (const h of context.history) {\n            const ehResult = ChatAgentResult.to(h.result);\n            const result = agentId === h.request.agentId ?\n                ehResult :\n                { ...ehResult, metadata: undefined };\n            const varsWithoutTools = ( h.request.variables.variables\n                .filter(v => !v.isTool)\n                .map(ChatPromptReference.to));\n            const toolReferences = ( h.request.variables.variables\n                .filter(v => v.isTool)\n                .map(ChatLanguageModelToolReference.to));\n            const turn = new ChatRequestTurn(h.request.message, h.request.command, varsWithoutTools, h.request.agentId);\n            turn.toolReferences = toolReferences;\n            res.push(turn);\n            const parts = coalesce(( h.response.map(r => ChatResponsePart.toContent(r, this._commands.converter))));\n            res.push(new ChatResponseTurn(parts, result, h.request.agentId, h.request.command));\n        }\n        return res;\n    }\n    $releaseSession(sessionId) {\n        this._sessionDisposables.deleteAndDispose(sessionId);\n    }\n    async $provideFollowups(requestDto, handle, result, context, token) {\n        const agent = this._agents.get(handle);\n        if (!agent) {\n            return Promise.resolve([]);\n        }\n        const request = revive(requestDto);\n        const convertedHistory = await this.prepareHistoryTurns(agent.id, context);\n        const ehResult = ChatAgentResult.to(result);\n        return ( (await agent.provideFollowups(ehResult, { history: convertedHistory }, token))\n            .filter(f => {\n            const isValid = !f.participant || ( Iterable.some(( this._agents.values()), a => a.id === f.participant && ExtensionIdentifier.equals(a.extension.identifier, agent.extension.identifier)));\n            if (!isValid) {\n                this._logService.warn(`[@${agent.id}] ChatFollowup refers to an unknown participant: ${f.participant}`);\n            }\n            return isValid;\n        })\n            .map(f => ChatFollowup.from(f, request)));\n    }\n    $acceptFeedback(handle, result, voteAction) {\n        const agent = this._agents.get(handle);\n        if (!agent) {\n            return;\n        }\n        const ehResult = ChatAgentResult.to(result);\n        let kind;\n        switch (voteAction.direction) {\n            case ChatAgentVoteDirection.Down:\n                kind = ChatResultFeedbackKind.Unhelpful;\n                break;\n            case ChatAgentVoteDirection.Up:\n                kind = ChatResultFeedbackKind.Helpful;\n                break;\n        }\n        const feedback = {\n            result: ehResult,\n            kind,\n            unhelpfulReason: isProposedApiEnabled(agent.extension, 'chatParticipantAdditions') ? voteAction.reason : undefined,\n        };\n        agent.acceptFeedback(( Object.freeze(feedback)));\n    }\n    $acceptAction(handle, result, event) {\n        const agent = this._agents.get(handle);\n        if (!agent) {\n            return;\n        }\n        if (event.action.kind === 'vote') {\n            return;\n        }\n        const ehAction = ChatAgentUserActionEvent.to(result, event, this._commands.converter);\n        if (ehAction) {\n            agent.acceptAction(( Object.freeze(ehAction)));\n        }\n    }\n    async $invokeCompletionProvider(handle, query, token) {\n        const agent = this._agents.get(handle);\n        if (!agent) {\n            return [];\n        }\n        let disposables = this._completionDisposables.get(handle);\n        if (disposables) {\n            disposables.clear();\n        }\n        else {\n            disposables = ( new DisposableStore());\n            this._completionDisposables.set(handle, disposables);\n        }\n        const items = await agent.invokeCompletionProvider(query, token);\n        return ( items.map(\n            (i) => ChatAgentCompletionItem.from(i, this._commands.converter, disposables)\n        ));\n    }\n    async $provideWelcomeMessage(handle, token) {\n        const agent = this._agents.get(handle);\n        if (!agent) {\n            return;\n        }\n        return await agent.provideWelcomeMessage(token);\n    }\n    async $provideChatTitle(handle, context, token) {\n        const agent = this._agents.get(handle);\n        if (!agent) {\n            return;\n        }\n        const history = await this.prepareHistoryTurns(agent.id, { history: context });\n        return await agent.provideTitle({ history }, token);\n    }\n    async $provideSampleQuestions(handle, location, token) {\n        const agent = this._agents.get(handle);\n        if (!agent) {\n            return;\n        }\n        return ( (await agent.provideSampleQuestions(ChatLocation.to(location), token))\n            .map(f => ChatFollowup.from(f, undefined)));\n    }\n}\nclass ExtHostParticipantDetector {\n    constructor(extension, provider) {\n        this.extension = extension;\n        this.provider = provider;\n    }\n}\nclass ExtHostChatAgent {\n    constructor(extension, id, _proxy, _handle, _requestHandler) {\n        this.extension = extension;\n        this.id = id;\n        this._proxy = _proxy;\n        this._handle = _handle;\n        this._requestHandler = _requestHandler;\n        this._onDidReceiveFeedback = ( new Emitter());\n        this._onDidPerformAction = ( new Emitter());\n    }\n    acceptFeedback(feedback) {\n        this._onDidReceiveFeedback.fire(feedback);\n    }\n    acceptAction(event) {\n        this._onDidPerformAction.fire(event);\n    }\n    async invokeCompletionProvider(query, token) {\n        if (!this._agentVariableProvider) {\n            return [];\n        }\n        return (await this._agentVariableProvider.provider.provideCompletionItems(query, token)) ?? [];\n    }\n    async provideFollowups(result, context, token) {\n        if (!this._followupProvider) {\n            return [];\n        }\n        const followups = await this._followupProvider.provideFollowups(result, context, token);\n        if (!followups) {\n            return [];\n        }\n        return followups\n            .filter(f => !(f && 'commandId' in f))\n            .filter(f => !(f && 'message' in f));\n    }\n    async provideWelcomeMessage(token) {\n        if (!this._welcomeMessageProvider?.provideWelcomeMessage) {\n            return undefined;\n        }\n        const content = await this._welcomeMessageProvider.provideWelcomeMessage(token);\n        const icon = content?.icon;\n        if (!content || !ThemeIcon.isThemeIcon(icon)) {\n            return undefined;\n        }\n        return {\n            ...content,\n            icon,\n            message: MarkdownString.from(content.message),\n        };\n    }\n    async provideTitle(context, token) {\n        if (!this._titleProvider) {\n            return;\n        }\n        return (await this._titleProvider.provideChatTitle(context, token)) ?? undefined;\n    }\n    async provideSampleQuestions(location, token) {\n        if (!this._welcomeMessageProvider || !this._welcomeMessageProvider.provideSampleQuestions) {\n            return [];\n        }\n        const content = await this._welcomeMessageProvider.provideSampleQuestions(location, token);\n        if (!content) {\n            return [];\n        }\n        return content;\n    }\n    get apiAgent() {\n        let disposed = false;\n        let updateScheduled = false;\n        const updateMetadataSoon = () => {\n            if (disposed) {\n                return;\n            }\n            if (updateScheduled) {\n                return;\n            }\n            updateScheduled = true;\n            queueMicrotask(() => {\n                this._proxy.$updateAgent(this._handle, {\n                    icon: !this._iconPath ? undefined :\n                        this._iconPath instanceof URI ? this._iconPath :\n                            'light' in this._iconPath ? this._iconPath.light :\n                                undefined,\n                    iconDark: !this._iconPath ? undefined :\n                        'dark' in this._iconPath ? this._iconPath.dark :\n                            undefined,\n                    themeIcon: this._iconPath instanceof ThemeIcon$1 ? this._iconPath : undefined,\n                    hasFollowups: this._followupProvider !== undefined,\n                    isSecondary: this._isSecondary,\n                    helpTextPrefix: (!this._helpTextPrefix || typeof this._helpTextPrefix === 'string') ? this._helpTextPrefix : MarkdownString.from(this._helpTextPrefix),\n                    helpTextVariablesPrefix: (!this._helpTextVariablesPrefix || typeof this._helpTextVariablesPrefix === 'string') ? this._helpTextVariablesPrefix : MarkdownString.from(this._helpTextVariablesPrefix),\n                    helpTextPostfix: (!this._helpTextPostfix || typeof this._helpTextPostfix === 'string') ? this._helpTextPostfix : MarkdownString.from(this._helpTextPostfix),\n                    supportIssueReporting: this._supportIssueReporting,\n                    requester: this._requester,\n                    supportsSlowVariables: this._supportsSlowReferences,\n                });\n                updateScheduled = false;\n            });\n        };\n        const that = this;\n        return {\n            get id() {\n                return that.id;\n            },\n            get iconPath() {\n                return that._iconPath;\n            },\n            set iconPath(v) {\n                that._iconPath = v;\n                updateMetadataSoon();\n            },\n            get requestHandler() {\n                return that._requestHandler;\n            },\n            set requestHandler(v) {\n                assertType(typeof v === 'function', 'Invalid request handler');\n                that._requestHandler = v;\n            },\n            get followupProvider() {\n                return that._followupProvider;\n            },\n            set followupProvider(v) {\n                that._followupProvider = v;\n                updateMetadataSoon();\n            },\n            get helpTextPrefix() {\n                checkProposedApiEnabled(that.extension, 'defaultChatParticipant');\n                return that._helpTextPrefix;\n            },\n            set helpTextPrefix(v) {\n                checkProposedApiEnabled(that.extension, 'defaultChatParticipant');\n                that._helpTextPrefix = v;\n                updateMetadataSoon();\n            },\n            get helpTextVariablesPrefix() {\n                checkProposedApiEnabled(that.extension, 'defaultChatParticipant');\n                return that._helpTextVariablesPrefix;\n            },\n            set helpTextVariablesPrefix(v) {\n                checkProposedApiEnabled(that.extension, 'defaultChatParticipant');\n                that._helpTextVariablesPrefix = v;\n                updateMetadataSoon();\n            },\n            get helpTextPostfix() {\n                checkProposedApiEnabled(that.extension, 'defaultChatParticipant');\n                return that._helpTextPostfix;\n            },\n            set helpTextPostfix(v) {\n                checkProposedApiEnabled(that.extension, 'defaultChatParticipant');\n                that._helpTextPostfix = v;\n                updateMetadataSoon();\n            },\n            get isSecondary() {\n                checkProposedApiEnabled(that.extension, 'defaultChatParticipant');\n                return that._isSecondary;\n            },\n            set isSecondary(v) {\n                checkProposedApiEnabled(that.extension, 'defaultChatParticipant');\n                that._isSecondary = v;\n                updateMetadataSoon();\n            },\n            get supportIssueReporting() {\n                checkProposedApiEnabled(that.extension, 'chatParticipantPrivate');\n                return that._supportIssueReporting;\n            },\n            set supportIssueReporting(v) {\n                checkProposedApiEnabled(that.extension, 'chatParticipantPrivate');\n                that._supportIssueReporting = v;\n                updateMetadataSoon();\n            },\n            get onDidReceiveFeedback() {\n                return that._onDidReceiveFeedback.event;\n            },\n            set participantVariableProvider(v) {\n                checkProposedApiEnabled(that.extension, 'chatParticipantAdditions');\n                that._agentVariableProvider = v;\n                if (v) {\n                    if (!v.triggerCharacters.length) {\n                        throw ( new Error('triggerCharacters are required'));\n                    }\n                    that._proxy.$registerAgentCompletionsProvider(that._handle, that.id, v.triggerCharacters);\n                }\n                else {\n                    that._proxy.$unregisterAgentCompletionsProvider(that._handle, that.id);\n                }\n            },\n            get participantVariableProvider() {\n                checkProposedApiEnabled(that.extension, 'chatParticipantAdditions');\n                return that._agentVariableProvider;\n            },\n            set welcomeMessageProvider(v) {\n                checkProposedApiEnabled(that.extension, 'defaultChatParticipant');\n                that._welcomeMessageProvider = v;\n                updateMetadataSoon();\n            },\n            get welcomeMessageProvider() {\n                checkProposedApiEnabled(that.extension, 'defaultChatParticipant');\n                return that._welcomeMessageProvider;\n            },\n            set titleProvider(v) {\n                checkProposedApiEnabled(that.extension, 'defaultChatParticipant');\n                that._titleProvider = v;\n                updateMetadataSoon();\n            },\n            get titleProvider() {\n                checkProposedApiEnabled(that.extension, 'defaultChatParticipant');\n                return that._titleProvider;\n            },\n            onDidPerformAction: !isProposedApiEnabled(this.extension, 'chatParticipantAdditions')\n                ? undefined\n                : this._onDidPerformAction.event,\n            set requester(v) {\n                that._requester = v;\n                updateMetadataSoon();\n            },\n            get requester() {\n                return that._requester;\n            },\n            set supportsSlowReferences(v) {\n                checkProposedApiEnabled(that.extension, 'chatParticipantPrivate');\n                that._supportsSlowReferences = v;\n                updateMetadataSoon();\n            },\n            get supportsSlowReferences() {\n                checkProposedApiEnabled(that.extension, 'chatParticipantPrivate');\n                return that._supportsSlowReferences;\n            },\n            dispose() {\n                disposed = true;\n                that._followupProvider = undefined;\n                that._onDidReceiveFeedback.dispose();\n                that._proxy.$unregisterAgent(that._handle);\n            },\n        };\n    }\n    invoke(request, context, response, token) {\n        return this._requestHandler(request, context, response, token);\n    }\n}\nexport { ExtHostChatAgents2 };\n","import { onUnexpectedExternalError } from '../../../base/common/errors.js';\nimport { toDisposable } from '../../../base/common/lifecycle.js';\nimport { ThemeIcon } from '../../../base/common/themables.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { ChatResponseProgressPart, ChatResponseReferencePart } from './extHostTypeConverters.js';\nimport { ChatResponseReferencePart as ChatResponseReferencePart$1, ChatResponseProgressPart as ChatResponseProgressPart$1 } from './extHostTypes.js';\nimport { checkProposedApiEnabled } from '../../services/extensions/common/extensions.js';\nclass ExtHostChatVariables {\n    static { this._idPool = 0; }\n    constructor(mainContext) {\n        this._resolver = ( new Map());\n        this._proxy = ( mainContext.getProxy(MainContext.MainThreadChatVariables));\n    }\n    async $resolveVariable(handle, requestId, messageText, token) {\n        const item = this._resolver.get(handle);\n        if (!item) {\n            return undefined;\n        }\n        try {\n            if (item.resolver.resolve2) {\n                checkProposedApiEnabled(item.extension, 'chatParticipantAdditions');\n                const stream = ( new ChatVariableResolverResponseStream(requestId, this._proxy));\n                const value = await item.resolver.resolve2(item.data.name, { prompt: messageText }, stream.apiObject, token);\n                if (value && value[0]) {\n                    return value[0].value;\n                }\n            }\n            else {\n                const value = await item.resolver.resolve(item.data.name, { prompt: messageText }, token);\n                if (value && value[0]) {\n                    return value[0].value;\n                }\n            }\n        }\n        catch (err) {\n            onUnexpectedExternalError(err);\n        }\n        return undefined;\n    }\n    registerVariableResolver(extension, id, name, userDescription, modelDescription, isSlow, resolver, fullName, themeIconId) {\n        const handle = ExtHostChatVariables._idPool++;\n        const icon = themeIconId ? ThemeIcon.fromId(themeIconId) : undefined;\n        this._resolver.set(handle, { extension, data: { id, name, description: userDescription, modelDescription, icon }, resolver: resolver });\n        this._proxy.$registerVariable(handle, { id, name, description: userDescription, modelDescription, isSlow, fullName, icon });\n        return toDisposable(() => {\n            this._resolver.delete(handle);\n            this._proxy.$unregisterVariable(handle);\n        });\n    }\n}\nclass ChatVariableResolverResponseStream {\n    constructor(_requestId, _proxy) {\n        this._requestId = _requestId;\n        this._proxy = _proxy;\n        this._isClosed = false;\n    }\n    close() {\n        this._isClosed = true;\n    }\n    get apiObject() {\n        if (!this._apiObject) {\n            const that = this;\n            function throwIfDone(source) {\n                if (that._isClosed) {\n                    const err = ( new Error('Response stream has been closed'));\n                    Error.captureStackTrace(err, source);\n                    throw err;\n                }\n            }\n            const _report = (progress) => {\n                this._proxy.$handleProgressChunk(this._requestId, progress);\n            };\n            this._apiObject = {\n                progress(value) {\n                    throwIfDone(this.progress);\n                    const part = new ChatResponseProgressPart$1(value);\n                    const dto = ChatResponseProgressPart.from(part);\n                    _report(dto);\n                    return this;\n                },\n                reference(value) {\n                    throwIfDone(this.reference);\n                    const part = new ChatResponseReferencePart$1(value);\n                    const dto = ChatResponseReferencePart.from(part);\n                    _report(dto);\n                    return this;\n                },\n                push(part) {\n                    throwIfDone(this.push);\n                    if (part instanceof ChatResponseReferencePart$1) {\n                        _report(ChatResponseReferencePart.from(part));\n                    }\n                    else if (part instanceof ChatResponseProgressPart$1) {\n                        _report(ChatResponseProgressPart.from(part));\n                    }\n                    return this;\n                }\n            };\n        }\n        return this._apiObject;\n    }\n}\nexport { ExtHostChatVariables };\n","import { MainContext } from './extHost.protocol.js';\nclass ExtHostClipboard {\n    constructor(mainContext) {\n        const proxy = ( mainContext.getProxy(MainContext.MainThreadClipboard));\n        this.value = ( Object.freeze({\n            readText() {\n                return proxy.$readText();\n            },\n            writeText(value) {\n                return proxy.$writeText(value);\n            }\n        }));\n    }\n}\nexport { ExtHostClipboard };\n","import { Emitter } from '../../../base/common/event.js';\nimport { DisposableStore } from '../../../base/common/lifecycle.js';\nimport { asWebviewUri, webviewGenericCspSource } from '../../contrib/webview/common/webview.js';\nclass ExtHostEditorInsets {\n    constructor(_proxy, _editors, _remoteInfo) {\n        this._proxy = _proxy;\n        this._editors = _editors;\n        this._remoteInfo = _remoteInfo;\n        this._handlePool = 0;\n        this._disposables = ( new DisposableStore());\n        this._insets = ( new Map());\n        this._disposables.add(_editors.onDidChangeVisibleTextEditors(() => {\n            const visibleEditor = _editors.getVisibleTextEditors();\n            for (const value of ( this._insets.values())) {\n                if (visibleEditor.indexOf(value.editor) < 0) {\n                    value.inset.dispose();\n                }\n            }\n        }));\n    }\n    dispose() {\n        this._insets.forEach(value => value.inset.dispose());\n        this._disposables.dispose();\n    }\n    createWebviewEditorInset(editor, line, height, options, extension) {\n        let apiEditor;\n        for (const candidate of this._editors.getVisibleTextEditors(true)) {\n            if (candidate.value === editor) {\n                apiEditor = candidate;\n                break;\n            }\n        }\n        if (!apiEditor) {\n            throw ( new Error('not a visible editor'));\n        }\n        const that = this;\n        const handle = this._handlePool++;\n        const onDidReceiveMessage = ( new Emitter());\n        const onDidDispose = ( new Emitter());\n        const webview = new (class {\n            constructor() {\n                this._html = '';\n                this._options = Object.create(null);\n            }\n            asWebviewUri(resource) {\n                return asWebviewUri(resource, that._remoteInfo);\n            }\n            get cspSource() {\n                return webviewGenericCspSource;\n            }\n            set options(value) {\n                this._options = value;\n                that._proxy.$setOptions(handle, value);\n            }\n            get options() {\n                return this._options;\n            }\n            set html(value) {\n                this._html = value;\n                that._proxy.$setHtml(handle, value);\n            }\n            get html() {\n                return this._html;\n            }\n            get onDidReceiveMessage() {\n                return onDidReceiveMessage.event;\n            }\n            postMessage(message) {\n                return that._proxy.$postMessage(handle, message);\n            }\n        });\n        const inset = new (class {\n            constructor() {\n                this.editor = editor;\n                this.line = line;\n                this.height = height;\n                this.webview = webview;\n                this.onDidDispose = onDidDispose.event;\n            }\n            dispose() {\n                if (( that._insets.has(handle))) {\n                    that._insets.delete(handle);\n                    that._proxy.$disposeEditorInset(handle);\n                    onDidDispose.fire();\n                    onDidDispose.dispose();\n                    onDidReceiveMessage.dispose();\n                }\n            }\n        });\n        this._proxy.$createEditorInset(handle, apiEditor.id, apiEditor.value.document.uri, line + 1, height, options || {}, extension.identifier, extension.extensionLocation);\n        this._insets.set(handle, { editor, inset, onDidReceiveMessage });\n        return inset;\n    }\n    $onDidDispose(handle) {\n        const value = this._insets.get(handle);\n        if (value) {\n            value.inset.dispose();\n        }\n    }\n    $onDidReceiveMessage(handle, message) {\n        const value = this._insets.get(handle);\n        value?.onDidReceiveMessage.fire(message);\n    }\n}\nexport { ExtHostEditorInsets };\n","import { MainContext } from './extHost.protocol.js';\nimport { TextEdit } from './extHostTypeConverters.js';\nimport { URI } from '../../../base/common/uri.js';\nclass ExtHostCodeMapper {\n    static { this._providerHandlePool = 0; }\n    constructor(mainContext) {\n        this.providers = ( new Map());\n        this._proxy = ( mainContext.getProxy(MainContext.MainThreadCodeMapper));\n    }\n    async $mapCode(handle, internalRequest, token) {\n        const provider = this.providers.get(handle);\n        if (!provider) {\n            throw ( new Error(`Received request to map code for unknown provider handle ${handle}`));\n        }\n        const stream = {\n            textEdit: (target, edits) => {\n                edits = (Array.isArray(edits) ? edits : [edits]);\n                this._proxy.$handleProgress(internalRequest.requestId, {\n                    uri: target,\n                    edits: ( edits.map(TextEdit.from))\n                });\n            }\n        };\n        const request = {\n            codeBlocks: ( internalRequest.codeBlocks.map(block => {\n                return {\n                    code: block.code,\n                    resource: URI.revive(block.resource)\n                };\n            })),\n            conversation: internalRequest.conversation\n        };\n        const result = await provider.provideMappedEdits(request, stream, token);\n        return result ?? null;\n    }\n    registerMappedEditsProvider(extension, provider) {\n        const handle = ExtHostCodeMapper._providerHandlePool++;\n        this._proxy.$registerCodeMapperProvider(handle);\n        this.providers.set(handle, provider);\n        return {\n            dispose: () => {\n                return this._proxy.$unregisterCodeMapperProvider(handle);\n            }\n        };\n    }\n}\nexport { ExtHostCodeMapper };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { validateConstraint } from '../../../base/common/types.js';\nimport { Position, Range, Selection, CallHierarchyItem, TypeHierarchyItem, Disposable, Location, NotebookRange } from './extHostTypes.js';\nimport { Position as Position$1, Range as Range$1, Selection as Selection$1, CallHierarchyItem as CallHierarchyItem$1, TypeHierarchyItem as TypeHierarchyItem$1, TestItem, location, NotebookRange as NotebookRange$1 } from './extHostTypeConverters.js';\nimport { cloneAndChange } from '../../../base/common/objects.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { isNonEmptyArray } from '../../../base/common/arrays.js';\nimport { ILogService } from '../../../platform/log/common/log.service.js';\nimport { revive } from '../../../base/common/marshalling.js';\nimport { Range as Range$2 } from '../../../editor/common/core/range.js';\nimport { Position as Position$2 } from '../../../editor/common/core/position.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { toDisposable } from '../../../base/common/lifecycle.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\nimport { TestItemImpl } from './extHostTestItem.js';\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport { SerializableObjectWithBuffers } from '../../services/extensions/common/proxyIdentifier.js';\nimport { toErrorMessage } from '../../../base/common/errorMessage.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { TelemetryTrustedValue } from '../../../platform/telemetry/common/telemetryUtils.js';\nimport { IExtHostTelemetry } from './extHostTelemetry.js';\nimport { generateUuid } from '../../../base/common/uuid.js';\nlet ExtHostCommands = class ExtHostCommands {\n    #proxy;\n    #telemetry;\n    #extHostTelemetry;\n    constructor(extHostRpc, logService, extHostTelemetry) {\n        this._commands = ( new Map());\n        this._apiCommands = ( new Map());\n        this.#proxy = ( extHostRpc.getProxy(MainContext.MainThreadCommands));\n        this._logService = logService;\n        this.#extHostTelemetry = extHostTelemetry;\n        this.#telemetry = ( extHostRpc.getProxy(MainContext.MainThreadTelemetry));\n        this.converter = ( new CommandsConverter(this, id => {\n            const candidate = this._apiCommands.get(id);\n            return candidate?.result === ApiCommandResult.Void\n                ? candidate : undefined;\n        }, logService));\n        this._argumentProcessors = [\n            {\n                processArgument(a) {\n                    return revive(a);\n                }\n            },\n            {\n                processArgument(arg) {\n                    return cloneAndChange(arg, function (obj) {\n                        if (Range$2.isIRange(obj)) {\n                            return Range$1.to(obj);\n                        }\n                        if (Position$2.isIPosition(obj)) {\n                            return Position$1.to(obj);\n                        }\n                        if (Range$2.isIRange(obj.range) && URI.isUri(obj.uri)) {\n                            return location.to(obj);\n                        }\n                        if (obj instanceof VSBuffer) {\n                            return obj.buffer.buffer;\n                        }\n                        if (!Array.isArray(obj)) {\n                            return obj;\n                        }\n                    });\n                }\n            }\n        ];\n    }\n    registerArgumentProcessor(processor) {\n        this._argumentProcessors.push(processor);\n    }\n    registerApiCommand(apiCommand) {\n        const registration = this.registerCommand(false, apiCommand.id, async (...apiArgs) => {\n            const internalArgs = ( apiCommand.args.map((arg, i) => {\n                if (!arg.validate(apiArgs[i])) {\n                    throw ( new Error(\n                        `Invalid argument '${arg.name}' when running '${apiCommand.id}', received: ${typeof apiArgs[i] === 'object' ? JSON.stringify(apiArgs[i], null, '\\t') : apiArgs[i]} `\n                    ));\n                }\n                return arg.convert(apiArgs[i]);\n            }));\n            const internalResult = await this.executeCommand(apiCommand.internalId, ...internalArgs);\n            return apiCommand.result.convert(internalResult, apiArgs, this.converter);\n        }, undefined, {\n            description: apiCommand.description,\n            args: apiCommand.args,\n            returns: apiCommand.result.description\n        });\n        this._apiCommands.set(apiCommand.id, apiCommand);\n        return new Disposable(() => {\n            registration.dispose();\n            this._apiCommands.delete(apiCommand.id);\n        });\n    }\n    registerCommand(global, id, callback, thisArg, metadata, extension) {\n        this._logService.trace('ExtHostCommands#registerCommand', id);\n        if (!id.trim().length) {\n            throw ( new Error('invalid id'));\n        }\n        if (( this._commands.has(id))) {\n            throw ( new Error(`command '${id}' already exists`));\n        }\n        this._commands.set(id, { callback, thisArg, metadata, extension });\n        if (global) {\n            this.#proxy.$registerCommand(id);\n        }\n        return new Disposable(() => {\n            if (this._commands.delete(id)) {\n                if (global) {\n                    this.#proxy.$unregisterCommand(id);\n                }\n            }\n        });\n    }\n    executeCommand(id, ...args) {\n        this._logService.trace('ExtHostCommands#executeCommand', id);\n        return this._doExecuteCommand(id, args, true);\n    }\n    async _doExecuteCommand(id, args, retry) {\n        if (( this._commands.has(id))) {\n            this.#proxy.$fireCommandActivationEvent(id);\n            return this._executeContributedCommand(id, args, false);\n        }\n        else {\n            let hasBuffers = false;\n            const toArgs = cloneAndChange(args, function (value) {\n                if (value instanceof Position) {\n                    return Position$1.from(value);\n                }\n                else if (value instanceof Range) {\n                    return Range$1.from(value);\n                }\n                else if (value instanceof Location) {\n                    return location.from(value);\n                }\n                else if (NotebookRange.isNotebookRange(value)) {\n                    return NotebookRange$1.from(value);\n                }\n                else if (value instanceof ArrayBuffer) {\n                    hasBuffers = true;\n                    return VSBuffer.wrap(( new Uint8Array(value)));\n                }\n                else if (value instanceof Uint8Array) {\n                    hasBuffers = true;\n                    return VSBuffer.wrap(value);\n                }\n                else if (value instanceof VSBuffer) {\n                    hasBuffers = true;\n                    return value;\n                }\n                if (!Array.isArray(value)) {\n                    return value;\n                }\n            });\n            try {\n                const result = await this.#proxy.$executeCommand(id, hasBuffers ? ( new SerializableObjectWithBuffers(toArgs)) : toArgs, retry);\n                return revive(result);\n            }\n            catch (e) {\n                if (e instanceof Error && e.message === '$executeCommand:retry') {\n                    return this._doExecuteCommand(id, args, false);\n                }\n                else {\n                    throw e;\n                }\n            }\n        }\n    }\n    async _executeContributedCommand(id, args, annotateError) {\n        const command = this._commands.get(id);\n        if (!command) {\n            throw ( new Error('Unknown command'));\n        }\n        const { callback, thisArg, metadata } = command;\n        if (metadata?.args) {\n            for (let i = 0; i < metadata.args.length; i++) {\n                try {\n                    validateConstraint(args[i], metadata.args[i].constraint);\n                }\n                catch (err) {\n                    throw ( new Error(\n                        `Running the contributed command: '${id}' failed. Illegal argument '${metadata.args[i].name}' - ${metadata.args[i].description}`\n                    ));\n                }\n            }\n        }\n        const stopWatch = StopWatch.create();\n        try {\n            return await callback.apply(thisArg, args);\n        }\n        catch (err) {\n            if (id === this.converter.delegatingCommandId) {\n                const actual = this.converter.getActualCommand(...args);\n                if (actual) {\n                    id = actual.command;\n                }\n            }\n            this._logService.error(err, id, command.extension?.identifier);\n            if (!annotateError) {\n                throw err;\n            }\n            if (command.extension?.identifier) {\n                const reported = this.#extHostTelemetry.onExtensionError(command.extension.identifier, err);\n                this._logService.trace('forwarded error to extension?', reported, command.extension?.identifier);\n            }\n            throw new (class CommandError extends Error {\n                constructor() {\n                    super(toErrorMessage(err));\n                    this.id = id;\n                    this.source = command.extension?.displayName ?? command.extension?.name;\n                }\n            });\n        }\n        finally {\n            this._reportTelemetry(command, id, stopWatch.elapsed());\n        }\n    }\n    _reportTelemetry(command, id, duration) {\n        if (!command.extension) {\n            return;\n        }\n        this.#telemetry.$publicLog2('Extension:ActionExecuted', {\n            extensionId: command.extension.identifier.value,\n            id: ( new TelemetryTrustedValue(id)),\n            duration: duration,\n        });\n    }\n    $executeContributedCommand(id, ...args) {\n        this._logService.trace('ExtHostCommands#$executeContributedCommand', id);\n        const cmdHandler = this._commands.get(id);\n        if (!cmdHandler) {\n            return Promise.reject(( new Error(`Contributed command '${id}' does not exist.`)));\n        }\n        else {\n            args = ( args.map(\n                arg => this._argumentProcessors.reduce((r, p) => p.processArgument(r, cmdHandler.extension?.identifier), arg)\n            ));\n            return this._executeContributedCommand(id, args, true);\n        }\n    }\n    getCommands(filterUnderscoreCommands = false) {\n        this._logService.trace('ExtHostCommands#getCommands', filterUnderscoreCommands);\n        return this.#proxy.$getCommands().then(result => {\n            if (filterUnderscoreCommands) {\n                result = result.filter(command => command[0] !== '_');\n            }\n            return result;\n        });\n    }\n    $getContributedCommandMetadata() {\n        const result = Object.create(null);\n        for (const [id, command] of this._commands) {\n            const { metadata } = command;\n            if (metadata) {\n                result[id] = metadata;\n            }\n        }\n        return Promise.resolve(result);\n    }\n};\nExtHostCommands = ( __decorate([\n    ( __param(0, IExtHostRpcService)),\n    ( __param(1, ILogService)),\n    ( __param(2, IExtHostTelemetry))\n], ExtHostCommands));\nconst IExtHostCommands = ( createDecorator('IExtHostCommands'));\nclass CommandsConverter {\n    constructor(_commands, _lookupApiCommand, _logService) {\n        this._commands = _commands;\n        this._lookupApiCommand = _lookupApiCommand;\n        this._logService = _logService;\n        this.delegatingCommandId = `__vsc${generateUuid()}`;\n        this._cache = ( new Map());\n        this._cachIdPool = 0;\n        this._commands.registerCommand(true, this.delegatingCommandId, this._executeConvertedCommand, this);\n    }\n    toInternal(command, disposables) {\n        if (!command) {\n            return undefined;\n        }\n        const result = {\n            $ident: undefined,\n            id: command.command,\n            title: command.title,\n            tooltip: command.tooltip\n        };\n        if (!command.command) {\n            return result;\n        }\n        const apiCommand = this._lookupApiCommand(command.command);\n        if (apiCommand) {\n            result.id = apiCommand.internalId;\n            result.arguments = ( apiCommand.args.map((arg, i) => arg.convert(command.arguments && command.arguments[i])));\n        }\n        else if (isNonEmptyArray(command.arguments)) {\n            const id = `${command.command} /${++this._cachIdPool}`;\n            this._cache.set(id, command);\n            disposables.add(toDisposable(() => {\n                this._cache.delete(id);\n                this._logService.trace('CommandsConverter#DISPOSE', id);\n            }));\n            result.$ident = id;\n            result.id = this.delegatingCommandId;\n            result.arguments = [id];\n            this._logService.trace('CommandsConverter#CREATE', command.command, id);\n        }\n        return result;\n    }\n    fromInternal(command) {\n        if (typeof command.$ident === 'string') {\n            return this._cache.get(command.$ident);\n        }\n        else {\n            return {\n                command: command.id,\n                title: command.title,\n                arguments: command.arguments\n            };\n        }\n    }\n    getActualCommand(...args) {\n        return this._cache.get(args[0]);\n    }\n    _executeConvertedCommand(...args) {\n        const actualCmd = this.getActualCommand(...args);\n        this._logService.trace('CommandsConverter#EXECUTE', args[0], actualCmd ? actualCmd.command : 'MISSING');\n        if (!actualCmd) {\n            return Promise.reject(`Actual command not found, wanted to execute ${args[0]}`);\n        }\n        return this._commands.executeCommand(actualCmd.command, ...(actualCmd.arguments || []));\n    }\n}\nclass ApiCommandArgument {\n    static { this.Uri = ( new ApiCommandArgument('uri', 'Uri of a text document', v => URI.isUri(v), v => v)); }\n    static { this.Position = ( new ApiCommandArgument(\n        'position',\n        'A position in a text document',\n        v => Position.isPosition(v),\n        Position$1.from\n    )); }\n    static { this.Range = ( new ApiCommandArgument(\n        'range',\n        'A range in a text document',\n        v => Range.isRange(v),\n        Range$1.from\n    )); }\n    static { this.Selection = ( new ApiCommandArgument(\n        'selection',\n        'A selection in a text document',\n        v => Selection.isSelection(v),\n        Selection$1.from\n    )); }\n    static { this.Number = ( new ApiCommandArgument('number', '', v => typeof v === 'number', v => v)); }\n    static { this.String = ( new ApiCommandArgument('string', '', v => typeof v === 'string', v => v)); }\n    static { this.StringArray = ApiCommandArgument.Arr(ApiCommandArgument.String); }\n    static Arr(element) {\n        return ( new ApiCommandArgument(\n            `${element.name}_array`,\n            `Array of ${element.name}, ${element.description}`,\n            (v) => Array.isArray(v) && v.every(e => element.validate(e)),\n            (v) => ( v.map(e => element.convert(e)))\n        ));\n    }\n    static { this.CallHierarchyItem = ( new ApiCommandArgument(\n        'item',\n        'A call hierarchy item',\n        v => v instanceof CallHierarchyItem,\n        CallHierarchyItem$1.from\n    )); }\n    static { this.TypeHierarchyItem = ( new ApiCommandArgument(\n        'item',\n        'A type hierarchy item',\n        v => v instanceof TypeHierarchyItem,\n        TypeHierarchyItem$1.from\n    )); }\n    static { this.TestItem = ( new ApiCommandArgument(\n        'testItem',\n        'A VS Code TestItem',\n        v => v instanceof TestItemImpl,\n        TestItem.from\n    )); }\n    constructor(name, description, validate, convert) {\n        this.name = name;\n        this.description = description;\n        this.validate = validate;\n        this.convert = convert;\n    }\n    optional() {\n        return ( new ApiCommandArgument(\n            this.name,\n            `(optional) ${this.description}`,\n            value => value === undefined || value === null || this.validate(value),\n            value => value === undefined ? undefined : value === null ? null : this.convert(value)\n        ));\n    }\n    with(name, description) {\n        return ( new ApiCommandArgument(\n            name ?? this.name,\n            description ?? this.description,\n            this.validate,\n            this.convert\n        ));\n    }\n}\nclass ApiCommandResult {\n    static { this.Void = ( new ApiCommandResult('no result', v => v)); }\n    constructor(description, convert) {\n        this.description = description;\n        this.convert = convert;\n    }\n}\nclass ApiCommand {\n    constructor(id, internalId, description, args, result) {\n        this.id = id;\n        this.internalId = internalId;\n        this.description = description;\n        this.args = args;\n        this.result = result;\n    }\n}\nexport { ApiCommand, ApiCommandArgument, ApiCommandResult, CommandsConverter, ExtHostCommands, IExtHostCommands };\n","import { asPromise } from '../../../base/common/async.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { MutableDisposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { CommentThreadCollapsibleState as CommentThreadCollapsibleState$1, CommentThreadState as CommentThreadState$1, CommentThreadApplicability as CommentThreadApplicability$1 } from '../../../editor/common/languages.js';\nimport { ExtensionIdentifierMap } from '../../../platform/extensions/common/extensions.js';\nimport { Range, MarkdownString, pathOrURIToURI } from './extHostTypeConverters.js';\nimport { MarkdownString as MarkdownString$1, CommentThreadFocus, CommentThreadCollapsibleState, CommentThreadState, CommentThreadApplicability } from './extHostTypes.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { checkProposedApiEnabled } from '../../services/extensions/common/extensions.js';\nfunction createExtHostComments(mainContext, commands, documents) {\n    const proxy = ( mainContext.getProxy(MainContext.MainThreadComments));\n    class ExtHostCommentsImpl {\n        static { this.handlePool = 0; }\n        constructor() {\n            this._commentControllers = ( new Map());\n            this._commentControllersByExtension = ( new ExtensionIdentifierMap());\n            commands.registerArgumentProcessor({\n                processArgument: arg => {\n                    if (arg && arg.$mid === 6 ) {\n                        const commentController = this._commentControllers.get(arg.handle);\n                        if (!commentController) {\n                            return arg;\n                        }\n                        return commentController.value;\n                    }\n                    else if (arg && arg.$mid === 7 ) {\n                        const marshalledCommentThread = arg;\n                        const commentController = this._commentControllers.get(marshalledCommentThread.commentControlHandle);\n                        if (!commentController) {\n                            return marshalledCommentThread;\n                        }\n                        const commentThread = commentController.getCommentThread(marshalledCommentThread.commentThreadHandle);\n                        if (!commentThread) {\n                            return marshalledCommentThread;\n                        }\n                        return commentThread.value;\n                    }\n                    else if (arg && ((arg.$mid === 9  || arg.$mid === 8) )) {\n                        const commentController = this._commentControllers.get(arg.thread.commentControlHandle);\n                        if (!commentController) {\n                            return arg;\n                        }\n                        const commentThread = commentController.getCommentThread(arg.thread.commentThreadHandle);\n                        if (!commentThread) {\n                            return arg;\n                        }\n                        if (arg.$mid === 8 ) {\n                            return commentThread.value;\n                        }\n                        return {\n                            thread: commentThread.value,\n                            text: arg.text\n                        };\n                    }\n                    else if (arg && arg.$mid === 10 ) {\n                        const commentController = this._commentControllers.get(arg.thread.commentControlHandle);\n                        if (!commentController) {\n                            return arg;\n                        }\n                        const commentThread = commentController.getCommentThread(arg.thread.commentThreadHandle);\n                        if (!commentThread) {\n                            return arg;\n                        }\n                        const commentUniqueId = arg.commentUniqueId;\n                        const comment = commentThread.getCommentByUniqueId(commentUniqueId);\n                        if (!comment) {\n                            return arg;\n                        }\n                        return comment;\n                    }\n                    else if (arg && arg.$mid === 11 ) {\n                        const commentController = this._commentControllers.get(arg.thread.commentControlHandle);\n                        if (!commentController) {\n                            return arg;\n                        }\n                        const commentThread = commentController.getCommentThread(arg.thread.commentThreadHandle);\n                        if (!commentThread) {\n                            return arg;\n                        }\n                        const body = arg.text;\n                        const commentUniqueId = arg.commentUniqueId;\n                        const comment = commentThread.getCommentByUniqueId(commentUniqueId);\n                        if (!comment) {\n                            return arg;\n                        }\n                        if (typeof comment.body === 'string') {\n                            comment.body = body;\n                        }\n                        else {\n                            comment.body = new MarkdownString$1(body);\n                        }\n                        return comment;\n                    }\n                    return arg;\n                }\n            });\n        }\n        createCommentController(extension, id, label) {\n            const handle = ExtHostCommentsImpl.handlePool++;\n            const commentController = ( new ExtHostCommentController(extension, handle, id, label));\n            this._commentControllers.set(commentController.handle, commentController);\n            const commentControllers = this._commentControllersByExtension.get(extension.identifier) || [];\n            commentControllers.push(commentController);\n            this._commentControllersByExtension.set(extension.identifier, commentControllers);\n            return commentController.value;\n        }\n        async $createCommentThreadTemplate(commentControllerHandle, uriComponents, range, editorId) {\n            const commentController = this._commentControllers.get(commentControllerHandle);\n            if (!commentController) {\n                return;\n            }\n            commentController.$createCommentThreadTemplate(uriComponents, range, editorId);\n        }\n        async $setActiveComment(controllerHandle, commentInfo) {\n            const commentController = this._commentControllers.get(controllerHandle);\n            if (!commentController) {\n                return;\n            }\n            commentController.$setActiveComment(commentInfo ?? undefined);\n        }\n        async $updateCommentThreadTemplate(commentControllerHandle, threadHandle, range) {\n            const commentController = this._commentControllers.get(commentControllerHandle);\n            if (!commentController) {\n                return;\n            }\n            commentController.$updateCommentThreadTemplate(threadHandle, range);\n        }\n        $deleteCommentThread(commentControllerHandle, commentThreadHandle) {\n            const commentController = this._commentControllers.get(commentControllerHandle);\n            commentController?.$deleteCommentThread(commentThreadHandle);\n        }\n        async $provideCommentingRanges(commentControllerHandle, uriComponents, token) {\n            const commentController = this._commentControllers.get(commentControllerHandle);\n            if (!commentController || !commentController.commentingRangeProvider) {\n                return Promise.resolve(undefined);\n            }\n            const document = await documents.ensureDocumentData(URI.revive(uriComponents));\n            return asPromise(async () => {\n                const rangesResult = await commentController.commentingRangeProvider.provideCommentingRanges(document.document, token);\n                let ranges;\n                if (Array.isArray(rangesResult)) {\n                    ranges = {\n                        ranges: rangesResult,\n                        fileComments: false\n                    };\n                }\n                else if (rangesResult) {\n                    ranges = {\n                        ranges: rangesResult.ranges || [],\n                        fileComments: rangesResult.enableFileComments || false\n                    };\n                }\n                else {\n                    ranges = rangesResult ?? undefined;\n                }\n                return ranges;\n            }).then(ranges => {\n                let convertedResult = undefined;\n                if (ranges) {\n                    convertedResult = {\n                        ranges: ( ranges.ranges.map(x => Range.from(x))),\n                        fileComments: ranges.fileComments\n                    };\n                }\n                return convertedResult;\n            });\n        }\n        $toggleReaction(commentControllerHandle, threadHandle, uri, comment, reaction) {\n            const commentController = this._commentControllers.get(commentControllerHandle);\n            if (!commentController || !commentController.reactionHandler) {\n                return Promise.resolve(undefined);\n            }\n            return asPromise(() => {\n                const commentThread = commentController.getCommentThread(threadHandle);\n                if (commentThread) {\n                    const vscodeComment = commentThread.getCommentByUniqueId(comment.uniqueIdInThread);\n                    if (commentController !== undefined && vscodeComment) {\n                        if (commentController.reactionHandler) {\n                            return commentController.reactionHandler(vscodeComment, convertFromReaction(reaction));\n                        }\n                    }\n                }\n                return Promise.resolve(undefined);\n            });\n        }\n    }\n    class ExtHostCommentThread {\n        static { this._handlePool = 0; }\n        set threadId(id) {\n            this._id = id;\n        }\n        get threadId() {\n            return this._id;\n        }\n        get id() {\n            return this._id;\n        }\n        get resource() {\n            return this._uri;\n        }\n        get uri() {\n            return this._uri;\n        }\n        set range(range) {\n            if (((range === undefined) !== (this._range === undefined)) || (!range || !this._range || !range.isEqual(this._range))) {\n                this._range = range;\n                this.modifications.range = range;\n                this._onDidUpdateCommentThread.fire();\n            }\n        }\n        get range() {\n            return this._range;\n        }\n        set canReply(state) {\n            if (this._canReply !== state) {\n                this._canReply = state;\n                this.modifications.canReply = state;\n                this._onDidUpdateCommentThread.fire();\n            }\n        }\n        get canReply() {\n            return this._canReply;\n        }\n        get label() {\n            return this._label;\n        }\n        set label(label) {\n            this._label = label;\n            this.modifications.label = label;\n            this._onDidUpdateCommentThread.fire();\n        }\n        get contextValue() {\n            return this._contextValue;\n        }\n        set contextValue(context) {\n            this._contextValue = context;\n            this.modifications.contextValue = context;\n            this._onDidUpdateCommentThread.fire();\n        }\n        get comments() {\n            return this._comments;\n        }\n        set comments(newComments) {\n            this._comments = newComments;\n            this.modifications.comments = newComments;\n            this._onDidUpdateCommentThread.fire();\n        }\n        get collapsibleState() {\n            return this._collapseState;\n        }\n        set collapsibleState(newState) {\n            this._collapseState = newState;\n            this.modifications.collapsibleState = newState;\n            this._onDidUpdateCommentThread.fire();\n        }\n        get state() {\n            return this._state;\n        }\n        set state(newState) {\n            this._state = newState;\n            if (typeof newState === 'object') {\n                checkProposedApiEnabled(this.extensionDescription, 'commentThreadApplicability');\n                this.modifications.state = newState.resolved;\n                this.modifications.applicability = newState.applicability;\n            }\n            else {\n                this.modifications.state = newState;\n            }\n            this._onDidUpdateCommentThread.fire();\n        }\n        get isDisposed() {\n            return this._isDiposed;\n        }\n        constructor(commentControllerId, _commentControllerHandle, _id, _uri, _range, _comments, extensionDescription, _isTemplate, editorId) {\n            this._commentControllerHandle = _commentControllerHandle;\n            this._id = _id;\n            this._uri = _uri;\n            this._range = _range;\n            this._comments = _comments;\n            this.extensionDescription = extensionDescription;\n            this._isTemplate = _isTemplate;\n            this.handle = ExtHostCommentThread._handlePool++;\n            this.commentHandle = 0;\n            this.modifications = Object.create(null);\n            this._onDidUpdateCommentThread = ( new Emitter());\n            this.onDidUpdateCommentThread = this._onDidUpdateCommentThread.event;\n            this._canReply = true;\n            this._commentsMap = ( new Map());\n            this._acceptInputDisposables = ( new MutableDisposable());\n            this._acceptInputDisposables.value = ( new DisposableStore());\n            if (this._id === undefined) {\n                this._id = `${commentControllerId}.${this.handle}`;\n            }\n            proxy.$createCommentThread(_commentControllerHandle, this.handle, this._id, this._uri, Range.from(this._range), ( this._comments.map(\n                cmt => convertToDTOComment(this, cmt, this._commentsMap, this.extensionDescription)\n            )), extensionDescription.identifier, this._isTemplate, editorId);\n            this._localDisposables = [];\n            this._isDiposed = false;\n            this._localDisposables.push(this.onDidUpdateCommentThread(() => {\n                this.eventuallyUpdateCommentThread();\n            }));\n            this._localDisposables.push({\n                dispose: () => {\n                    proxy.$deleteCommentThread(_commentControllerHandle, this.handle);\n                }\n            });\n            const that = this;\n            this.value = {\n                get uri() { return that.uri; },\n                get range() { return that.range; },\n                set range(value) { that.range = value; },\n                get comments() { return that.comments; },\n                set comments(value) { that.comments = value; },\n                get collapsibleState() { return that.collapsibleState; },\n                set collapsibleState(value) { that.collapsibleState = value; },\n                get canReply() { return that.canReply; },\n                set canReply(state) { that.canReply = state; },\n                get contextValue() { return that.contextValue; },\n                set contextValue(value) { that.contextValue = value; },\n                get label() { return that.label; },\n                set label(value) { that.label = value; },\n                get state() { return that.state; },\n                set state(value) { that.state = value; },\n                reveal: (comment, options) => that.reveal(comment, options),\n                hide: () => that.hide(),\n                dispose: () => {\n                    that.dispose();\n                }\n            };\n        }\n        updateIsTemplate() {\n            if (this._isTemplate) {\n                this._isTemplate = false;\n                this.modifications.isTemplate = false;\n            }\n        }\n        eventuallyUpdateCommentThread() {\n            if (this._isDiposed) {\n                return;\n            }\n            this.updateIsTemplate();\n            if (!this._acceptInputDisposables.value) {\n                this._acceptInputDisposables.value = ( new DisposableStore());\n            }\n            const modified = (value) => Object.prototype.hasOwnProperty.call(this.modifications, value);\n            const formattedModifications = {};\n            if (modified('range')) {\n                formattedModifications.range = Range.from(this._range);\n            }\n            if (modified('label')) {\n                formattedModifications.label = this.label;\n            }\n            if (modified('contextValue')) {\n                formattedModifications.contextValue = this.contextValue ?? null;\n            }\n            if (modified('comments')) {\n                formattedModifications.comments =\n                    ( this._comments.map(\n                        cmt => convertToDTOComment(this, cmt, this._commentsMap, this.extensionDescription)\n                    ));\n            }\n            if (modified('collapsibleState')) {\n                formattedModifications.collapseState = convertToCollapsibleState(this._collapseState);\n            }\n            if (modified('canReply')) {\n                formattedModifications.canReply = this.canReply;\n            }\n            if (modified('state')) {\n                formattedModifications.state = convertToState(this._state);\n            }\n            if (modified('applicability')) {\n                formattedModifications.applicability = convertToRelevance(this._state);\n            }\n            if (modified('isTemplate')) {\n                formattedModifications.isTemplate = this._isTemplate;\n            }\n            this.modifications = {};\n            proxy.$updateCommentThread(this._commentControllerHandle, this.handle, this._id, this._uri, formattedModifications);\n        }\n        getCommentByUniqueId(uniqueId) {\n            for (const key of this._commentsMap) {\n                const comment = key[0];\n                const id = key[1];\n                if (uniqueId === id) {\n                    return comment;\n                }\n            }\n            return;\n        }\n        async reveal(commentOrOptions, options) {\n            checkProposedApiEnabled(this.extensionDescription, 'commentReveal');\n            let comment;\n            if (commentOrOptions && commentOrOptions.body !== undefined) {\n                comment = commentOrOptions;\n            }\n            else {\n                options = options ?? commentOrOptions;\n            }\n            let commentToReveal = comment ? this._commentsMap.get(comment) : undefined;\n            commentToReveal ??= this._commentsMap.get(this._comments[0]);\n            let preserveFocus = true;\n            let focusReply = false;\n            if (options?.focus === CommentThreadFocus.Reply) {\n                focusReply = true;\n                preserveFocus = false;\n            }\n            else if (options?.focus === CommentThreadFocus.Comment) {\n                preserveFocus = false;\n            }\n            return proxy.$revealCommentThread(this._commentControllerHandle, this.handle, commentToReveal, { preserveFocus, focusReply });\n        }\n        async hide() {\n            return proxy.$hideCommentThread(this._commentControllerHandle, this.handle);\n        }\n        dispose() {\n            this._isDiposed = true;\n            this._acceptInputDisposables.dispose();\n            this._localDisposables.forEach(disposable => disposable.dispose());\n        }\n    }\n    class ExtHostCommentController {\n        get id() {\n            return this._id;\n        }\n        get label() {\n            return this._label;\n        }\n        get handle() {\n            return this._handle;\n        }\n        get commentingRangeProvider() {\n            return this._commentingRangeProvider;\n        }\n        set commentingRangeProvider(provider) {\n            this._commentingRangeProvider = provider;\n            if (provider?.resourceHints) {\n                checkProposedApiEnabled(this._extension, 'commentingRangeHint');\n            }\n            proxy.$updateCommentingRanges(this.handle, provider?.resourceHints);\n        }\n        get reactionHandler() {\n            return this._reactionHandler;\n        }\n        set reactionHandler(handler) {\n            this._reactionHandler = handler;\n            proxy.$updateCommentControllerFeatures(this.handle, { reactionHandler: !!handler });\n        }\n        get options() {\n            return this._options;\n        }\n        set options(options) {\n            this._options = options;\n            proxy.$updateCommentControllerFeatures(this.handle, { options: this._options });\n        }\n        get activeComment() {\n            checkProposedApiEnabled(this._extension, 'activeComment');\n            return this._activeComment;\n        }\n        get activeCommentThread() {\n            checkProposedApiEnabled(this._extension, 'activeComment');\n            return this._activeThread?.value;\n        }\n        constructor(_extension, _handle, _id, _label) {\n            this._extension = _extension;\n            this._handle = _handle;\n            this._id = _id;\n            this._label = _label;\n            this._threads = ( new Map());\n            proxy.$registerCommentController(this.handle, _id, _label, this._extension.identifier.value);\n            const that = this;\n            this.value = ( Object.freeze({\n                id: that.id,\n                label: that.label,\n                get options() { return that.options; },\n                set options(options) { that.options = options; },\n                get commentingRangeProvider() { return that.commentingRangeProvider; },\n                set commentingRangeProvider(commentingRangeProvider) { that.commentingRangeProvider = commentingRangeProvider; },\n                get reactionHandler() { return that.reactionHandler; },\n                set reactionHandler(handler) { that.reactionHandler = handler; },\n                get activeCommentThread() { return that.activeCommentThread; },\n                createCommentThread(uri, range, comments) {\n                    return that.createCommentThread(uri, range, comments).value;\n                },\n                dispose: () => { that.dispose(); },\n            }));\n            this._localDisposables = [];\n            this._localDisposables.push({\n                dispose: () => {\n                    proxy.$unregisterCommentController(this.handle);\n                }\n            });\n        }\n        createCommentThread(resource, range, comments) {\n            if (range === undefined) {\n                checkProposedApiEnabled(this._extension, 'fileComments');\n            }\n            const commentThread = ( new ExtHostCommentThread(\n                this.id,\n                this.handle,\n                undefined,\n                resource,\n                range,\n                comments,\n                this._extension,\n                false\n            ));\n            this._threads.set(commentThread.handle, commentThread);\n            return commentThread;\n        }\n        $setActiveComment(commentInfo) {\n            if (!commentInfo) {\n                this._activeComment = undefined;\n                this._activeThread = undefined;\n                return;\n            }\n            const thread = this._threads.get(commentInfo.commentThreadHandle);\n            if (thread) {\n                this._activeComment = commentInfo.uniqueIdInThread ? thread.getCommentByUniqueId(commentInfo.uniqueIdInThread) : undefined;\n                this._activeThread = thread;\n            }\n        }\n        $createCommentThreadTemplate(uriComponents, range, editorId) {\n            const commentThread = ( new ExtHostCommentThread(\n                this.id,\n                this.handle,\n                undefined,\n                URI.revive(uriComponents),\n                Range.to(range),\n                [],\n                this._extension,\n                true,\n                editorId\n            ));\n            commentThread.collapsibleState = CommentThreadCollapsibleState$1.Expanded;\n            this._threads.set(commentThread.handle, commentThread);\n            return commentThread;\n        }\n        $updateCommentThreadTemplate(threadHandle, range) {\n            const thread = this._threads.get(threadHandle);\n            if (thread) {\n                thread.range = Range.to(range);\n            }\n        }\n        $deleteCommentThread(threadHandle) {\n            const thread = this._threads.get(threadHandle);\n            thread?.dispose();\n            this._threads.delete(threadHandle);\n        }\n        getCommentThread(handle) {\n            return this._threads.get(handle);\n        }\n        dispose() {\n            this._threads.forEach(value => {\n                value.dispose();\n            });\n            this._localDisposables.forEach(disposable => disposable.dispose());\n        }\n    }\n    function convertToDTOComment(thread, vscodeComment, commentsMap, extension) {\n        let commentUniqueId = commentsMap.get(vscodeComment);\n        if (!commentUniqueId) {\n            commentUniqueId = ++thread.commentHandle;\n            commentsMap.set(vscodeComment, commentUniqueId);\n        }\n        if (vscodeComment.state !== undefined) {\n            checkProposedApiEnabled(extension, 'commentsDraftState');\n        }\n        if (vscodeComment.reactions?.some(reaction => reaction.reactors !== undefined)) {\n            checkProposedApiEnabled(extension, 'commentReactor');\n        }\n        return {\n            mode: vscodeComment.mode,\n            contextValue: vscodeComment.contextValue,\n            uniqueIdInThread: commentUniqueId,\n            body: (typeof vscodeComment.body === 'string') ? vscodeComment.body : MarkdownString.from(vscodeComment.body),\n            userName: vscodeComment.author.name,\n            userIconPath: vscodeComment.author.iconPath,\n            label: vscodeComment.label,\n            commentReactions: vscodeComment.reactions ? ( vscodeComment.reactions.map(reaction => convertToReaction(reaction))) : undefined,\n            state: vscodeComment.state,\n            timestamp: vscodeComment.timestamp?.toJSON()\n        };\n    }\n    function convertToReaction(reaction) {\n        return {\n            label: reaction.label,\n            iconPath: reaction.iconPath ? pathOrURIToURI(reaction.iconPath) : undefined,\n            count: reaction.count,\n            hasReacted: reaction.authorHasReacted,\n            reactors: ((reaction.reactors && (reaction.reactors.length > 0) && (typeof reaction.reactors[0] !== 'string')) ? ( reaction.reactors.map(reactor => reactor.name)) : reaction.reactors)\n        };\n    }\n    function convertFromReaction(reaction) {\n        return {\n            label: reaction.label || '',\n            count: reaction.count || 0,\n            iconPath: reaction.iconPath ? URI.revive(reaction.iconPath) : '',\n            authorHasReacted: reaction.hasReacted || false,\n            reactors: reaction.reactors?.map(reactor => ({ name: reactor }))\n        };\n    }\n    function convertToCollapsibleState(kind) {\n        if (kind !== undefined) {\n            switch (kind) {\n                case CommentThreadCollapsibleState.Expanded:\n                    return CommentThreadCollapsibleState$1.Expanded;\n                case CommentThreadCollapsibleState.Collapsed:\n                    return CommentThreadCollapsibleState$1.Collapsed;\n            }\n        }\n        return CommentThreadCollapsibleState$1.Collapsed;\n    }\n    function convertToState(kind) {\n        let resolvedKind;\n        if (typeof kind === 'object') {\n            resolvedKind = kind.resolved;\n        }\n        else {\n            resolvedKind = kind;\n        }\n        if (resolvedKind !== undefined) {\n            switch (resolvedKind) {\n                case CommentThreadState.Unresolved:\n                    return CommentThreadState$1.Unresolved;\n                case CommentThreadState.Resolved:\n                    return CommentThreadState$1.Resolved;\n            }\n        }\n        return CommentThreadState$1.Unresolved;\n    }\n    function convertToRelevance(kind) {\n        let applicabilityKind = undefined;\n        if (typeof kind === 'object') {\n            applicabilityKind = kind.applicability;\n        }\n        if (applicabilityKind !== undefined) {\n            switch (applicabilityKind) {\n                case CommentThreadApplicability.Current:\n                    return CommentThreadApplicability$1.Current;\n                case CommentThreadApplicability.Outdated:\n                    return CommentThreadApplicability$1.Outdated;\n            }\n        }\n        return CommentThreadApplicability$1.Current;\n    }\n    return ( new ExtHostCommentsImpl());\n}\nexport { createExtHostComments };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { mixin, deepClone } from '../../../base/common/objects.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { IExtHostWorkspace } from './extHostWorkspace.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { ConfigurationTarget } from './extHostTypes.js';\nimport { Configuration as Configuration$1, ConfigurationChangeEvent } from '../../../platform/configuration/common/configurationModels.js';\nimport { OVERRIDE_PROPERTY_REGEX } from '../../../platform/configuration/common/configurationRegistry.js';\nimport { isObject } from '../../../base/common/types.js';\nimport { Barrier } from '../../../base/common/async.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\nimport { ILogService } from '../../../platform/log/common/log.service.js';\nimport { URI } from '../../../base/common/uri.js';\nfunction lookUp(tree, key) {\n    if (key) {\n        const parts = key.split('.');\n        let node = tree;\n        for (let i = 0; node && i < parts.length; i++) {\n            node = node[parts[i]];\n        }\n        return node;\n    }\n}\nfunction isUri(thing) {\n    return thing instanceof URI;\n}\nfunction isResourceLanguage(thing) {\n    return thing\n        && thing.uri instanceof URI\n        && (thing.languageId && typeof thing.languageId === 'string');\n}\nfunction isLanguage(thing) {\n    return thing\n        && !thing.uri\n        && (thing.languageId && typeof thing.languageId === 'string');\n}\nfunction isWorkspaceFolder(thing) {\n    return thing\n        && thing.uri instanceof URI\n        && (!thing.name || typeof thing.name === 'string')\n        && (!thing.index || typeof thing.index === 'number');\n}\nfunction scopeToOverrides(scope) {\n    if (isUri(scope)) {\n        return { resource: scope };\n    }\n    if (isResourceLanguage(scope)) {\n        return { resource: scope.uri, overrideIdentifier: scope.languageId };\n    }\n    if (isLanguage(scope)) {\n        return { overrideIdentifier: scope.languageId };\n    }\n    if (isWorkspaceFolder(scope)) {\n        return { resource: scope.uri };\n    }\n    if (scope === null) {\n        return { resource: null };\n    }\n    return undefined;\n}\nlet ExtHostConfiguration = class ExtHostConfiguration {\n    constructor(extHostRpc, extHostWorkspace, logService) {\n        this._proxy = ( extHostRpc.getProxy(MainContext.MainThreadConfiguration));\n        this._extHostWorkspace = extHostWorkspace;\n        this._logService = logService;\n        this._barrier = ( new Barrier());\n        this._actual = null;\n    }\n    getConfigProvider() {\n        return this._barrier.wait().then(_ => this._actual);\n    }\n    $initializeConfiguration(data) {\n        this._actual = ( new ExtHostConfigProvider(this._proxy, this._extHostWorkspace, data, this._logService));\n        this._barrier.open();\n    }\n    $acceptConfigurationChanged(data, change) {\n        this.getConfigProvider().then(provider => provider.$acceptConfigurationChanged(data, change));\n    }\n};\nExtHostConfiguration = ( __decorate([\n    ( __param(0, IExtHostRpcService)),\n    ( __param(1, IExtHostWorkspace)),\n    ( __param(2, ILogService))\n], ExtHostConfiguration));\nclass ExtHostConfigProvider {\n    constructor(proxy, extHostWorkspace, data, logService) {\n        this._onDidChangeConfiguration = ( new Emitter());\n        this._proxy = proxy;\n        this._logService = logService;\n        this._extHostWorkspace = extHostWorkspace;\n        this._configuration = Configuration$1.parse(data, logService);\n        this._configurationScopes = this._toMap(data.configurationScopes);\n    }\n    get onDidChangeConfiguration() {\n        return this._onDidChangeConfiguration && this._onDidChangeConfiguration.event;\n    }\n    $acceptConfigurationChanged(data, change) {\n        const previous = { data: this._configuration.toData(), workspace: this._extHostWorkspace.workspace };\n        this._configuration = Configuration$1.parse(data, this._logService);\n        this._configurationScopes = this._toMap(data.configurationScopes);\n        this._onDidChangeConfiguration.fire(this._toConfigurationChangeEvent(change, previous));\n    }\n    getConfiguration(section, scope, extensionDescription) {\n        const overrides = scopeToOverrides(scope) || {};\n        const config = this._toReadonlyValue(section\n            ? lookUp(this._configuration.getValue(undefined, overrides, this._extHostWorkspace.workspace), section)\n            : this._configuration.getValue(undefined, overrides, this._extHostWorkspace.workspace));\n        if (section) {\n            this._validateConfigurationAccess(section, overrides, extensionDescription?.identifier);\n        }\n        function parseConfigurationTarget(arg) {\n            if (arg === undefined || arg === null) {\n                return null;\n            }\n            if (typeof arg === 'boolean') {\n                return arg ? 2  : 5 ;\n            }\n            switch (arg) {\n                case ConfigurationTarget.Global: return 2 ;\n                case ConfigurationTarget.Workspace: return 5 ;\n                case ConfigurationTarget.WorkspaceFolder: return 6 ;\n            }\n        }\n        const result = {\n            has(key) {\n                return typeof lookUp(config, key) !== 'undefined';\n            },\n            get: (key, defaultValue) => {\n                this._validateConfigurationAccess(section ? `${section}.${key}` : key, overrides, extensionDescription?.identifier);\n                let result = lookUp(config, key);\n                if (typeof result === 'undefined') {\n                    result = defaultValue;\n                }\n                else {\n                    let clonedConfig = undefined;\n                    const cloneOnWriteProxy = (target, accessor) => {\n                        if (isObject(target)) {\n                            let clonedTarget = undefined;\n                            const cloneTarget = () => {\n                                clonedConfig = clonedConfig ? clonedConfig : deepClone(config);\n                                clonedTarget = clonedTarget ? clonedTarget : lookUp(clonedConfig, accessor);\n                            };\n                            return ( new Proxy(target, {\n                                get: (target, property) => {\n                                    if (typeof property === 'string' && property.toLowerCase() === 'tojson') {\n                                        cloneTarget();\n                                        return () => clonedTarget;\n                                    }\n                                    if (clonedConfig) {\n                                        clonedTarget = clonedTarget ? clonedTarget : lookUp(clonedConfig, accessor);\n                                        return clonedTarget[property];\n                                    }\n                                    const result = target[property];\n                                    if (typeof property === 'string') {\n                                        return cloneOnWriteProxy(result, `${accessor}.${property}`);\n                                    }\n                                    return result;\n                                },\n                                set: (_target, property, value) => {\n                                    cloneTarget();\n                                    if (clonedTarget) {\n                                        clonedTarget[property] = value;\n                                    }\n                                    return true;\n                                },\n                                deleteProperty: (_target, property) => {\n                                    cloneTarget();\n                                    if (clonedTarget) {\n                                        delete clonedTarget[property];\n                                    }\n                                    return true;\n                                },\n                                defineProperty: (_target, property, descriptor) => {\n                                    cloneTarget();\n                                    if (clonedTarget) {\n                                        Object.defineProperty(clonedTarget, property, descriptor);\n                                    }\n                                    return true;\n                                }\n                            }));\n                        }\n                        if (Array.isArray(target)) {\n                            return deepClone(target);\n                        }\n                        return target;\n                    };\n                    result = cloneOnWriteProxy(result, key);\n                }\n                return result;\n            },\n            update: (key, value, extHostConfigurationTarget, scopeToLanguage) => {\n                key = section ? `${section}.${key}` : key;\n                const target = parseConfigurationTarget(extHostConfigurationTarget);\n                if (value !== undefined) {\n                    return this._proxy.$updateConfigurationOption(target, key, value, overrides, scopeToLanguage);\n                }\n                else {\n                    return this._proxy.$removeConfigurationOption(target, key, overrides, scopeToLanguage);\n                }\n            },\n            inspect: (key) => {\n                key = section ? `${section}.${key}` : key;\n                const config = this._configuration.inspect(key, overrides, this._extHostWorkspace.workspace);\n                if (config) {\n                    return {\n                        key,\n                        defaultValue: deepClone(config.policy?.value ?? config.default?.value),\n                        globalValue: deepClone(config.user?.value ?? config.application?.value),\n                        workspaceValue: deepClone(config.workspace?.value),\n                        workspaceFolderValue: deepClone(config.workspaceFolder?.value),\n                        defaultLanguageValue: deepClone(config.default?.override),\n                        globalLanguageValue: deepClone(config.user?.override ?? config.application?.override),\n                        workspaceLanguageValue: deepClone(config.workspace?.override),\n                        workspaceFolderLanguageValue: deepClone(config.workspaceFolder?.override),\n                        languageIds: deepClone(config.overrideIdentifiers)\n                    };\n                }\n                return undefined;\n            }\n        };\n        if (typeof config === 'object') {\n            mixin(result, config, false);\n        }\n        return ( Object.freeze(result));\n    }\n    _toReadonlyValue(result) {\n        const readonlyProxy = (target) => {\n            return isObject(target) ?\n                ( new Proxy(target, {\n                    get: (target, property) => readonlyProxy(target[property]),\n                    set: (_target, property, _value) => { throw ( new Error(\n                        `TypeError: Cannot assign to read only property '${String(property)}' of object`\n                    )); },\n                    deleteProperty: (_target, property) => { throw ( new Error(\n                        `TypeError: Cannot delete read only property '${String(property)}' of object`\n                    )); },\n                    defineProperty: (_target, property) => { throw ( new Error(\n                        `TypeError: Cannot define property '${String(property)}' for a readonly object`\n                    )); },\n                    setPrototypeOf: (_target) => { throw ( new Error(`TypeError: Cannot set prototype for a readonly object`)); },\n                    isExtensible: () => false,\n                    preventExtensions: () => true\n                })) : target;\n        };\n        return readonlyProxy(result);\n    }\n    _validateConfigurationAccess(key, overrides, extensionId) {\n        const scope = OVERRIDE_PROPERTY_REGEX.test(key) ? 4  : this._configurationScopes.get(key);\n        const extensionIdText = extensionId ? `[${extensionId.value}] ` : '';\n        if (4  === scope) {\n            if (typeof overrides?.resource === 'undefined') {\n                this._logService.warn(`${extensionIdText}Accessing a resource scoped configuration without providing a resource is not expected. To get the effective value for '${key}', provide the URI of a resource or 'null' for any resource.`);\n            }\n            return;\n        }\n        if (3  === scope) {\n            if (overrides?.resource) {\n                this._logService.warn(`${extensionIdText}Accessing a window scoped configuration for a resource is not expected. To associate '${key}' to a resource, define its scope to 'resource' in configuration contributions in 'package.json'.`);\n            }\n            return;\n        }\n    }\n    _toConfigurationChangeEvent(change, previous) {\n        const event = ( new ConfigurationChangeEvent(\n            change,\n            previous,\n            this._configuration,\n            this._extHostWorkspace.workspace,\n            this._logService\n        ));\n        return ( Object.freeze({\n            affectsConfiguration: (section, scope) => event.affectsConfiguration(section, scopeToOverrides(scope))\n        }));\n    }\n    _toMap(scopes) {\n        return scopes.reduce((result, scope) => { result.set(scope[0], scope[1]); return result; }, ( new Map()));\n    }\n}\nconst IExtHostConfiguration = ( createDecorator('IExtHostConfiguration'));\nexport { ExtHostConfigProvider, ExtHostConfiguration, IExtHostConfiguration };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { safeStringify } from '../../../base/common/objects.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { IExtHostInitDataService } from './extHostInitDataService.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\nlet AbstractExtHostConsoleForwarder = class AbstractExtHostConsoleForwarder {\n    constructor(extHostRpc, initData) {\n        this._mainThreadConsole = ( extHostRpc.getProxy(MainContext.MainThreadConsole));\n        this._includeStack = initData.consoleForward.includeStack;\n        this._logNative = initData.consoleForward.logNative;\n        this._wrapConsoleMethod('info', 'log');\n        this._wrapConsoleMethod('log', 'log');\n        this._wrapConsoleMethod('warn', 'warn');\n        this._wrapConsoleMethod('debug', 'debug');\n        this._wrapConsoleMethod('error', 'error');\n    }\n    _wrapConsoleMethod(method, severity) {\n        const that = this;\n        const original = console[method];\n        Object.defineProperty(console, method, {\n            set: () => { },\n            get: () => (function() {\n                that._handleConsoleCall(method, severity, original, arguments);\n            }),\n        });\n    }\n    _handleConsoleCall(method, severity, original, args) {\n        this._mainThreadConsole.$logExtensionHostMessage({\n            type: '__$console',\n            severity,\n            arguments: safeStringifyArgumentsToArray(args, this._includeStack)\n        });\n        if (this._logNative) {\n            this._nativeConsoleLogMessage(method, original, args);\n        }\n    }\n};\nAbstractExtHostConsoleForwarder = ( __decorate([\n    ( __param(0, IExtHostRpcService)),\n    ( __param(1, IExtHostInitDataService))\n], AbstractExtHostConsoleForwarder));\nconst MAX_LENGTH = 100000;\nfunction safeStringifyArgumentsToArray(args, includeStack) {\n    const argsArray = [];\n    if (args.length) {\n        for (let i = 0; i < args.length; i++) {\n            let arg = args[i];\n            if (typeof arg === 'undefined') {\n                arg = 'undefined';\n            }\n            else if (arg instanceof Error) {\n                const errorObj = arg;\n                if (errorObj.stack) {\n                    arg = errorObj.stack;\n                }\n                else {\n                    arg = ( errorObj.toString());\n                }\n            }\n            argsArray.push(arg);\n        }\n    }\n    if (includeStack) {\n        const stack = ( new Error()).stack;\n        if (stack) {\n            argsArray.push({ __$stack: stack.split('\\n').slice(3).join('\\n') });\n        }\n    }\n    try {\n        const res = safeStringify(argsArray);\n        if (res.length > MAX_LENGTH) {\n            return 'Output omitted for a large object that exceeds the limits';\n        }\n        return res;\n    }\n    catch (error) {\n        return `Output omitted for an object that cannot be inspected ('${( error.toString())}')`;\n    }\n}\nexport { AbstractExtHostConsoleForwarder };\n","import { CancellationToken } from '../../../base/common/cancellation.js';\nimport { hash } from '../../../base/common/hash.js';\nimport { DisposableStore } from '../../../base/common/lifecycle.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { joinPath } from '../../../base/common/resources.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { ViewColumn } from './extHostTypeConverters.js';\nimport { toExtensionData, shouldSerializeBuffersForPostMessage } from './extHostWebview.js';\nimport { Cache } from './cache.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { Disposable } from './extHostTypes.js';\nclass CustomDocumentStoreEntry {\n    constructor(document, _storagePath) {\n        this.document = document;\n        this._storagePath = _storagePath;\n        this._backupCounter = 1;\n        this._edits = ( new Cache('custom documents'));\n    }\n    addEdit(item) {\n        return this._edits.add([item]);\n    }\n    async undo(editId, isDirty) {\n        await this.getEdit(editId).undo();\n        if (!isDirty) {\n            this.disposeBackup();\n        }\n    }\n    async redo(editId, isDirty) {\n        await this.getEdit(editId).redo();\n        if (!isDirty) {\n            this.disposeBackup();\n        }\n    }\n    disposeEdits(editIds) {\n        for (const id of editIds) {\n            this._edits.delete(id);\n        }\n    }\n    getNewBackupUri() {\n        if (!this._storagePath) {\n            throw ( new Error('Backup requires a valid storage path'));\n        }\n        const fileName = hashPath(this.document.uri) + (this._backupCounter++);\n        return joinPath(this._storagePath, fileName);\n    }\n    updateBackup(backup) {\n        this._backup?.delete();\n        this._backup = backup;\n    }\n    disposeBackup() {\n        this._backup?.delete();\n        this._backup = undefined;\n    }\n    getEdit(editId) {\n        const edit = this._edits.get(editId, 0);\n        if (!edit) {\n            throw ( new Error('No edit found'));\n        }\n        return edit;\n    }\n}\nclass CustomDocumentStore {\n    constructor() {\n        this._documents = ( new Map());\n    }\n    get(viewType, resource) {\n        return this._documents.get(this.key(viewType, resource));\n    }\n    add(viewType, document, storagePath) {\n        const key = this.key(viewType, document.uri);\n        if (( this._documents.has(key))) {\n            throw ( new Error(\n                `Document already exists for viewType:${viewType} resource:${document.uri}`\n            ));\n        }\n        const entry = ( new CustomDocumentStoreEntry(document, storagePath));\n        this._documents.set(key, entry);\n        return entry;\n    }\n    delete(viewType, document) {\n        const key = this.key(viewType, document.uri);\n        this._documents.delete(key);\n    }\n    key(viewType, resource) {\n        return `${viewType}@@@${resource}`;\n    }\n}\nclass EditorProviderStore {\n    constructor() {\n        this._providers = ( new Map());\n    }\n    addTextProvider(viewType, extension, provider) {\n        return this.add(viewType, { type: 0 , extension, provider });\n    }\n    addCustomProvider(viewType, extension, provider) {\n        return this.add(viewType, { type: 1 , extension, provider });\n    }\n    get(viewType) {\n        return this._providers.get(viewType);\n    }\n    add(viewType, entry) {\n        if (( this._providers.has(viewType))) {\n            throw ( new Error(`Provider for viewType:${viewType} already registered`));\n        }\n        this._providers.set(viewType, entry);\n        return new Disposable(() => this._providers.delete(viewType));\n    }\n}\nclass ExtHostCustomEditors {\n    constructor(mainContext, _extHostDocuments, _extensionStoragePaths, _extHostWebview, _extHostWebviewPanels) {\n        this._extHostDocuments = _extHostDocuments;\n        this._extensionStoragePaths = _extensionStoragePaths;\n        this._extHostWebview = _extHostWebview;\n        this._extHostWebviewPanels = _extHostWebviewPanels;\n        this._editorProviders = ( new EditorProviderStore());\n        this._documents = ( new CustomDocumentStore());\n        this._proxy = ( mainContext.getProxy(MainContext.MainThreadCustomEditors));\n    }\n    registerCustomEditorProvider(extension, viewType, provider, options) {\n        const disposables = ( new DisposableStore());\n        if (isCustomTextEditorProvider(provider)) {\n            disposables.add(this._editorProviders.addTextProvider(viewType, extension, provider));\n            this._proxy.$registerTextEditorProvider(toExtensionData(extension), viewType, options.webviewOptions || {}, {\n                supportsMove: !!provider.moveCustomTextEditor,\n            }, shouldSerializeBuffersForPostMessage(extension));\n        }\n        else {\n            disposables.add(this._editorProviders.addCustomProvider(viewType, extension, provider));\n            if (isCustomEditorProviderWithEditingCapability(provider)) {\n                disposables.add(provider.onDidChangeCustomDocument(e => {\n                    const entry = this.getCustomDocumentEntry(viewType, e.document.uri);\n                    if (isEditEvent(e)) {\n                        const editId = entry.addEdit(e);\n                        this._proxy.$onDidEdit(e.document.uri, viewType, editId, e.label);\n                    }\n                    else {\n                        this._proxy.$onContentChange(e.document.uri, viewType);\n                    }\n                }));\n            }\n            this._proxy.$registerCustomEditorProvider(toExtensionData(extension), viewType, options.webviewOptions || {}, !!options.supportsMultipleEditorsPerDocument, shouldSerializeBuffersForPostMessage(extension));\n        }\n        return Disposable.from(disposables, new Disposable(() => {\n            this._proxy.$unregisterEditorProvider(viewType);\n        }));\n    }\n    async $createCustomDocument(resource, viewType, backupId, untitledDocumentData, cancellation) {\n        const entry = this._editorProviders.get(viewType);\n        if (!entry) {\n            throw ( new Error(`No provider found for '${viewType}'`));\n        }\n        if (entry.type !== 1 ) {\n            throw ( new Error(`Invalid provide type for '${viewType}'`));\n        }\n        const revivedResource = URI.revive(resource);\n        const document = await entry.provider.openCustomDocument(revivedResource, { backupId, untitledDocumentData: untitledDocumentData?.buffer }, cancellation);\n        let storageRoot;\n        if (isCustomEditorProviderWithEditingCapability(entry.provider) && this._extensionStoragePaths) {\n            storageRoot = this._extensionStoragePaths.workspaceValue(entry.extension) ?? this._extensionStoragePaths.globalValue(entry.extension);\n        }\n        this._documents.add(viewType, document, storageRoot);\n        return { editable: isCustomEditorProviderWithEditingCapability(entry.provider) };\n    }\n    async $disposeCustomDocument(resource, viewType) {\n        const entry = this._editorProviders.get(viewType);\n        if (!entry) {\n            throw ( new Error(`No provider found for '${viewType}'`));\n        }\n        if (entry.type !== 1 ) {\n            throw ( new Error(`Invalid provider type for '${viewType}'`));\n        }\n        const revivedResource = URI.revive(resource);\n        const { document } = this.getCustomDocumentEntry(viewType, revivedResource);\n        this._documents.delete(viewType, document);\n        document.dispose();\n    }\n    async $resolveCustomEditor(resource, handle, viewType, initData, position, cancellation) {\n        const entry = this._editorProviders.get(viewType);\n        if (!entry) {\n            throw ( new Error(`No provider found for '${viewType}'`));\n        }\n        const viewColumn = ViewColumn.to(position);\n        const webview = this._extHostWebview.createNewWebview(handle, initData.contentOptions, entry.extension);\n        const panel = this._extHostWebviewPanels.createNewWebviewPanel(handle, viewType, initData.title, viewColumn, initData.options, webview, initData.active);\n        const revivedResource = URI.revive(resource);\n        switch (entry.type) {\n            case 1 : {\n                const { document } = this.getCustomDocumentEntry(viewType, revivedResource);\n                return entry.provider.resolveCustomEditor(document, panel, cancellation);\n            }\n            case 0 : {\n                const document = this._extHostDocuments.getDocument(revivedResource);\n                return entry.provider.resolveCustomTextEditor(document, panel, cancellation);\n            }\n            default: {\n                throw ( new Error('Unknown webview provider type'));\n            }\n        }\n    }\n    $disposeEdits(resourceComponents, viewType, editIds) {\n        const document = this.getCustomDocumentEntry(viewType, resourceComponents);\n        document.disposeEdits(editIds);\n    }\n    async $onMoveCustomEditor(handle, newResourceComponents, viewType) {\n        const entry = this._editorProviders.get(viewType);\n        if (!entry) {\n            throw ( new Error(`No provider found for '${viewType}'`));\n        }\n        if (!entry.provider.moveCustomTextEditor) {\n            throw ( new Error(`Provider does not implement move '${viewType}'`));\n        }\n        const webview = this._extHostWebviewPanels.getWebviewPanel(handle);\n        if (!webview) {\n            throw ( new Error(`No webview found`));\n        }\n        const resource = URI.revive(newResourceComponents);\n        const document = this._extHostDocuments.getDocument(resource);\n        await entry.provider.moveCustomTextEditor(document, webview, CancellationToken.None);\n    }\n    async $undo(resourceComponents, viewType, editId, isDirty) {\n        const entry = this.getCustomDocumentEntry(viewType, resourceComponents);\n        return entry.undo(editId, isDirty);\n    }\n    async $redo(resourceComponents, viewType, editId, isDirty) {\n        const entry = this.getCustomDocumentEntry(viewType, resourceComponents);\n        return entry.redo(editId, isDirty);\n    }\n    async $revert(resourceComponents, viewType, cancellation) {\n        const entry = this.getCustomDocumentEntry(viewType, resourceComponents);\n        const provider = this.getCustomEditorProvider(viewType);\n        await provider.revertCustomDocument(entry.document, cancellation);\n        entry.disposeBackup();\n    }\n    async $onSave(resourceComponents, viewType, cancellation) {\n        const entry = this.getCustomDocumentEntry(viewType, resourceComponents);\n        const provider = this.getCustomEditorProvider(viewType);\n        await provider.saveCustomDocument(entry.document, cancellation);\n        entry.disposeBackup();\n    }\n    async $onSaveAs(resourceComponents, viewType, targetResource, cancellation) {\n        const entry = this.getCustomDocumentEntry(viewType, resourceComponents);\n        const provider = this.getCustomEditorProvider(viewType);\n        return provider.saveCustomDocumentAs(entry.document, URI.revive(targetResource), cancellation);\n    }\n    async $backup(resourceComponents, viewType, cancellation) {\n        const entry = this.getCustomDocumentEntry(viewType, resourceComponents);\n        const provider = this.getCustomEditorProvider(viewType);\n        const backup = await provider.backupCustomDocument(entry.document, {\n            destination: entry.getNewBackupUri(),\n        }, cancellation);\n        entry.updateBackup(backup);\n        return backup.id;\n    }\n    getCustomDocumentEntry(viewType, resource) {\n        const entry = this._documents.get(viewType, URI.revive(resource));\n        if (!entry) {\n            throw ( new Error('No custom document found'));\n        }\n        return entry;\n    }\n    getCustomEditorProvider(viewType) {\n        const entry = this._editorProviders.get(viewType);\n        const provider = entry?.provider;\n        if (!provider || !isCustomEditorProviderWithEditingCapability(provider)) {\n            throw ( new Error('Custom document is not editable'));\n        }\n        return provider;\n    }\n}\nfunction isCustomEditorProviderWithEditingCapability(provider) {\n    return !!provider.onDidChangeCustomDocument;\n}\nfunction isCustomTextEditorProvider(provider) {\n    return typeof provider.resolveCustomTextEditor === 'function';\n}\nfunction isEditEvent(e) {\n    return typeof e.undo === 'function'\n        && typeof e.redo === 'function';\n}\nfunction hashPath(resource) {\n    const str = resource.scheme === Schemas.file || resource.scheme === Schemas.untitled ? resource.fsPath : ( resource.toString());\n    return hash(str) + '';\n}\nexport { ExtHostCustomEditors };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { coalesce } from '../../../base/common/arrays.js';\nimport { asPromise } from '../../../base/common/async.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { ThemeIcon } from '../../../base/common/themables.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { ExtensionIdentifier } from '../../../platform/extensions/common/extensions.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { AbstractDebugAdapter } from '../../contrib/debug/common/abstractDebugAdapter.js';\nimport { convertToVSCPaths, convertToDAPaths, isDebuggerMainContribution } from '../../contrib/debug/common/debugUtils.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { IExtHostCommands } from './extHostCommands.js';\nimport { IExtHostConfiguration } from './extHostConfiguration.js';\nimport { IExtHostEditorTabs } from './extHostEditorTabs.js';\nimport { IExtHostExtensionService } from './extHostExtensionService.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\nimport { IExtHostTesting } from './extHostTesting.js';\nimport { DebugTreeItem } from './extHostTypeConverters.js';\nimport { SourceBreakpoint, DebugConsoleMode, Disposable as Disposable$1, DebugAdapterInlineImplementation, setBreakpointId, FunctionBreakpoint, Location, Position, DebugAdapterExecutable, DebugAdapterServer, DebugAdapterNamedPipeServer, ThemeIcon as ThemeIcon$1, DataBreakpoint, DebugThread, DebugStackFrame } from './extHostTypes.js';\nimport { IExtHostVariableResolverProvider } from './extHostVariableResolverService.js';\nimport { IExtHostWorkspace } from './extHostWorkspace.js';\nconst IExtHostDebugService = ( createDecorator('IExtHostDebugService'));\nlet ExtHostDebugServiceBase = class ExtHostDebugServiceBase extends Disposable {\n    get onDidStartDebugSession() { return this._onDidStartDebugSession.event; }\n    get onDidTerminateDebugSession() { return this._onDidTerminateDebugSession.event; }\n    get onDidChangeActiveDebugSession() { return this._onDidChangeActiveDebugSession.event; }\n    get activeDebugSession() { return this._activeDebugSession?.api; }\n    get onDidReceiveDebugSessionCustomEvent() { return this._onDidReceiveDebugSessionCustomEvent.event; }\n    get activeDebugConsole() { return this._activeDebugConsole.value; }\n    constructor(extHostRpcService, _workspaceService, _extensionService, _configurationService, _editorTabs, _variableResolver, _commands, _testing) {\n        super();\n        this._workspaceService = _workspaceService;\n        this._extensionService = _extensionService;\n        this._configurationService = _configurationService;\n        this._editorTabs = _editorTabs;\n        this._variableResolver = _variableResolver;\n        this._commands = _commands;\n        this._testing = _testing;\n        this._debugSessions = ( new Map());\n        this._debugVisualizationTreeItemIdsCounter = 0;\n        this._debugVisualizationProviders = ( new Map());\n        this._debugVisualizationTrees = ( new Map());\n        this._debugVisualizationTreeItemIds = ( new WeakMap());\n        this._debugVisualizationElements = ( new Map());\n        this._visualizers = ( new Map());\n        this._visualizerIdCounter = 0;\n        this._configProviderHandleCounter = 0;\n        this._configProviders = [];\n        this._adapterFactoryHandleCounter = 0;\n        this._adapterFactories = [];\n        this._trackerFactoryHandleCounter = 0;\n        this._trackerFactories = [];\n        this._debugAdapters = ( new Map());\n        this._debugAdaptersTrackers = ( new Map());\n        this._onDidStartDebugSession = this._register(( new Emitter()));\n        this._onDidTerminateDebugSession = this._register(( new Emitter()));\n        this._onDidChangeActiveDebugSession = this._register(( new Emitter()));\n        this._onDidReceiveDebugSessionCustomEvent = this._register(( new Emitter()));\n        this._debugServiceProxy = ( extHostRpcService.getProxy(MainContext.MainThreadDebugService));\n        this._onDidChangeBreakpoints = this._register(( new Emitter()));\n        this._onDidChangeActiveStackItem = this._register(( new Emitter()));\n        this._activeDebugConsole = ( new ExtHostDebugConsole(this._debugServiceProxy));\n        this._breakpoints = ( new Map());\n        this._extensionService.getExtensionRegistry().then((extensionRegistry) => {\n            this._register(extensionRegistry.onDidChange(_ => {\n                this.registerAllDebugTypes(extensionRegistry);\n            }));\n            this.registerAllDebugTypes(extensionRegistry);\n        });\n    }\n    async $getVisualizerTreeItem(treeId, element) {\n        const context = this.hydrateVisualizationContext(element);\n        if (!context) {\n            return undefined;\n        }\n        const item = await this._debugVisualizationTrees.get(treeId)?.getTreeItem?.(context);\n        return item ? this.convertVisualizerTreeItem(treeId, item) : undefined;\n    }\n    registerDebugVisualizationTree(manifest, id, provider) {\n        const extensionId = ExtensionIdentifier.toKey(manifest.identifier);\n        const key = this.extensionVisKey(extensionId, id);\n        if (( this._debugVisualizationProviders.has(key))) {\n            throw ( new Error(`A debug visualization provider with id '${id}' is already registered`));\n        }\n        this._debugVisualizationTrees.set(key, provider);\n        this._debugServiceProxy.$registerDebugVisualizerTree(key, !!provider.editItem);\n        return toDisposable(() => {\n            this._debugServiceProxy.$unregisterDebugVisualizerTree(key);\n            this._debugVisualizationTrees.delete(id);\n        });\n    }\n    async $getVisualizerTreeItemChildren(treeId, element) {\n        const item = this._debugVisualizationElements.get(element)?.item;\n        if (!item) {\n            return [];\n        }\n        const children = await this._debugVisualizationTrees.get(treeId)?.getChildren?.(item);\n        return children?.map(i => this.convertVisualizerTreeItem(treeId, i)) || [];\n    }\n    async $editVisualizerTreeItem(element, value) {\n        const e = this._debugVisualizationElements.get(element);\n        if (!e) {\n            return undefined;\n        }\n        const r = await this._debugVisualizationTrees.get(e.provider)?.editItem?.(e.item, value);\n        return this.convertVisualizerTreeItem(e.provider, r || e.item);\n    }\n    $disposeVisualizedTree(element) {\n        const root = this._debugVisualizationElements.get(element);\n        if (!root) {\n            return;\n        }\n        const queue = [root.children];\n        for (const children of queue) {\n            if (children) {\n                for (const child of children) {\n                    queue.push(this._debugVisualizationElements.get(child)?.children);\n                    this._debugVisualizationElements.delete(child);\n                }\n            }\n        }\n    }\n    convertVisualizerTreeItem(treeId, item) {\n        let id = this._debugVisualizationTreeItemIds.get(item);\n        if (!id) {\n            id = this._debugVisualizationTreeItemIdsCounter++;\n            this._debugVisualizationTreeItemIds.set(item, id);\n            this._debugVisualizationElements.set(id, { provider: treeId, item });\n        }\n        return DebugTreeItem.from(item, id);\n    }\n    asDebugSourceUri(src, session) {\n        const source = src;\n        if (typeof source.sourceReference === 'number' && source.sourceReference > 0) {\n            let debug = `debug:${encodeURIComponent(source.path || '')}`;\n            let sep = '?';\n            if (session) {\n                debug += `${sep}session=${encodeURIComponent(session.id)}`;\n                sep = '&';\n            }\n            debug += `${sep}ref=${source.sourceReference}`;\n            return ( URI.parse(debug));\n        }\n        else if (source.path) {\n            return URI.file(source.path);\n        }\n        else {\n            throw ( new Error(\n                `cannot create uri from DAP 'source' object; properties 'path' and 'sourceReference' are both missing.`\n            ));\n        }\n    }\n    registerAllDebugTypes(extensionRegistry) {\n        const debugTypes = [];\n        for (const ed of extensionRegistry.getAllExtensionDescriptions()) {\n            if (ed.contributes) {\n                const debuggers = ed.contributes['debuggers'];\n                if (debuggers && debuggers.length > 0) {\n                    for (const dbg of debuggers) {\n                        if (isDebuggerMainContribution(dbg)) {\n                            debugTypes.push(dbg.type);\n                        }\n                    }\n                }\n            }\n        }\n        this._debugServiceProxy.$registerDebugTypes(debugTypes);\n    }\n    get activeStackItem() {\n        return this._activeStackItem;\n    }\n    get onDidChangeActiveStackItem() {\n        return this._onDidChangeActiveStackItem.event;\n    }\n    get onDidChangeBreakpoints() {\n        return this._onDidChangeBreakpoints.event;\n    }\n    get breakpoints() {\n        const result = [];\n        this._breakpoints.forEach(bp => result.push(bp));\n        return result;\n    }\n    async $resolveDebugVisualizer(id, token) {\n        const visualizer = this._visualizers.get(id);\n        if (!visualizer) {\n            throw ( new Error(`No debug visualizer found with id '${id}'`));\n        }\n        let { v, provider, extensionId } = visualizer;\n        if (!v.visualization) {\n            v = (await provider.resolveDebugVisualization?.(v, token)) || v;\n            visualizer.v = v;\n        }\n        if (!v.visualization) {\n            throw ( new Error(\n                `No visualization returned from resolveDebugVisualization in '${provider}'`\n            ));\n        }\n        return this.serializeVisualization(extensionId, v.visualization);\n    }\n    async $executeDebugVisualizerCommand(id) {\n        const visualizer = this._visualizers.get(id);\n        if (!visualizer) {\n            throw ( new Error(`No debug visualizer found with id '${id}'`));\n        }\n        const command = visualizer.v.visualization;\n        if (command && 'command' in command) {\n            this._commands.executeCommand(command.command, ...(command.arguments || []));\n        }\n    }\n    hydrateVisualizationContext(context) {\n        const session = this._debugSessions.get(context.sessionId);\n        return session && {\n            session: session.api,\n            variable: context.variable,\n            containerId: context.containerId,\n            frameId: context.frameId,\n            threadId: context.threadId,\n        };\n    }\n    async $provideDebugVisualizers(extensionId, id, context, token) {\n        const contextHydrated = this.hydrateVisualizationContext(context);\n        const key = this.extensionVisKey(extensionId, id);\n        const provider = this._debugVisualizationProviders.get(key);\n        if (!contextHydrated || !provider) {\n            return [];\n        }\n        const visualizations = await provider.provideDebugVisualization(contextHydrated, token);\n        if (!visualizations) {\n            return [];\n        }\n        return ( visualizations.map(v => {\n            const id = ++this._visualizerIdCounter;\n            this._visualizers.set(id, { v, provider, extensionId });\n            const icon = v.iconPath ? this.getIconPathOrClass(v.iconPath) : undefined;\n            return {\n                id,\n                name: v.name,\n                iconClass: icon?.iconClass,\n                iconPath: icon?.iconPath,\n                visualization: this.serializeVisualization(extensionId, v.visualization),\n            };\n        }));\n    }\n    $disposeDebugVisualizers(ids) {\n        for (const id of ids) {\n            this._visualizers.delete(id);\n        }\n    }\n    registerDebugVisualizationProvider(manifest, id, provider) {\n        if (!manifest.contributes?.debugVisualizers?.some(r => r.id === id)) {\n            throw ( new Error(\n                `Extensions may only call registerDebugVisualizationProvider() for renderers they contribute (got ${id})`\n            ));\n        }\n        const extensionId = ExtensionIdentifier.toKey(manifest.identifier);\n        const key = this.extensionVisKey(extensionId, id);\n        if (( this._debugVisualizationProviders.has(key))) {\n            throw ( new Error(`A debug visualization provider with id '${id}' is already registered`));\n        }\n        this._debugVisualizationProviders.set(key, provider);\n        this._debugServiceProxy.$registerDebugVisualizer(extensionId, id);\n        return toDisposable(() => {\n            this._debugServiceProxy.$unregisterDebugVisualizer(extensionId, id);\n            this._debugVisualizationProviders.delete(id);\n        });\n    }\n    addBreakpoints(breakpoints0) {\n        const breakpoints = breakpoints0.filter(bp => {\n            const id = bp.id;\n            if (!( this._breakpoints.has(id))) {\n                this._breakpoints.set(id, bp);\n                return true;\n            }\n            return false;\n        });\n        this.fireBreakpointChanges(breakpoints, [], []);\n        const dtos = [];\n        const map = ( new Map());\n        for (const bp of breakpoints) {\n            if (bp instanceof SourceBreakpoint) {\n                let dto = map.get(( bp.location.uri.toString()));\n                if (!dto) {\n                    dto = {\n                        type: 'sourceMulti',\n                        uri: bp.location.uri,\n                        lines: []\n                    };\n                    map.set(( bp.location.uri.toString()), dto);\n                    dtos.push(dto);\n                }\n                dto.lines.push({\n                    id: bp.id,\n                    enabled: bp.enabled,\n                    condition: bp.condition,\n                    hitCondition: bp.hitCondition,\n                    logMessage: bp.logMessage,\n                    line: bp.location.range.start.line,\n                    character: bp.location.range.start.character,\n                    mode: bp.mode,\n                });\n            }\n            else if (bp instanceof FunctionBreakpoint) {\n                dtos.push({\n                    type: 'function',\n                    id: bp.id,\n                    enabled: bp.enabled,\n                    hitCondition: bp.hitCondition,\n                    logMessage: bp.logMessage,\n                    condition: bp.condition,\n                    functionName: bp.functionName,\n                    mode: bp.mode,\n                });\n            }\n        }\n        return this._debugServiceProxy.$registerBreakpoints(dtos);\n    }\n    removeBreakpoints(breakpoints0) {\n        const breakpoints = breakpoints0.filter(b => this._breakpoints.delete(b.id));\n        this.fireBreakpointChanges([], breakpoints, []);\n        const ids = ( breakpoints.filter(bp => bp instanceof SourceBreakpoint).map(bp => bp.id));\n        const fids = ( breakpoints.filter(bp => bp instanceof FunctionBreakpoint).map(bp => bp.id));\n        const dids = ( breakpoints.filter(bp => bp instanceof DataBreakpoint).map(bp => bp.id));\n        return this._debugServiceProxy.$unregisterBreakpoints(ids, fids, dids);\n    }\n    startDebugging(folder, nameOrConfig, options) {\n        const testRunMeta = options.testRun && this._testing.getMetadataForRun(options.testRun);\n        return this._debugServiceProxy.$startDebugging(folder ? folder.uri : undefined, nameOrConfig, {\n            parentSessionID: options.parentSession ? options.parentSession.id : undefined,\n            lifecycleManagedByParent: options.lifecycleManagedByParent,\n            repl: options.consoleMode === DebugConsoleMode.MergeWithParent ? 'mergeWithParent' : 'separate',\n            noDebug: options.noDebug,\n            compact: options.compact,\n            suppressSaveBeforeStart: options.suppressSaveBeforeStart,\n            testRun: testRunMeta && {\n                runId: testRunMeta.runId,\n                taskId: testRunMeta.taskId,\n            },\n            suppressDebugStatusbar: options.suppressDebugStatusbar ?? options.debugUI?.simple,\n            suppressDebugToolbar: options.suppressDebugToolbar ?? options.debugUI?.simple,\n            suppressDebugView: options.suppressDebugView ?? options.debugUI?.simple,\n        });\n    }\n    stopDebugging(session) {\n        return this._debugServiceProxy.$stopDebugging(session ? session.id : undefined);\n    }\n    registerDebugConfigurationProvider(type, provider, trigger) {\n        if (!provider) {\n            return ( new Disposable$1(() => { }));\n        }\n        const handle = this._configProviderHandleCounter++;\n        this._configProviders.push({ type, handle, provider });\n        this._debugServiceProxy.$registerDebugConfigurationProvider(type, trigger, !!provider.provideDebugConfigurations, !!provider.resolveDebugConfiguration, !!provider.resolveDebugConfigurationWithSubstitutedVariables, handle);\n        return ( new Disposable$1(() => {\n            this._configProviders = this._configProviders.filter(p => p.provider !== provider);\n            this._debugServiceProxy.$unregisterDebugConfigurationProvider(handle);\n        }));\n    }\n    registerDebugAdapterDescriptorFactory(extension, type, factory) {\n        if (!factory) {\n            return ( new Disposable$1(() => { }));\n        }\n        if (!this.definesDebugType(extension, type)) {\n            throw ( new Error(\n                `a DebugAdapterDescriptorFactory can only be registered from the extension that defines the '${type}' debugger.`\n            ));\n        }\n        if (this.getAdapterDescriptorFactoryByType(type)) {\n            throw ( new Error(`a DebugAdapterDescriptorFactory can only be registered once per a type.`));\n        }\n        const handle = this._adapterFactoryHandleCounter++;\n        this._adapterFactories.push({ type, handle, factory });\n        this._debugServiceProxy.$registerDebugAdapterDescriptorFactory(type, handle);\n        return ( new Disposable$1(() => {\n            this._adapterFactories = this._adapterFactories.filter(p => p.factory !== factory);\n            this._debugServiceProxy.$unregisterDebugAdapterDescriptorFactory(handle);\n        }));\n    }\n    registerDebugAdapterTrackerFactory(type, factory) {\n        if (!factory) {\n            return ( new Disposable$1(() => { }));\n        }\n        const handle = this._trackerFactoryHandleCounter++;\n        this._trackerFactories.push({ type, handle, factory });\n        return ( new Disposable$1(() => {\n            this._trackerFactories = this._trackerFactories.filter(p => p.factory !== factory);\n        }));\n    }\n    async $runInTerminal(args, sessionId) {\n        return Promise.resolve(undefined);\n    }\n    async $substituteVariables(folderUri, config) {\n        let ws;\n        const folder = await this.getFolder(folderUri);\n        if (folder) {\n            ws = {\n                uri: folder.uri,\n                name: folder.name,\n                index: folder.index,\n                toResource: () => {\n                    throw ( new Error('Not implemented'));\n                }\n            };\n        }\n        const variableResolver = await this._variableResolver.getResolver();\n        return variableResolver.resolveAnyAsync(ws, config);\n    }\n    createDebugAdapter(adapter, session) {\n        if (adapter instanceof DebugAdapterInlineImplementation) {\n            return ( new DirectDebugAdapter(adapter.implementation));\n        }\n        return undefined;\n    }\n    createSignService() {\n        return undefined;\n    }\n    async $startDASession(debugAdapterHandle, sessionDto) {\n        const mythis = this;\n        const session = await this.getSession(sessionDto);\n        return this.getAdapterDescriptor(this.getAdapterDescriptorFactoryByType(session.type), session).then(daDescriptor => {\n            if (!daDescriptor) {\n                throw ( new Error(\n                    `Couldn't find a debug adapter descriptor for debug type '${session.type}' (extension might have failed to activate)`\n                ));\n            }\n            const da = this.createDebugAdapter(daDescriptor, session);\n            if (!da) {\n                throw ( new Error(`Couldn't create a debug adapter for type '${session.type}'.`));\n            }\n            const debugAdapter = da;\n            this._debugAdapters.set(debugAdapterHandle, debugAdapter);\n            return this.getDebugAdapterTrackers(session).then(tracker => {\n                if (tracker) {\n                    this._debugAdaptersTrackers.set(debugAdapterHandle, tracker);\n                }\n                debugAdapter.onMessage(async (message) => {\n                    if (message.type === 'request' && message.command === 'handshake') {\n                        const request = message;\n                        const response = {\n                            type: 'response',\n                            seq: 0,\n                            command: request.command,\n                            request_seq: request.seq,\n                            success: true\n                        };\n                        if (!this._signService) {\n                            this._signService = this.createSignService();\n                        }\n                        try {\n                            if (this._signService) {\n                                const signature = await this._signService.sign(request.arguments.value);\n                                response.body = {\n                                    signature: signature\n                                };\n                                debugAdapter.sendResponse(response);\n                            }\n                            else {\n                                throw ( new Error('no signer'));\n                            }\n                        }\n                        catch (e) {\n                            response.success = false;\n                            response.message = e.message;\n                            debugAdapter.sendResponse(response);\n                        }\n                    }\n                    else {\n                        if (tracker && tracker.onDidSendMessage) {\n                            tracker.onDidSendMessage(message);\n                        }\n                        message = convertToVSCPaths(message, true);\n                        mythis._debugServiceProxy.$acceptDAMessage(debugAdapterHandle, message);\n                    }\n                });\n                debugAdapter.onError(err => {\n                    if (tracker && tracker.onError) {\n                        tracker.onError(err);\n                    }\n                    this._debugServiceProxy.$acceptDAError(debugAdapterHandle, err.name, err.message, err.stack);\n                });\n                debugAdapter.onExit((code) => {\n                    if (tracker && tracker.onExit) {\n                        tracker.onExit(code ?? undefined, undefined);\n                    }\n                    this._debugServiceProxy.$acceptDAExit(debugAdapterHandle, code ?? undefined, undefined);\n                });\n                if (tracker && tracker.onWillStartSession) {\n                    tracker.onWillStartSession();\n                }\n                return debugAdapter.startSession();\n            });\n        });\n    }\n    $sendDAMessage(debugAdapterHandle, message) {\n        message = convertToDAPaths(message, false);\n        const tracker = this._debugAdaptersTrackers.get(debugAdapterHandle);\n        if (tracker && tracker.onWillReceiveMessage) {\n            tracker.onWillReceiveMessage(message);\n        }\n        const da = this._debugAdapters.get(debugAdapterHandle);\n        da?.sendMessage(message);\n    }\n    $stopDASession(debugAdapterHandle) {\n        const tracker = this._debugAdaptersTrackers.get(debugAdapterHandle);\n        this._debugAdaptersTrackers.delete(debugAdapterHandle);\n        if (tracker && tracker.onWillStopSession) {\n            tracker.onWillStopSession();\n        }\n        const da = this._debugAdapters.get(debugAdapterHandle);\n        this._debugAdapters.delete(debugAdapterHandle);\n        if (da) {\n            return da.stopSession();\n        }\n        else {\n            return Promise.resolve(void 0);\n        }\n    }\n    $acceptBreakpointsDelta(delta) {\n        const a = [];\n        const r = [];\n        const c = [];\n        if (delta.added) {\n            for (const bpd of delta.added) {\n                const id = bpd.id;\n                if (id && !( this._breakpoints.has(id))) {\n                    let bp;\n                    if (bpd.type === 'function') {\n                        bp = ( new FunctionBreakpoint(\n                            bpd.functionName,\n                            bpd.enabled,\n                            bpd.condition,\n                            bpd.hitCondition,\n                            bpd.logMessage,\n                            bpd.mode\n                        ));\n                    }\n                    else if (bpd.type === 'data') {\n                        bp = ( new DataBreakpoint(\n                            bpd.label,\n                            bpd.dataId,\n                            bpd.canPersist,\n                            bpd.enabled,\n                            bpd.hitCondition,\n                            bpd.condition,\n                            bpd.logMessage,\n                            bpd.mode\n                        ));\n                    }\n                    else {\n                        const uri = URI.revive(bpd.uri);\n                        bp = ( new SourceBreakpoint(( new Location(uri, ( new Position(bpd.line, bpd.character)))), bpd.enabled, bpd.condition, bpd.hitCondition, bpd.logMessage, bpd.mode));\n                    }\n                    setBreakpointId(bp, id);\n                    this._breakpoints.set(id, bp);\n                    a.push(bp);\n                }\n            }\n        }\n        if (delta.removed) {\n            for (const id of delta.removed) {\n                const bp = this._breakpoints.get(id);\n                if (bp) {\n                    this._breakpoints.delete(id);\n                    r.push(bp);\n                }\n            }\n        }\n        if (delta.changed) {\n            for (const bpd of delta.changed) {\n                if (bpd.id) {\n                    const bp = this._breakpoints.get(bpd.id);\n                    if (bp) {\n                        if (bp instanceof FunctionBreakpoint && bpd.type === 'function') {\n                            const fbp = bp;\n                            fbp.enabled = bpd.enabled;\n                            fbp.condition = bpd.condition;\n                            fbp.hitCondition = bpd.hitCondition;\n                            fbp.logMessage = bpd.logMessage;\n                            fbp.functionName = bpd.functionName;\n                        }\n                        else if (bp instanceof SourceBreakpoint && bpd.type === 'source') {\n                            const sbp = bp;\n                            sbp.enabled = bpd.enabled;\n                            sbp.condition = bpd.condition;\n                            sbp.hitCondition = bpd.hitCondition;\n                            sbp.logMessage = bpd.logMessage;\n                            sbp.location = ( new Location(URI.revive(bpd.uri), ( new Position(bpd.line, bpd.character))));\n                        }\n                        c.push(bp);\n                    }\n                }\n            }\n        }\n        this.fireBreakpointChanges(a, r, c);\n    }\n    async $acceptStackFrameFocus(focusDto) {\n        let focus;\n        if (focusDto) {\n            const session = await this.getSession(focusDto.sessionId);\n            if (focusDto.kind === 'thread') {\n                focus = ( new DebugThread(session.api, focusDto.threadId));\n            }\n            else {\n                focus = ( new DebugStackFrame(session.api, focusDto.threadId, focusDto.frameId));\n            }\n        }\n        this._activeStackItem = focus;\n        this._onDidChangeActiveStackItem.fire(this._activeStackItem);\n    }\n    $provideDebugConfigurations(configProviderHandle, folderUri, token) {\n        return asPromise(async () => {\n            const provider = this.getConfigProviderByHandle(configProviderHandle);\n            if (!provider) {\n                throw ( new Error('no DebugConfigurationProvider found'));\n            }\n            if (!provider.provideDebugConfigurations) {\n                throw ( new Error('DebugConfigurationProvider has no method provideDebugConfigurations'));\n            }\n            const folder = await this.getFolder(folderUri);\n            return provider.provideDebugConfigurations(folder, token);\n        }).then(debugConfigurations => {\n            if (!debugConfigurations) {\n                throw ( new Error(\n                    'nothing returned from DebugConfigurationProvider.provideDebugConfigurations'\n                ));\n            }\n            return debugConfigurations;\n        });\n    }\n    $resolveDebugConfiguration(configProviderHandle, folderUri, debugConfiguration, token) {\n        return asPromise(async () => {\n            const provider = this.getConfigProviderByHandle(configProviderHandle);\n            if (!provider) {\n                throw ( new Error('no DebugConfigurationProvider found'));\n            }\n            if (!provider.resolveDebugConfiguration) {\n                throw ( new Error('DebugConfigurationProvider has no method resolveDebugConfiguration'));\n            }\n            const folder = await this.getFolder(folderUri);\n            return provider.resolveDebugConfiguration(folder, debugConfiguration, token);\n        });\n    }\n    $resolveDebugConfigurationWithSubstitutedVariables(configProviderHandle, folderUri, debugConfiguration, token) {\n        return asPromise(async () => {\n            const provider = this.getConfigProviderByHandle(configProviderHandle);\n            if (!provider) {\n                throw ( new Error('no DebugConfigurationProvider found'));\n            }\n            if (!provider.resolveDebugConfigurationWithSubstitutedVariables) {\n                throw ( new Error(\n                    'DebugConfigurationProvider has no method resolveDebugConfigurationWithSubstitutedVariables'\n                ));\n            }\n            const folder = await this.getFolder(folderUri);\n            return provider.resolveDebugConfigurationWithSubstitutedVariables(folder, debugConfiguration, token);\n        });\n    }\n    async $provideDebugAdapter(adapterFactoryHandle, sessionDto) {\n        const adapterDescriptorFactory = this.getAdapterDescriptorFactoryByHandle(adapterFactoryHandle);\n        if (!adapterDescriptorFactory) {\n            return Promise.reject(( new Error('no adapter descriptor factory found for handle')));\n        }\n        const session = await this.getSession(sessionDto);\n        return this.getAdapterDescriptor(adapterDescriptorFactory, session).then(adapterDescriptor => {\n            if (!adapterDescriptor) {\n                throw ( new Error(\n                    `Couldn't find a debug adapter descriptor for debug type '${session.type}'`\n                ));\n            }\n            return this.convertToDto(adapterDescriptor);\n        });\n    }\n    async $acceptDebugSessionStarted(sessionDto) {\n        const session = await this.getSession(sessionDto);\n        this._onDidStartDebugSession.fire(session.api);\n    }\n    async $acceptDebugSessionTerminated(sessionDto) {\n        const session = await this.getSession(sessionDto);\n        if (session) {\n            this._onDidTerminateDebugSession.fire(session.api);\n            this._debugSessions.delete(session.id);\n        }\n    }\n    async $acceptDebugSessionActiveChanged(sessionDto) {\n        this._activeDebugSession = sessionDto ? await this.getSession(sessionDto) : undefined;\n        this._onDidChangeActiveDebugSession.fire(this._activeDebugSession?.api);\n    }\n    async $acceptDebugSessionNameChanged(sessionDto, name) {\n        const session = await this.getSession(sessionDto);\n        session?._acceptNameChanged(name);\n    }\n    async $acceptDebugSessionCustomEvent(sessionDto, event) {\n        const session = await this.getSession(sessionDto);\n        const ee = {\n            session: session.api,\n            event: event.event,\n            body: event.body\n        };\n        this._onDidReceiveDebugSessionCustomEvent.fire(ee);\n    }\n    convertToDto(x) {\n        if (x instanceof DebugAdapterExecutable) {\n            return this.convertExecutableToDto(x);\n        }\n        else if (x instanceof DebugAdapterServer) {\n            return this.convertServerToDto(x);\n        }\n        else if (x instanceof DebugAdapterNamedPipeServer) {\n            return this.convertPipeServerToDto(x);\n        }\n        else if (x instanceof DebugAdapterInlineImplementation) {\n            return this.convertImplementationToDto(x);\n        }\n        else {\n            throw ( new Error('convertToDto unexpected type'));\n        }\n    }\n    convertExecutableToDto(x) {\n        return {\n            type: 'executable',\n            command: x.command,\n            args: x.args,\n            options: x.options\n        };\n    }\n    convertServerToDto(x) {\n        return {\n            type: 'server',\n            port: x.port,\n            host: x.host\n        };\n    }\n    convertPipeServerToDto(x) {\n        return {\n            type: 'pipeServer',\n            path: x.path\n        };\n    }\n    convertImplementationToDto(x) {\n        return {\n            type: 'implementation',\n        };\n    }\n    getAdapterDescriptorFactoryByType(type) {\n        const results = this._adapterFactories.filter(p => p.type === type);\n        if (results.length > 0) {\n            return results[0].factory;\n        }\n        return undefined;\n    }\n    getAdapterDescriptorFactoryByHandle(handle) {\n        const results = this._adapterFactories.filter(p => p.handle === handle);\n        if (results.length > 0) {\n            return results[0].factory;\n        }\n        return undefined;\n    }\n    getConfigProviderByHandle(handle) {\n        const results = this._configProviders.filter(p => p.handle === handle);\n        if (results.length > 0) {\n            return results[0].provider;\n        }\n        return undefined;\n    }\n    definesDebugType(ed, type) {\n        if (ed.contributes) {\n            const debuggers = ed.contributes['debuggers'];\n            if (debuggers && debuggers.length > 0) {\n                for (const dbg of debuggers) {\n                    if (dbg.label && dbg.type) {\n                        if (dbg.type === type) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    getDebugAdapterTrackers(session) {\n        const config = session.configuration;\n        const type = config.type;\n        const promises = ( this._trackerFactories\n            .filter(tuple => tuple.type === type || tuple.type === '*')\n            .map(\n            tuple => asPromise(() => tuple.factory.createDebugAdapterTracker(session.api)).then(p => p, err => null)\n        ));\n        return Promise.race([\n            Promise.all(promises).then(result => {\n                const trackers = coalesce(result);\n                if (trackers.length > 0) {\n                    return ( new MultiTracker(trackers));\n                }\n                return undefined;\n            }),\n            ( new Promise(resolve => setTimeout(() => resolve(undefined), 1000))),\n        ]).catch(err => {\n            return undefined;\n        });\n    }\n    async getAdapterDescriptor(adapterDescriptorFactory, session) {\n        const serverPort = session.configuration.debugServer;\n        if (typeof serverPort === 'number') {\n            return Promise.resolve(( new DebugAdapterServer(serverPort)));\n        }\n        if (adapterDescriptorFactory) {\n            const extensionRegistry = await this._extensionService.getExtensionRegistry();\n            return asPromise(() => adapterDescriptorFactory.createDebugAdapterDescriptor(session.api, this.daExecutableFromPackage(session, extensionRegistry))).then(daDescriptor => {\n                if (daDescriptor) {\n                    return daDescriptor;\n                }\n                return undefined;\n            });\n        }\n        const extensionRegistry = await this._extensionService.getExtensionRegistry();\n        return Promise.resolve(this.daExecutableFromPackage(session, extensionRegistry));\n    }\n    daExecutableFromPackage(session, extensionRegistry) {\n        return undefined;\n    }\n    fireBreakpointChanges(added, removed, changed) {\n        if (added.length > 0 || removed.length > 0 || changed.length > 0) {\n            this._onDidChangeBreakpoints.fire(( Object.freeze({\n                added,\n                removed,\n                changed,\n            })));\n        }\n    }\n    async getSession(dto) {\n        if (dto) {\n            if (typeof dto === 'string') {\n                const ds = this._debugSessions.get(dto);\n                if (ds) {\n                    return ds;\n                }\n            }\n            else {\n                let ds = this._debugSessions.get(dto.id);\n                if (!ds) {\n                    const folder = await this.getFolder(dto.folderUri);\n                    const parent = dto.parent ? this._debugSessions.get(dto.parent) : undefined;\n                    ds = ( new ExtHostDebugSession(\n                        this._debugServiceProxy,\n                        dto.id,\n                        dto.type,\n                        dto.name,\n                        folder,\n                        dto.configuration,\n                        parent?.api\n                    ));\n                    this._debugSessions.set(ds.id, ds);\n                    this._debugServiceProxy.$sessionCached(ds.id);\n                }\n                return ds;\n            }\n        }\n        throw ( new Error('cannot find session'));\n    }\n    getFolder(_folderUri) {\n        if (_folderUri) {\n            const folderURI = URI.revive(_folderUri);\n            return this._workspaceService.resolveWorkspaceFolder(folderURI);\n        }\n        return Promise.resolve(undefined);\n    }\n    extensionVisKey(extensionId, id) {\n        return `${extensionId}\\0${id}`;\n    }\n    serializeVisualization(extensionId, viz) {\n        if (!viz) {\n            return undefined;\n        }\n        if ('title' in viz && 'command' in viz) {\n            return { type: 0  };\n        }\n        if ('treeId' in viz) {\n            return { type: 1 , id: `${extensionId}\\0${viz.treeId}` };\n        }\n        throw ( new Error('Unsupported debug visualization type'));\n    }\n    getIconPathOrClass(icon) {\n        const iconPathOrIconClass = this.getIconUris(icon);\n        let iconPath;\n        let iconClass;\n        if ('id' in iconPathOrIconClass) {\n            iconClass = ThemeIcon.asClassName(iconPathOrIconClass);\n        }\n        else {\n            iconPath = iconPathOrIconClass;\n        }\n        return {\n            iconPath,\n            iconClass\n        };\n    }\n    getIconUris(iconPath) {\n        if (iconPath instanceof ThemeIcon$1) {\n            return { id: iconPath.id };\n        }\n        const dark = typeof iconPath === 'object' && 'dark' in iconPath ? iconPath.dark : iconPath;\n        const light = typeof iconPath === 'object' && 'light' in iconPath ? iconPath.light : iconPath;\n        return {\n            dark: (typeof dark === 'string' ? URI.file(dark) : dark),\n            light: (typeof light === 'string' ? URI.file(light) : light),\n        };\n    }\n};\nExtHostDebugServiceBase = ( __decorate([\n    ( __param(0, IExtHostRpcService)),\n    ( __param(1, IExtHostWorkspace)),\n    ( __param(2, IExtHostExtensionService)),\n    ( __param(3, IExtHostConfiguration)),\n    ( __param(4, IExtHostEditorTabs)),\n    ( __param(5, IExtHostVariableResolverProvider)),\n    ( __param(6, IExtHostCommands)),\n    ( __param(7, IExtHostTesting))\n], ExtHostDebugServiceBase));\nclass ExtHostDebugSession {\n    constructor(_debugServiceProxy, _id, _type, _name, _workspaceFolder, _configuration, _parentSession) {\n        this._debugServiceProxy = _debugServiceProxy;\n        this._id = _id;\n        this._type = _type;\n        this._name = _name;\n        this._workspaceFolder = _workspaceFolder;\n        this._configuration = _configuration;\n        this._parentSession = _parentSession;\n    }\n    get api() {\n        const that = this;\n        return this.apiSession ??= ( Object.freeze({\n            id: that._id,\n            type: that._type,\n            get name() {\n                return that._name;\n            },\n            set name(name) {\n                that._name = name;\n                that._debugServiceProxy.$setDebugSessionName(that._id, name);\n            },\n            parentSession: that._parentSession,\n            workspaceFolder: that._workspaceFolder,\n            configuration: that._configuration,\n            customRequest(command, args) {\n                return that._debugServiceProxy.$customDebugAdapterRequest(that._id, command, args);\n            },\n            getDebugProtocolBreakpoint(breakpoint) {\n                return that._debugServiceProxy.$getDebugProtocolBreakpoint(that._id, breakpoint.id);\n            }\n        }));\n    }\n    get id() {\n        return this._id;\n    }\n    get type() {\n        return this._type;\n    }\n    _acceptNameChanged(name) {\n        this._name = name;\n    }\n    get configuration() {\n        return this._configuration;\n    }\n}\nclass ExtHostDebugConsole {\n    constructor(proxy) {\n        this.value = ( Object.freeze({\n            append(value) {\n                proxy.$appendDebugConsole(value);\n            },\n            appendLine(value) {\n                this.append(value + '\\n');\n            }\n        }));\n    }\n}\nclass MultiTracker {\n    constructor(trackers) {\n        this.trackers = trackers;\n    }\n    onWillStartSession() {\n        this.trackers.forEach(t => t.onWillStartSession ? t.onWillStartSession() : undefined);\n    }\n    onWillReceiveMessage(message) {\n        this.trackers.forEach(t => t.onWillReceiveMessage ? t.onWillReceiveMessage(message) : undefined);\n    }\n    onDidSendMessage(message) {\n        this.trackers.forEach(t => t.onDidSendMessage ? t.onDidSendMessage(message) : undefined);\n    }\n    onWillStopSession() {\n        this.trackers.forEach(t => t.onWillStopSession ? t.onWillStopSession() : undefined);\n    }\n    onError(error) {\n        this.trackers.forEach(t => t.onError ? t.onError(error) : undefined);\n    }\n    onExit(code, signal) {\n        this.trackers.forEach(t => t.onExit ? t.onExit(code, signal) : undefined);\n    }\n}\nclass DirectDebugAdapter extends AbstractDebugAdapter {\n    constructor(implementation) {\n        super();\n        this.implementation = implementation;\n        implementation.onDidSendMessage((message) => {\n            this.acceptMessage(message);\n        });\n    }\n    startSession() {\n        return Promise.resolve(undefined);\n    }\n    sendMessage(message) {\n        this.implementation.handleMessage(message);\n    }\n    stopSession() {\n        this.implementation.dispose();\n        return Promise.resolve(undefined);\n    }\n}\nlet WorkerExtHostDebugService = class WorkerExtHostDebugService extends ExtHostDebugServiceBase {\n    constructor(extHostRpcService, workspaceService, extensionService, configurationService, editorTabs, variableResolver, commands, testing) {\n        super(extHostRpcService, workspaceService, extensionService, configurationService, editorTabs, variableResolver, commands, testing);\n    }\n};\nWorkerExtHostDebugService = ( __decorate([\n    ( __param(0, IExtHostRpcService)),\n    ( __param(1, IExtHostWorkspace)),\n    ( __param(2, IExtHostExtensionService)),\n    ( __param(3, IExtHostConfiguration)),\n    ( __param(4, IExtHostEditorTabs)),\n    ( __param(5, IExtHostVariableResolverProvider)),\n    ( __param(6, IExtHostCommands)),\n    ( __param(7, IExtHostTesting))\n], WorkerExtHostDebugService));\nexport { ExtHostDebugConsole, ExtHostDebugServiceBase, ExtHostDebugSession, IExtHostDebugService, WorkerExtHostDebugService };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { Disposable, FileDecoration } from './extHostTypes.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\nimport { ILogService } from '../../../platform/log/common/log.service.js';\nimport { groupBy, asArray } from '../../../base/common/arrays.js';\nimport { compare, count } from '../../../base/common/strings.js';\nimport { dirname } from '../../../base/common/path.js';\nimport { checkProposedApiEnabled } from '../../services/extensions/common/extensions.js';\nvar ExtHostDecorations_1;\nlet ExtHostDecorations = class ExtHostDecorations {\n    static { ExtHostDecorations_1 = this; }\n    static { this._handlePool = 0; }\n    static { this._maxEventSize = 250; }\n    constructor(extHostRpc, _logService) {\n        this._logService = _logService;\n        this._provider = ( new Map());\n        this._proxy = ( extHostRpc.getProxy(MainContext.MainThreadDecorations));\n    }\n    registerFileDecorationProvider(provider, extensionDescription) {\n        const handle = ExtHostDecorations_1._handlePool++;\n        this._provider.set(handle, { provider, extensionDescription });\n        this._proxy.$registerDecorationProvider(handle, extensionDescription.identifier.value);\n        const listener = provider.onDidChangeFileDecorations && provider.onDidChangeFileDecorations(e => {\n            if (!e) {\n                this._proxy.$onDidChange(handle, null);\n                return;\n            }\n            const array = asArray(e);\n            if (array.length <= ExtHostDecorations_1._maxEventSize) {\n                this._proxy.$onDidChange(handle, array);\n                return;\n            }\n            this._logService.warn('[Decorations] CAPPING events from decorations provider', extensionDescription.identifier.value, array.length);\n            const mapped = ( array.map(uri => ({ uri, rank: count(uri.path, '/') })));\n            const groups = groupBy(mapped, (a, b) => a.rank - b.rank || compare(a.uri.path, b.uri.path));\n            const picked = [];\n            outer: for (const uris of groups) {\n                let lastDirname;\n                for (const obj of uris) {\n                    const myDirname = dirname(obj.uri.path);\n                    if (lastDirname !== myDirname) {\n                        lastDirname = myDirname;\n                        if (picked.push(obj.uri) >= ExtHostDecorations_1._maxEventSize) {\n                            break outer;\n                        }\n                    }\n                }\n            }\n            this._proxy.$onDidChange(handle, picked);\n        });\n        return ( new Disposable(() => {\n            listener?.dispose();\n            this._proxy.$unregisterDecorationProvider(handle);\n            this._provider.delete(handle);\n        }));\n    }\n    async $provideDecorations(handle, requests, token) {\n        if (!( this._provider.has(handle))) {\n            return Object.create(null);\n        }\n        const result = Object.create(null);\n        const { provider, extensionDescription: extensionId } = this._provider.get(handle);\n        await Promise.all(( requests.map(async (request) => {\n            try {\n                const { uri, id } = request;\n                const data = await Promise.resolve(provider.provideFileDecoration(URI.revive(uri), token));\n                if (!data) {\n                    return;\n                }\n                try {\n                    FileDecoration.validate(data);\n                    if (data.badge && typeof data.badge !== 'string') {\n                        checkProposedApiEnabled(extensionId, 'codiconDecoration');\n                    }\n                    result[id] = [data.propagate, data.tooltip, data.badge, data.color];\n                }\n                catch (e) {\n                    this._logService.warn(`INVALID decoration from extension '${extensionId.identifier.value}': ${e}`);\n                }\n            }\n            catch (err) {\n                this._logService.error(err);\n            }\n        })));\n        return result;\n    }\n};\nExtHostDecorations = ExtHostDecorations_1 = ( __decorate([\n    ( __param(0, IExtHostRpcService)),\n    ( __param(1, ILogService))\n], ExtHostDecorations));\nconst IExtHostDecorations = ( createDecorator('IExtHostDecorations'));\nexport { ExtHostDecorations, IExtHostDecorations };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { localize } from '../../../nls.js';\nimport { MarkerSeverity } from '../../../platform/markers/common/markers.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { DiagnosticSeverity } from './extHostTypes.js';\nimport { Diagnostic } from './extHostTypeConverters.js';\nimport { DebounceEmitter, Event } from '../../../base/common/event.js';\nimport { ILogService } from '../../../platform/log/common/log.service.js';\nimport { ResourceMap } from '../../../base/common/map.js';\nimport { IExtHostFileSystemInfo } from './extHostFileSystemInfo.js';\nvar ExtHostDiagnostics_1;\nclass DiagnosticCollection {\n    #proxy;\n    #onDidChangeDiagnostics;\n    #data;\n    constructor(_name, _owner, _maxDiagnosticsTotal, _maxDiagnosticsPerFile, _modelVersionIdProvider, extUri, proxy, onDidChangeDiagnostics) {\n        this._name = _name;\n        this._owner = _owner;\n        this._maxDiagnosticsTotal = _maxDiagnosticsTotal;\n        this._maxDiagnosticsPerFile = _maxDiagnosticsPerFile;\n        this._modelVersionIdProvider = _modelVersionIdProvider;\n        this._isDisposed = false;\n        this._maxDiagnosticsTotal = Math.max(_maxDiagnosticsPerFile, _maxDiagnosticsTotal);\n        this.#data = ( (new ResourceMap(uri => extUri.getComparisonKey(uri))));\n        this.#proxy = proxy;\n        this.#onDidChangeDiagnostics = onDidChangeDiagnostics;\n    }\n    dispose() {\n        if (!this._isDisposed) {\n            this.#onDidChangeDiagnostics.fire([...( (this.#data.keys()))]);\n            this.#proxy?.$clear(this._owner);\n            this.#data.clear();\n            this._isDisposed = true;\n        }\n    }\n    get name() {\n        this._checkDisposed();\n        return this._name;\n    }\n    set(first, diagnostics) {\n        if (!first) {\n            this.clear();\n            return;\n        }\n        this._checkDisposed();\n        let toSync = [];\n        if (URI.isUri(first)) {\n            if (!diagnostics) {\n                this.delete(first);\n                return;\n            }\n            this.#data.set(first, diagnostics.slice());\n            toSync = [first];\n        }\n        else if (Array.isArray(first)) {\n            toSync = [];\n            let lastUri;\n            first = [...first].sort(DiagnosticCollection._compareIndexedTuplesByUri);\n            for (const tuple of first) {\n                const [uri, diagnostics] = tuple;\n                if (!lastUri || ( (uri.toString())) !== ( (lastUri.toString()))) {\n                    if (lastUri && this.#data.get(lastUri).length === 0) {\n                        this.#data.delete(lastUri);\n                    }\n                    lastUri = uri;\n                    toSync.push(uri);\n                    this.#data.set(uri, []);\n                }\n                if (!diagnostics) {\n                    const currentDiagnostics = this.#data.get(uri);\n                    if (currentDiagnostics) {\n                        currentDiagnostics.length = 0;\n                    }\n                }\n                else {\n                    const currentDiagnostics = this.#data.get(uri);\n                    currentDiagnostics?.push(...diagnostics);\n                }\n            }\n        }\n        this.#onDidChangeDiagnostics.fire(toSync);\n        if (!this.#proxy) {\n            return;\n        }\n        const entries = [];\n        let totalMarkerCount = 0;\n        for (const uri of toSync) {\n            let marker = [];\n            const diagnostics = this.#data.get(uri);\n            if (diagnostics) {\n                if (diagnostics.length > this._maxDiagnosticsPerFile) {\n                    marker = [];\n                    const order = [DiagnosticSeverity.Error, DiagnosticSeverity.Warning, DiagnosticSeverity.Information, DiagnosticSeverity.Hint];\n                    orderLoop: for (let i = 0; i < 4; i++) {\n                        for (const diagnostic of diagnostics) {\n                            if (diagnostic.severity === order[i]) {\n                                const len = marker.push({ ...Diagnostic.from(diagnostic), modelVersionId: this._modelVersionIdProvider(uri) });\n                                if (len === this._maxDiagnosticsPerFile) {\n                                    break orderLoop;\n                                }\n                            }\n                        }\n                    }\n                    marker.push({\n                        severity: MarkerSeverity.Info,\n                        message: ( localize(\n                            4797,\n                            \"Not showing {0} further errors and warnings.\",\n                            diagnostics.length - this._maxDiagnosticsPerFile\n                        )),\n                        startLineNumber: marker[marker.length - 1].startLineNumber,\n                        startColumn: marker[marker.length - 1].startColumn,\n                        endLineNumber: marker[marker.length - 1].endLineNumber,\n                        endColumn: marker[marker.length - 1].endColumn\n                    });\n                }\n                else {\n                    marker = ( (diagnostics.map(\n                        diag => ({ ...Diagnostic.from(diag), modelVersionId: this._modelVersionIdProvider(uri) })\n                    )));\n                }\n            }\n            entries.push([uri, marker]);\n            totalMarkerCount += marker.length;\n            if (totalMarkerCount > this._maxDiagnosticsTotal) {\n                break;\n            }\n        }\n        this.#proxy.$changeMany(this._owner, entries);\n    }\n    delete(uri) {\n        this._checkDisposed();\n        this.#onDidChangeDiagnostics.fire([uri]);\n        this.#data.delete(uri);\n        this.#proxy?.$changeMany(this._owner, [[uri, undefined]]);\n    }\n    clear() {\n        this._checkDisposed();\n        this.#onDidChangeDiagnostics.fire([...( (this.#data.keys()))]);\n        this.#data.clear();\n        this.#proxy?.$clear(this._owner);\n    }\n    forEach(callback, thisArg) {\n        this._checkDisposed();\n        for (const [uri, values] of this) {\n            callback.call(thisArg, uri, values, this);\n        }\n    }\n    *[Symbol.iterator]() {\n        this._checkDisposed();\n        for (const uri of ( (this.#data.keys()))) {\n            yield [uri, this.get(uri)];\n        }\n    }\n    get(uri) {\n        this._checkDisposed();\n        const result = this.#data.get(uri);\n        if (Array.isArray(result)) {\n            return (\n                 (Object.freeze(result.slice(0)))\n            );\n        }\n        return [];\n    }\n    has(uri) {\n        this._checkDisposed();\n        return Array.isArray(this.#data.get(uri));\n    }\n    _checkDisposed() {\n        if (this._isDisposed) {\n            throw ( (new Error('illegal state - object is disposed')));\n        }\n    }\n    static _compareIndexedTuplesByUri(a, b) {\n        if (( (a[0].toString())) < ( (b[0].toString()))) {\n            return -1;\n        }\n        else if (( (a[0].toString())) > ( (b[0].toString()))) {\n            return 1;\n        }\n        else {\n            return 0;\n        }\n    }\n}\nlet ExtHostDiagnostics = class ExtHostDiagnostics {\n    static { ExtHostDiagnostics_1 = this; }\n    static { this._idPool = 0; }\n    static { this._maxDiagnosticsPerFile = 1000; }\n    static { this._maxDiagnosticsTotal = 1.1 * this._maxDiagnosticsPerFile; }\n    static _mapper(last) {\n        const map = ( (new ResourceMap()));\n        for (const uri of last) {\n            map.set(uri, uri);\n        }\n        return { uris: ( (Object.freeze(Array.from(( (map.values())))))) };\n    }\n    constructor(mainContext, _logService, _fileSystemInfoService, _extHostDocumentsAndEditors) {\n        this._logService = _logService;\n        this._fileSystemInfoService = _fileSystemInfoService;\n        this._extHostDocumentsAndEditors = _extHostDocumentsAndEditors;\n        this._collections = ( (new Map()));\n        this._onDidChangeDiagnostics = ( (new DebounceEmitter({ merge: all => all.flat(), delay: 50 })));\n        this.onDidChangeDiagnostics = ( (Event.map(this._onDidChangeDiagnostics.event, ExtHostDiagnostics_1._mapper)));\n        this._proxy = ( (mainContext.getProxy(MainContext.MainThreadDiagnostics)));\n    }\n    createDiagnosticCollection(extensionId, name) {\n        const { _collections, _proxy, _onDidChangeDiagnostics, _logService, _fileSystemInfoService, _extHostDocumentsAndEditors } = this;\n        const loggingProxy = new (class {\n            $changeMany(owner, entries) {\n                _proxy.$changeMany(owner, entries);\n                _logService.trace('[DiagnosticCollection] change many (extension, owner, uris)', extensionId.value, owner, entries.length === 0 ? 'CLEARING' : entries);\n            }\n            $clear(owner) {\n                _proxy.$clear(owner);\n                _logService.trace('[DiagnosticCollection] remove all (extension, owner)', extensionId.value, owner);\n            }\n            dispose() {\n                _proxy.dispose();\n            }\n        });\n        let owner;\n        if (!name) {\n            name = '_generated_diagnostic_collection_name_#' + ExtHostDiagnostics_1._idPool++;\n            owner = name;\n        }\n        else if (!( (_collections.has(name)))) {\n            owner = name;\n        }\n        else {\n            this._logService.warn(`DiagnosticCollection with name '${name}' does already exist.`);\n            do {\n                owner = name + ExtHostDiagnostics_1._idPool++;\n            } while (( (_collections.has(owner))));\n        }\n        const result = new (class extends DiagnosticCollection {\n            constructor() {\n                super(name, owner, ExtHostDiagnostics_1._maxDiagnosticsTotal, ExtHostDiagnostics_1._maxDiagnosticsPerFile, uri => _extHostDocumentsAndEditors.getDocument(uri)?.version, _fileSystemInfoService.extUri, loggingProxy, _onDidChangeDiagnostics);\n                _collections.set(owner, this);\n            }\n            dispose() {\n                super.dispose();\n                _collections.delete(owner);\n            }\n        });\n        return result;\n    }\n    getDiagnostics(resource) {\n        if (resource) {\n            return this._getDiagnostics(resource);\n        }\n        else {\n            const index = ( (new Map()));\n            const res = [];\n            for (const collection of ( (this._collections.values()))) {\n                collection.forEach((uri, diagnostics) => {\n                    let idx = index.get(( (uri.toString())));\n                    if (typeof idx === 'undefined') {\n                        idx = res.length;\n                        index.set(( (uri.toString())), idx);\n                        res.push([uri, []]);\n                    }\n                    res[idx][1] = res[idx][1].concat(...diagnostics);\n                });\n            }\n            return res;\n        }\n    }\n    _getDiagnostics(resource) {\n        let res = [];\n        for (const collection of ( (this._collections.values()))) {\n            if (( (collection.has(resource)))) {\n                res = res.concat(collection.get(resource));\n            }\n        }\n        return res;\n    }\n    $acceptMarkersChange(data) {\n        if (!this._mirrorCollection) {\n            const name = '_generated_mirror';\n            const collection = ( (new DiagnosticCollection(\n                name,\n                name,\n                Number.MAX_SAFE_INTEGER,\n                Number.MAX_SAFE_INTEGER,\n                _uri => undefined,\n                this._fileSystemInfoService.extUri,\n                undefined,\n                this._onDidChangeDiagnostics\n            )));\n            this._collections.set(name, collection);\n            this._mirrorCollection = collection;\n        }\n        for (const [uri, markers] of data) {\n            this._mirrorCollection.set(URI.revive(uri), ( (markers.map(Diagnostic.to))));\n        }\n    }\n};\nExtHostDiagnostics = ExtHostDiagnostics_1 = ( (__decorate([\n    ( (__param(1, ILogService))),\n    ( (__param(2, IExtHostFileSystemInfo)))\n], ExtHostDiagnostics)));\nexport { DiagnosticCollection, ExtHostDiagnostics };\n","import { URI } from '../../../base/common/uri.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { checkProposedApiEnabled } from '../../services/extensions/common/extensions.js';\nclass ExtHostDialogs {\n    constructor(mainContext) {\n        this._proxy = ( mainContext.getProxy(MainContext.MainThreadDialogs));\n    }\n    showOpenDialog(extension, options) {\n        if (options?.allowUIResources) {\n            checkProposedApiEnabled(extension, 'showLocal');\n        }\n        return this._proxy.$showOpenDialog(options).then(filepaths => {\n            return filepaths ? ( filepaths.map(p => URI.revive(p))) : undefined;\n        });\n    }\n    showSaveDialog(options) {\n        return this._proxy.$showSaveDialog(options).then(filepath => {\n            return filepath ? URI.revive(filepath) : undefined;\n        });\n    }\n}\nexport { ExtHostDialogs };\n","import { onUnexpectedError } from '../../../base/common/errors.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { Disposable } from './extHostTypes.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { splitLines } from '../../../base/common/strings.js';\nclass ExtHostDocumentContentProvider {\n    static { this._handlePool = 0; }\n    constructor(mainContext, _documentsAndEditors, _logService) {\n        this._documentsAndEditors = _documentsAndEditors;\n        this._logService = _logService;\n        this._documentContentProviders = ( new Map());\n        this._proxy = ( mainContext.getProxy(MainContext.MainThreadDocumentContentProviders));\n    }\n    registerTextDocumentContentProvider(scheme, provider) {\n        if (( Object.keys(Schemas)).indexOf(scheme) >= 0) {\n            throw ( new Error(`scheme '${scheme}' already registered`));\n        }\n        const handle = ExtHostDocumentContentProvider._handlePool++;\n        this._documentContentProviders.set(handle, provider);\n        this._proxy.$registerTextContentProvider(handle, scheme);\n        let subscription;\n        if (typeof provider.onDidChange === 'function') {\n            let lastEvent;\n            subscription = provider.onDidChange(async (uri) => {\n                if (uri.scheme !== scheme) {\n                    this._logService.warn(`Provider for scheme '${scheme}' is firing event for schema '${uri.scheme}' which will be IGNORED`);\n                    return;\n                }\n                if (!this._documentsAndEditors.getDocument(uri)) {\n                    return;\n                }\n                if (lastEvent) {\n                    await lastEvent;\n                }\n                const thisEvent = this.$provideTextDocumentContent(handle, uri)\n                    .then(async (value) => {\n                    if (!value && typeof value !== 'string') {\n                        return;\n                    }\n                    const document = this._documentsAndEditors.getDocument(uri);\n                    if (!document) {\n                        return;\n                    }\n                    const lines = splitLines(value);\n                    if (!document.equalLines(lines)) {\n                        return this._proxy.$onVirtualDocumentChange(uri, value);\n                    }\n                })\n                    .catch(onUnexpectedError)\n                    .finally(() => {\n                    if (lastEvent === thisEvent) {\n                        lastEvent = undefined;\n                    }\n                });\n                lastEvent = thisEvent;\n            });\n        }\n        return ( new Disposable(() => {\n            if (this._documentContentProviders.delete(handle)) {\n                this._proxy.$unregisterTextContentProvider(handle);\n            }\n            if (subscription) {\n                subscription.dispose();\n                subscription = undefined;\n            }\n        }));\n    }\n    $provideTextDocumentContent(handle, uri) {\n        const provider = this._documentContentProviders.get(handle);\n        if (!provider) {\n            return Promise.reject(( new Error(`unsupported uri-scheme: ${uri.scheme}`)));\n        }\n        return Promise.resolve(provider.provideTextDocumentContent(URI.revive(uri), CancellationToken.None));\n    }\n}\nexport { ExtHostDocumentContentProvider };\n","import { ok } from '../../../base/common/assert.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { regExpLeadsToEndlessLoop } from '../../../base/common/strings.js';\nimport { MirrorTextModel } from '../../../editor/common/model/mirrorTextModel.js';\nimport { getWordAtText, ensureValidWordDefinition } from '../../../editor/common/core/wordHelper.js';\nimport { EndOfLine, Position, Range } from './extHostTypes.js';\nimport { equals } from '../../../base/common/arrays.js';\nconst _languageId2WordDefinition = ( new Map());\nfunction setWordDefinitionFor(languageId, wordDefinition) {\n    if (!wordDefinition) {\n        _languageId2WordDefinition.delete(languageId);\n    }\n    else {\n        _languageId2WordDefinition.set(languageId, wordDefinition);\n    }\n}\nfunction getWordDefinitionFor(languageId) {\n    return _languageId2WordDefinition.get(languageId);\n}\nclass ExtHostDocumentData extends MirrorTextModel {\n    constructor(_proxy, uri, lines, eol, versionId, _languageId, _isDirty) {\n        super(uri, lines, eol, versionId);\n        this._proxy = _proxy;\n        this._languageId = _languageId;\n        this._isDirty = _isDirty;\n        this._isDisposed = false;\n    }\n    dispose() {\n        ok(!this._isDisposed);\n        this._isDisposed = true;\n        this._isDirty = false;\n    }\n    equalLines(lines) {\n        return equals(this._lines, lines);\n    }\n    get document() {\n        if (!this._document) {\n            const that = this;\n            this._document = {\n                get uri() { return that._uri; },\n                get fileName() { return that._uri.fsPath; },\n                get isUntitled() { return that._uri.scheme === Schemas.untitled; },\n                get languageId() { return that._languageId; },\n                get version() { return that._versionId; },\n                get isClosed() { return that._isDisposed; },\n                get isDirty() { return that._isDirty; },\n                save() { return that._save(); },\n                getText(range) { return range ? that._getTextInRange(range) : that.getText(); },\n                get eol() { return that._eol === '\\n' ? EndOfLine.LF : EndOfLine.CRLF; },\n                get lineCount() { return that._lines.length; },\n                lineAt(lineOrPos) { return that._lineAt(lineOrPos); },\n                offsetAt(pos) { return that._offsetAt(pos); },\n                positionAt(offset) { return that._positionAt(offset); },\n                validateRange(ran) { return that._validateRange(ran); },\n                validatePosition(pos) { return that._validatePosition(pos); },\n                getWordRangeAtPosition(pos, regexp) { return that._getWordRangeAtPosition(pos, regexp); },\n                [Symbol.for('debug.description')]() {\n                    return `TextDocument(${( that._uri.toString())})`;\n                }\n            };\n        }\n        return ( Object.freeze(this._document));\n    }\n    _acceptLanguageId(newLanguageId) {\n        ok(!this._isDisposed);\n        this._languageId = newLanguageId;\n    }\n    _acceptIsDirty(isDirty) {\n        ok(!this._isDisposed);\n        this._isDirty = isDirty;\n    }\n    _save() {\n        if (this._isDisposed) {\n            return Promise.reject(( new Error('Document has been closed')));\n        }\n        return this._proxy.$trySaveDocument(this._uri);\n    }\n    _getTextInRange(_range) {\n        const range = this._validateRange(_range);\n        if (range.isEmpty) {\n            return '';\n        }\n        if (range.isSingleLine) {\n            return this._lines[range.start.line].substring(range.start.character, range.end.character);\n        }\n        const lineEnding = this._eol, startLineIndex = range.start.line, endLineIndex = range.end.line, resultLines = [];\n        resultLines.push(this._lines[startLineIndex].substring(range.start.character));\n        for (let i = startLineIndex + 1; i < endLineIndex; i++) {\n            resultLines.push(this._lines[i]);\n        }\n        resultLines.push(this._lines[endLineIndex].substring(0, range.end.character));\n        return resultLines.join(lineEnding);\n    }\n    _lineAt(lineOrPosition) {\n        let line;\n        if (lineOrPosition instanceof Position) {\n            line = lineOrPosition.line;\n        }\n        else if (typeof lineOrPosition === 'number') {\n            line = lineOrPosition;\n        }\n        if (typeof line !== 'number' || line < 0 || line >= this._lines.length || Math.floor(line) !== line) {\n            throw ( new Error('Illegal value for `line`'));\n        }\n        return ( new ExtHostDocumentLine(line, this._lines[line], line === this._lines.length - 1));\n    }\n    _offsetAt(position) {\n        position = this._validatePosition(position);\n        this._ensureLineStarts();\n        return this._lineStarts.getPrefixSum(position.line - 1) + position.character;\n    }\n    _positionAt(offset) {\n        offset = Math.floor(offset);\n        offset = Math.max(0, offset);\n        this._ensureLineStarts();\n        const out = this._lineStarts.getIndexOf(offset);\n        const lineLength = this._lines[out.index].length;\n        return ( new Position(out.index, Math.min(out.remainder, lineLength)));\n    }\n    _validateRange(range) {\n        if (!(range instanceof Range)) {\n            throw ( new Error('Invalid argument'));\n        }\n        const start = this._validatePosition(range.start);\n        const end = this._validatePosition(range.end);\n        if (start === range.start && end === range.end) {\n            return range;\n        }\n        return ( new Range(start.line, start.character, end.line, end.character));\n    }\n    _validatePosition(position) {\n        if (!(position instanceof Position)) {\n            throw ( new Error('Invalid argument'));\n        }\n        if (this._lines.length === 0) {\n            return position.with(0, 0);\n        }\n        let { line, character } = position;\n        let hasChanged = false;\n        if (line < 0) {\n            line = 0;\n            character = 0;\n            hasChanged = true;\n        }\n        else if (line >= this._lines.length) {\n            line = this._lines.length - 1;\n            character = this._lines[line].length;\n            hasChanged = true;\n        }\n        else {\n            const maxCharacter = this._lines[line].length;\n            if (character < 0) {\n                character = 0;\n                hasChanged = true;\n            }\n            else if (character > maxCharacter) {\n                character = maxCharacter;\n                hasChanged = true;\n            }\n        }\n        if (!hasChanged) {\n            return position;\n        }\n        return ( new Position(line, character));\n    }\n    _getWordRangeAtPosition(_position, regexp) {\n        const position = this._validatePosition(_position);\n        if (!regexp) {\n            regexp = getWordDefinitionFor(this._languageId);\n        }\n        else if (regExpLeadsToEndlessLoop(regexp)) {\n            throw ( new Error(\n                `[getWordRangeAtPosition]: ignoring custom regexp '${regexp.source}' because it matches the empty string.`\n            ));\n        }\n        const wordAtText = getWordAtText(position.character + 1, ensureValidWordDefinition(regexp), this._lines[position.line], 0);\n        if (wordAtText) {\n            return ( new Range(\n                position.line,\n                wordAtText.startColumn - 1,\n                position.line,\n                wordAtText.endColumn - 1\n            ));\n        }\n        return undefined;\n    }\n}\nclass ExtHostDocumentLine {\n    constructor(line, text, isLastLine) {\n        this._line = line;\n        this._text = text;\n        this._isLastLine = isLastLine;\n    }\n    get lineNumber() {\n        return this._line;\n    }\n    get text() {\n        return this._text;\n    }\n    get range() {\n        return ( new Range(this._line, 0, this._line, this._text.length));\n    }\n    get rangeIncludingLineBreak() {\n        if (this._isLastLine) {\n            return this.range;\n        }\n        return ( new Range(this._line, 0, this._line + 1, 0));\n    }\n    get firstNonWhitespaceCharacterIndex() {\n        return /^(\\s*)/.exec(this._text)[1].length;\n    }\n    get isEmptyOrWhitespace() {\n        return this.firstNonWhitespaceCharacterIndex === this._text.length;\n    }\n}\nexport { ExtHostDocumentData, ExtHostDocumentLine, setWordDefinitionFor };\n","import { URI } from '../../../base/common/uri.js';\nimport { illegalState } from '../../../base/common/errors.js';\nimport { TextEdit } from './extHostTypes.js';\nimport { TextDocumentSaveReason, Range, EndOfLine } from './extHostTypeConverters.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\nimport { SerializableObjectWithBuffers } from '../../services/extensions/common/proxyIdentifier.js';\nclass ExtHostDocumentSaveParticipant {\n    constructor(_logService, _documents, _mainThreadBulkEdits, _thresholds = { timeout: 1500, errors: 3 }) {\n        this._logService = _logService;\n        this._documents = _documents;\n        this._mainThreadBulkEdits = _mainThreadBulkEdits;\n        this._thresholds = _thresholds;\n        this._callbacks = ( new LinkedList());\n        this._badListeners = ( new WeakMap());\n    }\n    dispose() {\n        this._callbacks.clear();\n    }\n    getOnWillSaveTextDocumentEvent(extension) {\n        return (listener, thisArg, disposables) => {\n            const remove = this._callbacks.push([listener, thisArg, extension]);\n            const result = { dispose: remove };\n            if (Array.isArray(disposables)) {\n                disposables.push(result);\n            }\n            return result;\n        };\n    }\n    async $participateInSave(data, reason) {\n        const resource = URI.revive(data);\n        let didTimeout = false;\n        const didTimeoutHandle = setTimeout(() => didTimeout = true, this._thresholds.timeout);\n        const results = [];\n        try {\n            for (const listener of [...this._callbacks]) {\n                if (didTimeout) {\n                    break;\n                }\n                const document = this._documents.getDocument(resource);\n                const success = await this._deliverEventAsyncAndBlameBadListeners(listener, { document, reason: TextDocumentSaveReason.to(reason) });\n                results.push(success);\n            }\n        }\n        finally {\n            clearTimeout(didTimeoutHandle);\n        }\n        return results;\n    }\n    _deliverEventAsyncAndBlameBadListeners([listener, thisArg, extension], stubEvent) {\n        const errors = this._badListeners.get(listener);\n        if (typeof errors === 'number' && errors > this._thresholds.errors) {\n            return Promise.resolve(false);\n        }\n        return this._deliverEventAsync(extension, listener, thisArg, stubEvent).then(() => {\n            return true;\n        }, err => {\n            this._logService.error(`onWillSaveTextDocument-listener from extension '${extension.identifier.value}' threw ERROR`);\n            this._logService.error(err);\n            if (!(err instanceof Error) || err.message !== 'concurrent_edits') {\n                const errors = this._badListeners.get(listener);\n                this._badListeners.set(listener, !errors ? 1 : errors + 1);\n                if (typeof errors === 'number' && errors > this._thresholds.errors) {\n                    this._logService.info(`onWillSaveTextDocument-listener from extension '${extension.identifier.value}' will now be IGNORED because of timeouts and/or errors`);\n                }\n            }\n            return false;\n        });\n    }\n    _deliverEventAsync(extension, listener, thisArg, stubEvent) {\n        const promises = [];\n        const t1 = Date.now();\n        const { document, reason } = stubEvent;\n        const { version } = document;\n        const event = ( Object.freeze({\n            document,\n            reason,\n            waitUntil(p) {\n                if (Object.isFrozen(promises)) {\n                    throw illegalState('waitUntil can not be called async');\n                }\n                promises.push(Promise.resolve(p));\n            }\n        }));\n        try {\n            listener.apply(thisArg, [event]);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n        return ( new Promise((resolve, reject) => {\n            const handle = setTimeout(() => reject(( new Error('timeout'))), this._thresholds.timeout);\n            return Promise.all(promises).then(edits => {\n                this._logService.debug(`onWillSaveTextDocument-listener from extension '${extension.identifier.value}' finished after ${(Date.now() - t1)}ms`);\n                clearTimeout(handle);\n                resolve(edits);\n            }).catch(err => {\n                clearTimeout(handle);\n                reject(err);\n            });\n        })).then(values => {\n            const dto = { edits: [] };\n            for (const value of values) {\n                if (Array.isArray(value) && value.every(e => e instanceof TextEdit)) {\n                    for (const { newText, newEol, range } of value) {\n                        dto.edits.push({\n                            resource: document.uri,\n                            versionId: undefined,\n                            textEdit: {\n                                range: range && Range.from(range),\n                                text: newText,\n                                eol: newEol && EndOfLine.from(newEol),\n                            }\n                        });\n                    }\n                }\n            }\n            if (dto.edits.length === 0) {\n                return undefined;\n            }\n            if (version === document.version) {\n                return this._mainThreadBulkEdits.$tryApplyWorkspaceEdit(( new SerializableObjectWithBuffers(dto)));\n            }\n            return Promise.reject(( new Error('concurrent_edits')));\n        });\n    }\n}\nexport { ExtHostDocumentSaveParticipant };\n","import { Emitter } from '../../../base/common/event.js';\nimport { DisposableStore } from '../../../base/common/lifecycle.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { setWordDefinitionFor } from './extHostDocumentData.js';\nimport { Range } from './extHostTypeConverters.js';\nimport { assertIsDefined } from '../../../base/common/types.js';\nimport { deepFreeze } from '../../../base/common/objects.js';\nimport { TextDocumentChangeReason } from './extHostTypes.js';\nclass ExtHostDocuments {\n    constructor(mainContext, documentsAndEditors) {\n        this._onDidAddDocument = ( new Emitter());\n        this._onDidRemoveDocument = ( new Emitter());\n        this._onDidChangeDocument = ( new Emitter());\n        this._onDidSaveDocument = ( new Emitter());\n        this.onDidAddDocument = this._onDidAddDocument.event;\n        this.onDidRemoveDocument = this._onDidRemoveDocument.event;\n        this.onDidChangeDocument = this._onDidChangeDocument.event;\n        this.onDidSaveDocument = this._onDidSaveDocument.event;\n        this._toDispose = ( new DisposableStore());\n        this._documentLoader = ( new Map());\n        this._proxy = ( mainContext.getProxy(MainContext.MainThreadDocuments));\n        this._documentsAndEditors = documentsAndEditors;\n        this._documentsAndEditors.onDidRemoveDocuments(documents => {\n            for (const data of documents) {\n                this._onDidRemoveDocument.fire(data.document);\n            }\n        }, undefined, this._toDispose);\n        this._documentsAndEditors.onDidAddDocuments(documents => {\n            for (const data of documents) {\n                this._onDidAddDocument.fire(data.document);\n            }\n        }, undefined, this._toDispose);\n    }\n    dispose() {\n        this._toDispose.dispose();\n    }\n    getAllDocumentData() {\n        return [...this._documentsAndEditors.allDocuments()];\n    }\n    getDocumentData(resource) {\n        if (!resource) {\n            return undefined;\n        }\n        const data = this._documentsAndEditors.getDocument(resource);\n        if (data) {\n            return data;\n        }\n        return undefined;\n    }\n    getDocument(resource) {\n        const data = this.getDocumentData(resource);\n        if (!data?.document) {\n            throw ( new Error(`Unable to retrieve document from URI '${resource}'`));\n        }\n        return data.document;\n    }\n    ensureDocumentData(uri) {\n        const cached = this._documentsAndEditors.getDocument(uri);\n        if (cached) {\n            return Promise.resolve(cached);\n        }\n        let promise = this._documentLoader.get(( uri.toString()));\n        if (!promise) {\n            promise = this._proxy.$tryOpenDocument(uri).then(uriData => {\n                this._documentLoader.delete(( uri.toString()));\n                const canonicalUri = URI.revive(uriData);\n                return assertIsDefined(this._documentsAndEditors.getDocument(canonicalUri));\n            }, err => {\n                this._documentLoader.delete(( uri.toString()));\n                return Promise.reject(err);\n            });\n            this._documentLoader.set(( uri.toString()), promise);\n        }\n        return promise;\n    }\n    createDocumentData(options) {\n        return this._proxy.$tryCreateDocument(options).then(data => URI.revive(data));\n    }\n    $acceptModelLanguageChanged(uriComponents, newLanguageId) {\n        const uri = URI.revive(uriComponents);\n        const data = this._documentsAndEditors.getDocument(uri);\n        if (!data) {\n            throw ( new Error('unknown document'));\n        }\n        this._onDidRemoveDocument.fire(data.document);\n        data._acceptLanguageId(newLanguageId);\n        this._onDidAddDocument.fire(data.document);\n    }\n    $acceptModelSaved(uriComponents) {\n        const uri = URI.revive(uriComponents);\n        const data = this._documentsAndEditors.getDocument(uri);\n        if (!data) {\n            throw ( new Error('unknown document'));\n        }\n        this.$acceptDirtyStateChanged(uriComponents, false);\n        this._onDidSaveDocument.fire(data.document);\n    }\n    $acceptDirtyStateChanged(uriComponents, isDirty) {\n        const uri = URI.revive(uriComponents);\n        const data = this._documentsAndEditors.getDocument(uri);\n        if (!data) {\n            throw ( new Error('unknown document'));\n        }\n        data._acceptIsDirty(isDirty);\n        this._onDidChangeDocument.fire({\n            document: data.document,\n            contentChanges: [],\n            reason: undefined\n        });\n    }\n    $acceptModelChanged(uriComponents, events, isDirty) {\n        const uri = URI.revive(uriComponents);\n        const data = this._documentsAndEditors.getDocument(uri);\n        if (!data) {\n            throw ( new Error('unknown document'));\n        }\n        data._acceptIsDirty(isDirty);\n        data.onEvents(events);\n        let reason = undefined;\n        if (events.isUndoing) {\n            reason = TextDocumentChangeReason.Undo;\n        }\n        else if (events.isRedoing) {\n            reason = TextDocumentChangeReason.Redo;\n        }\n        this._onDidChangeDocument.fire(deepFreeze({\n            document: data.document,\n            contentChanges: ( events.changes.map((change) => {\n                return {\n                    range: Range.to(change.range),\n                    rangeOffset: change.rangeOffset,\n                    rangeLength: change.rangeLength,\n                    text: change.text\n                };\n            })),\n            reason\n        }));\n    }\n    setWordDefinitionFor(languageId, wordDefinition) {\n        setWordDefinitionFor(languageId, wordDefinition);\n    }\n}\nexport { ExtHostDocuments };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { ok } from '../../../base/common/assert.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { dispose } from '../../../base/common/lifecycle.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { ExtHostDocumentData } from './extHostDocumentData.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\nimport { ExtHostTextEditor } from './extHostTextEditor.js';\nimport { Selection, Range, ViewColumn } from './extHostTypeConverters.js';\nimport { ILogService } from '../../../platform/log/common/log.service.js';\nimport { ResourceMap } from '../../../base/common/map.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { Iterable } from '../../../base/common/iterator.js';\nimport { Lazy } from '../../../base/common/lazy.js';\nclass Reference {\n    constructor(value) {\n        this.value = value;\n        this._count = 0;\n    }\n    ref() {\n        this._count++;\n    }\n    unref() {\n        return --this._count === 0;\n    }\n}\nlet ExtHostDocumentsAndEditors = class ExtHostDocumentsAndEditors {\n    constructor(_extHostRpc, _logService) {\n        this._extHostRpc = _extHostRpc;\n        this._logService = _logService;\n        this._activeEditorId = null;\n        this._editors = ( new Map());\n        this._documents = ( new ResourceMap());\n        this._onDidAddDocuments = ( new Emitter());\n        this._onDidRemoveDocuments = ( new Emitter());\n        this._onDidChangeVisibleTextEditors = ( new Emitter());\n        this._onDidChangeActiveTextEditor = ( new Emitter());\n        this.onDidAddDocuments = this._onDidAddDocuments.event;\n        this.onDidRemoveDocuments = this._onDidRemoveDocuments.event;\n        this.onDidChangeVisibleTextEditors = this._onDidChangeVisibleTextEditors.event;\n        this.onDidChangeActiveTextEditor = this._onDidChangeActiveTextEditor.event;\n    }\n    $acceptDocumentsAndEditorsDelta(delta) {\n        this.acceptDocumentsAndEditorsDelta(delta);\n    }\n    acceptDocumentsAndEditorsDelta(delta) {\n        const removedDocuments = [];\n        const addedDocuments = [];\n        const removedEditors = [];\n        if (delta.removedDocuments) {\n            for (const uriComponent of delta.removedDocuments) {\n                const uri = URI.revive(uriComponent);\n                const data = this._documents.get(uri);\n                if (data?.unref()) {\n                    this._documents.delete(uri);\n                    removedDocuments.push(data.value);\n                }\n            }\n        }\n        if (delta.addedDocuments) {\n            for (const data of delta.addedDocuments) {\n                const resource = URI.revive(data.uri);\n                let ref = this._documents.get(resource);\n                if (ref) {\n                    if (resource.scheme !== Schemas.vscodeNotebookCell && resource.scheme !== Schemas.vscodeInteractiveInput) {\n                        throw ( new Error(`document '${resource} already exists!'`));\n                    }\n                }\n                if (!ref) {\n                    ref = ( new Reference(( new ExtHostDocumentData(( this._extHostRpc.getProxy(MainContext.MainThreadDocuments)), resource, data.lines, data.EOL, data.versionId, data.languageId, data.isDirty))));\n                    this._documents.set(resource, ref);\n                    addedDocuments.push(ref.value);\n                }\n                ref.ref();\n            }\n        }\n        if (delta.removedEditors) {\n            for (const id of delta.removedEditors) {\n                const editor = this._editors.get(id);\n                this._editors.delete(id);\n                if (editor) {\n                    removedEditors.push(editor);\n                }\n            }\n        }\n        if (delta.addedEditors) {\n            for (const data of delta.addedEditors) {\n                const resource = URI.revive(data.documentUri);\n                ok(( this._documents.has(resource)), `document '${resource}' does not exist`);\n                ok(!( this._editors.has(data.id)), `editor '${data.id}' already exists!`);\n                const documentData = this._documents.get(resource).value;\n                const editor = ( new ExtHostTextEditor(data.id, ( this._extHostRpc.getProxy(MainContext.MainThreadTextEditors)), this._logService, ( new Lazy(() => documentData.document)), ( data.selections.map(Selection.to)), data.options, ( data.visibleRanges.map(range => Range.to(range))), typeof data.editorPosition === 'number' ? ViewColumn.to(data.editorPosition) : undefined));\n                this._editors.set(data.id, editor);\n            }\n        }\n        if (delta.newActiveEditor !== undefined) {\n            ok(delta.newActiveEditor === null || ( this._editors.has(delta.newActiveEditor)), `active editor '${delta.newActiveEditor}' does not exist`);\n            this._activeEditorId = delta.newActiveEditor;\n        }\n        dispose(removedDocuments);\n        dispose(removedEditors);\n        if (delta.removedDocuments) {\n            this._onDidRemoveDocuments.fire(removedDocuments);\n        }\n        if (delta.addedDocuments) {\n            this._onDidAddDocuments.fire(addedDocuments);\n        }\n        if (delta.removedEditors || delta.addedEditors) {\n            this._onDidChangeVisibleTextEditors.fire(( this.allEditors().map(editor => editor.value)));\n        }\n        if (delta.newActiveEditor !== undefined) {\n            this._onDidChangeActiveTextEditor.fire(this.activeEditor());\n        }\n    }\n    getDocument(uri) {\n        return this._documents.get(uri)?.value;\n    }\n    allDocuments() {\n        return ( Iterable.map(( this._documents.values()), ref => ref.value));\n    }\n    getEditor(id) {\n        return this._editors.get(id);\n    }\n    activeEditor(internal) {\n        if (!this._activeEditorId) {\n            return undefined;\n        }\n        const editor = this._editors.get(this._activeEditorId);\n        if (internal) {\n            return editor;\n        }\n        else {\n            return editor?.value;\n        }\n    }\n    allEditors() {\n        return [...( this._editors.values())];\n    }\n};\nExtHostDocumentsAndEditors = ( __decorate([\n    ( __param(0, IExtHostRpcService)),\n    ( __param(1, ILogService))\n], ExtHostDocumentsAndEditors));\nconst IExtHostDocumentsAndEditors = ( createDecorator('IExtHostDocumentsAndEditors'));\nexport { ExtHostDocumentsAndEditors, IExtHostDocumentsAndEditors };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { diffSets } from '../../../base/common/collections.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { assertIsDefined } from '../../../base/common/types.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\nimport { ViewColumn } from './extHostTypeConverters.js';\nimport { TextMultiDiffTabInput, TextDiffTabInput, ChatEditorTabInput, InteractiveWindowInput, TerminalEditorTabInput, NotebookDiffEditorTabInput, NotebookEditorTabInput, WebviewEditorTabInput, CustomEditorTabInput, TextMergeTabInput, TextTabInput } from './extHostTypes.js';\nconst IExtHostEditorTabs = ( createDecorator('IExtHostEditorTabs'));\nclass ExtHostEditorTab {\n    constructor(dto, parentGroup, activeTabIdGetter) {\n        this._activeTabIdGetter = activeTabIdGetter;\n        this._parentGroup = parentGroup;\n        this.acceptDtoUpdate(dto);\n    }\n    get apiObject() {\n        if (!this._apiObject) {\n            const that = this;\n            const obj = {\n                get isActive() {\n                    return that._dto.id === that._activeTabIdGetter();\n                },\n                get label() {\n                    return that._dto.label;\n                },\n                get input() {\n                    return that._input;\n                },\n                get isDirty() {\n                    return that._dto.isDirty;\n                },\n                get isPinned() {\n                    return that._dto.isPinned;\n                },\n                get isPreview() {\n                    return that._dto.isPreview;\n                },\n                get group() {\n                    return that._parentGroup.apiObject;\n                }\n            };\n            this._apiObject = ( Object.freeze(obj));\n        }\n        return this._apiObject;\n    }\n    get tabId() {\n        return this._dto.id;\n    }\n    acceptDtoUpdate(dto) {\n        this._dto = dto;\n        this._input = this._initInput();\n    }\n    _initInput() {\n        switch (this._dto.input.kind) {\n            case 1 :\n                return ( new TextTabInput(URI.revive(this._dto.input.uri)));\n            case 2 :\n                return ( new TextDiffTabInput(URI.revive(this._dto.input.original), URI.revive(this._dto.input.modified)));\n            case 3 :\n                return ( new TextMergeTabInput(\n                    URI.revive(this._dto.input.base),\n                    URI.revive(this._dto.input.input1),\n                    URI.revive(this._dto.input.input2),\n                    URI.revive(this._dto.input.result)\n                ));\n            case 6 :\n                return ( new CustomEditorTabInput(URI.revive(this._dto.input.uri), this._dto.input.viewType));\n            case 7 :\n                return ( new WebviewEditorTabInput(this._dto.input.viewType));\n            case 4 :\n                return ( new NotebookEditorTabInput(URI.revive(this._dto.input.uri), this._dto.input.notebookType));\n            case 5 :\n                return ( new NotebookDiffEditorTabInput(\n                    URI.revive(this._dto.input.original),\n                    URI.revive(this._dto.input.modified),\n                    this._dto.input.notebookType\n                ));\n            case 8 :\n                return ( new TerminalEditorTabInput());\n            case 9 :\n                return ( new InteractiveWindowInput(URI.revive(this._dto.input.uri), URI.revive(this._dto.input.inputBoxUri)));\n            case 10 :\n                return ( new ChatEditorTabInput());\n            case 11 :\n                return ( new TextMultiDiffTabInput(( this._dto.input.diffEditors.map(diff => ( new TextDiffTabInput(URI.revive(diff.original), URI.revive(diff.modified)))))));\n            default:\n                return undefined;\n        }\n    }\n}\nclass ExtHostEditorTabGroup {\n    constructor(dto, activeGroupIdGetter) {\n        this._tabs = [];\n        this._activeTabId = '';\n        this._dto = dto;\n        this._activeGroupIdGetter = activeGroupIdGetter;\n        for (const tabDto of dto.tabs) {\n            if (tabDto.isActive) {\n                this._activeTabId = tabDto.id;\n            }\n            this._tabs.push(( new ExtHostEditorTab(tabDto, this, () => this.activeTabId())));\n        }\n    }\n    get apiObject() {\n        if (!this._apiObject) {\n            const that = this;\n            const obj = {\n                get isActive() {\n                    return that._dto.groupId === that._activeGroupIdGetter();\n                },\n                get viewColumn() {\n                    return ViewColumn.to(that._dto.viewColumn);\n                },\n                get activeTab() {\n                    return that._tabs.find(tab => tab.tabId === that._activeTabId)?.apiObject;\n                },\n                get tabs() {\n                    return ( Object.freeze(( that._tabs.map(tab => tab.apiObject))));\n                }\n            };\n            this._apiObject = ( Object.freeze(obj));\n        }\n        return this._apiObject;\n    }\n    get groupId() {\n        return this._dto.groupId;\n    }\n    get tabs() {\n        return this._tabs;\n    }\n    acceptGroupDtoUpdate(dto) {\n        this._dto = dto;\n    }\n    acceptTabOperation(operation) {\n        if (operation.kind === 0 ) {\n            const tab = ( new ExtHostEditorTab(operation.tabDto, this, () => this.activeTabId()));\n            this._tabs.splice(operation.index, 0, tab);\n            if (operation.tabDto.isActive) {\n                this._activeTabId = tab.tabId;\n            }\n            return tab;\n        }\n        else if (operation.kind === 1 ) {\n            const tab = this._tabs.splice(operation.index, 1)[0];\n            if (!tab) {\n                throw ( new Error(\n                    `Tab close updated received for index ${operation.index} which does not exist`\n                ));\n            }\n            if (tab.tabId === this._activeTabId) {\n                this._activeTabId = '';\n            }\n            return tab;\n        }\n        else if (operation.kind === 3 ) {\n            if (operation.oldIndex === undefined) {\n                throw ( new Error('Invalid old index on move IPC'));\n            }\n            const tab = this._tabs.splice(operation.oldIndex, 1)[0];\n            if (!tab) {\n                throw ( new Error(\n                    `Tab move updated received for index ${operation.oldIndex} which does not exist`\n                ));\n            }\n            this._tabs.splice(operation.index, 0, tab);\n            return tab;\n        }\n        const tab = this._tabs.find(extHostTab => extHostTab.tabId === operation.tabDto.id);\n        if (!tab) {\n            throw ( new Error('INVALID tab'));\n        }\n        if (operation.tabDto.isActive) {\n            this._activeTabId = operation.tabDto.id;\n        }\n        else if (this._activeTabId === operation.tabDto.id && !operation.tabDto.isActive) {\n            this._activeTabId = '';\n        }\n        tab.acceptDtoUpdate(operation.tabDto);\n        return tab;\n    }\n    activeTabId() {\n        return this._activeTabId;\n    }\n}\nlet ExtHostEditorTabs = class ExtHostEditorTabs {\n    constructor(extHostRpc) {\n        this._onDidChangeTabs = ( new Emitter());\n        this._onDidChangeTabGroups = ( new Emitter());\n        this._extHostTabGroups = [];\n        this._proxy = ( extHostRpc.getProxy(MainContext.MainThreadEditorTabs));\n    }\n    get tabGroups() {\n        if (!this._apiObject) {\n            const that = this;\n            const obj = {\n                onDidChangeTabGroups: that._onDidChangeTabGroups.event,\n                onDidChangeTabs: that._onDidChangeTabs.event,\n                get all() {\n                    return ( Object.freeze(( that._extHostTabGroups.map(group => group.apiObject))));\n                },\n                get activeTabGroup() {\n                    const activeTabGroupId = that._activeGroupId;\n                    const activeTabGroup = assertIsDefined(that._extHostTabGroups.find(candidate => candidate.groupId === activeTabGroupId)?.apiObject);\n                    return activeTabGroup;\n                },\n                close: async (tabOrTabGroup, preserveFocus) => {\n                    const tabsOrTabGroups = Array.isArray(tabOrTabGroup) ? tabOrTabGroup : [tabOrTabGroup];\n                    if (!tabsOrTabGroups.length) {\n                        return true;\n                    }\n                    if (isTabGroup(tabsOrTabGroups[0])) {\n                        return this._closeGroups(tabsOrTabGroups, preserveFocus);\n                    }\n                    else {\n                        return this._closeTabs(tabsOrTabGroups, preserveFocus);\n                    }\n                },\n            };\n            this._apiObject = ( Object.freeze(obj));\n        }\n        return this._apiObject;\n    }\n    $acceptEditorTabModel(tabGroups) {\n        const groupIdsBefore = ( new Set(( this._extHostTabGroups.map(group => group.groupId))));\n        const groupIdsAfter = ( new Set(( tabGroups.map(dto => dto.groupId))));\n        const diff = diffSets(groupIdsBefore, groupIdsAfter);\n        const closed = ( this._extHostTabGroups.filter(group => diff.removed.includes(group.groupId)).map(group => group.apiObject));\n        const opened = [];\n        const changed = [];\n        this._extHostTabGroups = ( tabGroups.map(tabGroup => {\n            const group = ( new ExtHostEditorTabGroup(tabGroup, () => this._activeGroupId));\n            if (diff.added.includes(group.groupId)) {\n                opened.push(group.apiObject);\n            }\n            else {\n                changed.push(group.apiObject);\n            }\n            return group;\n        }));\n        const activeTabGroupId = assertIsDefined(tabGroups.find(group => group.isActive === true)?.groupId);\n        if (activeTabGroupId !== undefined && this._activeGroupId !== activeTabGroupId) {\n            this._activeGroupId = activeTabGroupId;\n        }\n        this._onDidChangeTabGroups.fire(( Object.freeze({ opened, closed, changed })));\n    }\n    $acceptTabGroupUpdate(groupDto) {\n        const group = this._extHostTabGroups.find(group => group.groupId === groupDto.groupId);\n        if (!group) {\n            throw ( new Error('Update Group IPC call received before group creation.'));\n        }\n        group.acceptGroupDtoUpdate(groupDto);\n        if (groupDto.isActive) {\n            this._activeGroupId = groupDto.groupId;\n        }\n        this._onDidChangeTabGroups.fire(( Object.freeze({ changed: [group.apiObject], opened: [], closed: [] })));\n    }\n    $acceptTabOperation(operation) {\n        const group = this._extHostTabGroups.find(group => group.groupId === operation.groupId);\n        if (!group) {\n            throw ( new Error('Update Tabs IPC call received before group creation.'));\n        }\n        const tab = group.acceptTabOperation(operation);\n        switch (operation.kind) {\n            case 0 :\n                this._onDidChangeTabs.fire(( Object.freeze({\n                    opened: [tab.apiObject],\n                    closed: [],\n                    changed: []\n                })));\n                return;\n            case 1 :\n                this._onDidChangeTabs.fire(( Object.freeze({\n                    opened: [],\n                    closed: [tab.apiObject],\n                    changed: []\n                })));\n                return;\n            case 3 :\n            case 2 :\n                this._onDidChangeTabs.fire(( Object.freeze({\n                    opened: [],\n                    closed: [],\n                    changed: [tab.apiObject]\n                })));\n                return;\n        }\n    }\n    _findExtHostTabFromApi(apiTab) {\n        for (const group of this._extHostTabGroups) {\n            for (const tab of group.tabs) {\n                if (tab.apiObject === apiTab) {\n                    return tab;\n                }\n            }\n        }\n        return;\n    }\n    _findExtHostTabGroupFromApi(apiTabGroup) {\n        return this._extHostTabGroups.find(candidate => candidate.apiObject === apiTabGroup);\n    }\n    async _closeTabs(tabs, preserveFocus) {\n        const extHostTabIds = [];\n        for (const tab of tabs) {\n            const extHostTab = this._findExtHostTabFromApi(tab);\n            if (!extHostTab) {\n                throw ( new Error('Tab close: Invalid tab not found!'));\n            }\n            extHostTabIds.push(extHostTab.tabId);\n        }\n        return this._proxy.$closeTab(extHostTabIds, preserveFocus);\n    }\n    async _closeGroups(groups, preserverFoucs) {\n        const extHostGroupIds = [];\n        for (const group of groups) {\n            const extHostGroup = this._findExtHostTabGroupFromApi(group);\n            if (!extHostGroup) {\n                throw ( new Error('Group close: Invalid group not found!'));\n            }\n            extHostGroupIds.push(extHostGroup.groupId);\n        }\n        return this._proxy.$closeGroup(extHostGroupIds, preserverFoucs);\n    }\n};\nExtHostEditorTabs = ( __decorate([\n    ( __param(0, IExtHostRpcService))\n], ExtHostEditorTabs));\nfunction isTabGroup(obj) {\n    const tabGroup = obj;\n    if (tabGroup.tabs !== undefined) {\n        return true;\n    }\n    return false;\n}\nexport { ExtHostEditorTabs, IExtHostEditorTabs };\n","import { CancellationToken } from '../../../base/common/cancellation.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { toDisposable } from '../../../base/common/lifecycle.js';\nimport { MainContext } from './extHost.protocol.js';\nclass ExtHostEmbeddings {\n    constructor(mainContext) {\n        this._provider = ( new Map());\n        this._onDidChange = ( new Emitter());\n        this.onDidChange = this._onDidChange.event;\n        this._allKnownModels = ( new Set());\n        this._handlePool = 0;\n        this._proxy = ( mainContext.getProxy(MainContext.MainThreadEmbeddings));\n    }\n    registerEmbeddingsProvider(_extension, embeddingsModel, provider) {\n        if (( this._allKnownModels.has(embeddingsModel))) {\n            throw ( new Error('An embeddings provider for this model is already registered'));\n        }\n        const handle = this._handlePool++;\n        this._proxy.$registerEmbeddingProvider(handle, embeddingsModel);\n        this._provider.set(handle, { id: embeddingsModel, provider });\n        return toDisposable(() => {\n            this._allKnownModels.delete(embeddingsModel);\n            this._proxy.$unregisterEmbeddingProvider(handle);\n            this._provider.delete(handle);\n        });\n    }\n    async computeEmbeddings(embeddingsModel, input, token) {\n        token ??= CancellationToken.None;\n        let returnSingle = false;\n        if (typeof input === 'string') {\n            input = [input];\n            returnSingle = true;\n        }\n        const result = await this._proxy.$computeEmbeddings(embeddingsModel, input, token);\n        if (result.length !== input.length) {\n            throw ( new Error());\n        }\n        if (returnSingle) {\n            if (result.length !== 1) {\n                throw ( new Error());\n            }\n            return result[0];\n        }\n        return result;\n    }\n    async $provideEmbeddings(handle, input, token) {\n        const data = this._provider.get(handle);\n        if (!data) {\n            return [];\n        }\n        const result = await data.provider.provideEmbeddings(input, token);\n        if (!result) {\n            return [];\n        }\n        return result;\n    }\n    get embeddingsModels() {\n        return Array.from(this._allKnownModels);\n    }\n    $acceptEmbeddingModels(models) {\n        this._allKnownModels = ( new Set(models));\n        this._onDidChange.fire();\n    }\n}\nexport { ExtHostEmbeddings };\n","import { MainContext } from './extHost.protocol.js';\nimport { Disposable } from './extHostTypes.js';\nclass ExtHostAiEmbeddingVector {\n    constructor(mainContext) {\n        this._AiEmbeddingVectorProviders = ( new Map());\n        this._nextHandle = 0;\n        this._proxy = ( mainContext.getProxy(MainContext.MainThreadAiEmbeddingVector));\n    }\n    async $provideAiEmbeddingVector(handle, strings, token) {\n        if (this._AiEmbeddingVectorProviders.size === 0) {\n            throw ( new Error('No embedding vector providers registered'));\n        }\n        const provider = this._AiEmbeddingVectorProviders.get(handle);\n        if (!provider) {\n            throw ( new Error('Embedding vector provider not found'));\n        }\n        const result = await provider.provideEmbeddingVector(strings, token);\n        if (!result) {\n            throw ( new Error('Embedding vector provider returned undefined'));\n        }\n        return result;\n    }\n    registerEmbeddingVectorProvider(extension, model, provider) {\n        const handle = this._nextHandle;\n        this._nextHandle++;\n        this._AiEmbeddingVectorProviders.set(handle, provider);\n        this._proxy.$registerAiEmbeddingVectorProvider(model, handle);\n        return ( new Disposable(() => {\n            this._proxy.$unregisterAiEmbeddingVectorProvider(handle);\n            this._AiEmbeddingVectorProviders.delete(handle);\n        }));\n    }\n}\nexport { ExtHostAiEmbeddingVector };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { isCancellationError } from '../../../base/common/errors.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { ExtensionDescriptionRegistry } from '../../services/extensions/common/extensionDescriptionRegistry.js';\nimport { ExtensionIdentifierMap } from '../../../platform/extensions/common/extensions.js';\nimport { MissingExtensionDependency } from '../../services/extensions/common/extensions.js';\nimport { ILogService } from '../../../platform/log/common/log.service.js';\nimport { Barrier } from '../../../base/common/async.js';\nclass ExtensionActivationTimes {\n    static { this.NONE = ( new ExtensionActivationTimes(false, -1, -1, -1)); }\n    constructor(startup, codeLoadingTime, activateCallTime, activateResolvedTime) {\n        this.startup = startup;\n        this.codeLoadingTime = codeLoadingTime;\n        this.activateCallTime = activateCallTime;\n        this.activateResolvedTime = activateResolvedTime;\n    }\n}\nclass ExtensionActivationTimesBuilder {\n    constructor(startup) {\n        this._startup = startup;\n        this._codeLoadingStart = -1;\n        this._codeLoadingStop = -1;\n        this._activateCallStart = -1;\n        this._activateCallStop = -1;\n        this._activateResolveStart = -1;\n        this._activateResolveStop = -1;\n    }\n    _delta(start, stop) {\n        if (start === -1 || stop === -1) {\n            return -1;\n        }\n        return stop - start;\n    }\n    build() {\n        return ( new ExtensionActivationTimes(\n            this._startup,\n            this._delta(this._codeLoadingStart, this._codeLoadingStop),\n            this._delta(this._activateCallStart, this._activateCallStop),\n            this._delta(this._activateResolveStart, this._activateResolveStop)\n        ));\n    }\n    codeLoadingStart() {\n        this._codeLoadingStart = Date.now();\n    }\n    codeLoadingStop() {\n        this._codeLoadingStop = Date.now();\n    }\n    activateCallStart() {\n        this._activateCallStart = Date.now();\n    }\n    activateCallStop() {\n        this._activateCallStop = Date.now();\n    }\n    activateResolveStart() {\n        this._activateResolveStart = Date.now();\n    }\n    activateResolveStop() {\n        this._activateResolveStop = Date.now();\n    }\n}\nclass ActivatedExtension {\n    constructor(activationFailed, activationFailedError, activationTimes, module, exports, disposable) {\n        this.activationFailed = activationFailed;\n        this.activationFailedError = activationFailedError;\n        this.activationTimes = activationTimes;\n        this.module = module;\n        this.exports = exports;\n        this.disposable = disposable;\n    }\n}\nclass EmptyExtension extends ActivatedExtension {\n    constructor(activationTimes) {\n        super(false, null, activationTimes, { activate: undefined, deactivate: undefined }, undefined, Disposable.None);\n    }\n}\nclass HostExtension extends ActivatedExtension {\n    constructor() {\n        super(false, null, ExtensionActivationTimes.NONE, { activate: undefined, deactivate: undefined }, undefined, Disposable.None);\n    }\n}\nclass FailedExtension extends ActivatedExtension {\n    constructor(activationError) {\n        super(true, activationError, ExtensionActivationTimes.NONE, { activate: undefined, deactivate: undefined }, undefined, Disposable.None);\n    }\n}\nlet ExtensionsActivator = class ExtensionsActivator {\n    constructor(registry, globalRegistry, host, _logService) {\n        this._logService = _logService;\n        this._registry = registry;\n        this._globalRegistry = globalRegistry;\n        this._host = host;\n        this._operations = ( new ExtensionIdentifierMap());\n        this._alreadyActivatedEvents = Object.create(null);\n    }\n    dispose() {\n        for (const [_, op] of this._operations) {\n            op.dispose();\n        }\n    }\n    async waitForActivatingExtensions() {\n        const res = [];\n        for (const [_, op] of this._operations) {\n            res.push(op.wait());\n        }\n        await Promise.all(res);\n    }\n    isActivated(extensionId) {\n        const op = this._operations.get(extensionId);\n        return Boolean(op && op.value);\n    }\n    getActivatedExtension(extensionId) {\n        const op = this._operations.get(extensionId);\n        if (!op || !op.value) {\n            throw ( new Error(`Extension '${extensionId.value}' is not known or not activated`));\n        }\n        return op.value;\n    }\n    async activateByEvent(activationEvent, startup) {\n        if (this._alreadyActivatedEvents[activationEvent]) {\n            return;\n        }\n        const activateExtensions = this._registry.getExtensionDescriptionsForActivationEvent(activationEvent);\n        await this._activateExtensions(( activateExtensions.map(e => ({\n            id: e.identifier,\n            reason: { startup, extensionId: e.identifier, activationEvent }\n        }))));\n        this._alreadyActivatedEvents[activationEvent] = true;\n    }\n    activateById(extensionId, reason) {\n        const desc = this._registry.getExtensionDescription(extensionId);\n        if (!desc) {\n            throw ( new Error(`Extension '${extensionId.value}' is not known`));\n        }\n        return this._activateExtensions([{ id: desc.identifier, reason }]);\n    }\n    async _activateExtensions(extensions) {\n        const operations = ( extensions\n            .filter((p) => !this.isActivated(p.id))\n            .map(ext => this._handleActivationRequest(ext)));\n        await Promise.all(( operations.map(op => op.wait())));\n    }\n    _handleActivationRequest(currentActivation) {\n        if (( this._operations.has(currentActivation.id))) {\n            return this._operations.get(currentActivation.id);\n        }\n        if (this._isHostExtension(currentActivation.id)) {\n            return this._createAndSaveOperation(currentActivation, null, [], null);\n        }\n        const currentExtension = this._registry.getExtensionDescription(currentActivation.id);\n        if (!currentExtension) {\n            const error = ( new Error(`Cannot activate unknown extension '${currentActivation.id.value}'`));\n            const result = this._createAndSaveOperation(currentActivation, null, [], ( new FailedExtension(error)));\n            this._host.onExtensionActivationError(currentActivation.id, error, ( new MissingExtensionDependency(currentActivation.id.value)));\n            return result;\n        }\n        const deps = [];\n        const depIds = (typeof currentExtension.extensionDependencies === 'undefined' ? [] : currentExtension.extensionDependencies);\n        for (const depId of depIds) {\n            if (this._isResolvedExtension(depId)) {\n                continue;\n            }\n            const dep = this._operations.get(depId);\n            if (dep) {\n                deps.push(dep);\n                continue;\n            }\n            if (this._isHostExtension(depId)) {\n                deps.push(this._handleActivationRequest({\n                    id: this._globalRegistry.getExtensionDescription(depId).identifier,\n                    reason: currentActivation.reason\n                }));\n                continue;\n            }\n            const depDesc = this._registry.getExtensionDescription(depId);\n            if (depDesc) {\n                if (!depDesc.main && !depDesc.browser) {\n                    continue;\n                }\n                deps.push(this._handleActivationRequest({\n                    id: depDesc.identifier,\n                    reason: currentActivation.reason\n                }));\n                continue;\n            }\n            const currentExtensionFriendlyName = currentExtension.displayName || currentExtension.identifier.value;\n            const error = ( new Error(\n                `Cannot activate the '${currentExtensionFriendlyName}' extension because it depends on unknown extension '${depId}'`\n            ));\n            const result = this._createAndSaveOperation(currentActivation, currentExtension.displayName, [], ( new FailedExtension(error)));\n            this._host.onExtensionActivationError(currentExtension.identifier, error, ( new MissingExtensionDependency(depId)));\n            return result;\n        }\n        return this._createAndSaveOperation(currentActivation, currentExtension.displayName, deps, null);\n    }\n    _createAndSaveOperation(activation, displayName, deps, value) {\n        const operation = ( new ActivationOperation(\n            activation.id,\n            displayName,\n            activation.reason,\n            deps,\n            value,\n            this._host,\n            this._logService\n        ));\n        this._operations.set(activation.id, operation);\n        return operation;\n    }\n    _isHostExtension(extensionId) {\n        return ExtensionDescriptionRegistry.isHostExtension(extensionId, this._registry, this._globalRegistry);\n    }\n    _isResolvedExtension(extensionId) {\n        const extensionDescription = this._globalRegistry.getExtensionDescription(extensionId);\n        if (!extensionDescription) {\n            return false;\n        }\n        return (!extensionDescription.main && !extensionDescription.browser);\n    }\n};\nExtensionsActivator = ( __decorate([\n    ( __param(3, ILogService))\n], ExtensionsActivator));\nlet ActivationOperation = class ActivationOperation {\n    get value() {\n        return this._value;\n    }\n    get friendlyName() {\n        return this._displayName || this._id.value;\n    }\n    constructor(_id, _displayName, _reason, _deps, _value, _host, _logService) {\n        this._id = _id;\n        this._displayName = _displayName;\n        this._reason = _reason;\n        this._deps = _deps;\n        this._value = _value;\n        this._host = _host;\n        this._logService = _logService;\n        this._barrier = ( new Barrier());\n        this._isDisposed = false;\n        this._initialize();\n    }\n    dispose() {\n        this._isDisposed = true;\n    }\n    wait() {\n        return this._barrier.wait();\n    }\n    async _initialize() {\n        await this._waitForDepsThenActivate();\n        this._barrier.open();\n    }\n    async _waitForDepsThenActivate() {\n        if (this._value) {\n            return;\n        }\n        while (this._deps.length > 0) {\n            for (let i = 0; i < this._deps.length; i++) {\n                const dep = this._deps[i];\n                if (dep.value && !dep.value.activationFailed) {\n                    this._deps.splice(i, 1);\n                    i--;\n                    continue;\n                }\n                if (dep.value && dep.value.activationFailed) {\n                    const error = ( new Error(\n                        `Cannot activate the '${this.friendlyName}' extension because its dependency '${dep.friendlyName}' failed to activate`\n                    ));\n                    error.detail = dep.value.activationFailedError;\n                    this._value = ( new FailedExtension(error));\n                    this._host.onExtensionActivationError(this._id, error, null);\n                    return;\n                }\n            }\n            if (this._deps.length > 0) {\n                await Promise.race(( this._deps.map(dep => dep.wait())));\n            }\n        }\n        await this._activate();\n    }\n    async _activate() {\n        try {\n            this._value = await this._host.actualActivateExtension(this._id, this._reason);\n        }\n        catch (err) {\n            const error = ( new Error());\n            if (err && err.name) {\n                error.name = err.name;\n            }\n            if (err && err.message) {\n                error.message = `Activating extension '${this._id.value}' failed: ${err.message}.`;\n            }\n            else {\n                error.message = `Activating extension '${this._id.value}' failed: ${err}.`;\n            }\n            if (err && err.stack) {\n                error.stack = err.stack;\n            }\n            this._value = ( new FailedExtension(error));\n            if (this._isDisposed && isCancellationError(err)) {\n                return;\n            }\n            this._host.onExtensionActivationError(this._id, error, null);\n            this._logService.error(`Activating extension ${this._id.value} failed due to an error:`);\n            this._logService.error(err);\n        }\n    }\n};\nActivationOperation = ( __decorate([\n    ( __param(6, ILogService))\n], ActivationOperation));\nexport { ActivatedExtension, EmptyExtension, ExtensionActivationTimes, ExtensionActivationTimesBuilder, ExtensionsActivator, HostExtension };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { localize } from '../../../nls.js';\nimport { join, normalize } from '../../../base/common/path.js';\nimport { mark, getMarks } from '../../../base/common/performance.js';\nimport { joinPath, originalFSPath, extUriBiasedIgnorePathCase } from '../../../base/common/resources.js';\nimport { Barrier, timeout, asPromise, IntervalTimer } from '../../../base/common/async.js';\nimport { Disposable, toDisposable, dispose, DisposableStore } from '../../../base/common/lifecycle.js';\nimport { TernarySearchTree } from '../../../base/common/ternarySearchTree.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { ILogService } from '../../../platform/log/common/log.service.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { IExtHostConfiguration } from './extHostConfiguration.js';\nimport { ExtensionsActivator, HostExtension, EmptyExtension, ExtensionActivationTimes, ActivatedExtension, ExtensionActivationTimesBuilder } from './extHostExtensionActivator.js';\nimport { ExtHostStorage, IExtHostStorage } from './extHostStorage.js';\nimport { IExtHostWorkspace } from './extHostWorkspace.js';\nimport { isProposedApiEnabled, checkProposedApiEnabled } from '../../services/extensions/common/extensions.js';\nimport { ExtensionDescriptionRegistry } from '../../services/extensions/common/extensionDescriptionRegistry.js';\nimport { transformErrorForSerialization, onUnexpectedError, setUnexpectedErrorHandler } from '../../../base/common/errors.js';\nimport { ExtensionIdentifier, ExtensionIdentifierMap, ExtensionIdentifierSet } from '../../../platform/extensions/common/extensions.js';\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport { ExtensionGlobalMemento, ExtensionMemento } from './extHostMemento.js';\nimport { RemoteAuthorityResolverError, ManagedResolvedAuthority, ExtensionMode, ExtensionKind } from './extHostTypes.js';\nimport { RemoteAuthorityResolverErrorCode, getRemoteAuthorityPrefix, ManagedRemoteConnection, WebSocketRemoteConnection } from '../../../platform/remote/common/remoteAuthorityResolver.js';\nimport { createDecorator, IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nimport { IExtHostInitDataService } from './extHostInitDataService.js';\nimport { IExtensionStoragePaths } from './extHostStoragePaths.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\nimport { ServiceCollection } from '../../../platform/instantiation/common/serviceCollection.js';\nimport { IExtHostTunnelService } from './extHostTunnelService.js';\nimport { IExtHostTerminalService } from './extHostTerminalService.js';\nimport { IExtHostLanguageModels } from './extHostLanguageModels.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { checkActivateWorkspaceContainsExtension } from '../../services/extensions/common/workspaceContains.js';\nimport { ExtHostSecretState, IExtHostSecretState } from './extHostSecretState.js';\nimport { ExtensionSecrets } from './extHostSecrets.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { IExtHostLocalizationService } from './extHostLocalizationService.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { isCI, isWebWorker, setTimeout0 } from '../../../base/common/platform.js';\nimport { IExtHostManagedSockets } from './extHostManagedSockets.js';\nvar AbstractExtHostExtensionService_1;\nconst IHostUtils = ( createDecorator('IHostUtils'));\nlet AbstractExtHostExtensionService = AbstractExtHostExtensionService_1 = class AbstractExtHostExtensionService extends Disposable {\n    constructor(instaService, hostUtils, extHostContext, extHostWorkspace, extHostConfiguration, logService, initData, storagePath, extHostTunnelService, extHostTerminalService, extHostLocalizationService, _extHostManagedSockets, _extHostLanguageModels) {\n        super();\n        this._extHostManagedSockets = _extHostManagedSockets;\n        this._extHostLanguageModels = _extHostLanguageModels;\n        this._onDidChangeRemoteConnectionData = this._register(( new Emitter()));\n        this.onDidChangeRemoteConnectionData = this._onDidChangeRemoteConnectionData.event;\n        this._realPathCache = ( new Map());\n        this._isTerminating = false;\n        this._hostUtils = hostUtils;\n        this._extHostContext = extHostContext;\n        this._initData = initData;\n        this._extHostWorkspace = extHostWorkspace;\n        this._extHostConfiguration = extHostConfiguration;\n        this._logService = logService;\n        this._extHostTunnelService = extHostTunnelService;\n        this._extHostTerminalService = extHostTerminalService;\n        this._extHostLocalizationService = extHostLocalizationService;\n        this._mainThreadWorkspaceProxy = ( this._extHostContext.getProxy(MainContext.MainThreadWorkspace));\n        this._mainThreadTelemetryProxy = ( this._extHostContext.getProxy(MainContext.MainThreadTelemetry));\n        this._mainThreadExtensionsProxy = ( this._extHostContext.getProxy(MainContext.MainThreadExtensionService));\n        this._almostReadyToRunExtensions = ( new Barrier());\n        this._readyToStartExtensionHost = ( new Barrier());\n        this._readyToRunExtensions = ( new Barrier());\n        this._eagerExtensionsActivated = ( new Barrier());\n        this._activationEventsReader = ( new SyncedActivationEventsReader(this._initData.extensions.activationEvents));\n        this._globalRegistry = ( new ExtensionDescriptionRegistry(this._activationEventsReader, this._initData.extensions.allExtensions));\n        const myExtensionsSet = ( new ExtensionIdentifierSet(this._initData.extensions.myExtensions));\n        this._myRegistry = ( new ExtensionDescriptionRegistry(\n            this._activationEventsReader,\n            filterExtensions(this._globalRegistry, myExtensionsSet)\n        ));\n        if (isCI) {\n            this._logService.info(`Creating extension host with the following global extensions: ${printExtIds(this._globalRegistry)}`);\n            this._logService.info(`Creating extension host with the following local extensions: ${printExtIds(this._myRegistry)}`);\n        }\n        this._storage = ( new ExtHostStorage(this._extHostContext, this._logService));\n        this._secretState = ( new ExtHostSecretState(this._extHostContext));\n        this._storagePath = storagePath;\n        this._instaService = this._store.add(instaService.createChild(( new ServiceCollection([IExtHostStorage, this._storage], [IExtHostSecretState, this._secretState]))));\n        this._activator = this._register(( new ExtensionsActivator(this._myRegistry, this._globalRegistry, {\n            onExtensionActivationError: (extensionId, error, missingExtensionDependency) => {\n                this._mainThreadExtensionsProxy.$onExtensionActivationError(extensionId, transformErrorForSerialization(error), missingExtensionDependency);\n            },\n            actualActivateExtension: async (extensionId, reason) => {\n                if (ExtensionDescriptionRegistry.isHostExtension(extensionId, this._myRegistry, this._globalRegistry)) {\n                    await this._mainThreadExtensionsProxy.$activateExtension(extensionId, reason);\n                    return ( new HostExtension());\n                }\n                const extensionDescription = this._myRegistry.getExtensionDescription(extensionId);\n                return this._activateExtension(extensionDescription, reason);\n            }\n        }, this._logService)));\n        this._extensionPathIndex = null;\n        this._resolvers = Object.create(null);\n        this._started = false;\n        this._remoteConnectionData = this._initData.remote.connectionData;\n    }\n    getRemoteConnectionData() {\n        return this._remoteConnectionData;\n    }\n    async initialize() {\n        try {\n            await this._beforeAlmostReadyToRunExtensions();\n            this._almostReadyToRunExtensions.open();\n            await this._extHostWorkspace.waitForInitializeCall();\n            mark('code/extHost/ready');\n            this._readyToStartExtensionHost.open();\n            if (this._initData.autoStart) {\n                this._startExtensionHost();\n            }\n        }\n        catch (err) {\n            onUnexpectedError(err);\n        }\n    }\n    async _deactivateAll() {\n        this._storagePath.onWillDeactivateAll();\n        let allPromises = [];\n        try {\n            const allExtensions = this._myRegistry.getAllExtensionDescriptions();\n            const allExtensionsIds = ( allExtensions.map(ext => ext.identifier));\n            const activatedExtensions = allExtensionsIds.filter(id => this.isActivated(id));\n            allPromises = ( activatedExtensions.map((extensionId) => {\n                return this._deactivate(extensionId);\n            }));\n        }\n        catch (err) {\n        }\n        await Promise.all(allPromises);\n    }\n    terminate(reason, code = 0) {\n        if (this._isTerminating) {\n            return;\n        }\n        this._isTerminating = true;\n        this._logService.info(`Extension host terminating: ${reason}`);\n        this._logService.flush();\n        this._extHostTerminalService.dispose();\n        this._activator.dispose();\n        if (isWebWorker) {\n            setUnexpectedErrorHandler((err) => {\n                this._logService.error(err);\n            });\n        }\n        this._extHostContext.dispose();\n        const extensionsDeactivated = this._deactivateAll();\n        Promise.race([timeout(5000), extensionsDeactivated]).finally(() => {\n            if (this._hostUtils.pid) {\n                this._logService.info(`Extension host with pid ${this._hostUtils.pid} exiting with code ${code}`);\n            }\n            else {\n                this._logService.info(`Extension host exiting with code ${code}`);\n            }\n            this._logService.flush();\n            this._logService.dispose();\n            this._hostUtils.exit(code);\n        });\n    }\n    isActivated(extensionId) {\n        if (this._readyToRunExtensions.isOpen()) {\n            return this._activator.isActivated(extensionId);\n        }\n        return false;\n    }\n    async getExtension(extensionId) {\n        const ext = await this._mainThreadExtensionsProxy.$getExtension(extensionId);\n        return ext && {\n            ...ext,\n            identifier: ( new ExtensionIdentifier(ext.identifier.value)),\n            extensionLocation: URI.revive(ext.extensionLocation)\n        };\n    }\n    _activateByEvent(activationEvent, startup) {\n        return this._activator.activateByEvent(activationEvent, startup);\n    }\n    _activateById(extensionId, reason) {\n        return this._activator.activateById(extensionId, reason);\n    }\n    activateByIdWithErrors(extensionId, reason) {\n        return this._activateById(extensionId, reason).then(() => {\n            const extension = this._activator.getActivatedExtension(extensionId);\n            if (extension.activationFailed) {\n                return Promise.reject(extension.activationFailedError);\n            }\n            return undefined;\n        });\n    }\n    getExtensionRegistry() {\n        return this._readyToRunExtensions.wait().then(_ => this._myRegistry);\n    }\n    getExtensionExports(extensionId) {\n        if (this._readyToRunExtensions.isOpen()) {\n            return this._activator.getActivatedExtension(extensionId).exports;\n        }\n        else {\n            try {\n                return this._activator.getActivatedExtension(extensionId).exports;\n            }\n            catch (err) {\n                return null;\n            }\n        }\n    }\n    async _realPathExtensionUri(uri) {\n        if (uri.scheme === Schemas.file && this._hostUtils.fsRealpath) {\n            const fsPath = uri.fsPath;\n            if (!( this._realPathCache.has(fsPath))) {\n                this._realPathCache.set(fsPath, this._hostUtils.fsRealpath(fsPath));\n            }\n            const realpathValue = await this._realPathCache.get(fsPath);\n            return URI.file(realpathValue);\n        }\n        return uri;\n    }\n    async getExtensionPathIndex() {\n        if (!this._extensionPathIndex) {\n            this._extensionPathIndex = this._createExtensionPathIndex(this._myRegistry.getAllExtensionDescriptions()).then((searchTree) => {\n                return ( new ExtensionPaths(searchTree));\n            });\n        }\n        return this._extensionPathIndex;\n    }\n    async _createExtensionPathIndex(extensions) {\n        const tst = TernarySearchTree.forUris(key => {\n            return extUriBiasedIgnorePathCase.ignorePathCasing(key);\n        });\n        await Promise.all(( extensions.map(async (ext) => {\n            if (this._getEntryPoint(ext)) {\n                const uri = await this._realPathExtensionUri(ext.extensionLocation);\n                tst.set(uri, ext);\n            }\n        })));\n        return tst;\n    }\n    _deactivate(extensionId) {\n        let result = Promise.resolve(undefined);\n        if (!this._readyToRunExtensions.isOpen()) {\n            return result;\n        }\n        if (!this._activator.isActivated(extensionId)) {\n            return result;\n        }\n        const extension = this._activator.getActivatedExtension(extensionId);\n        if (!extension) {\n            return result;\n        }\n        try {\n            if (typeof extension.module.deactivate === 'function') {\n                result = Promise.resolve(extension.module.deactivate()).then(undefined, (err) => {\n                    this._logService.error(err);\n                    return Promise.resolve(undefined);\n                });\n            }\n        }\n        catch (err) {\n            this._logService.error(`An error occurred when deactivating the extension '${extensionId.value}':`);\n            this._logService.error(err);\n        }\n        try {\n            extension.disposable.dispose();\n        }\n        catch (err) {\n            this._logService.error(`An error occurred when disposing the subscriptions for extension '${extensionId.value}':`);\n            this._logService.error(err);\n        }\n        return result;\n    }\n    async _activateExtension(extensionDescription, reason) {\n        if (!this._initData.remote.isRemote) {\n            await this._mainThreadExtensionsProxy.$onWillActivateExtension(extensionDescription.identifier);\n        }\n        else {\n            this._mainThreadExtensionsProxy.$onWillActivateExtension(extensionDescription.identifier);\n        }\n        return this._doActivateExtension(extensionDescription, reason).then((activatedExtension) => {\n            const activationTimes = activatedExtension.activationTimes;\n            this._mainThreadExtensionsProxy.$onDidActivateExtension(extensionDescription.identifier, activationTimes.codeLoadingTime, activationTimes.activateCallTime, activationTimes.activateResolvedTime, reason);\n            this._logExtensionActivationTimes(extensionDescription, reason, 'success', activationTimes);\n            return activatedExtension;\n        }, (err) => {\n            this._logExtensionActivationTimes(extensionDescription, reason, 'failure');\n            throw err;\n        });\n    }\n    _logExtensionActivationTimes(extensionDescription, reason, outcome, activationTimes) {\n        const event = getTelemetryActivationEvent(extensionDescription, reason);\n        this._mainThreadTelemetryProxy.$publicLog2('extensionActivationTimes', {\n            ...event,\n            ...(activationTimes || {}),\n            outcome\n        });\n    }\n    _doActivateExtension(extensionDescription, reason) {\n        const event = getTelemetryActivationEvent(extensionDescription, reason);\n        this._mainThreadTelemetryProxy.$publicLog2('activatePlugin', event);\n        const entryPoint = this._getEntryPoint(extensionDescription);\n        if (!entryPoint) {\n            return Promise.resolve(( new EmptyExtension(ExtensionActivationTimes.NONE)));\n        }\n        this._logService.info(`ExtensionService#_doActivateExtension ${extensionDescription.identifier.value}, startup: ${reason.startup}, activationEvent: '${reason.activationEvent}'${extensionDescription.identifier.value !== reason.extensionId.value ? `, root cause: ${reason.extensionId.value}` : ``}`);\n        this._logService.flush();\n        const extensionInternalStore = ( new DisposableStore());\n        const activationTimesBuilder = ( new ExtensionActivationTimesBuilder(reason.startup));\n        return Promise.all([\n            this._loadCommonJSModule(extensionDescription, joinPath(extensionDescription.extensionLocation, entryPoint), activationTimesBuilder),\n            this._loadExtensionContext(extensionDescription, extensionInternalStore)\n        ]).then(values => {\n            mark(`code/extHost/willActivateExtension/${extensionDescription.identifier.value}`);\n            return AbstractExtHostExtensionService_1._callActivate(this._logService, extensionDescription.identifier, values[0], values[1], extensionInternalStore, activationTimesBuilder);\n        }).then((activatedExtension) => {\n            mark(`code/extHost/didActivateExtension/${extensionDescription.identifier.value}`);\n            return activatedExtension;\n        });\n    }\n    _loadExtensionContext(extensionDescription, extensionInternalStore) {\n        const languageModelAccessInformation = this._extHostLanguageModels.createLanguageModelAccessInformation(extensionDescription);\n        const globalState = extensionInternalStore.add(( new ExtensionGlobalMemento(extensionDescription, this._storage)));\n        const workspaceState = extensionInternalStore.add(( new ExtensionMemento(extensionDescription.identifier.value, false, this._storage)));\n        const secrets = extensionInternalStore.add(( new ExtensionSecrets(extensionDescription, this._secretState)));\n        const extensionMode = extensionDescription.isUnderDevelopment\n            ? (this._initData.environment.extensionTestsLocationURI ? ExtensionMode.Test : ExtensionMode.Development)\n            : ExtensionMode.Production;\n        const extensionKind = this._initData.remote.isRemote ? ExtensionKind.Workspace : ExtensionKind.UI;\n        this._logService.trace(`ExtensionService#loadExtensionContext ${extensionDescription.identifier.value}`);\n        return Promise.all([\n            globalState.whenReady,\n            workspaceState.whenReady,\n            this._storagePath.whenReady\n        ]).then(() => {\n            const that = this;\n            let extension;\n            let messagePassingProtocol;\n            const messagePort = isProposedApiEnabled(extensionDescription, 'ipc')\n                ? this._initData.messagePorts?.get(ExtensionIdentifier.toKey(extensionDescription.identifier))\n                : undefined;\n            return ( Object.freeze({\n                globalState,\n                workspaceState,\n                secrets,\n                subscriptions: [],\n                get languageModelAccessInformation() { return languageModelAccessInformation; },\n                get extensionUri() { return extensionDescription.extensionLocation; },\n                get extensionPath() { return extensionDescription.extensionLocation.fsPath; },\n                asAbsolutePath(relativePath) { return join(extensionDescription.extensionLocation.fsPath, relativePath); },\n                get storagePath() { return that._storagePath.workspaceValue(extensionDescription)?.fsPath; },\n                get globalStoragePath() { return that._storagePath.globalValue(extensionDescription).fsPath; },\n                get logPath() { return join(that._initData.logsLocation.fsPath, extensionDescription.identifier.value); },\n                get logUri() { return URI.joinPath(that._initData.logsLocation, extensionDescription.identifier.value); },\n                get storageUri() { return that._storagePath.workspaceValue(extensionDescription); },\n                get globalStorageUri() { return that._storagePath.globalValue(extensionDescription); },\n                get extensionMode() { return extensionMode; },\n                get extension() {\n                    if (extension === undefined) {\n                        extension = ( new Extension(\n                            that,\n                            extensionDescription.identifier,\n                            extensionDescription,\n                            extensionKind,\n                            false\n                        ));\n                    }\n                    return extension;\n                },\n                get extensionRuntime() {\n                    checkProposedApiEnabled(extensionDescription, 'extensionRuntime');\n                    return that.extensionRuntime;\n                },\n                get environmentVariableCollection() { return that._extHostTerminalService.getEnvironmentVariableCollection(extensionDescription); },\n                get messagePassingProtocol() {\n                    if (!messagePassingProtocol) {\n                        if (!messagePort) {\n                            return undefined;\n                        }\n                        const onDidReceiveMessage = Event.buffer(Event.fromDOMEventEmitter(messagePort, 'message', e => e.data));\n                        messagePort.start();\n                        messagePassingProtocol = {\n                            onDidReceiveMessage,\n                            postMessage: messagePort.postMessage.bind(messagePort)\n                        };\n                    }\n                    return messagePassingProtocol;\n                }\n            }));\n        });\n    }\n    static _callActivate(logService, extensionId, extensionModule, context, extensionInternalStore, activationTimesBuilder) {\n        extensionModule = extensionModule || {\n            activate: undefined,\n            deactivate: undefined\n        };\n        return this._callActivateOptional(logService, extensionId, extensionModule, context, activationTimesBuilder).then((extensionExports) => {\n            return ( new ActivatedExtension(\n                false,\n                null,\n                activationTimesBuilder.build(),\n                extensionModule,\n                extensionExports,\n                toDisposable(() => {\n                    extensionInternalStore.dispose();\n                    dispose(context.subscriptions);\n                })\n            ));\n        });\n    }\n    static _callActivateOptional(logService, extensionId, extensionModule, context, activationTimesBuilder) {\n        if (typeof extensionModule.activate === 'function') {\n            try {\n                activationTimesBuilder.activateCallStart();\n                logService.trace(`ExtensionService#_callActivateOptional ${extensionId.value}`);\n                const scope = typeof global === 'object' ? global : self;\n                const activateResult = extensionModule.activate.apply(scope, [context]);\n                activationTimesBuilder.activateCallStop();\n                activationTimesBuilder.activateResolveStart();\n                return Promise.resolve(activateResult).then((value) => {\n                    activationTimesBuilder.activateResolveStop();\n                    return value;\n                });\n            }\n            catch (err) {\n                return Promise.reject(err);\n            }\n        }\n        else {\n            return Promise.resolve(extensionModule);\n        }\n    }\n    _activateOneStartupFinished(desc, activationEvent) {\n        this._activateById(desc.identifier, {\n            startup: false,\n            extensionId: desc.identifier,\n            activationEvent: activationEvent\n        }).then(undefined, (err) => {\n            this._logService.error(err);\n        });\n    }\n    _activateAllStartupFinishedDeferred(extensions, start = 0) {\n        const timeBudget = 50;\n        const startTime = Date.now();\n        setTimeout0(() => {\n            for (let i = start; i < extensions.length; i += 1) {\n                const desc = extensions[i];\n                for (const activationEvent of (desc.activationEvents ?? [])) {\n                    if (activationEvent === 'onStartupFinished') {\n                        if (Date.now() - startTime > timeBudget) {\n                            this._activateAllStartupFinishedDeferred(extensions, i);\n                            break;\n                        }\n                        else {\n                            this._activateOneStartupFinished(desc, activationEvent);\n                        }\n                    }\n                }\n            }\n        });\n    }\n    _activateAllStartupFinished() {\n        this._mainThreadExtensionsProxy.$setPerformanceMarks(getMarks());\n        this._extHostConfiguration.getConfigProvider().then((configProvider) => {\n            const shouldDeferActivation = configProvider.getConfiguration('extensions.experimental').get('deferredStartupFinishedActivation');\n            const allExtensionDescriptions = this._myRegistry.getAllExtensionDescriptions();\n            if (shouldDeferActivation) {\n                this._activateAllStartupFinishedDeferred(allExtensionDescriptions);\n            }\n            else {\n                for (const desc of allExtensionDescriptions) {\n                    if (desc.activationEvents) {\n                        for (const activationEvent of desc.activationEvents) {\n                            if (activationEvent === 'onStartupFinished') {\n                                this._activateOneStartupFinished(desc, activationEvent);\n                            }\n                        }\n                    }\n                }\n            }\n        });\n    }\n    _handleEagerExtensions() {\n        const starActivation = this._activateByEvent('*', true).then(undefined, (err) => {\n            this._logService.error(err);\n        });\n        this._register(this._extHostWorkspace.onDidChangeWorkspace((e) => this._handleWorkspaceContainsEagerExtensions(e.added)));\n        const folders = this._extHostWorkspace.workspace ? this._extHostWorkspace.workspace.folders : [];\n        const workspaceContainsActivation = this._handleWorkspaceContainsEagerExtensions(folders);\n        const remoteResolverActivation = this._handleRemoteResolverEagerExtensions();\n        const eagerExtensionsActivation = Promise.all([remoteResolverActivation, starActivation, workspaceContainsActivation]).then(() => { });\n        Promise.race([eagerExtensionsActivation, timeout(10000)]).then(() => {\n            this._activateAllStartupFinished();\n        });\n        return eagerExtensionsActivation;\n    }\n    _handleWorkspaceContainsEagerExtensions(folders) {\n        if (folders.length === 0) {\n            return Promise.resolve(undefined);\n        }\n        return Promise.all(( this._myRegistry.getAllExtensionDescriptions().map((desc) => {\n            return this._handleWorkspaceContainsEagerExtension(folders, desc);\n        }))).then(() => { });\n    }\n    async _handleWorkspaceContainsEagerExtension(folders, desc) {\n        if (this.isActivated(desc.identifier)) {\n            return;\n        }\n        const localWithRemote = !this._initData.remote.isRemote && !!this._initData.remote.authority;\n        const host = {\n            logService: this._logService,\n            folders: ( folders.map(folder => folder.uri)),\n            forceUsingSearch: localWithRemote || !this._hostUtils.fsExists,\n            exists: (uri) => this._hostUtils.fsExists(uri.fsPath),\n            checkExists: (folders, includes, token) => this._mainThreadWorkspaceProxy.$checkExists(folders, includes, token)\n        };\n        const result = await checkActivateWorkspaceContainsExtension(host, desc);\n        if (!result) {\n            return;\n        }\n        return (this._activateById(desc.identifier, { startup: true, extensionId: desc.identifier, activationEvent: result.activationEvent })\n            .then(undefined, err => this._logService.error(err)));\n    }\n    async _handleRemoteResolverEagerExtensions() {\n        if (this._initData.remote.authority) {\n            return this._activateByEvent(`onResolveRemoteAuthority:${this._initData.remote.authority}`, false);\n        }\n    }\n    async $extensionTestsExecute() {\n        await this._eagerExtensionsActivated.wait();\n        try {\n            return await this._doHandleExtensionTests();\n        }\n        catch (error) {\n            console.error(error);\n            throw error;\n        }\n    }\n    async _doHandleExtensionTests() {\n        const { extensionDevelopmentLocationURI, extensionTestsLocationURI } = this._initData.environment;\n        if (!extensionDevelopmentLocationURI || !extensionTestsLocationURI) {\n            throw ( new Error(localize(445, \"Cannot load test runner.\")));\n        }\n        const testRunner = await this._loadCommonJSModule(null, extensionTestsLocationURI, ( new ExtensionActivationTimesBuilder(false)));\n        if (!testRunner || typeof testRunner.run !== 'function') {\n            throw ( new Error(localize(\n                446,\n                \"Path {0} does not point to a valid extension test runner.\",\n                ( extensionTestsLocationURI.toString())\n            )));\n        }\n        return ( new Promise((resolve, reject) => {\n            const oldTestRunnerCallback = (error, failures) => {\n                if (error) {\n                    if (isCI) {\n                        this._logService.error(`Test runner called back with error`, error);\n                    }\n                    reject(error);\n                }\n                else {\n                    if (isCI) {\n                        if (failures) {\n                            this._logService.info(`Test runner called back with ${failures} failures.`);\n                        }\n                        else {\n                            this._logService.info(`Test runner called back with successful outcome.`);\n                        }\n                    }\n                    resolve((typeof failures === 'number' && failures > 0) ? 1  : 0 );\n                }\n            };\n            const extensionTestsPath = originalFSPath(extensionTestsLocationURI);\n            const runResult = testRunner.run(extensionTestsPath, oldTestRunnerCallback);\n            if (runResult && runResult.then) {\n                runResult\n                    .then(() => {\n                    if (isCI) {\n                        this._logService.info(`Test runner finished successfully.`);\n                    }\n                    resolve(0);\n                })\n                    .catch((err) => {\n                    if (isCI) {\n                        this._logService.error(`Test runner finished with error`, err);\n                    }\n                    reject(err instanceof Error && err.stack ? err.stack : String(err));\n                });\n            }\n        }));\n    }\n    _startExtensionHost() {\n        if (this._started) {\n            throw ( new Error(`Extension host is already started!`));\n        }\n        this._started = true;\n        return this._readyToStartExtensionHost.wait()\n            .then(() => this._readyToRunExtensions.open())\n            .then(() => {\n            return Promise.race([this._activator.waitForActivatingExtensions(), timeout(1000)]);\n        })\n            .then(() => this._handleEagerExtensions())\n            .then(() => {\n            this._eagerExtensionsActivated.open();\n            this._logService.info(`Eager extensions activated`);\n        });\n    }\n    registerRemoteAuthorityResolver(authorityPrefix, resolver) {\n        this._resolvers[authorityPrefix] = resolver;\n        return toDisposable(() => {\n            delete this._resolvers[authorityPrefix];\n        });\n    }\n    async getRemoteExecServer(remoteAuthority) {\n        const { resolver } = await this._activateAndGetResolver(remoteAuthority);\n        return resolver?.resolveExecServer?.(remoteAuthority, { resolveAttempt: 0 });\n    }\n    async _activateAndGetResolver(remoteAuthority) {\n        const authorityPlusIndex = remoteAuthority.indexOf('+');\n        if (authorityPlusIndex === -1) {\n            throw ( new RemoteAuthorityResolverError(\n                `Not an authority that can be resolved!`,\n                RemoteAuthorityResolverErrorCode.InvalidAuthority\n            ));\n        }\n        const authorityPrefix = remoteAuthority.substr(0, authorityPlusIndex);\n        await this._almostReadyToRunExtensions.wait();\n        await this._activateByEvent(`onResolveRemoteAuthority:${authorityPrefix}`, false);\n        return { authorityPrefix, resolver: this._resolvers[authorityPrefix] };\n    }\n    async $resolveAuthority(remoteAuthorityChain, resolveAttempt) {\n        const sw = StopWatch.create(false);\n        const prefix = () => `[resolveAuthority(${getRemoteAuthorityPrefix(remoteAuthorityChain)},${resolveAttempt})][${sw.elapsed()}ms] `;\n        const logInfo = (msg) => this._logService.info(`${prefix()}${msg}`);\n        const logWarning = (msg) => this._logService.warn(`${prefix()}${msg}`);\n        const logError = (msg, err = undefined) => this._logService.error(`${prefix()}${msg}`, err);\n        const normalizeError = (err) => {\n            if (err instanceof RemoteAuthorityResolverError) {\n                return {\n                    type: 'error',\n                    error: {\n                        code: err._code,\n                        message: err._message,\n                        detail: err._detail\n                    }\n                };\n            }\n            throw err;\n        };\n        const getResolver = async (remoteAuthority) => {\n            logInfo(`activating resolver for ${remoteAuthority}...`);\n            const { resolver, authorityPrefix } = await this._activateAndGetResolver(remoteAuthority);\n            if (!resolver) {\n                logError(`no resolver for ${authorityPrefix}`);\n                throw ( new RemoteAuthorityResolverError(\n                    `No remote extension installed to resolve ${authorityPrefix}.`,\n                    RemoteAuthorityResolverErrorCode.NoResolverFound\n                ));\n            }\n            return { resolver, authorityPrefix, remoteAuthority };\n        };\n        const chain = remoteAuthorityChain.split(/@|%40/g).reverse();\n        logInfo(`activating remote resolvers ${chain.join(' -> ')}`);\n        let resolvers;\n        try {\n            resolvers = await Promise.all(( chain.map(getResolver))).catch(async (e) => {\n                if (!(e instanceof RemoteAuthorityResolverError) || e._code !== RemoteAuthorityResolverErrorCode.InvalidAuthority) {\n                    throw e;\n                }\n                logWarning(`resolving nested authorities failed: ${e.message}`);\n                return [await getResolver(remoteAuthorityChain)];\n            });\n        }\n        catch (e) {\n            return normalizeError(e);\n        }\n        const intervalLogger = ( new IntervalTimer());\n        intervalLogger.cancelAndSet(() => logInfo('waiting...'), 1000);\n        let result;\n        let execServer;\n        for (const [i, { authorityPrefix, resolver, remoteAuthority }] of resolvers.entries()) {\n            try {\n                if (i === resolvers.length - 1) {\n                    logInfo(`invoking final resolve()...`);\n                    mark(`code/extHost/willResolveAuthority/${authorityPrefix}`);\n                    result = await resolver.resolve(remoteAuthority, { resolveAttempt, execServer });\n                    mark(`code/extHost/didResolveAuthorityOK/${authorityPrefix}`);\n                    logInfo(`setting tunnel factory...`);\n                    this._register(await this._extHostTunnelService.setTunnelFactory(resolver, ManagedResolvedAuthority.isManagedResolvedAuthority(result) ? result : undefined));\n                }\n                else {\n                    logInfo(`invoking resolveExecServer() for ${remoteAuthority}`);\n                    mark(`code/extHost/willResolveExecServer/${authorityPrefix}`);\n                    execServer = await resolver.resolveExecServer?.(remoteAuthority, { resolveAttempt, execServer });\n                    if (!execServer) {\n                        throw ( new RemoteAuthorityResolverError(\n                            `Exec server was not available for ${remoteAuthority}`,\n                            RemoteAuthorityResolverErrorCode.NoResolverFound\n                        ));\n                    }\n                    mark(`code/extHost/didResolveExecServerOK/${authorityPrefix}`);\n                }\n            }\n            catch (e) {\n                mark(`code/extHost/didResolveAuthorityError/${authorityPrefix}`);\n                logError(`returned an error`, e);\n                intervalLogger.dispose();\n                return normalizeError(e);\n            }\n        }\n        intervalLogger.dispose();\n        const tunnelInformation = {\n            environmentTunnels: result.environmentTunnels,\n            features: result.tunnelFeatures ? {\n                elevation: result.tunnelFeatures.elevation,\n                privacyOptions: result.tunnelFeatures.privacyOptions,\n                protocol: result.tunnelFeatures.protocol === undefined ? true : result.tunnelFeatures.protocol,\n            } : undefined\n        };\n        const options = {\n            extensionHostEnv: result.extensionHostEnv,\n            isTrusted: result.isTrusted,\n            authenticationSession: result.authenticationSessionForInitializingExtensions ? { id: result.authenticationSessionForInitializingExtensions.id, providerId: result.authenticationSessionForInitializingExtensions.providerId } : undefined\n        };\n        logInfo(`returned ${ManagedResolvedAuthority.isManagedResolvedAuthority(result) ? 'managed authority' : `${result.host}:${result.port}`}`);\n        let authority;\n        if (ManagedResolvedAuthority.isManagedResolvedAuthority(result)) {\n            const socketFactoryId = resolveAttempt;\n            this._extHostManagedSockets.setFactory(socketFactoryId, result.makeConnection);\n            authority = {\n                authority: remoteAuthorityChain,\n                connectTo: ( new ManagedRemoteConnection(socketFactoryId)),\n                connectionToken: result.connectionToken\n            };\n        }\n        else {\n            authority = {\n                authority: remoteAuthorityChain,\n                connectTo: ( new WebSocketRemoteConnection(result.host, result.port)),\n                connectionToken: result.connectionToken\n            };\n        }\n        return {\n            type: 'ok',\n            value: {\n                authority: authority,\n                options,\n                tunnelInformation,\n            }\n        };\n    }\n    async $getCanonicalURI(remoteAuthority, uriComponents) {\n        this._logService.info(`$getCanonicalURI invoked for authority (${getRemoteAuthorityPrefix(remoteAuthority)})`);\n        const { resolver } = await this._activateAndGetResolver(remoteAuthority);\n        if (!resolver) {\n            return null;\n        }\n        const uri = URI.revive(uriComponents);\n        if (typeof resolver.getCanonicalURI === 'undefined') {\n            return uri;\n        }\n        const result = await asPromise(() => resolver.getCanonicalURI(uri));\n        if (!result) {\n            return uri;\n        }\n        return result;\n    }\n    async $startExtensionHost(extensionsDelta) {\n        extensionsDelta.toAdd.forEach((extension) => extension.extensionLocation = URI.revive(extension.extensionLocation));\n        const { globalRegistry, myExtensions } = applyExtensionsDelta(this._activationEventsReader, this._globalRegistry, this._myRegistry, extensionsDelta);\n        const newSearchTree = await this._createExtensionPathIndex(myExtensions);\n        const extensionsPaths = await this.getExtensionPathIndex();\n        extensionsPaths.setSearchTree(newSearchTree);\n        this._globalRegistry.set(globalRegistry.getAllExtensionDescriptions());\n        this._myRegistry.set(myExtensions);\n        if (isCI) {\n            this._logService.info(`$startExtensionHost: global extensions: ${printExtIds(this._globalRegistry)}`);\n            this._logService.info(`$startExtensionHost: local extensions: ${printExtIds(this._myRegistry)}`);\n        }\n        return this._startExtensionHost();\n    }\n    $activateByEvent(activationEvent, activationKind) {\n        if (activationKind === 1 ) {\n            return this._almostReadyToRunExtensions.wait()\n                .then(_ => this._activateByEvent(activationEvent, false));\n        }\n        return (this._readyToRunExtensions.wait()\n            .then(_ => this._activateByEvent(activationEvent, false)));\n    }\n    async $activate(extensionId, reason) {\n        await this._readyToRunExtensions.wait();\n        if (!this._myRegistry.getExtensionDescription(extensionId)) {\n            return false;\n        }\n        await this._activateById(extensionId, reason);\n        return true;\n    }\n    async $deltaExtensions(extensionsDelta) {\n        extensionsDelta.toAdd.forEach((extension) => extension.extensionLocation = URI.revive(extension.extensionLocation));\n        const { globalRegistry, myExtensions } = applyExtensionsDelta(this._activationEventsReader, this._globalRegistry, this._myRegistry, extensionsDelta);\n        const newSearchTree = await this._createExtensionPathIndex(myExtensions);\n        const extensionsPaths = await this.getExtensionPathIndex();\n        extensionsPaths.setSearchTree(newSearchTree);\n        this._globalRegistry.set(globalRegistry.getAllExtensionDescriptions());\n        this._myRegistry.set(myExtensions);\n        if (isCI) {\n            this._logService.info(`$deltaExtensions: global extensions: ${printExtIds(this._globalRegistry)}`);\n            this._logService.info(`$deltaExtensions: local extensions: ${printExtIds(this._myRegistry)}`);\n        }\n        return Promise.resolve(undefined);\n    }\n    async $test_latency(n) {\n        return n;\n    }\n    async $test_up(b) {\n        return b.byteLength;\n    }\n    async $test_down(size) {\n        const buff = VSBuffer.alloc(size);\n        const value = Math.random() % 256;\n        for (let i = 0; i < size; i++) {\n            buff.writeUInt8(value, i);\n        }\n        return buff;\n    }\n    async $updateRemoteConnectionData(connectionData) {\n        this._remoteConnectionData = connectionData;\n        this._onDidChangeRemoteConnectionData.fire();\n    }\n};\nAbstractExtHostExtensionService = AbstractExtHostExtensionService_1 = ( __decorate([\n    ( __param(0, IInstantiationService)),\n    ( __param(1, IHostUtils)),\n    ( __param(2, IExtHostRpcService)),\n    ( __param(3, IExtHostWorkspace)),\n    ( __param(4, IExtHostConfiguration)),\n    ( __param(5, ILogService)),\n    ( __param(6, IExtHostInitDataService)),\n    ( __param(7, IExtensionStoragePaths)),\n    ( __param(8, IExtHostTunnelService)),\n    ( __param(9, IExtHostTerminalService)),\n    ( __param(10, IExtHostLocalizationService)),\n    ( __param(11, IExtHostManagedSockets)),\n    ( __param(12, IExtHostLanguageModels))\n], AbstractExtHostExtensionService));\nfunction applyExtensionsDelta(activationEventsReader, oldGlobalRegistry, oldMyRegistry, extensionsDelta) {\n    activationEventsReader.addActivationEvents(extensionsDelta.addActivationEvents);\n    const globalRegistry = ( new ExtensionDescriptionRegistry(activationEventsReader, oldGlobalRegistry.getAllExtensionDescriptions()));\n    globalRegistry.deltaExtensions(extensionsDelta.toAdd, extensionsDelta.toRemove);\n    const myExtensionsSet = ( new ExtensionIdentifierSet(( oldMyRegistry.getAllExtensionDescriptions().map(extension => extension.identifier))));\n    for (const extensionId of extensionsDelta.myToRemove) {\n        myExtensionsSet.delete(extensionId);\n    }\n    for (const extensionId of extensionsDelta.myToAdd) {\n        myExtensionsSet.add(extensionId);\n    }\n    const myExtensions = filterExtensions(globalRegistry, myExtensionsSet);\n    return { globalRegistry, myExtensions };\n}\nfunction getTelemetryActivationEvent(extensionDescription, reason) {\n    const event = {\n        id: extensionDescription.identifier.value,\n        name: extensionDescription.name,\n        extensionVersion: extensionDescription.version,\n        publisherDisplayName: extensionDescription.publisher,\n        activationEvents: extensionDescription.activationEvents ? extensionDescription.activationEvents.join(',') : null,\n        isBuiltin: extensionDescription.isBuiltin,\n        reason: reason.activationEvent,\n        reasonId: reason.extensionId.value,\n    };\n    return event;\n}\nfunction printExtIds(registry) {\n    return ( registry.getAllExtensionDescriptions().map(ext => ext.identifier.value)).join(',');\n}\nconst IExtHostExtensionService = ( createDecorator('IExtHostExtensionService'));\nclass Extension {\n    #extensionService;\n    #originExtensionId;\n    #identifier;\n    constructor(extensionService, originExtensionId, description, kind, isFromDifferentExtensionHost) {\n        this.#extensionService = extensionService;\n        this.#originExtensionId = originExtensionId;\n        this.#identifier = description.identifier;\n        this.id = description.identifier.value;\n        this.extensionUri = description.extensionLocation;\n        this.extensionPath = normalize(originalFSPath(description.extensionLocation));\n        this.packageJSON = description;\n        this.extensionKind = kind;\n        this.isFromDifferentExtensionHost = isFromDifferentExtensionHost;\n    }\n    get isActive() {\n        return this.#extensionService.isActivated(this.#identifier);\n    }\n    get exports() {\n        if (this.packageJSON.api === 'none' || this.isFromDifferentExtensionHost) {\n            return undefined;\n        }\n        return this.#extensionService.getExtensionExports(this.#identifier);\n    }\n    async activate() {\n        if (this.isFromDifferentExtensionHost) {\n            throw ( new Error('Cannot activate foreign extension'));\n        }\n        await this.#extensionService.activateByIdWithErrors(this.#identifier, { startup: false, extensionId: this.#originExtensionId, activationEvent: 'api' });\n        return this.exports;\n    }\n}\nfunction filterExtensions(globalRegistry, desiredExtensions) {\n    return globalRegistry.getAllExtensionDescriptions().filter(extension => ( desiredExtensions.has(extension.identifier)));\n}\nclass ExtensionPaths {\n    constructor(_searchTree) {\n        this._searchTree = _searchTree;\n    }\n    setSearchTree(searchTree) {\n        this._searchTree = searchTree;\n    }\n    findSubstr(key) {\n        return this._searchTree.findSubstr(key);\n    }\n    forEach(callback) {\n        return this._searchTree.forEach(callback);\n    }\n}\nclass SyncedActivationEventsReader {\n    constructor(activationEvents) {\n        this._map = ( new ExtensionIdentifierMap());\n        this.addActivationEvents(activationEvents);\n    }\n    readActivationEvents(extensionDescription) {\n        return this._map.get(extensionDescription.identifier) ?? [];\n    }\n    addActivationEvents(activationEvents) {\n        for (const extensionId of ( Object.keys(activationEvents))) {\n            this._map.set(extensionId, activationEvents[extensionId]);\n        }\n    }\n}\nexport { AbstractExtHostExtensionService, Extension, ExtensionPaths, IExtHostExtensionService, IHostUtils };\n","import { URI } from '../../../base/common/uri.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { toDisposable } from '../../../base/common/lifecycle.js';\nimport { FileChangeType } from './extHostTypes.js';\nimport { DocumentLink } from './extHostTypeConverters.js';\nimport { StateMachine, LinkComputer } from '../../../editor/common/languages/linkComputer.js';\nimport { commonPrefixLength } from '../../../base/common/strings.js';\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport { checkProposedApiEnabled } from '../../services/extensions/common/extensions.js';\nimport { isMarkdownString } from '../../../base/common/htmlContent.js';\nclass FsLinkProvider {\n    constructor() {\n        this._schemes = [];\n    }\n    add(scheme) {\n        this._stateMachine = undefined;\n        this._schemes.push(scheme);\n    }\n    delete(scheme) {\n        const idx = this._schemes.indexOf(scheme);\n        if (idx >= 0) {\n            this._schemes.splice(idx, 1);\n            this._stateMachine = undefined;\n        }\n    }\n    _initStateMachine() {\n        if (!this._stateMachine) {\n            const schemes = this._schemes.sort();\n            const edges = [];\n            let prevScheme;\n            let prevState;\n            let lastState = 14 ;\n            let nextState = 14 ;\n            for (const scheme of schemes) {\n                let pos = !prevScheme ? 0 : commonPrefixLength(prevScheme, scheme);\n                if (pos === 0) {\n                    prevState = 1 ;\n                }\n                else {\n                    prevState = nextState;\n                }\n                for (; pos < scheme.length; pos++) {\n                    if (pos + 1 === scheme.length) {\n                        lastState = nextState;\n                        nextState = 9 ;\n                    }\n                    else {\n                        nextState += 1;\n                    }\n                    edges.push([prevState, scheme.toUpperCase().charCodeAt(pos), nextState]);\n                    edges.push([prevState, scheme.toLowerCase().charCodeAt(pos), nextState]);\n                    prevState = nextState;\n                }\n                prevScheme = scheme;\n                nextState = lastState;\n            }\n            edges.push([9 , 58 , 10 ]);\n            edges.push([10 , 47 , 12 ]);\n            this._stateMachine = ( new StateMachine(edges));\n        }\n    }\n    provideDocumentLinks(document) {\n        this._initStateMachine();\n        const result = [];\n        const links = LinkComputer.computeLinks({\n            getLineContent(lineNumber) {\n                return document.lineAt(lineNumber - 1).text;\n            },\n            getLineCount() {\n                return document.lineCount;\n            }\n        }, this._stateMachine);\n        for (const link of links) {\n            const docLink = DocumentLink.to(link);\n            if (docLink.target) {\n                result.push(docLink);\n            }\n        }\n        return result;\n    }\n}\nclass ExtHostFileSystem {\n    constructor(mainContext, _extHostLanguageFeatures) {\n        this._extHostLanguageFeatures = _extHostLanguageFeatures;\n        this._linkProvider = ( new FsLinkProvider());\n        this._fsProvider = ( new Map());\n        this._registeredSchemes = ( new Set());\n        this._watches = ( new Map());\n        this._handlePool = 0;\n        this._proxy = ( mainContext.getProxy(MainContext.MainThreadFileSystem));\n    }\n    dispose() {\n        this._linkProviderRegistration?.dispose();\n    }\n    registerFileSystemProvider(extension, scheme, provider, options = {}) {\n        ExtHostFileSystem._validateFileSystemProvider(provider);\n        if (( this._registeredSchemes.has(scheme))) {\n            throw ( new Error(`a provider for the scheme '${scheme}' is already registered`));\n        }\n        if (!this._linkProviderRegistration) {\n            this._linkProviderRegistration = this._extHostLanguageFeatures.registerDocumentLinkProvider(extension, '*', this._linkProvider);\n        }\n        const handle = this._handlePool++;\n        this._linkProvider.add(scheme);\n        this._registeredSchemes.add(scheme);\n        this._fsProvider.set(handle, provider);\n        let capabilities = 2 ;\n        if (options.isCaseSensitive) {\n            capabilities += 1024 ;\n        }\n        if (options.isReadonly) {\n            capabilities += 2048 ;\n        }\n        if (typeof provider.copy === 'function') {\n            capabilities += 8 ;\n        }\n        if (typeof provider.open === 'function' && typeof provider.close === 'function'\n            && typeof provider.read === 'function' && typeof provider.write === 'function') {\n            checkProposedApiEnabled(extension, 'fsChunks');\n            capabilities += 4 ;\n        }\n        let readOnlyMessage;\n        if (options.isReadonly && isMarkdownString(options.isReadonly) && options.isReadonly.value !== '') {\n            readOnlyMessage = {\n                value: options.isReadonly.value,\n                isTrusted: options.isReadonly.isTrusted,\n                supportThemeIcons: options.isReadonly.supportThemeIcons,\n                supportHtml: options.isReadonly.supportHtml,\n                baseUri: options.isReadonly.baseUri,\n                uris: options.isReadonly.uris\n            };\n        }\n        this._proxy.$registerFileSystemProvider(handle, scheme, capabilities, readOnlyMessage).catch(err => {\n            console.error(`FAILED to register filesystem provider of ${extension.identifier.value}-extension for the scheme ${scheme}`);\n            console.error(err);\n        });\n        const subscription = provider.onDidChangeFile(event => {\n            const mapped = [];\n            for (const e of event) {\n                const { uri: resource, type } = e;\n                if (resource.scheme !== scheme) {\n                    continue;\n                }\n                let newType;\n                switch (type) {\n                    case FileChangeType.Changed:\n                        newType = 0 ;\n                        break;\n                    case FileChangeType.Created:\n                        newType = 1 ;\n                        break;\n                    case FileChangeType.Deleted:\n                        newType = 2 ;\n                        break;\n                    default:\n                        throw ( new Error('Unknown FileChangeType'));\n                }\n                mapped.push({ resource, type: newType });\n            }\n            this._proxy.$onFileSystemChange(handle, mapped);\n        });\n        return toDisposable(() => {\n            subscription.dispose();\n            this._linkProvider.delete(scheme);\n            this._registeredSchemes.delete(scheme);\n            this._fsProvider.delete(handle);\n            this._proxy.$unregisterProvider(handle);\n        });\n    }\n    static _validateFileSystemProvider(provider) {\n        if (!provider) {\n            throw ( new Error('MISSING provider'));\n        }\n        if (typeof provider.watch !== 'function') {\n            throw ( new Error('Provider does NOT implement watch'));\n        }\n        if (typeof provider.stat !== 'function') {\n            throw ( new Error('Provider does NOT implement stat'));\n        }\n        if (typeof provider.readDirectory !== 'function') {\n            throw ( new Error('Provider does NOT implement readDirectory'));\n        }\n        if (typeof provider.createDirectory !== 'function') {\n            throw ( new Error('Provider does NOT implement createDirectory'));\n        }\n        if (typeof provider.readFile !== 'function') {\n            throw ( new Error('Provider does NOT implement readFile'));\n        }\n        if (typeof provider.writeFile !== 'function') {\n            throw ( new Error('Provider does NOT implement writeFile'));\n        }\n        if (typeof provider.delete !== 'function') {\n            throw ( new Error('Provider does NOT implement delete'));\n        }\n        if (typeof provider.rename !== 'function') {\n            throw ( new Error('Provider does NOT implement rename'));\n        }\n    }\n    static _asIStat(stat) {\n        const { type, ctime, mtime, size, permissions } = stat;\n        return { type, ctime, mtime, size, permissions };\n    }\n    $stat(handle, resource) {\n        return Promise.resolve(this._getFsProvider(handle).stat(URI.revive(resource))).then(stat => ExtHostFileSystem._asIStat(stat));\n    }\n    $readdir(handle, resource) {\n        return Promise.resolve(this._getFsProvider(handle).readDirectory(URI.revive(resource)));\n    }\n    $readFile(handle, resource) {\n        return Promise.resolve(this._getFsProvider(handle).readFile(URI.revive(resource))).then(data => VSBuffer.wrap(data));\n    }\n    $writeFile(handle, resource, content, opts) {\n        return Promise.resolve(this._getFsProvider(handle).writeFile(URI.revive(resource), content.buffer, opts));\n    }\n    $delete(handle, resource, opts) {\n        return Promise.resolve(this._getFsProvider(handle).delete(URI.revive(resource), opts));\n    }\n    $rename(handle, oldUri, newUri, opts) {\n        return Promise.resolve(this._getFsProvider(handle).rename(URI.revive(oldUri), URI.revive(newUri), opts));\n    }\n    $copy(handle, oldUri, newUri, opts) {\n        const provider = this._getFsProvider(handle);\n        if (!provider.copy) {\n            throw ( new Error('FileSystemProvider does not implement \"copy\"'));\n        }\n        return Promise.resolve(provider.copy(URI.revive(oldUri), URI.revive(newUri), opts));\n    }\n    $mkdir(handle, resource) {\n        return Promise.resolve(this._getFsProvider(handle).createDirectory(URI.revive(resource)));\n    }\n    $watch(handle, session, resource, opts) {\n        const subscription = this._getFsProvider(handle).watch(URI.revive(resource), opts);\n        this._watches.set(session, subscription);\n    }\n    $unwatch(_handle, session) {\n        const subscription = this._watches.get(session);\n        if (subscription) {\n            subscription.dispose();\n            this._watches.delete(session);\n        }\n    }\n    $open(handle, resource, opts) {\n        const provider = this._getFsProvider(handle);\n        if (!provider.open) {\n            throw ( new Error('FileSystemProvider does not implement \"open\"'));\n        }\n        return Promise.resolve(provider.open(URI.revive(resource), opts));\n    }\n    $close(handle, fd) {\n        const provider = this._getFsProvider(handle);\n        if (!provider.close) {\n            throw ( new Error('FileSystemProvider does not implement \"close\"'));\n        }\n        return Promise.resolve(provider.close(fd));\n    }\n    $read(handle, fd, pos, length) {\n        const provider = this._getFsProvider(handle);\n        if (!provider.read) {\n            throw ( new Error('FileSystemProvider does not implement \"read\"'));\n        }\n        const data = VSBuffer.alloc(length);\n        return Promise.resolve(provider.read(fd, pos, data.buffer, 0, length)).then(read => {\n            return data.slice(0, read);\n        });\n    }\n    $write(handle, fd, pos, data) {\n        const provider = this._getFsProvider(handle);\n        if (!provider.write) {\n            throw ( new Error('FileSystemProvider does not implement \"write\"'));\n        }\n        return Promise.resolve(provider.write(fd, pos, data.buffer, 0, data.byteLength));\n    }\n    _getFsProvider(handle) {\n        const provider = this._fsProvider.get(handle);\n        if (!provider) {\n            const err = ( new Error());\n            err.name = 'ENOPRO';\n            err.message = `no provider`;\n            throw err;\n        }\n        return provider;\n    }\n}\nexport { ExtHostFileSystem };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { FilePermission, FileType, toFileSystemProviderErrorCode, FileSystemProviderErrorCode, FileSystemProviderError } from '../../../platform/files/common/files.js';\nimport { FileSystemError } from './extHostTypes.js';\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\nimport { IExtHostFileSystemInfo } from './extHostFileSystemInfo.js';\nimport { toDisposable } from '../../../base/common/lifecycle.js';\nimport { ResourceQueue } from '../../../base/common/async.js';\nimport { extUri, extUriIgnorePathCase } from '../../../base/common/resources.js';\nimport { Schemas } from '../../../base/common/network.js';\nvar ExtHostConsumerFileSystem_1;\nlet ExtHostConsumerFileSystem = ExtHostConsumerFileSystem_1 = class ExtHostConsumerFileSystem {\n    constructor(extHostRpc, fileSystemInfo) {\n        this._fileSystemProvider = ( new Map());\n        this._writeQueue = ( new ResourceQueue());\n        this._proxy = ( extHostRpc.getProxy(MainContext.MainThreadFileSystem));\n        const that = this;\n        this.value = ( Object.freeze({\n            async stat(uri) {\n                try {\n                    let stat;\n                    const provider = that._fileSystemProvider.get(uri.scheme);\n                    if (provider) {\n                        await that._proxy.$ensureActivation(uri.scheme);\n                        stat = await provider.impl.stat(uri);\n                    }\n                    else {\n                        stat = await that._proxy.$stat(uri);\n                    }\n                    return {\n                        type: stat.type,\n                        ctime: stat.ctime,\n                        mtime: stat.mtime,\n                        size: stat.size,\n                        permissions: stat.permissions === FilePermission.Readonly ? 1 : undefined\n                    };\n                }\n                catch (err) {\n                    ExtHostConsumerFileSystem_1._handleError(err);\n                }\n            },\n            async readDirectory(uri) {\n                try {\n                    const provider = that._fileSystemProvider.get(uri.scheme);\n                    if (provider) {\n                        await that._proxy.$ensureActivation(uri.scheme);\n                        return (await provider.impl.readDirectory(uri)).slice();\n                    }\n                    else {\n                        return await that._proxy.$readdir(uri);\n                    }\n                }\n                catch (err) {\n                    return ExtHostConsumerFileSystem_1._handleError(err);\n                }\n            },\n            async createDirectory(uri) {\n                try {\n                    const provider = that._fileSystemProvider.get(uri.scheme);\n                    if (provider && !provider.isReadonly) {\n                        await that._proxy.$ensureActivation(uri.scheme);\n                        return await that.mkdirp(provider.impl, provider.extUri, uri);\n                    }\n                    else {\n                        return await that._proxy.$mkdir(uri);\n                    }\n                }\n                catch (err) {\n                    return ExtHostConsumerFileSystem_1._handleError(err);\n                }\n            },\n            async readFile(uri) {\n                try {\n                    const provider = that._fileSystemProvider.get(uri.scheme);\n                    if (provider) {\n                        await that._proxy.$ensureActivation(uri.scheme);\n                        return (await provider.impl.readFile(uri)).slice();\n                    }\n                    else {\n                        const buff = await that._proxy.$readFile(uri);\n                        return buff.buffer;\n                    }\n                }\n                catch (err) {\n                    return ExtHostConsumerFileSystem_1._handleError(err);\n                }\n            },\n            async writeFile(uri, content) {\n                try {\n                    const provider = that._fileSystemProvider.get(uri.scheme);\n                    if (provider && !provider.isReadonly) {\n                        await that._proxy.$ensureActivation(uri.scheme);\n                        await that.mkdirp(provider.impl, provider.extUri, provider.extUri.dirname(uri));\n                        return await that._writeQueue.queueFor(uri, () => Promise.resolve(provider.impl.writeFile(uri, content, { create: true, overwrite: true })));\n                    }\n                    else {\n                        return await that._proxy.$writeFile(uri, VSBuffer.wrap(content));\n                    }\n                }\n                catch (err) {\n                    return ExtHostConsumerFileSystem_1._handleError(err);\n                }\n            },\n            async delete(uri, options) {\n                try {\n                    const provider = that._fileSystemProvider.get(uri.scheme);\n                    if (provider && !provider.isReadonly && !options?.useTrash ) {\n                        await that._proxy.$ensureActivation(uri.scheme);\n                        return await provider.impl.delete(uri, { recursive: false, ...options });\n                    }\n                    else {\n                        return await that._proxy.$delete(uri, { recursive: false, useTrash: false, atomic: false, ...options });\n                    }\n                }\n                catch (err) {\n                    return ExtHostConsumerFileSystem_1._handleError(err);\n                }\n            },\n            async rename(oldUri, newUri, options) {\n                try {\n                    return await that._proxy.$rename(oldUri, newUri, { ...{ overwrite: false }, ...options });\n                }\n                catch (err) {\n                    return ExtHostConsumerFileSystem_1._handleError(err);\n                }\n            },\n            async copy(source, destination, options) {\n                try {\n                    return await that._proxy.$copy(source, destination, { ...{ overwrite: false }, ...options });\n                }\n                catch (err) {\n                    return ExtHostConsumerFileSystem_1._handleError(err);\n                }\n            },\n            isWritableFileSystem(scheme) {\n                const capabilities = fileSystemInfo.getCapabilities(scheme);\n                if (typeof capabilities === 'number') {\n                    return !((capabilities & 2048) );\n                }\n                return undefined;\n            }\n        }));\n    }\n    async mkdirp(provider, providerExtUri, directory) {\n        const directoriesToCreate = [];\n        while (!providerExtUri.isEqual(directory, providerExtUri.dirname(directory))) {\n            try {\n                const stat = await provider.stat(directory);\n                if ((stat.type & FileType.Directory) === 0) {\n                    throw FileSystemError.FileExists(`Unable to create folder '${directory.scheme === Schemas.file ? directory.fsPath : ( directory.toString(true))}' that already exists but is not a directory`);\n                }\n                break;\n            }\n            catch (error) {\n                if (toFileSystemProviderErrorCode(error) !== FileSystemProviderErrorCode.FileNotFound) {\n                    throw error;\n                }\n                directoriesToCreate.push(providerExtUri.basename(directory));\n                directory = providerExtUri.dirname(directory);\n            }\n        }\n        for (let i = directoriesToCreate.length - 1; i >= 0; i--) {\n            directory = providerExtUri.joinPath(directory, directoriesToCreate[i]);\n            try {\n                await provider.createDirectory(directory);\n            }\n            catch (error) {\n                if (toFileSystemProviderErrorCode(error) !== FileSystemProviderErrorCode.FileExists) {\n                    throw error;\n                }\n            }\n        }\n    }\n    static _handleError(err) {\n        if (err instanceof FileSystemError) {\n            throw err;\n        }\n        if (err instanceof FileSystemProviderError) {\n            switch (err.code) {\n                case FileSystemProviderErrorCode.FileExists: throw FileSystemError.FileExists(err.message);\n                case FileSystemProviderErrorCode.FileNotFound: throw FileSystemError.FileNotFound(err.message);\n                case FileSystemProviderErrorCode.FileNotADirectory: throw FileSystemError.FileNotADirectory(err.message);\n                case FileSystemProviderErrorCode.FileIsADirectory: throw FileSystemError.FileIsADirectory(err.message);\n                case FileSystemProviderErrorCode.NoPermissions: throw FileSystemError.NoPermissions(err.message);\n                case FileSystemProviderErrorCode.Unavailable: throw FileSystemError.Unavailable(err.message);\n                default: throw ( new FileSystemError(err.message, err.name));\n            }\n        }\n        if (!(err instanceof Error)) {\n            throw ( new FileSystemError(String(err)));\n        }\n        if (err.name === 'ENOPRO' || err.message.includes('ENOPRO')) {\n            throw FileSystemError.Unavailable(err.message);\n        }\n        switch (err.name) {\n            case FileSystemProviderErrorCode.FileExists: throw FileSystemError.FileExists(err.message);\n            case FileSystemProviderErrorCode.FileNotFound: throw FileSystemError.FileNotFound(err.message);\n            case FileSystemProviderErrorCode.FileNotADirectory: throw FileSystemError.FileNotADirectory(err.message);\n            case FileSystemProviderErrorCode.FileIsADirectory: throw FileSystemError.FileIsADirectory(err.message);\n            case FileSystemProviderErrorCode.NoPermissions: throw FileSystemError.NoPermissions(err.message);\n            case FileSystemProviderErrorCode.Unavailable: throw FileSystemError.Unavailable(err.message);\n            default: throw ( new FileSystemError(err.message, err.name));\n        }\n    }\n    addFileSystemProvider(scheme, provider, options) {\n        this._fileSystemProvider.set(scheme, { impl: provider, extUri: options?.isCaseSensitive ? extUri : extUriIgnorePathCase, isReadonly: !!options?.isReadonly });\n        return toDisposable(() => this._fileSystemProvider.delete(scheme));\n    }\n    getFileSystemProviderExtUri(scheme) {\n        return this._fileSystemProvider.get(scheme)?.extUri ?? extUri;\n    }\n};\nExtHostConsumerFileSystem = ExtHostConsumerFileSystem_1 = ( __decorate([\n    ( __param(0, IExtHostRpcService)),\n    ( __param(1, IExtHostFileSystemInfo))\n], ExtHostConsumerFileSystem));\nconst IExtHostConsumerFileSystem = ( createDecorator('IExtHostConsumerFileSystem'));\nexport { ExtHostConsumerFileSystem, IExtHostConsumerFileSystem };\n","import { Emitter, AsyncEmitter } from '../../../base/common/event.js';\nimport { parse, GLOBSTAR, GLOB_SPLIT } from '../../../base/common/glob.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { GlobPattern, WorkspaceEdit as WorkspaceEdit$1 } from './extHostTypeConverters.js';\nimport { WorkspaceEdit, Disposable } from './extHostTypes.js';\nimport { Lazy } from '../../../base/common/lazy.js';\nimport { rtrim } from '../../../base/common/strings.js';\nimport { normalizeWatcherPattern } from '../../../platform/files/common/watcher.js';\nclass FileSystemWatcher {\n    get ignoreCreateEvents() {\n        return Boolean(this._config & 0b001);\n    }\n    get ignoreChangeEvents() {\n        return Boolean(this._config & 0b010);\n    }\n    get ignoreDeleteEvents() {\n        return Boolean(this._config & 0b100);\n    }\n    constructor(mainContext, configuration, workspace, extension, dispatcher, globPattern, options) {\n        this.session = Math.random();\n        this._onDidCreate = ( new Emitter());\n        this._onDidChange = ( new Emitter());\n        this._onDidDelete = ( new Emitter());\n        this._config = 0;\n        if (options.ignoreCreateEvents) {\n            this._config += 0b001;\n        }\n        if (options.ignoreChangeEvents) {\n            this._config += 0b010;\n        }\n        if (options.ignoreDeleteEvents) {\n            this._config += 0b100;\n        }\n        const parsedPattern = parse(globPattern);\n        const excludeOutOfWorkspaceEvents = typeof globPattern === 'string';\n        const excludeUncorrelatedEvents = options.correlate;\n        const subscription = dispatcher(events => {\n            if (typeof events.session === 'number' && events.session !== this.session) {\n                return;\n            }\n            if (excludeUncorrelatedEvents && typeof events.session === 'undefined') {\n                return;\n            }\n            if (!options.ignoreCreateEvents) {\n                for (const created of events.created) {\n                    const uri = URI.revive(created);\n                    if (parsedPattern(uri.fsPath) && (!excludeOutOfWorkspaceEvents || workspace.getWorkspaceFolder(uri))) {\n                        this._onDidCreate.fire(uri);\n                    }\n                }\n            }\n            if (!options.ignoreChangeEvents) {\n                for (const changed of events.changed) {\n                    const uri = URI.revive(changed);\n                    if (parsedPattern(uri.fsPath) && (!excludeOutOfWorkspaceEvents || workspace.getWorkspaceFolder(uri))) {\n                        this._onDidChange.fire(uri);\n                    }\n                }\n            }\n            if (!options.ignoreDeleteEvents) {\n                for (const deleted of events.deleted) {\n                    const uri = URI.revive(deleted);\n                    if (parsedPattern(uri.fsPath) && (!excludeOutOfWorkspaceEvents || workspace.getWorkspaceFolder(uri))) {\n                        this._onDidDelete.fire(uri);\n                    }\n                }\n            }\n        });\n        this._disposable = Disposable.from(this.ensureWatching(mainContext, workspace, configuration, extension, globPattern, options, options.correlate), this._onDidCreate, this._onDidChange, this._onDidDelete, subscription);\n    }\n    ensureWatching(mainContext, workspace, configuration, extension, globPattern, options, correlate) {\n        const disposable = Disposable.from();\n        if (typeof globPattern === 'string') {\n            return disposable;\n        }\n        if (options.ignoreChangeEvents && options.ignoreCreateEvents && options.ignoreDeleteEvents) {\n            return disposable;\n        }\n        const proxy = ( mainContext.getProxy(MainContext.MainThreadFileSystemEventService));\n        let recursive = false;\n        if (globPattern.pattern.includes(GLOBSTAR) || globPattern.pattern.includes(GLOB_SPLIT)) {\n            recursive = true;\n        }\n        const excludes = options.excludes ?? [];\n        let includes = undefined;\n        let filter;\n        if (correlate) {\n            if (options.ignoreChangeEvents || options.ignoreCreateEvents || options.ignoreDeleteEvents) {\n                filter = 2  | 4  | 8 ;\n                if (options.ignoreChangeEvents) {\n                    filter &= ~2 ;\n                }\n                if (options.ignoreCreateEvents) {\n                    filter &= ~4 ;\n                }\n                if (options.ignoreDeleteEvents) {\n                    filter &= ~8 ;\n                }\n            }\n        }\n        else {\n            if (recursive && excludes.length === 0) {\n                const workspaceFolder = workspace.getWorkspaceFolder(URI.revive(globPattern.baseUri));\n                const watcherExcludes = configuration.getConfiguration('files', workspaceFolder).get('watcherExclude');\n                if (watcherExcludes) {\n                    for (const key in watcherExcludes) {\n                        if (key && watcherExcludes[key] === true) {\n                            excludes.push(key);\n                        }\n                    }\n                }\n            }\n            else if (!recursive) {\n                const workspaceFolder = workspace.getWorkspaceFolder(URI.revive(globPattern.baseUri));\n                if (workspaceFolder) {\n                    const watcherExcludes = configuration.getConfiguration('files', workspaceFolder).get('watcherExclude');\n                    if (watcherExcludes) {\n                        for (const key in watcherExcludes) {\n                            if (key && watcherExcludes[key] === true) {\n                                const includePattern = `${rtrim(key, '/')}/${GLOBSTAR}`;\n                                if (!includes) {\n                                    includes = [];\n                                }\n                                includes.push(normalizeWatcherPattern(workspaceFolder.uri.fsPath, includePattern));\n                            }\n                        }\n                    }\n                    if (!includes || includes.length === 0) {\n                        return disposable;\n                    }\n                }\n            }\n        }\n        proxy.$watch(extension.identifier.value, this.session, globPattern.baseUri, { recursive, excludes, includes, filter }, Boolean(correlate));\n        return Disposable.from({ dispose: () => proxy.$unwatch(this.session) });\n    }\n    dispose() {\n        this._disposable.dispose();\n    }\n    get onDidCreate() {\n        return this._onDidCreate.event;\n    }\n    get onDidChange() {\n        return this._onDidChange.event;\n    }\n    get onDidDelete() {\n        return this._onDidDelete.event;\n    }\n}\nclass LazyRevivedFileSystemEvents {\n    constructor(_events) {\n        this._events = _events;\n        this.session = this._events.session;\n        this._created = ( new Lazy(() => ( this._events.created.map(URI.revive))));\n        this._changed = ( new Lazy(() => ( this._events.changed.map(URI.revive))));\n        this._deleted = ( new Lazy(() => ( this._events.deleted.map(URI.revive))));\n    }\n    get created() { return this._created.value; }\n    get changed() { return this._changed.value; }\n    get deleted() { return this._deleted.value; }\n}\nclass ExtHostFileSystemEventService {\n    constructor(_mainContext, _logService, _extHostDocumentsAndEditors) {\n        this._mainContext = _mainContext;\n        this._logService = _logService;\n        this._extHostDocumentsAndEditors = _extHostDocumentsAndEditors;\n        this._onFileSystemEvent = ( new Emitter());\n        this._onDidRenameFile = ( new Emitter());\n        this._onDidCreateFile = ( new Emitter());\n        this._onDidDeleteFile = ( new Emitter());\n        this._onWillRenameFile = ( new AsyncEmitter());\n        this._onWillCreateFile = ( new AsyncEmitter());\n        this._onWillDeleteFile = ( new AsyncEmitter());\n        this.onDidRenameFile = this._onDidRenameFile.event;\n        this.onDidCreateFile = this._onDidCreateFile.event;\n        this.onDidDeleteFile = this._onDidDeleteFile.event;\n    }\n    createFileSystemWatcher(workspace, configProvider, extension, globPattern, options) {\n        return ( new FileSystemWatcher(\n            this._mainContext,\n            configProvider,\n            workspace,\n            extension,\n            this._onFileSystemEvent.event,\n            GlobPattern.from(globPattern),\n            options\n        ));\n    }\n    $onFileEvent(events) {\n        this._onFileSystemEvent.fire(( new LazyRevivedFileSystemEvents(events)));\n    }\n    $onDidRunFileOperation(operation, files) {\n        switch (operation) {\n            case 2 :\n                this._onDidRenameFile.fire(( Object.freeze({ files: ( files.map(f => ({ oldUri: URI.revive(f.source), newUri: URI.revive(f.target) }))) })));\n                break;\n            case 1 :\n                this._onDidDeleteFile.fire(( Object.freeze({ files: ( files.map(f => URI.revive(f.target))) })));\n                break;\n            case 0 :\n            case 3 :\n                this._onDidCreateFile.fire(( Object.freeze({ files: ( files.map(f => URI.revive(f.target))) })));\n                break;\n        }\n    }\n    getOnWillRenameFileEvent(extension) {\n        return this._createWillExecuteEvent(extension, this._onWillRenameFile);\n    }\n    getOnWillCreateFileEvent(extension) {\n        return this._createWillExecuteEvent(extension, this._onWillCreateFile);\n    }\n    getOnWillDeleteFileEvent(extension) {\n        return this._createWillExecuteEvent(extension, this._onWillDeleteFile);\n    }\n    _createWillExecuteEvent(extension, emitter) {\n        return (listener, thisArg, disposables) => {\n            const wrappedListener = function wrapped(e) { listener.call(thisArg, e); };\n            wrappedListener.extension = extension;\n            return emitter.event(wrappedListener, undefined, disposables);\n        };\n    }\n    async $onWillRunFileOperation(operation, files, timeout, token) {\n        switch (operation) {\n            case 2 :\n                return await this._fireWillEvent(this._onWillRenameFile, { files: ( files.map(f => ({ oldUri: URI.revive(f.source), newUri: URI.revive(f.target) }))) }, timeout, token);\n            case 1 :\n                return await this._fireWillEvent(this._onWillDeleteFile, { files: ( files.map(f => URI.revive(f.target))) }, timeout, token);\n            case 0 :\n            case 3 :\n                return await this._fireWillEvent(this._onWillCreateFile, { files: ( files.map(f => URI.revive(f.target))) }, timeout, token);\n        }\n        return undefined;\n    }\n    async _fireWillEvent(emitter, data, timeout, token) {\n        const extensionNames = ( new Set());\n        const edits = [];\n        await emitter.fireAsync(data, token, async (thenable, listener) => {\n            const now = Date.now();\n            const result = await Promise.resolve(thenable);\n            if (result instanceof WorkspaceEdit) {\n                edits.push([listener.extension, result]);\n                extensionNames.add(listener.extension.displayName ?? listener.extension.identifier.value);\n            }\n            if (Date.now() - now > timeout) {\n                this._logService.warn('SLOW file-participant', listener.extension.identifier);\n            }\n        });\n        if (token.isCancellationRequested) {\n            return undefined;\n        }\n        if (edits.length === 0) {\n            return undefined;\n        }\n        const dto = { edits: [] };\n        for (const [, edit] of edits) {\n            const { edits } = WorkspaceEdit$1.from(edit, {\n                getTextDocumentVersion: uri => this._extHostDocumentsAndEditors.getDocument(uri)?.version,\n                getNotebookDocumentVersion: () => undefined,\n            });\n            dto.edits = dto.edits.concat(edits);\n        }\n        return { edit: dto, extensionNames: Array.from(extensionNames) };\n    }\n}\nexport { ExtHostFileSystemEventService };\n","import { Schemas } from '../../../base/common/network.js';\nimport { ExtUri } from '../../../base/common/resources.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nclass ExtHostFileSystemInfo {\n    constructor() {\n        this._systemSchemes = ( new Set(( Object.keys(Schemas))));\n        this._providerInfo = ( new Map());\n        this.extUri = ( new ExtUri(uri => {\n            const capabilities = this._providerInfo.get(uri.scheme);\n            if (capabilities === undefined) {\n                return false;\n            }\n            if (capabilities & 1024 ) {\n                return false;\n            }\n            return true;\n        }));\n    }\n    $acceptProviderInfos(uri, capabilities) {\n        if (capabilities === null) {\n            this._providerInfo.delete(uri.scheme);\n        }\n        else {\n            this._providerInfo.set(uri.scheme, capabilities);\n        }\n    }\n    isFreeScheme(scheme) {\n        return !( this._providerInfo.has(scheme)) && !( this._systemSchemes.has(scheme));\n    }\n    getCapabilities(scheme) {\n        return this._providerInfo.get(scheme);\n    }\n}\nconst IExtHostFileSystemInfo = ( createDecorator('IExtHostFileSystemInfo'));\nexport { ExtHostFileSystemInfo, IExtHostFileSystemInfo };\n","import { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nconst IExtHostInitDataService = ( createDecorator('IExtHostInitDataService'));\nexport { IExtHostInitDataService };\n","import { URI } from '../../../base/common/uri.js';\nimport { ApiCommand, ApiCommandArgument, ApiCommandResult } from './extHostCommands.js';\nclass ExtHostInteractive {\n    constructor(mainContext, _extHostNotebooks, _textDocumentsAndEditors, _commands, _logService) {\n        this._extHostNotebooks = _extHostNotebooks;\n        this._textDocumentsAndEditors = _textDocumentsAndEditors;\n        this._commands = _commands;\n        const openApiCommand = ( new ApiCommand(\n            'interactive.open',\n            '_interactive.open',\n            'Open interactive window and return notebook editor and input URI',\n            [\n                ( new ApiCommandArgument('showOptions', 'Show Options', v => true, v => v)),\n                ( new ApiCommandArgument('resource', 'Interactive resource Uri', v => true, v => v)),\n                ( new ApiCommandArgument('controllerId', 'Notebook controller Id', v => true, v => v)),\n                ( new ApiCommandArgument('title', 'Interactive editor title', v => true, v => v))\n            ],\n            ( new ApiCommandResult('Notebook and input URI', (v) => {\n                _logService.debug('[ExtHostInteractive] open iw with notebook editor id', v.notebookEditorId);\n                if (v.notebookEditorId !== undefined) {\n                    const editor = this._extHostNotebooks.getEditorById(v.notebookEditorId);\n                    _logService.debug('[ExtHostInteractive] notebook editor found', editor.id);\n                    return { notebookUri: URI.revive(v.notebookUri), inputUri: URI.revive(v.inputUri), notebookEditor: editor.apiEditor };\n                }\n                _logService.debug('[ExtHostInteractive] notebook editor not found, uris for the interactive document', v.notebookUri, v.inputUri);\n                return { notebookUri: URI.revive(v.notebookUri), inputUri: URI.revive(v.inputUri) };\n            }))\n        ));\n        this._commands.registerApiCommand(openApiCommand);\n    }\n    $willAddInteractiveDocument(uri, eol, languageId, notebookUri) {\n        this._textDocumentsAndEditors.acceptDocumentsAndEditorsDelta({\n            addedDocuments: [{\n                    EOL: eol,\n                    lines: [''],\n                    languageId: languageId,\n                    uri: uri,\n                    isDirty: false,\n                    versionId: 1,\n                }]\n        });\n    }\n    $willRemoveInteractiveDocument(uri, notebookUri) {\n        this._textDocumentsAndEditors.acceptDocumentsAndEditorsDelta({\n            removedDocuments: [uri]\n        });\n    }\n}\nexport { ExtHostInteractive };\n","import { toDisposable } from '../../../base/common/lifecycle.js';\nimport { MainContext } from './extHost.protocol.js';\nclass ExtHostLabelService {\n    constructor(mainContext) {\n        this._handlePool = 0;\n        this._proxy = ( mainContext.getProxy(MainContext.MainThreadLabelService));\n    }\n    $registerResourceLabelFormatter(formatter) {\n        const handle = this._handlePool++;\n        this._proxy.$registerResourceLabelFormatter(handle, formatter);\n        return toDisposable(() => {\n            this._proxy.$unregisterResourceLabelFormatter(handle);\n        });\n    }\n}\nexport { ExtHostLabelService };\n","import { isNonEmptyArray, coalesce, isFalsyOrEmpty, asArray } from '../../../base/common/arrays.js';\nimport { raceCancellationError } from '../../../base/common/async.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { isCancellationError, NotImplementedError } from '../../../base/common/errors.js';\nimport { IdGenerator } from '../../../base/common/idGenerator.js';\nimport { DisposableStore } from '../../../base/common/lifecycle.js';\nimport { mixin, equals } from '../../../base/common/objects.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { regExpLeadsToEndlessLoop } from '../../../base/common/strings.js';\nimport { assertType, isObject } from '../../../base/common/types.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { Range as Range$1 } from '../../../editor/common/core/range.js';\nimport { Selection } from '../../../editor/common/core/selection.js';\nimport { NewSymbolNameTriggerKind, InlineEditTriggerKind, InlineCompletionTriggerKind } from '../../../editor/common/languages.js';\nimport { encodeSemanticTokensDto } from '../../../editor/common/services/semanticTokensDto.js';\nimport { localize } from '../../../nls.js';\nimport { ExtensionIdentifier } from '../../../platform/extensions/common/extensions.js';\nimport { Selection as Selection$1, Range, CodeActionTriggerKind, Diagnostic, WorkspaceEdit, DocumentSelector, DocumentSymbol as DocumentSymbol$1, SymbolKind, SymbolTag, Position, Hover, EvaluatableExpression, InlineValueContext, InlineValue, DocumentHighlight, MultiDocumentHighlight, location, DataTransfer, TextEdit, WorkspaceSymbol, CompletionContext, CompletionItemKind, CompletionItemTag, MarkdownString, SignatureHelp, InlayHintKind, DocumentLink, Color, ColorPresentation, FoldingRange, SelectionRange, CallHierarchyItem, TypeHierarchyItem, DefinitionLink, PartialAcceptInfo } from './extHostTypeConverters.js';\nimport { CodeActionKind, NewSymbolNameTriggerKind as NewSymbolNameTriggerKind$1, Disposable, SyntaxTokenType, DocumentSymbol, Range as Range$2, InternalDataTransferItem, DocumentDropOrPasteEditKind, SemanticTokens, SemanticTokensEdits, SemanticTokensEdit, SnippetString, InlineEditTriggerKind as InlineEditTriggerKind$1, Location, CompletionList, InlineCompletionTriggerKind as InlineCompletionTriggerKind$1 } from './extHostTypes.js';\nimport { isProposedApiEnabled, checkProposedApiEnabled } from '../../services/extensions/common/extensions.js';\nimport { Cache } from './cache.js';\nimport { MainContext } from './extHost.protocol.js';\nclass DocumentSymbolAdapter {\n    constructor(_documents, _provider) {\n        this._documents = _documents;\n        this._provider = _provider;\n    }\n    async provideDocumentSymbols(resource, token) {\n        const doc = this._documents.getDocument(resource);\n        const value = await this._provider.provideDocumentSymbols(doc, token);\n        if (isFalsyOrEmpty(value)) {\n            return undefined;\n        }\n        else if (value[0] instanceof DocumentSymbol) {\n            return (\n                 (value.map(DocumentSymbol$1.from))\n            );\n        }\n        else {\n            return DocumentSymbolAdapter._asDocumentSymbolTree(value);\n        }\n    }\n    static _asDocumentSymbolTree(infos) {\n        infos = infos.slice(0).sort((a, b) => {\n            let res = a.location.range.start.compareTo(b.location.range.start);\n            if (res === 0) {\n                res = b.location.range.end.compareTo(a.location.range.end);\n            }\n            return res;\n        });\n        const res = [];\n        const parentStack = [];\n        for (const info of infos) {\n            const element = {\n                name: info.name || '!!MISSING: name!!',\n                kind: SymbolKind.from(info.kind),\n                tags: info.tags?.map(SymbolTag.from) || [],\n                detail: '',\n                containerName: info.containerName,\n                range: Range.from(info.location.range),\n                selectionRange: Range.from(info.location.range),\n                children: []\n            };\n            while (true) {\n                if (parentStack.length === 0) {\n                    parentStack.push(element);\n                    res.push(element);\n                    break;\n                }\n                const parent = parentStack[parentStack.length - 1];\n                if (Range$1.containsRange(parent.range, element.range) && !Range$1.equalsRange(parent.range, element.range)) {\n                    parent.children?.push(element);\n                    parentStack.push(element);\n                    break;\n                }\n                parentStack.pop();\n            }\n        }\n        return res;\n    }\n}\nclass CodeLensAdapter {\n    constructor(_documents, _commands, _provider, _extension, _extTelemetry, _logService) {\n        this._documents = _documents;\n        this._commands = _commands;\n        this._provider = _provider;\n        this._extension = _extension;\n        this._extTelemetry = _extTelemetry;\n        this._logService = _logService;\n        this._cache = ( (new Cache('CodeLens')));\n        this._disposables = ( (new Map()));\n    }\n    async provideCodeLenses(resource, token) {\n        const doc = this._documents.getDocument(resource);\n        const lenses = await this._provider.provideCodeLenses(doc, token);\n        if (!lenses || token.isCancellationRequested) {\n            return undefined;\n        }\n        const cacheId = this._cache.add(lenses);\n        const disposables = ( (new DisposableStore()));\n        this._disposables.set(cacheId, disposables);\n        const result = {\n            cacheId,\n            lenses: [],\n        };\n        for (let i = 0; i < lenses.length; i++) {\n            result.lenses.push({\n                cacheId: [cacheId, i],\n                range: Range.from(lenses[i].range),\n                command: this._commands.toInternal(lenses[i].command, disposables)\n            });\n        }\n        return result;\n    }\n    async resolveCodeLens(symbol, token) {\n        const lens = symbol.cacheId && this._cache.get(...symbol.cacheId);\n        if (!lens) {\n            return undefined;\n        }\n        let resolvedLens;\n        if (typeof this._provider.resolveCodeLens !== 'function' || lens.isResolved) {\n            resolvedLens = lens;\n        }\n        else {\n            resolvedLens = await this._provider.resolveCodeLens(lens, token);\n        }\n        if (!resolvedLens) {\n            resolvedLens = lens;\n        }\n        if (token.isCancellationRequested) {\n            return undefined;\n        }\n        const disposables = symbol.cacheId && this._disposables.get(symbol.cacheId[0]);\n        if (!disposables) {\n            return undefined;\n        }\n        if (!resolvedLens.command) {\n            const error = ( (new Error(\n                'INVALID code lens resolved, lacks command: ' + this._extension.identifier.value\n            )));\n            this._extTelemetry.onExtensionError(this._extension.identifier, error);\n            this._logService.error(error);\n            return undefined;\n        }\n        symbol.command = this._commands.toInternal(resolvedLens.command, disposables);\n        return symbol;\n    }\n    releaseCodeLenses(cachedId) {\n        this._disposables.get(cachedId)?.dispose();\n        this._disposables.delete(cachedId);\n        this._cache.delete(cachedId);\n    }\n}\nfunction convertToLocationLinks(value) {\n    if (Array.isArray(value)) {\n        return (\n             (value.map(DefinitionLink.from))\n        );\n    }\n    else if (value) {\n        return [DefinitionLink.from(value)];\n    }\n    return [];\n}\nclass DefinitionAdapter {\n    constructor(_documents, _provider) {\n        this._documents = _documents;\n        this._provider = _provider;\n    }\n    async provideDefinition(resource, position, token) {\n        const doc = this._documents.getDocument(resource);\n        const pos = Position.to(position);\n        const value = await this._provider.provideDefinition(doc, pos, token);\n        return convertToLocationLinks(value);\n    }\n}\nclass DeclarationAdapter {\n    constructor(_documents, _provider) {\n        this._documents = _documents;\n        this._provider = _provider;\n    }\n    async provideDeclaration(resource, position, token) {\n        const doc = this._documents.getDocument(resource);\n        const pos = Position.to(position);\n        const value = await this._provider.provideDeclaration(doc, pos, token);\n        return convertToLocationLinks(value);\n    }\n}\nclass ImplementationAdapter {\n    constructor(_documents, _provider) {\n        this._documents = _documents;\n        this._provider = _provider;\n    }\n    async provideImplementation(resource, position, token) {\n        const doc = this._documents.getDocument(resource);\n        const pos = Position.to(position);\n        const value = await this._provider.provideImplementation(doc, pos, token);\n        return convertToLocationLinks(value);\n    }\n}\nclass TypeDefinitionAdapter {\n    constructor(_documents, _provider) {\n        this._documents = _documents;\n        this._provider = _provider;\n    }\n    async provideTypeDefinition(resource, position, token) {\n        const doc = this._documents.getDocument(resource);\n        const pos = Position.to(position);\n        const value = await this._provider.provideTypeDefinition(doc, pos, token);\n        return convertToLocationLinks(value);\n    }\n}\nclass HoverAdapter {\n    static { this.HOVER_MAP_MAX_SIZE = 10; }\n    constructor(_documents, _provider) {\n        this._documents = _documents;\n        this._provider = _provider;\n        this._hoverCounter = 0;\n        this._hoverMap = ( (new Map()));\n    }\n    async provideHover(resource, position, context, token) {\n        const doc = this._documents.getDocument(resource);\n        const pos = Position.to(position);\n        let value;\n        if (context && context.verbosityRequest) {\n            const previousHoverId = context.verbosityRequest.previousHover.id;\n            const previousHover = this._hoverMap.get(previousHoverId);\n            if (!previousHover) {\n                throw ( (new Error(`Hover with id ${previousHoverId} not found`)));\n            }\n            const hoverContext = { verbosityDelta: context.verbosityRequest.verbosityDelta, previousHover };\n            value = await this._provider.provideHover(doc, pos, token, hoverContext);\n        }\n        else {\n            value = await this._provider.provideHover(doc, pos, token);\n        }\n        if (!value || isFalsyOrEmpty(value.contents)) {\n            return undefined;\n        }\n        if (!value.range) {\n            value.range = doc.getWordRangeAtPosition(pos);\n        }\n        if (!value.range) {\n            value.range = ( (new Range$2(pos, pos)));\n        }\n        const convertedHover = Hover.from(value);\n        const id = this._hoverCounter;\n        if (this._hoverMap.size === HoverAdapter.HOVER_MAP_MAX_SIZE) {\n            const minimumId = Math.min(...( (this._hoverMap.keys())));\n            this._hoverMap.delete(minimumId);\n        }\n        this._hoverMap.set(id, value);\n        this._hoverCounter += 1;\n        const hover = {\n            ...convertedHover,\n            id\n        };\n        return hover;\n    }\n    releaseHover(id) {\n        this._hoverMap.delete(id);\n    }\n}\nclass EvaluatableExpressionAdapter {\n    constructor(_documents, _provider) {\n        this._documents = _documents;\n        this._provider = _provider;\n    }\n    async provideEvaluatableExpression(resource, position, token) {\n        const doc = this._documents.getDocument(resource);\n        const pos = Position.to(position);\n        const value = await this._provider.provideEvaluatableExpression(doc, pos, token);\n        if (value) {\n            return EvaluatableExpression.from(value);\n        }\n        return undefined;\n    }\n}\nclass InlineValuesAdapter {\n    constructor(_documents, _provider) {\n        this._documents = _documents;\n        this._provider = _provider;\n    }\n    async provideInlineValues(resource, viewPort, context, token) {\n        const doc = this._documents.getDocument(resource);\n        const value = await this._provider.provideInlineValues(doc, Range.to(viewPort), InlineValueContext.to(context), token);\n        if (Array.isArray(value)) {\n            return (\n                 (value.map(iv => InlineValue.from(iv)))\n            );\n        }\n        return undefined;\n    }\n}\nclass DocumentHighlightAdapter {\n    constructor(_documents, _provider) {\n        this._documents = _documents;\n        this._provider = _provider;\n    }\n    async provideDocumentHighlights(resource, position, token) {\n        const doc = this._documents.getDocument(resource);\n        const pos = Position.to(position);\n        const value = await this._provider.provideDocumentHighlights(doc, pos, token);\n        if (Array.isArray(value)) {\n            return (\n                 (value.map(DocumentHighlight.from))\n            );\n        }\n        return undefined;\n    }\n}\nclass MultiDocumentHighlightAdapter {\n    constructor(_documents, _provider, _logService) {\n        this._documents = _documents;\n        this._provider = _provider;\n        this._logService = _logService;\n    }\n    async provideMultiDocumentHighlights(resource, position, otherResources, token) {\n        const doc = this._documents.getDocument(resource);\n        const otherDocuments = ( (otherResources.map(r => {\n            try {\n                return this._documents.getDocument(r);\n            }\n            catch (err) {\n                this._logService.error('Error: Unable to retrieve document from URI: ' + r + '. Error message: ' + err);\n                return undefined;\n            }\n        }))).filter(doc => doc !== undefined);\n        const pos = Position.to(position);\n        const value = await this._provider.provideMultiDocumentHighlights(doc, pos, otherDocuments, token);\n        if (Array.isArray(value)) {\n            return (\n                 (value.map(MultiDocumentHighlight.from))\n            );\n        }\n        return undefined;\n    }\n}\nclass LinkedEditingRangeAdapter {\n    constructor(_documents, _provider) {\n        this._documents = _documents;\n        this._provider = _provider;\n    }\n    async provideLinkedEditingRanges(resource, position, token) {\n        const doc = this._documents.getDocument(resource);\n        const pos = Position.to(position);\n        const value = await this._provider.provideLinkedEditingRanges(doc, pos, token);\n        if (value && Array.isArray(value.ranges)) {\n            return {\n                ranges: coalesce(( (value.ranges.map(Range.from)))),\n                wordPattern: value.wordPattern\n            };\n        }\n        return undefined;\n    }\n}\nclass ReferenceAdapter {\n    constructor(_documents, _provider) {\n        this._documents = _documents;\n        this._provider = _provider;\n    }\n    async provideReferences(resource, position, context, token) {\n        const doc = this._documents.getDocument(resource);\n        const pos = Position.to(position);\n        const value = await this._provider.provideReferences(doc, pos, context, token);\n        if (Array.isArray(value)) {\n            return (\n                 (value.map(location.from))\n            );\n        }\n        return undefined;\n    }\n}\nclass CodeActionAdapter {\n    static { this._maxCodeActionsPerFile = 1000; }\n    constructor(_documents, _commands, _diagnostics, _provider, _logService, _extension, _apiDeprecation) {\n        this._documents = _documents;\n        this._commands = _commands;\n        this._diagnostics = _diagnostics;\n        this._provider = _provider;\n        this._logService = _logService;\n        this._extension = _extension;\n        this._apiDeprecation = _apiDeprecation;\n        this._cache = ( (new Cache('CodeAction')));\n        this._disposables = ( (new Map()));\n    }\n    async provideCodeActions(resource, rangeOrSelection, context, token) {\n        const doc = this._documents.getDocument(resource);\n        const ran = Selection.isISelection(rangeOrSelection)\n            ? Selection$1.to(rangeOrSelection)\n            : Range.to(rangeOrSelection);\n        const allDiagnostics = [];\n        for (const diagnostic of this._diagnostics.getDiagnostics(resource)) {\n            if (ran.intersection(diagnostic.range)) {\n                const newLen = allDiagnostics.push(diagnostic);\n                if (newLen > CodeActionAdapter._maxCodeActionsPerFile) {\n                    break;\n                }\n            }\n        }\n        const codeActionContext = {\n            diagnostics: allDiagnostics,\n            only: context.only ? ( (new CodeActionKind(context.only))) : undefined,\n            triggerKind: CodeActionTriggerKind.to(context.trigger),\n        };\n        const commandsOrActions = await this._provider.provideCodeActions(doc, ran, codeActionContext, token);\n        if (!isNonEmptyArray(commandsOrActions) || token.isCancellationRequested) {\n            return undefined;\n        }\n        const cacheId = this._cache.add(commandsOrActions);\n        const disposables = ( (new DisposableStore()));\n        this._disposables.set(cacheId, disposables);\n        const actions = [];\n        for (let i = 0; i < commandsOrActions.length; i++) {\n            const candidate = commandsOrActions[i];\n            if (!candidate) {\n                continue;\n            }\n            if (CodeActionAdapter._isCommand(candidate)) {\n                this._apiDeprecation.report('CodeActionProvider.provideCodeActions - return commands', this._extension, `Return 'CodeAction' instances instead.`);\n                actions.push({\n                    _isSynthetic: true,\n                    title: candidate.title,\n                    command: this._commands.toInternal(candidate, disposables),\n                });\n            }\n            else {\n                if (codeActionContext.only) {\n                    if (!candidate.kind) {\n                        this._logService.warn(`${this._extension.identifier.value} - Code actions of kind '${codeActionContext.only.value}' requested but returned code action does not have a 'kind'. Code action will be dropped. Please set 'CodeAction.kind'.`);\n                    }\n                    else if (!codeActionContext.only.contains(candidate.kind)) {\n                        this._logService.warn(`${this._extension.identifier.value} - Code actions of kind '${codeActionContext.only.value}' requested but returned code action is of kind '${candidate.kind.value}'. Code action will be dropped. Please check 'CodeActionContext.only' to only return requested code actions.`);\n                    }\n                }\n                const range = candidate.ranges ?? [];\n                actions.push({\n                    cacheId: [cacheId, i],\n                    title: candidate.title,\n                    command: candidate.command && this._commands.toInternal(candidate.command, disposables),\n                    diagnostics: candidate.diagnostics && ( (candidate.diagnostics.map(Diagnostic.from))),\n                    edit: candidate.edit && WorkspaceEdit.from(candidate.edit, undefined),\n                    kind: candidate.kind && candidate.kind.value,\n                    isPreferred: candidate.isPreferred,\n                    isAI: isProposedApiEnabled(this._extension, 'codeActionAI') ? candidate.isAI : false,\n                    ranges: isProposedApiEnabled(this._extension, 'codeActionRanges') ? coalesce(( (range.map(Range.from)))) : undefined,\n                    disabled: candidate.disabled?.reason\n                });\n            }\n        }\n        return { cacheId, actions };\n    }\n    async resolveCodeAction(id, token) {\n        const [sessionId, itemId] = id;\n        const item = this._cache.get(sessionId, itemId);\n        if (!item || CodeActionAdapter._isCommand(item)) {\n            return {};\n        }\n        if (!this._provider.resolveCodeAction) {\n            return {};\n        }\n        const resolvedItem = (await this._provider.resolveCodeAction(item, token)) ?? item;\n        let resolvedEdit;\n        if (resolvedItem.edit) {\n            resolvedEdit = WorkspaceEdit.from(resolvedItem.edit, undefined);\n        }\n        let resolvedCommand;\n        if (resolvedItem.command) {\n            const disposables = this._disposables.get(sessionId);\n            if (disposables) {\n                resolvedCommand = this._commands.toInternal(resolvedItem.command, disposables);\n            }\n        }\n        return { edit: resolvedEdit, command: resolvedCommand };\n    }\n    releaseCodeActions(cachedId) {\n        this._disposables.get(cachedId)?.dispose();\n        this._disposables.delete(cachedId);\n        this._cache.delete(cachedId);\n    }\n    static _isCommand(thing) {\n        return typeof thing.command === 'string' && typeof thing.title === 'string';\n    }\n}\nclass DocumentPasteEditProvider {\n    constructor(_proxy, _documents, _provider, _handle, _extension) {\n        this._proxy = _proxy;\n        this._documents = _documents;\n        this._provider = _provider;\n        this._handle = _handle;\n        this._extension = _extension;\n        this._cache = ( (new Cache('DocumentPasteEdit')));\n    }\n    async prepareDocumentPaste(resource, ranges, dataTransferDto, token) {\n        if (!this._provider.prepareDocumentPaste) {\n            return;\n        }\n        const doc = this._documents.getDocument(resource);\n        const vscodeRanges = ( (ranges.map(range => Range.to(range))));\n        const dataTransfer = DataTransfer.toDataTransfer(dataTransferDto, () => {\n            throw ( (new NotImplementedError()));\n        });\n        await this._provider.prepareDocumentPaste(doc, vscodeRanges, dataTransfer, token);\n        if (token.isCancellationRequested) {\n            return;\n        }\n        const entries = Array.from(dataTransfer).filter(([, value]) => !(value instanceof InternalDataTransferItem));\n        return DataTransfer.from(entries);\n    }\n    async providePasteEdits(requestId, resource, ranges, dataTransferDto, context, token) {\n        if (!this._provider.provideDocumentPasteEdits) {\n            return [];\n        }\n        const doc = this._documents.getDocument(resource);\n        const vscodeRanges = ( (ranges.map(range => Range.to(range))));\n        const dataTransfer = DataTransfer.toDataTransfer(dataTransferDto, async (id) => {\n            return (await this._proxy.$resolvePasteFileData(this._handle, requestId, id)).buffer;\n        });\n        const edits = await this._provider.provideDocumentPasteEdits(doc, vscodeRanges, dataTransfer, {\n            only: context.only ? ( (new DocumentDropOrPasteEditKind(context.only))) : undefined,\n            triggerKind: context.triggerKind,\n        }, token);\n        if (!edits || token.isCancellationRequested) {\n            return [];\n        }\n        const cacheId = this._cache.add(edits);\n        return (\n             (edits.map((edit, i) => ({\n                _cacheId: [cacheId, i],\n                title: edit.title ?? ( localize(\n                    4798,\n                    \"Paste using '{0}' extension\",\n                    this._extension.displayName || this._extension.name\n                )),\n                kind: edit.kind,\n                yieldTo: edit.yieldTo?.map(x => x.value),\n                insertText: typeof edit.insertText === 'string' ? edit.insertText : { snippet: edit.insertText.value },\n                additionalEdit: edit.additionalEdit ? WorkspaceEdit.from(edit.additionalEdit, undefined) : undefined,\n            })))\n        );\n    }\n    async resolvePasteEdit(id, token) {\n        const [sessionId, itemId] = id;\n        const item = this._cache.get(sessionId, itemId);\n        if (!item || !this._provider.resolveDocumentPasteEdit) {\n            return {};\n        }\n        const resolvedItem = (await this._provider.resolveDocumentPasteEdit(item, token)) ?? item;\n        const additionalEdit = resolvedItem.additionalEdit ? WorkspaceEdit.from(resolvedItem.additionalEdit, undefined) : undefined;\n        return { additionalEdit };\n    }\n    releasePasteEdits(id) {\n        this._cache.delete(id);\n    }\n}\nclass DocumentFormattingAdapter {\n    constructor(_documents, _provider) {\n        this._documents = _documents;\n        this._provider = _provider;\n    }\n    async provideDocumentFormattingEdits(resource, options, token) {\n        const document = this._documents.getDocument(resource);\n        const value = await this._provider.provideDocumentFormattingEdits(document, options, token);\n        if (Array.isArray(value)) {\n            return (\n                 (value.map(TextEdit.from))\n            );\n        }\n        return undefined;\n    }\n}\nclass RangeFormattingAdapter {\n    constructor(_documents, _provider) {\n        this._documents = _documents;\n        this._provider = _provider;\n    }\n    async provideDocumentRangeFormattingEdits(resource, range, options, token) {\n        const document = this._documents.getDocument(resource);\n        const ran = Range.to(range);\n        const value = await this._provider.provideDocumentRangeFormattingEdits(document, ran, options, token);\n        if (Array.isArray(value)) {\n            return (\n                 (value.map(TextEdit.from))\n            );\n        }\n        return undefined;\n    }\n    async provideDocumentRangesFormattingEdits(resource, ranges, options, token) {\n        assertType(typeof this._provider.provideDocumentRangesFormattingEdits === 'function', 'INVALID invocation of `provideDocumentRangesFormattingEdits`');\n        const document = this._documents.getDocument(resource);\n        const _ranges = ( (ranges.map(Range.to)));\n        const value = await this._provider.provideDocumentRangesFormattingEdits(document, _ranges, options, token);\n        if (Array.isArray(value)) {\n            return (\n                 (value.map(TextEdit.from))\n            );\n        }\n        return undefined;\n    }\n}\nclass OnTypeFormattingAdapter {\n    constructor(_documents, _provider) {\n        this._documents = _documents;\n        this._provider = _provider;\n        this.autoFormatTriggerCharacters = [];\n    }\n    async provideOnTypeFormattingEdits(resource, position, ch, options, token) {\n        const document = this._documents.getDocument(resource);\n        const pos = Position.to(position);\n        const value = await this._provider.provideOnTypeFormattingEdits(document, pos, ch, options, token);\n        if (Array.isArray(value)) {\n            return (\n                 (value.map(TextEdit.from))\n            );\n        }\n        return undefined;\n    }\n}\nclass NavigateTypeAdapter {\n    constructor(_provider, _logService) {\n        this._provider = _provider;\n        this._logService = _logService;\n        this._cache = ( (new Cache('WorkspaceSymbols')));\n    }\n    async provideWorkspaceSymbols(search, token) {\n        const value = await this._provider.provideWorkspaceSymbols(search, token);\n        if (!isNonEmptyArray(value)) {\n            return { symbols: [] };\n        }\n        const sid = this._cache.add(value);\n        const result = {\n            cacheId: sid,\n            symbols: []\n        };\n        for (let i = 0; i < value.length; i++) {\n            const item = value[i];\n            if (!item || !item.name) {\n                this._logService.warn('INVALID SymbolInformation', item);\n                continue;\n            }\n            result.symbols.push({\n                ...WorkspaceSymbol.from(item),\n                cacheId: [sid, i]\n            });\n        }\n        return result;\n    }\n    async resolveWorkspaceSymbol(symbol, token) {\n        if (typeof this._provider.resolveWorkspaceSymbol !== 'function') {\n            return symbol;\n        }\n        if (!symbol.cacheId) {\n            return symbol;\n        }\n        const item = this._cache.get(...symbol.cacheId);\n        if (item) {\n            const value = await this._provider.resolveWorkspaceSymbol(item, token);\n            return value && mixin(symbol, WorkspaceSymbol.from(value), true);\n        }\n        return undefined;\n    }\n    releaseWorkspaceSymbols(id) {\n        this._cache.delete(id);\n    }\n}\nclass RenameAdapter {\n    static supportsResolving(provider) {\n        return typeof provider.prepareRename === 'function';\n    }\n    constructor(_documents, _provider, _logService) {\n        this._documents = _documents;\n        this._provider = _provider;\n        this._logService = _logService;\n    }\n    async provideRenameEdits(resource, position, newName, token) {\n        const doc = this._documents.getDocument(resource);\n        const pos = Position.to(position);\n        try {\n            const value = await this._provider.provideRenameEdits(doc, pos, newName, token);\n            if (!value) {\n                return undefined;\n            }\n            return WorkspaceEdit.from(value);\n        }\n        catch (err) {\n            const rejectReason = RenameAdapter._asMessage(err);\n            if (rejectReason) {\n                return { rejectReason, edits: undefined };\n            }\n            else {\n                return Promise.reject(err);\n            }\n        }\n    }\n    async resolveRenameLocation(resource, position, token) {\n        if (typeof this._provider.prepareRename !== 'function') {\n            return Promise.resolve(undefined);\n        }\n        const doc = this._documents.getDocument(resource);\n        const pos = Position.to(position);\n        try {\n            const rangeOrLocation = await this._provider.prepareRename(doc, pos, token);\n            let range;\n            let text;\n            if (Range$2.isRange(rangeOrLocation)) {\n                range = rangeOrLocation;\n                text = doc.getText(rangeOrLocation);\n            }\n            else if (isObject(rangeOrLocation)) {\n                range = rangeOrLocation.range;\n                text = rangeOrLocation.placeholder;\n            }\n            if (!range || !text) {\n                return undefined;\n            }\n            if (range.start.line > pos.line || range.end.line < pos.line) {\n                this._logService.warn('INVALID rename location: position line must be within range start/end lines');\n                return undefined;\n            }\n            return { range: Range.from(range), text };\n        }\n        catch (err) {\n            const rejectReason = RenameAdapter._asMessage(err);\n            if (rejectReason) {\n                return { rejectReason, range: undefined, text: undefined };\n            }\n            else {\n                return Promise.reject(err);\n            }\n        }\n    }\n    static _asMessage(err) {\n        if (typeof err === 'string') {\n            return err;\n        }\n        else if (err instanceof Error && typeof err.message === 'string') {\n            return err.message;\n        }\n        else {\n            return undefined;\n        }\n    }\n}\nclass NewSymbolNamesAdapter {\n    static { this.languageTriggerKindToVSCodeTriggerKind = {\n        [NewSymbolNameTriggerKind.Invoke]: NewSymbolNameTriggerKind$1.Invoke,\n        [NewSymbolNameTriggerKind.Automatic]: NewSymbolNameTriggerKind$1.Automatic,\n    }; }\n    constructor(_documents, _provider, _logService) {\n        this._documents = _documents;\n        this._provider = _provider;\n        this._logService = _logService;\n    }\n    async supportsAutomaticNewSymbolNamesTriggerKind() {\n        return this._provider.supportsAutomaticTriggerKind;\n    }\n    async provideNewSymbolNames(resource, range, triggerKind, token) {\n        const doc = this._documents.getDocument(resource);\n        const pos = Range.to(range);\n        try {\n            const kind = NewSymbolNamesAdapter.languageTriggerKindToVSCodeTriggerKind[triggerKind];\n            const value = await this._provider.provideNewSymbolNames(doc, pos, kind, token);\n            if (!value) {\n                return undefined;\n            }\n            return (\n                 (value.map(\n                    v => typeof v === 'string'\n                        ? { newSymbolName: v }\n                        : { newSymbolName: v.newSymbolName, tags: v.tags }\n                ))\n            );\n        }\n        catch (err) {\n            this._logService.error(NewSymbolNamesAdapter._asMessage(err) ?? JSON.stringify(err, null, '\\t') );\n            return undefined;\n        }\n    }\n    static _asMessage(err) {\n        if (typeof err === 'string') {\n            return err;\n        }\n        else if (err instanceof Error && typeof err.message === 'string') {\n            return err.message;\n        }\n        else {\n            return undefined;\n        }\n    }\n}\nclass SemanticTokensPreviousResult {\n    constructor(resultId, tokens) {\n        this.resultId = resultId;\n        this.tokens = tokens;\n    }\n}\nclass DocumentSemanticTokensAdapter {\n    constructor(_documents, _provider) {\n        this._documents = _documents;\n        this._provider = _provider;\n        this._nextResultId = 1;\n        this._previousResults = ( (new Map()));\n    }\n    async provideDocumentSemanticTokens(resource, previousResultId, token) {\n        const doc = this._documents.getDocument(resource);\n        const previousResult = (previousResultId !== 0 ? this._previousResults.get(previousResultId) : null);\n        let value = typeof previousResult?.resultId === 'string' && typeof this._provider.provideDocumentSemanticTokensEdits === 'function'\n            ? await this._provider.provideDocumentSemanticTokensEdits(doc, previousResult.resultId, token)\n            : await this._provider.provideDocumentSemanticTokens(doc, token);\n        if (previousResult) {\n            this._previousResults.delete(previousResultId);\n        }\n        if (!value) {\n            return null;\n        }\n        value = DocumentSemanticTokensAdapter._fixProvidedSemanticTokens(value);\n        return this._send(DocumentSemanticTokensAdapter._convertToEdits(previousResult, value), value);\n    }\n    async releaseDocumentSemanticColoring(semanticColoringResultId) {\n        this._previousResults.delete(semanticColoringResultId);\n    }\n    static _fixProvidedSemanticTokens(v) {\n        if (DocumentSemanticTokensAdapter._isSemanticTokens(v)) {\n            if (DocumentSemanticTokensAdapter._isCorrectSemanticTokens(v)) {\n                return v;\n            }\n            return (\n                 (new SemanticTokens( (new Uint32Array(v.data)), v.resultId))\n            );\n        }\n        else if (DocumentSemanticTokensAdapter._isSemanticTokensEdits(v)) {\n            if (DocumentSemanticTokensAdapter._isCorrectSemanticTokensEdits(v)) {\n                return v;\n            }\n            return (\n                 (new SemanticTokensEdits( (v.edits.map(edit => ( (new SemanticTokensEdit(\n                    edit.start,\n                    edit.deleteCount,\n                    edit.data ? ( (new Uint32Array(edit.data))) : edit.data\n                ))))), v.resultId))\n            );\n        }\n        return v;\n    }\n    static _isSemanticTokens(v) {\n        return v && !!(v.data);\n    }\n    static _isCorrectSemanticTokens(v) {\n        return (v.data instanceof Uint32Array);\n    }\n    static _isSemanticTokensEdits(v) {\n        return v && Array.isArray(v.edits);\n    }\n    static _isCorrectSemanticTokensEdits(v) {\n        for (const edit of v.edits) {\n            if (!(edit.data instanceof Uint32Array)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _convertToEdits(previousResult, newResult) {\n        if (!DocumentSemanticTokensAdapter._isSemanticTokens(newResult)) {\n            return newResult;\n        }\n        if (!previousResult || !previousResult.tokens) {\n            return newResult;\n        }\n        const oldData = previousResult.tokens;\n        const oldLength = oldData.length;\n        const newData = newResult.data;\n        const newLength = newData.length;\n        let commonPrefixLength = 0;\n        const maxCommonPrefixLength = Math.min(oldLength, newLength);\n        while (commonPrefixLength < maxCommonPrefixLength && oldData[commonPrefixLength] === newData[commonPrefixLength]) {\n            commonPrefixLength++;\n        }\n        if (commonPrefixLength === oldLength && commonPrefixLength === newLength) {\n            return (\n                 (new SemanticTokensEdits([], newResult.resultId))\n            );\n        }\n        let commonSuffixLength = 0;\n        const maxCommonSuffixLength = maxCommonPrefixLength - commonPrefixLength;\n        while (commonSuffixLength < maxCommonSuffixLength && oldData[oldLength - commonSuffixLength - 1] === newData[newLength - commonSuffixLength - 1]) {\n            commonSuffixLength++;\n        }\n        return (\n             (new SemanticTokensEdits([{\n                    start: commonPrefixLength,\n                    deleteCount: (oldLength - commonPrefixLength - commonSuffixLength),\n                    data: newData.subarray(commonPrefixLength, newLength - commonSuffixLength)\n                }], newResult.resultId))\n        );\n    }\n    _send(value, original) {\n        if (DocumentSemanticTokensAdapter._isSemanticTokens(value)) {\n            const myId = this._nextResultId++;\n            this._previousResults.set(myId, ( (new SemanticTokensPreviousResult(value.resultId, value.data))));\n            return encodeSemanticTokensDto({\n                id: myId,\n                type: 'full',\n                data: value.data\n            });\n        }\n        if (DocumentSemanticTokensAdapter._isSemanticTokensEdits(value)) {\n            const myId = this._nextResultId++;\n            if (DocumentSemanticTokensAdapter._isSemanticTokens(original)) {\n                this._previousResults.set(myId, ( (new SemanticTokensPreviousResult(original.resultId, original.data))));\n            }\n            else {\n                this._previousResults.set(myId, ( (new SemanticTokensPreviousResult(value.resultId))));\n            }\n            return encodeSemanticTokensDto({\n                id: myId,\n                type: 'delta',\n                deltas: ( ((value.edits || []).map(\n                    edit => ({ start: edit.start, deleteCount: edit.deleteCount, data: edit.data })\n                )))\n            });\n        }\n        return null;\n    }\n}\nclass DocumentRangeSemanticTokensAdapter {\n    constructor(_documents, _provider) {\n        this._documents = _documents;\n        this._provider = _provider;\n    }\n    async provideDocumentRangeSemanticTokens(resource, range, token) {\n        const doc = this._documents.getDocument(resource);\n        const value = await this._provider.provideDocumentRangeSemanticTokens(doc, Range.to(range), token);\n        if (!value) {\n            return null;\n        }\n        return this._send(value);\n    }\n    _send(value) {\n        return encodeSemanticTokensDto({\n            id: 0,\n            type: 'full',\n            data: value.data\n        });\n    }\n}\nclass CompletionsAdapter {\n    static supportsResolving(provider) {\n        return typeof provider.resolveCompletionItem === 'function';\n    }\n    constructor(_documents, _commands, _provider, _apiDeprecation, _extension) {\n        this._documents = _documents;\n        this._commands = _commands;\n        this._provider = _provider;\n        this._apiDeprecation = _apiDeprecation;\n        this._extension = _extension;\n        this._cache = ( (new Cache('CompletionItem')));\n        this._disposables = ( (new Map()));\n    }\n    async provideCompletionItems(resource, position, context, token) {\n        const doc = this._documents.getDocument(resource);\n        const pos = Position.to(position);\n        const replaceRange = doc.getWordRangeAtPosition(pos) || ( (new Range$2(pos, pos)));\n        const insertRange = replaceRange.with({ end: pos });\n        const sw = ( (new StopWatch()));\n        const itemsOrList = await this._provider.provideCompletionItems(doc, pos, token, CompletionContext.to(context));\n        if (!itemsOrList) {\n            return undefined;\n        }\n        if (token.isCancellationRequested) {\n            return undefined;\n        }\n        const list = Array.isArray(itemsOrList) ? ( (new CompletionList(itemsOrList))) : itemsOrList;\n        const pid = CompletionsAdapter.supportsResolving(this._provider) ? this._cache.add(list.items) : this._cache.add([]);\n        const disposables = ( (new DisposableStore()));\n        this._disposables.set(pid, disposables);\n        const completions = [];\n        const result = {\n            x: pid,\n            [\"b\" ]: completions,\n            [\"a\" ]: { replace: Range.from(replaceRange), insert: Range.from(insertRange) },\n            [\"c\" ]: list.isIncomplete || undefined,\n            [\"d\" ]: sw.elapsed()\n        };\n        for (let i = 0; i < list.items.length; i++) {\n            const item = list.items[i];\n            const dto = this._convertCompletionItem(item, [pid, i], insertRange, replaceRange);\n            completions.push(dto);\n        }\n        return result;\n    }\n    async resolveCompletionItem(id, token) {\n        if (typeof this._provider.resolveCompletionItem !== 'function') {\n            return undefined;\n        }\n        const item = this._cache.get(...id);\n        if (!item) {\n            return undefined;\n        }\n        const dto1 = this._convertCompletionItem(item, id);\n        const resolvedItem = await this._provider.resolveCompletionItem(item, token);\n        if (!resolvedItem) {\n            return undefined;\n        }\n        const dto2 = this._convertCompletionItem(resolvedItem, id);\n        if (dto1[\"h\" ] !== dto2[\"h\" ]\n            || dto1[\"i\" ] !== dto2[\"i\" ]) {\n            this._apiDeprecation.report('CompletionItem.insertText', this._extension, 'extension MAY NOT change \\'insertText\\' of a CompletionItem during resolve');\n        }\n        if (dto1[\"n\" ] !== dto2[\"n\" ]\n            || dto1[\"o\" ] !== dto2[\"o\" ]\n            || !equals(dto1[\"p\" ], dto2[\"p\" ])) {\n            this._apiDeprecation.report('CompletionItem.command', this._extension, 'extension MAY NOT change \\'command\\' of a CompletionItem during resolve');\n        }\n        return {\n            ...dto1,\n            [\"d\" ]: dto2[\"d\" ],\n            [\"c\" ]: dto2[\"c\" ],\n            [\"l\" ]: dto2[\"l\" ],\n            [\"h\" ]: dto2[\"h\" ],\n            [\"i\" ]: dto2[\"i\" ],\n            [\"n\" ]: dto2[\"n\" ],\n            [\"o\" ]: dto2[\"o\" ],\n            [\"p\" ]: dto2[\"p\" ],\n        };\n    }\n    releaseCompletionItems(id) {\n        this._disposables.get(id)?.dispose();\n        this._disposables.delete(id);\n        this._cache.delete(id);\n    }\n    _convertCompletionItem(item, id, defaultInsertRange, defaultReplaceRange) {\n        const disposables = this._disposables.get(id[0]);\n        if (!disposables) {\n            throw Error('DisposableStore is missing...');\n        }\n        const command = this._commands.toInternal(item.command, disposables);\n        const result = {\n            x: id,\n            [\"a\" ]: item.label,\n            [\"b\" ]: item.kind !== undefined ? CompletionItemKind.from(item.kind) : undefined,\n            [\"m\" ]: item.tags && ( (item.tags.map(CompletionItemTag.from))),\n            [\"c\" ]: item.detail,\n            [\"d\" ]: typeof item.documentation === 'undefined' ? undefined : MarkdownString.fromStrict(item.documentation),\n            [\"e\" ]: item.sortText !== item.label ? item.sortText : undefined,\n            [\"f\" ]: item.filterText !== item.label ? item.filterText : undefined,\n            [\"g\" ]: item.preselect || undefined,\n            [\"i\" ]: item.keepWhitespace ? 1  : 0 ,\n            [\"k\" ]: item.commitCharacters?.join(''),\n            [\"l\" ]: item.additionalTextEdits && ( (item.additionalTextEdits.map(TextEdit.from))),\n            [\"n\" ]: command?.$ident,\n            [\"o\" ]: command?.id,\n            [\"p\" ]: command?.$ident ? undefined : command?.arguments,\n        };\n        if (item.textEdit) {\n            this._apiDeprecation.report('CompletionItem.textEdit', this._extension, `Use 'CompletionItem.insertText' and 'CompletionItem.range' instead.`);\n            result[\"h\" ] = item.textEdit.newText;\n        }\n        else if (typeof item.insertText === 'string') {\n            result[\"h\" ] = item.insertText;\n        }\n        else if (item.insertText instanceof SnippetString) {\n            result[\"h\" ] = item.insertText.value;\n            result[\"i\" ] |= 4 ;\n        }\n        let range;\n        if (item.textEdit) {\n            range = item.textEdit.range;\n        }\n        else if (item.range) {\n            range = item.range;\n        }\n        if (Range$2.isRange(range)) {\n            result[\"j\" ] = Range.from(range);\n        }\n        else if (range && (!defaultInsertRange?.isEqual(range.inserting) || !defaultReplaceRange?.isEqual(range.replacing))) {\n            result[\"j\" ] = {\n                insert: Range.from(range.inserting),\n                replace: Range.from(range.replacing)\n            };\n        }\n        return result;\n    }\n}\nclass InlineCompletionAdapterBase {\n    async provideInlineCompletions(resource, position, context, token) {\n        return undefined;\n    }\n    async provideInlineEditsForRange(resource, range, context, token) {\n        return undefined;\n    }\n    disposeCompletions(pid) { }\n    handleDidShowCompletionItem(pid, idx, updatedInsertText) { }\n    handlePartialAccept(pid, idx, acceptedCharacters, info) { }\n}\nclass InlineCompletionAdapter extends InlineCompletionAdapterBase {\n    constructor(_extension, _documents, _provider, _commands) {\n        super();\n        this._extension = _extension;\n        this._documents = _documents;\n        this._provider = _provider;\n        this._commands = _commands;\n        this._references = ( (new ReferenceMap()));\n        this._isAdditionsProposedApiEnabled = isProposedApiEnabled(this._extension, 'inlineCompletionsAdditions');\n        this.languageTriggerKindToVSCodeTriggerKind = {\n            [InlineCompletionTriggerKind.Automatic]: InlineCompletionTriggerKind$1.Automatic,\n            [InlineCompletionTriggerKind.Explicit]: InlineCompletionTriggerKind$1.Invoke,\n        };\n    }\n    get supportsHandleEvents() {\n        return isProposedApiEnabled(this._extension, 'inlineCompletionsAdditions')\n            && (typeof this._provider.handleDidShowCompletionItem === 'function'\n                || typeof this._provider.handleDidPartiallyAcceptCompletionItem === 'function');\n    }\n    async provideInlineCompletions(resource, position, context, token) {\n        const doc = this._documents.getDocument(resource);\n        const pos = Position.to(position);\n        const result = await this._provider.provideInlineCompletionItems(doc, pos, {\n            selectedCompletionInfo: context.selectedSuggestionInfo\n                ? {\n                    range: Range.to(context.selectedSuggestionInfo.range),\n                    text: context.selectedSuggestionInfo.text\n                }\n                : undefined,\n            triggerKind: this.languageTriggerKindToVSCodeTriggerKind[context.triggerKind]\n        }, token);\n        if (!result) {\n            return undefined;\n        }\n        if (token.isCancellationRequested) {\n            return undefined;\n        }\n        const normalizedResult = Array.isArray(result) ? result : result.items;\n        const commands = this._isAdditionsProposedApiEnabled ? Array.isArray(result) ? [] : result.commands || [] : [];\n        const enableForwardStability = this._isAdditionsProposedApiEnabled && !Array.isArray(result) ? result.enableForwardStability : undefined;\n        let disposableStore = undefined;\n        const pid = this._references.createReferenceId({\n            dispose() {\n                disposableStore?.dispose();\n            },\n            items: normalizedResult\n        });\n        return {\n            pid,\n            items: ( (normalizedResult.map((item, idx) => {\n                let command = undefined;\n                if (item.command) {\n                    if (!disposableStore) {\n                        disposableStore = ( (new DisposableStore()));\n                    }\n                    command = this._commands.toInternal(item.command, disposableStore);\n                }\n                const insertText = item.insertText;\n                return ({\n                    insertText: typeof insertText === 'string' ? insertText : { snippet: insertText.value },\n                    filterText: item.filterText,\n                    range: item.range ? Range.from(item.range) : undefined,\n                    command,\n                    idx: idx,\n                    completeBracketPairs: this._isAdditionsProposedApiEnabled ? item.completeBracketPairs : false,\n                });\n            }))),\n            commands: ( (commands.map(c => {\n                if (!disposableStore) {\n                    disposableStore = ( (new DisposableStore()));\n                }\n                return this._commands.toInternal(c, disposableStore);\n            }))),\n            suppressSuggestions: false,\n            enableForwardStability,\n        };\n    }\n    async provideInlineEditsForRange(resource, range, context, token) {\n        if (!this._provider.provideInlineEditsForRange) {\n            return undefined;\n        }\n        checkProposedApiEnabled(this._extension, 'inlineCompletionsAdditions');\n        const doc = this._documents.getDocument(resource);\n        const r = Range.to(range);\n        const result = await this._provider.provideInlineEditsForRange(doc, r, {\n            selectedCompletionInfo: context.selectedSuggestionInfo\n                ? {\n                    range: Range.to(context.selectedSuggestionInfo.range),\n                    text: context.selectedSuggestionInfo.text\n                }\n                : undefined,\n            triggerKind: this.languageTriggerKindToVSCodeTriggerKind[context.triggerKind],\n            userPrompt: context.userPrompt,\n        }, token);\n        if (!result) {\n            return undefined;\n        }\n        if (token.isCancellationRequested) {\n            return undefined;\n        }\n        const normalizedResult = Array.isArray(result) ? result : result.items;\n        const commands = this._isAdditionsProposedApiEnabled ? Array.isArray(result) ? [] : result.commands || [] : [];\n        const enableForwardStability = this._isAdditionsProposedApiEnabled && !Array.isArray(result) ? result.enableForwardStability : undefined;\n        let disposableStore = undefined;\n        const pid = this._references.createReferenceId({\n            dispose() {\n                disposableStore?.dispose();\n            },\n            items: normalizedResult\n        });\n        return {\n            pid,\n            items: ( (normalizedResult.map((item, idx) => {\n                let command = undefined;\n                if (item.command) {\n                    if (!disposableStore) {\n                        disposableStore = ( (new DisposableStore()));\n                    }\n                    command = this._commands.toInternal(item.command, disposableStore);\n                }\n                const insertText = item.insertText;\n                return ({\n                    insertText: typeof insertText === 'string' ? insertText : { snippet: insertText.value },\n                    filterText: item.filterText,\n                    range: item.range ? Range.from(item.range) : undefined,\n                    command,\n                    idx: idx,\n                    completeBracketPairs: this._isAdditionsProposedApiEnabled ? item.completeBracketPairs : false,\n                });\n            }))),\n            commands: ( (commands.map(c => {\n                if (!disposableStore) {\n                    disposableStore = ( (new DisposableStore()));\n                }\n                return this._commands.toInternal(c, disposableStore);\n            }))),\n            suppressSuggestions: false,\n            enableForwardStability,\n        };\n    }\n    disposeCompletions(pid) {\n        const data = this._references.disposeReferenceId(pid);\n        data?.dispose();\n    }\n    handleDidShowCompletionItem(pid, idx, updatedInsertText) {\n        const completionItem = this._references.get(pid)?.items[idx];\n        if (completionItem) {\n            if (this._provider.handleDidShowCompletionItem && this._isAdditionsProposedApiEnabled) {\n                this._provider.handleDidShowCompletionItem(completionItem, updatedInsertText);\n            }\n        }\n    }\n    handlePartialAccept(pid, idx, acceptedCharacters, info) {\n        const completionItem = this._references.get(pid)?.items[idx];\n        if (completionItem) {\n            if (this._provider.handleDidPartiallyAcceptCompletionItem && this._isAdditionsProposedApiEnabled) {\n                this._provider.handleDidPartiallyAcceptCompletionItem(completionItem, acceptedCharacters);\n                this._provider.handleDidPartiallyAcceptCompletionItem(completionItem, PartialAcceptInfo.to(info));\n            }\n        }\n    }\n}\nclass InlineEditAdapter {\n    async provideInlineEdits(uri, context, token) {\n        const doc = this._documents.getDocument(uri);\n        const result = await this._provider.provideInlineEdit(doc, {\n            triggerKind: this.languageTriggerKindToVSCodeTriggerKind[context.triggerKind]\n        }, token);\n        if (!result) {\n            return undefined;\n        }\n        if (token.isCancellationRequested) {\n            return undefined;\n        }\n        let disposableStore = undefined;\n        const pid = this._references.createReferenceId({\n            dispose() {\n                disposableStore?.dispose();\n            },\n            item: result\n        });\n        let acceptCommand = undefined;\n        if (result.accepted) {\n            if (!disposableStore) {\n                disposableStore = ( (new DisposableStore()));\n            }\n            acceptCommand = this._commands.toInternal(result.accepted, disposableStore);\n        }\n        let rejectCommand = undefined;\n        if (result.rejected) {\n            if (!disposableStore) {\n                disposableStore = ( (new DisposableStore()));\n            }\n            rejectCommand = this._commands.toInternal(result.rejected, disposableStore);\n        }\n        const langResult = {\n            pid,\n            text: result.text,\n            range: Range.from(result.range),\n            accepted: acceptCommand,\n            rejected: rejectCommand,\n        };\n        return langResult;\n    }\n    disposeEdit(pid) {\n        const data = this._references.disposeReferenceId(pid);\n        data?.dispose();\n    }\n    constructor(_extension, _documents, _provider, _commands) {\n        this._documents = _documents;\n        this._provider = _provider;\n        this._commands = _commands;\n        this._references = ( (new ReferenceMap()));\n        this.languageTriggerKindToVSCodeTriggerKind = {\n            [InlineEditTriggerKind.Automatic]: InlineEditTriggerKind$1.Automatic,\n            [InlineEditTriggerKind.Invoke]: InlineEditTriggerKind$1.Invoke,\n        };\n    }\n}\nclass ReferenceMap {\n    constructor() {\n        this._references = ( (new Map()));\n        this._idPool = 1;\n    }\n    createReferenceId(value) {\n        const id = this._idPool++;\n        this._references.set(id, value);\n        return id;\n    }\n    disposeReferenceId(referenceId) {\n        const value = this._references.get(referenceId);\n        this._references.delete(referenceId);\n        return value;\n    }\n    get(referenceId) {\n        return this._references.get(referenceId);\n    }\n}\nclass SignatureHelpAdapter {\n    constructor(_documents, _provider) {\n        this._documents = _documents;\n        this._provider = _provider;\n        this._cache = ( (new Cache('SignatureHelp')));\n    }\n    async provideSignatureHelp(resource, position, context, token) {\n        const doc = this._documents.getDocument(resource);\n        const pos = Position.to(position);\n        const vscodeContext = this.reviveContext(context);\n        const value = await this._provider.provideSignatureHelp(doc, pos, token, vscodeContext);\n        if (value) {\n            const id = this._cache.add([value]);\n            return { ...SignatureHelp.from(value), id };\n        }\n        return undefined;\n    }\n    reviveContext(context) {\n        let activeSignatureHelp = undefined;\n        if (context.activeSignatureHelp) {\n            const revivedSignatureHelp = SignatureHelp.to(context.activeSignatureHelp);\n            const saved = this._cache.get(context.activeSignatureHelp.id, 0);\n            if (saved) {\n                activeSignatureHelp = saved;\n                activeSignatureHelp.activeSignature = revivedSignatureHelp.activeSignature;\n                activeSignatureHelp.activeParameter = revivedSignatureHelp.activeParameter;\n            }\n            else {\n                activeSignatureHelp = revivedSignatureHelp;\n            }\n        }\n        return { ...context, activeSignatureHelp };\n    }\n    releaseSignatureHelp(id) {\n        this._cache.delete(id);\n    }\n}\nclass InlayHintsAdapter {\n    constructor(_documents, _commands, _provider, _logService, _extension) {\n        this._documents = _documents;\n        this._commands = _commands;\n        this._provider = _provider;\n        this._logService = _logService;\n        this._extension = _extension;\n        this._cache = ( (new Cache('InlayHints')));\n        this._disposables = ( (new Map()));\n    }\n    async provideInlayHints(resource, ran, token) {\n        const doc = this._documents.getDocument(resource);\n        const range = Range.to(ran);\n        const hints = await this._provider.provideInlayHints(doc, range, token);\n        if (!Array.isArray(hints) || hints.length === 0) {\n            this._logService.trace(`[InlayHints] NO inlay hints from '${this._extension.identifier.value}' for range ${JSON.stringify(ran)}`);\n            return undefined;\n        }\n        if (token.isCancellationRequested) {\n            return undefined;\n        }\n        const pid = this._cache.add(hints);\n        this._disposables.set(pid, ( (new DisposableStore())));\n        const result = { hints: [], cacheId: pid };\n        for (let i = 0; i < hints.length; i++) {\n            if (this._isValidInlayHint(hints[i], range)) {\n                result.hints.push(this._convertInlayHint(hints[i], [pid, i]));\n            }\n        }\n        this._logService.trace(`[InlayHints] ${result.hints.length} inlay hints from '${this._extension.identifier.value}' for range ${JSON.stringify(ran)}`);\n        return result;\n    }\n    async resolveInlayHint(id, token) {\n        if (typeof this._provider.resolveInlayHint !== 'function') {\n            return undefined;\n        }\n        const item = this._cache.get(...id);\n        if (!item) {\n            return undefined;\n        }\n        const hint = await this._provider.resolveInlayHint(item, token);\n        if (!hint) {\n            return undefined;\n        }\n        if (!this._isValidInlayHint(hint)) {\n            return undefined;\n        }\n        return this._convertInlayHint(hint, id);\n    }\n    releaseHints(id) {\n        this._disposables.get(id)?.dispose();\n        this._disposables.delete(id);\n        this._cache.delete(id);\n    }\n    _isValidInlayHint(hint, range) {\n        if (hint.label.length === 0 || Array.isArray(hint.label) && hint.label.every(part => part.value.length === 0)) {\n            console.log('INVALID inlay hint, empty label', hint);\n            return false;\n        }\n        if (range && !range.contains(hint.position)) {\n            return false;\n        }\n        return true;\n    }\n    _convertInlayHint(hint, id) {\n        const disposables = this._disposables.get(id[0]);\n        if (!disposables) {\n            throw Error('DisposableStore is missing...');\n        }\n        const result = {\n            label: '',\n            cacheId: id,\n            tooltip: MarkdownString.fromStrict(hint.tooltip),\n            position: Position.from(hint.position),\n            textEdits: hint.textEdits && ( (hint.textEdits.map(TextEdit.from))),\n            kind: hint.kind && InlayHintKind.from(hint.kind),\n            paddingLeft: hint.paddingLeft,\n            paddingRight: hint.paddingRight,\n        };\n        if (typeof hint.label === 'string') {\n            result.label = hint.label;\n        }\n        else {\n            const parts = [];\n            result.label = parts;\n            for (const part of hint.label) {\n                if (!part.value) {\n                    console.warn('INVALID inlay hint, empty label part', this._extension.identifier.value);\n                    continue;\n                }\n                const part2 = {\n                    label: part.value,\n                    tooltip: MarkdownString.fromStrict(part.tooltip)\n                };\n                if (Location.isLocation(part.location)) {\n                    part2.location = location.from(part.location);\n                }\n                if (part.command) {\n                    part2.command = this._commands.toInternal(part.command, disposables);\n                }\n                parts.push(part2);\n            }\n        }\n        return result;\n    }\n}\nclass LinkProviderAdapter {\n    constructor(_documents, _provider) {\n        this._documents = _documents;\n        this._provider = _provider;\n        this._cache = ( (new Cache('DocumentLink')));\n    }\n    async provideLinks(resource, token) {\n        const doc = this._documents.getDocument(resource);\n        const links = await this._provider.provideDocumentLinks(doc, token);\n        if (!Array.isArray(links) || links.length === 0) {\n            return undefined;\n        }\n        if (token.isCancellationRequested) {\n            return undefined;\n        }\n        if (typeof this._provider.resolveDocumentLink !== 'function') {\n            return { links: ( (links.filter(LinkProviderAdapter._validateLink).map(DocumentLink.from))) };\n        }\n        else {\n            const pid = this._cache.add(links);\n            const result = { links: [], cacheId: pid };\n            for (let i = 0; i < links.length; i++) {\n                if (!LinkProviderAdapter._validateLink(links[i])) {\n                    continue;\n                }\n                const dto = DocumentLink.from(links[i]);\n                dto.cacheId = [pid, i];\n                result.links.push(dto);\n            }\n            return result;\n        }\n    }\n    static _validateLink(link) {\n        if (link.target && link.target.path.length > 50_000) {\n            console.warn('DROPPING link because it is too long');\n            return false;\n        }\n        return true;\n    }\n    async resolveLink(id, token) {\n        if (typeof this._provider.resolveDocumentLink !== 'function') {\n            return undefined;\n        }\n        const item = this._cache.get(...id);\n        if (!item) {\n            return undefined;\n        }\n        const link = await this._provider.resolveDocumentLink(item, token);\n        if (!link || !LinkProviderAdapter._validateLink(link)) {\n            return undefined;\n        }\n        return DocumentLink.from(link);\n    }\n    releaseLinks(id) {\n        this._cache.delete(id);\n    }\n}\nclass ColorProviderAdapter {\n    constructor(_documents, _provider) {\n        this._documents = _documents;\n        this._provider = _provider;\n    }\n    async provideColors(resource, token) {\n        const doc = this._documents.getDocument(resource);\n        const colors = await this._provider.provideDocumentColors(doc, token);\n        if (!Array.isArray(colors)) {\n            return [];\n        }\n        const colorInfos = ( (colors.map(ci => {\n            return {\n                color: Color.from(ci.color),\n                range: Range.from(ci.range)\n            };\n        })));\n        return colorInfos;\n    }\n    async provideColorPresentations(resource, raw, token) {\n        const document = this._documents.getDocument(resource);\n        const range = Range.to(raw.range);\n        const color = Color.to(raw.color);\n        const value = await this._provider.provideColorPresentations(color, { document, range }, token);\n        if (!Array.isArray(value)) {\n            return undefined;\n        }\n        return (\n             (value.map(ColorPresentation.from))\n        );\n    }\n}\nclass FoldingProviderAdapter {\n    constructor(_documents, _provider) {\n        this._documents = _documents;\n        this._provider = _provider;\n    }\n    async provideFoldingRanges(resource, context, token) {\n        const doc = this._documents.getDocument(resource);\n        const ranges = await this._provider.provideFoldingRanges(doc, context, token);\n        if (!Array.isArray(ranges)) {\n            return undefined;\n        }\n        return (\n             (ranges.map(FoldingRange.from))\n        );\n    }\n}\nclass SelectionRangeAdapter {\n    constructor(_documents, _provider, _logService) {\n        this._documents = _documents;\n        this._provider = _provider;\n        this._logService = _logService;\n    }\n    async provideSelectionRanges(resource, pos, token) {\n        const document = this._documents.getDocument(resource);\n        const positions = ( (pos.map(Position.to)));\n        const allProviderRanges = await this._provider.provideSelectionRanges(document, positions, token);\n        if (!isNonEmptyArray(allProviderRanges)) {\n            return [];\n        }\n        if (allProviderRanges.length !== positions.length) {\n            this._logService.warn('BAD selection ranges, provider must return ranges for each position');\n            return [];\n        }\n        const allResults = [];\n        for (let i = 0; i < positions.length; i++) {\n            const oneResult = [];\n            allResults.push(oneResult);\n            let last = positions[i];\n            let selectionRange = allProviderRanges[i];\n            while (true) {\n                if (!selectionRange.range.contains(last)) {\n                    throw ( (new Error('INVALID selection range, must contain the previous range')));\n                }\n                oneResult.push(SelectionRange.from(selectionRange));\n                if (!selectionRange.parent) {\n                    break;\n                }\n                last = selectionRange.range;\n                selectionRange = selectionRange.parent;\n            }\n        }\n        return allResults;\n    }\n}\nclass CallHierarchyAdapter {\n    constructor(_documents, _provider) {\n        this._documents = _documents;\n        this._provider = _provider;\n        this._idPool = ( (new IdGenerator('')));\n        this._cache = ( (new Map()));\n    }\n    async prepareSession(uri, position, token) {\n        const doc = this._documents.getDocument(uri);\n        const pos = Position.to(position);\n        const items = await this._provider.prepareCallHierarchy(doc, pos, token);\n        if (!items) {\n            return undefined;\n        }\n        const sessionId = this._idPool.nextId();\n        this._cache.set(sessionId, ( (new Map())));\n        if (Array.isArray(items)) {\n            return (\n                 (items.map(item => this._cacheAndConvertItem(sessionId, item)))\n            );\n        }\n        else {\n            return [this._cacheAndConvertItem(sessionId, items)];\n        }\n    }\n    async provideCallsTo(sessionId, itemId, token) {\n        const item = this._itemFromCache(sessionId, itemId);\n        if (!item) {\n            throw ( (new Error('missing call hierarchy item')));\n        }\n        const calls = await this._provider.provideCallHierarchyIncomingCalls(item, token);\n        if (!calls) {\n            return undefined;\n        }\n        return (\n             (calls.map(call => {\n                return {\n                    from: this._cacheAndConvertItem(sessionId, call.from),\n                    fromRanges: ( (call.fromRanges.map(r => Range.from(r))))\n                };\n            }))\n        );\n    }\n    async provideCallsFrom(sessionId, itemId, token) {\n        const item = this._itemFromCache(sessionId, itemId);\n        if (!item) {\n            throw ( (new Error('missing call hierarchy item')));\n        }\n        const calls = await this._provider.provideCallHierarchyOutgoingCalls(item, token);\n        if (!calls) {\n            return undefined;\n        }\n        return (\n             (calls.map(call => {\n                return {\n                    to: this._cacheAndConvertItem(sessionId, call.to),\n                    fromRanges: ( (call.fromRanges.map(r => Range.from(r))))\n                };\n            }))\n        );\n    }\n    releaseSession(sessionId) {\n        this._cache.delete(sessionId);\n    }\n    _cacheAndConvertItem(sessionId, item) {\n        const map = this._cache.get(sessionId);\n        const dto = CallHierarchyItem.from(item, sessionId, ( (map.size.toString(36))));\n        map.set(dto._itemId, item);\n        return dto;\n    }\n    _itemFromCache(sessionId, itemId) {\n        const map = this._cache.get(sessionId);\n        return map?.get(itemId);\n    }\n}\nclass TypeHierarchyAdapter {\n    constructor(_documents, _provider) {\n        this._documents = _documents;\n        this._provider = _provider;\n        this._idPool = ( (new IdGenerator('')));\n        this._cache = ( (new Map()));\n    }\n    async prepareSession(uri, position, token) {\n        const doc = this._documents.getDocument(uri);\n        const pos = Position.to(position);\n        const items = await this._provider.prepareTypeHierarchy(doc, pos, token);\n        if (!items) {\n            return undefined;\n        }\n        const sessionId = this._idPool.nextId();\n        this._cache.set(sessionId, ( (new Map())));\n        if (Array.isArray(items)) {\n            return (\n                 (items.map(item => this._cacheAndConvertItem(sessionId, item)))\n            );\n        }\n        else {\n            return [this._cacheAndConvertItem(sessionId, items)];\n        }\n    }\n    async provideSupertypes(sessionId, itemId, token) {\n        const item = this._itemFromCache(sessionId, itemId);\n        if (!item) {\n            throw ( (new Error('missing type hierarchy item')));\n        }\n        const supertypes = await this._provider.provideTypeHierarchySupertypes(item, token);\n        if (!supertypes) {\n            return undefined;\n        }\n        return (\n             (supertypes.map(supertype => {\n                return this._cacheAndConvertItem(sessionId, supertype);\n            }))\n        );\n    }\n    async provideSubtypes(sessionId, itemId, token) {\n        const item = this._itemFromCache(sessionId, itemId);\n        if (!item) {\n            throw ( (new Error('missing type hierarchy item')));\n        }\n        const subtypes = await this._provider.provideTypeHierarchySubtypes(item, token);\n        if (!subtypes) {\n            return undefined;\n        }\n        return (\n             (subtypes.map(subtype => {\n                return this._cacheAndConvertItem(sessionId, subtype);\n            }))\n        );\n    }\n    releaseSession(sessionId) {\n        this._cache.delete(sessionId);\n    }\n    _cacheAndConvertItem(sessionId, item) {\n        const map = this._cache.get(sessionId);\n        const dto = TypeHierarchyItem.from(item, sessionId, ( (map.size.toString(36))));\n        map.set(dto._itemId, item);\n        return dto;\n    }\n    _itemFromCache(sessionId, itemId) {\n        const map = this._cache.get(sessionId);\n        return map?.get(itemId);\n    }\n}\nclass DocumentDropEditAdapter {\n    constructor(_proxy, _documents, _provider, _handle, _extension) {\n        this._proxy = _proxy;\n        this._documents = _documents;\n        this._provider = _provider;\n        this._handle = _handle;\n        this._extension = _extension;\n        this._cache = ( (new Cache('DocumentDropEdit')));\n    }\n    async provideDocumentOnDropEdits(requestId, uri, position, dataTransferDto, token) {\n        const doc = this._documents.getDocument(uri);\n        const pos = Position.to(position);\n        const dataTransfer = DataTransfer.toDataTransfer(dataTransferDto, async (id) => {\n            return (await this._proxy.$resolveDocumentOnDropFileData(this._handle, requestId, id)).buffer;\n        });\n        const edits = await this._provider.provideDocumentDropEdits(doc, pos, dataTransfer, token);\n        if (!edits) {\n            return undefined;\n        }\n        const editsArray = asArray(edits);\n        const cacheId = this._cache.add(editsArray);\n        return (\n             (editsArray.map((edit, i) => ({\n                _cacheId: [cacheId, i],\n                title: edit.title ?? ( localize(\n                    4799,\n                    \"Drop using '{0}' extension\",\n                    this._extension.displayName || this._extension.name\n                )),\n                kind: edit.kind?.value,\n                yieldTo: edit.yieldTo?.map(x => x.value),\n                insertText: typeof edit.insertText === 'string' ? edit.insertText : { snippet: edit.insertText.value },\n                additionalEdit: edit.additionalEdit ? WorkspaceEdit.from(edit.additionalEdit, undefined) : undefined,\n            })))\n        );\n    }\n    async resolveDropEdit(id, token) {\n        const [sessionId, itemId] = id;\n        const item = this._cache.get(sessionId, itemId);\n        if (!item || !this._provider.resolveDocumentDropEdit) {\n            return {};\n        }\n        const resolvedItem = (await this._provider.resolveDocumentDropEdit(item, token)) ?? item;\n        const additionalEdit = resolvedItem.additionalEdit ? WorkspaceEdit.from(resolvedItem.additionalEdit, undefined) : undefined;\n        return { additionalEdit };\n    }\n    releaseDropEdits(id) {\n        this._cache.delete(id);\n    }\n}\nclass MappedEditsAdapter {\n    constructor(_documents, _provider) {\n        this._documents = _documents;\n        this._provider = _provider;\n    }\n    async provideMappedEdits(resource, codeBlocks, context, token) {\n        const uri = URI.revive(resource);\n        const doc = this._documents.getDocument(uri);\n        const reviveContextItem = (item) => ({\n            uri: URI.revive(item.uri),\n            version: item.version,\n            ranges: ( (item.ranges.map(r => Range.to(r)))),\n        });\n        const usedContext = ( (context.documents.map(docSubArray => ( (docSubArray.map(reviveContextItem))))));\n        const ctx = {\n            documents: usedContext,\n            selections: usedContext[0]?.[0]?.ranges ?? [],\n            conversation: context.conversation?.map(c => {\n                if (c.type === 'response') {\n                    return {\n                        type: 'response',\n                        message: c.message,\n                        references: c.references?.map(reviveContextItem)\n                    };\n                }\n                else {\n                    return {\n                        type: 'request',\n                        message: c.message,\n                    };\n                }\n            })\n        };\n        const mappedEdits = await this._provider.provideMappedEdits(doc, codeBlocks, ctx, token);\n        return mappedEdits ? WorkspaceEdit.from(mappedEdits) : null;\n    }\n}\nclass AdapterData {\n    constructor(adapter, extension) {\n        this.adapter = adapter;\n        this.extension = extension;\n    }\n}\nclass ExtHostLanguageFeatures {\n    static { this._handlePool = 0; }\n    constructor(mainContext, _uriTransformer, _documents, _commands, _diagnostics, _logService, _apiDeprecation, _extensionTelemetry) {\n        this._uriTransformer = _uriTransformer;\n        this._documents = _documents;\n        this._commands = _commands;\n        this._diagnostics = _diagnostics;\n        this._logService = _logService;\n        this._apiDeprecation = _apiDeprecation;\n        this._extensionTelemetry = _extensionTelemetry;\n        this._adapter = ( (new Map()));\n        this._proxy = ( (mainContext.getProxy(MainContext.MainThreadLanguageFeatures)));\n    }\n    _transformDocumentSelector(selector, extension) {\n        return DocumentSelector.from(selector, this._uriTransformer, extension);\n    }\n    _createDisposable(handle) {\n        return (\n             (new Disposable(() => {\n                this._adapter.delete(handle);\n                this._proxy.$unregister(handle);\n            }))\n        );\n    }\n    _nextHandle() {\n        return ExtHostLanguageFeatures._handlePool++;\n    }\n    async _withAdapter(handle, ctor, callback, fallbackValue, tokenToRaceAgainst, doNotLog = false) {\n        const data = this._adapter.get(handle);\n        if (!data || !(data.adapter instanceof ctor)) {\n            return fallbackValue;\n        }\n        const t1 = Date.now();\n        if (!doNotLog) {\n            this._logService.trace(`[${data.extension.identifier.value}] INVOKE provider '${( (callback.toString())).replace(/[\\r\\n]/g, '')}'`);\n        }\n        const result = callback(data.adapter, data.extension);\n        Promise.resolve(result).catch(err => {\n            if (!isCancellationError(err)) {\n                this._logService.error(`[${data.extension.identifier.value}] provider FAILED`);\n                this._logService.error(err);\n                this._extensionTelemetry.onExtensionError(data.extension.identifier, err);\n            }\n        }).finally(() => {\n            if (!doNotLog) {\n                this._logService.trace(`[${data.extension.identifier.value}] provider DONE after ${Date.now() - t1}ms`);\n            }\n        });\n        if (CancellationToken.isCancellationToken(tokenToRaceAgainst)) {\n            return raceCancellationError(result, tokenToRaceAgainst);\n        }\n        return result;\n    }\n    _addNewAdapter(adapter, extension) {\n        const handle = this._nextHandle();\n        this._adapter.set(handle, ( (new AdapterData(adapter, extension))));\n        return handle;\n    }\n    static _extLabel(ext) {\n        return ext.displayName || ext.name;\n    }\n    static _extId(ext) {\n        return ext.identifier.value;\n    }\n    registerDocumentSymbolProvider(extension, selector, provider, metadata) {\n        const handle = this._addNewAdapter(( (new DocumentSymbolAdapter(this._documents, provider))), extension);\n        const displayName = (metadata && metadata.label) || ExtHostLanguageFeatures._extLabel(extension);\n        this._proxy.$registerDocumentSymbolProvider(handle, this._transformDocumentSelector(selector, extension), displayName);\n        return this._createDisposable(handle);\n    }\n    $provideDocumentSymbols(handle, resource, token) {\n        return this._withAdapter(handle, DocumentSymbolAdapter, adapter => adapter.provideDocumentSymbols(URI.revive(resource), token), undefined, token);\n    }\n    registerCodeLensProvider(extension, selector, provider) {\n        const handle = this._nextHandle();\n        const eventHandle = typeof provider.onDidChangeCodeLenses === 'function' ? this._nextHandle() : undefined;\n        this._adapter.set(handle, ( (new AdapterData( (new CodeLensAdapter(\n            this._documents,\n            this._commands.converter,\n            provider,\n            extension,\n            this._extensionTelemetry,\n            this._logService\n        )), extension))));\n        this._proxy.$registerCodeLensSupport(handle, this._transformDocumentSelector(selector, extension), eventHandle);\n        let result = this._createDisposable(handle);\n        if (eventHandle !== undefined) {\n            const subscription = provider.onDidChangeCodeLenses(_ => this._proxy.$emitCodeLensEvent(eventHandle));\n            result = Disposable.from(result, subscription);\n        }\n        return result;\n    }\n    $provideCodeLenses(handle, resource, token) {\n        return this._withAdapter(handle, CodeLensAdapter, adapter => adapter.provideCodeLenses(URI.revive(resource), token), undefined, token, resource.scheme === 'output');\n    }\n    $resolveCodeLens(handle, symbol, token) {\n        return this._withAdapter(handle, CodeLensAdapter, adapter => adapter.resolveCodeLens(symbol, token), undefined, undefined, true);\n    }\n    $releaseCodeLenses(handle, cacheId) {\n        this._withAdapter(handle, CodeLensAdapter, adapter => Promise.resolve(adapter.releaseCodeLenses(cacheId)), undefined, undefined, true);\n    }\n    registerDefinitionProvider(extension, selector, provider) {\n        const handle = this._addNewAdapter(( (new DefinitionAdapter(this._documents, provider))), extension);\n        this._proxy.$registerDefinitionSupport(handle, this._transformDocumentSelector(selector, extension));\n        return this._createDisposable(handle);\n    }\n    $provideDefinition(handle, resource, position, token) {\n        return this._withAdapter(handle, DefinitionAdapter, adapter => adapter.provideDefinition(URI.revive(resource), position, token), [], token);\n    }\n    registerDeclarationProvider(extension, selector, provider) {\n        const handle = this._addNewAdapter(( (new DeclarationAdapter(this._documents, provider))), extension);\n        this._proxy.$registerDeclarationSupport(handle, this._transformDocumentSelector(selector, extension));\n        return this._createDisposable(handle);\n    }\n    $provideDeclaration(handle, resource, position, token) {\n        return this._withAdapter(handle, DeclarationAdapter, adapter => adapter.provideDeclaration(URI.revive(resource), position, token), [], token);\n    }\n    registerImplementationProvider(extension, selector, provider) {\n        const handle = this._addNewAdapter(( (new ImplementationAdapter(this._documents, provider))), extension);\n        this._proxy.$registerImplementationSupport(handle, this._transformDocumentSelector(selector, extension));\n        return this._createDisposable(handle);\n    }\n    $provideImplementation(handle, resource, position, token) {\n        return this._withAdapter(handle, ImplementationAdapter, adapter => adapter.provideImplementation(URI.revive(resource), position, token), [], token);\n    }\n    registerTypeDefinitionProvider(extension, selector, provider) {\n        const handle = this._addNewAdapter(( (new TypeDefinitionAdapter(this._documents, provider))), extension);\n        this._proxy.$registerTypeDefinitionSupport(handle, this._transformDocumentSelector(selector, extension));\n        return this._createDisposable(handle);\n    }\n    $provideTypeDefinition(handle, resource, position, token) {\n        return this._withAdapter(handle, TypeDefinitionAdapter, adapter => adapter.provideTypeDefinition(URI.revive(resource), position, token), [], token);\n    }\n    registerHoverProvider(extension, selector, provider, extensionId) {\n        const handle = this._addNewAdapter(( (new HoverAdapter(this._documents, provider))), extension);\n        this._proxy.$registerHoverProvider(handle, this._transformDocumentSelector(selector, extension));\n        return this._createDisposable(handle);\n    }\n    $provideHover(handle, resource, position, context, token) {\n        return this._withAdapter(handle, HoverAdapter, adapter => adapter.provideHover(URI.revive(resource), position, context, token), undefined, token);\n    }\n    $releaseHover(handle, id) {\n        this._withAdapter(handle, HoverAdapter, adapter => Promise.resolve(adapter.releaseHover(id)), undefined, undefined);\n    }\n    registerEvaluatableExpressionProvider(extension, selector, provider, extensionId) {\n        const handle = this._addNewAdapter(( (new EvaluatableExpressionAdapter(this._documents, provider))), extension);\n        this._proxy.$registerEvaluatableExpressionProvider(handle, this._transformDocumentSelector(selector, extension));\n        return this._createDisposable(handle);\n    }\n    $provideEvaluatableExpression(handle, resource, position, token) {\n        return this._withAdapter(handle, EvaluatableExpressionAdapter, adapter => adapter.provideEvaluatableExpression(URI.revive(resource), position, token), undefined, token);\n    }\n    registerInlineValuesProvider(extension, selector, provider, extensionId) {\n        const eventHandle = typeof provider.onDidChangeInlineValues === 'function' ? this._nextHandle() : undefined;\n        const handle = this._addNewAdapter(( (new InlineValuesAdapter(this._documents, provider))), extension);\n        this._proxy.$registerInlineValuesProvider(handle, this._transformDocumentSelector(selector, extension), eventHandle);\n        let result = this._createDisposable(handle);\n        if (eventHandle !== undefined) {\n            const subscription = provider.onDidChangeInlineValues(_ => this._proxy.$emitInlineValuesEvent(eventHandle));\n            result = Disposable.from(result, subscription);\n        }\n        return result;\n    }\n    $provideInlineValues(handle, resource, range, context, token) {\n        return this._withAdapter(handle, InlineValuesAdapter, adapter => adapter.provideInlineValues(URI.revive(resource), range, context, token), undefined, token);\n    }\n    registerDocumentHighlightProvider(extension, selector, provider) {\n        const handle = this._addNewAdapter(( (new DocumentHighlightAdapter(this._documents, provider))), extension);\n        this._proxy.$registerDocumentHighlightProvider(handle, this._transformDocumentSelector(selector, extension));\n        return this._createDisposable(handle);\n    }\n    registerMultiDocumentHighlightProvider(extension, selector, provider) {\n        const handle = this._addNewAdapter(( (new MultiDocumentHighlightAdapter(this._documents, provider, this._logService))), extension);\n        this._proxy.$registerMultiDocumentHighlightProvider(handle, this._transformDocumentSelector(selector, extension));\n        return this._createDisposable(handle);\n    }\n    $provideDocumentHighlights(handle, resource, position, token) {\n        return this._withAdapter(handle, DocumentHighlightAdapter, adapter => adapter.provideDocumentHighlights(URI.revive(resource), position, token), undefined, token);\n    }\n    $provideMultiDocumentHighlights(handle, resource, position, otherModels, token) {\n        return this._withAdapter(handle, MultiDocumentHighlightAdapter, adapter => adapter.provideMultiDocumentHighlights(URI.revive(resource), position, ( (otherModels.map(model => URI.revive(model)))), token), undefined, token);\n    }\n    registerLinkedEditingRangeProvider(extension, selector, provider) {\n        const handle = this._addNewAdapter(( (new LinkedEditingRangeAdapter(this._documents, provider))), extension);\n        this._proxy.$registerLinkedEditingRangeProvider(handle, this._transformDocumentSelector(selector, extension));\n        return this._createDisposable(handle);\n    }\n    $provideLinkedEditingRanges(handle, resource, position, token) {\n        return this._withAdapter(handle, LinkedEditingRangeAdapter, async (adapter) => {\n            const res = await adapter.provideLinkedEditingRanges(URI.revive(resource), position, token);\n            if (res) {\n                return {\n                    ranges: res.ranges,\n                    wordPattern: res.wordPattern ? ExtHostLanguageFeatures._serializeRegExp(res.wordPattern) : undefined\n                };\n            }\n            return undefined;\n        }, undefined, token);\n    }\n    registerReferenceProvider(extension, selector, provider) {\n        const handle = this._addNewAdapter(( (new ReferenceAdapter(this._documents, provider))), extension);\n        this._proxy.$registerReferenceSupport(handle, this._transformDocumentSelector(selector, extension));\n        return this._createDisposable(handle);\n    }\n    $provideReferences(handle, resource, position, context, token) {\n        return this._withAdapter(handle, ReferenceAdapter, adapter => adapter.provideReferences(URI.revive(resource), position, context, token), undefined, token);\n    }\n    registerCodeActionProvider(extension, selector, provider, metadata) {\n        const store = ( (new DisposableStore()));\n        const handle = this._addNewAdapter(( (new CodeActionAdapter(\n            this._documents,\n            this._commands.converter,\n            this._diagnostics,\n            provider,\n            this._logService,\n            extension,\n            this._apiDeprecation\n        ))), extension);\n        this._proxy.$registerCodeActionSupport(handle, this._transformDocumentSelector(selector, extension), {\n            providedKinds: metadata?.providedCodeActionKinds?.map(kind => kind.value),\n            documentation: metadata?.documentation?.map(x => ({\n                kind: x.kind.value,\n                command: this._commands.converter.toInternal(x.command, store),\n            }))\n        }, ExtHostLanguageFeatures._extLabel(extension), ExtHostLanguageFeatures._extId(extension), Boolean(provider.resolveCodeAction));\n        store.add(this._createDisposable(handle));\n        return store;\n    }\n    $provideCodeActions(handle, resource, rangeOrSelection, context, token) {\n        return this._withAdapter(handle, CodeActionAdapter, adapter => adapter.provideCodeActions(URI.revive(resource), rangeOrSelection, context, token), undefined, token);\n    }\n    $resolveCodeAction(handle, id, token) {\n        return this._withAdapter(handle, CodeActionAdapter, adapter => adapter.resolveCodeAction(id, token), {}, undefined);\n    }\n    $releaseCodeActions(handle, cacheId) {\n        this._withAdapter(handle, CodeActionAdapter, adapter => Promise.resolve(adapter.releaseCodeActions(cacheId)), undefined, undefined);\n    }\n    registerDocumentFormattingEditProvider(extension, selector, provider) {\n        const handle = this._addNewAdapter(( (new DocumentFormattingAdapter(this._documents, provider))), extension);\n        this._proxy.$registerDocumentFormattingSupport(handle, this._transformDocumentSelector(selector, extension), extension.identifier, extension.displayName || extension.name);\n        return this._createDisposable(handle);\n    }\n    $provideDocumentFormattingEdits(handle, resource, options, token) {\n        return this._withAdapter(handle, DocumentFormattingAdapter, adapter => adapter.provideDocumentFormattingEdits(URI.revive(resource), options, token), undefined, token);\n    }\n    registerDocumentRangeFormattingEditProvider(extension, selector, provider) {\n        const canFormatMultipleRanges = typeof provider.provideDocumentRangesFormattingEdits === 'function';\n        const handle = this._addNewAdapter(( (new RangeFormattingAdapter(this._documents, provider))), extension);\n        this._proxy.$registerRangeFormattingSupport(handle, this._transformDocumentSelector(selector, extension), extension.identifier, extension.displayName || extension.name, canFormatMultipleRanges);\n        return this._createDisposable(handle);\n    }\n    $provideDocumentRangeFormattingEdits(handle, resource, range, options, token) {\n        return this._withAdapter(handle, RangeFormattingAdapter, adapter => adapter.provideDocumentRangeFormattingEdits(URI.revive(resource), range, options, token), undefined, token);\n    }\n    $provideDocumentRangesFormattingEdits(handle, resource, ranges, options, token) {\n        return this._withAdapter(handle, RangeFormattingAdapter, adapter => adapter.provideDocumentRangesFormattingEdits(URI.revive(resource), ranges, options, token), undefined, token);\n    }\n    registerOnTypeFormattingEditProvider(extension, selector, provider, triggerCharacters) {\n        const handle = this._addNewAdapter(( (new OnTypeFormattingAdapter(this._documents, provider))), extension);\n        this._proxy.$registerOnTypeFormattingSupport(handle, this._transformDocumentSelector(selector, extension), triggerCharacters, extension.identifier);\n        return this._createDisposable(handle);\n    }\n    $provideOnTypeFormattingEdits(handle, resource, position, ch, options, token) {\n        return this._withAdapter(handle, OnTypeFormattingAdapter, adapter => adapter.provideOnTypeFormattingEdits(URI.revive(resource), position, ch, options, token), undefined, token);\n    }\n    registerWorkspaceSymbolProvider(extension, provider) {\n        const handle = this._addNewAdapter(( (new NavigateTypeAdapter(provider, this._logService))), extension);\n        this._proxy.$registerNavigateTypeSupport(handle, typeof provider.resolveWorkspaceSymbol === 'function');\n        return this._createDisposable(handle);\n    }\n    $provideWorkspaceSymbols(handle, search, token) {\n        return this._withAdapter(handle, NavigateTypeAdapter, adapter => adapter.provideWorkspaceSymbols(search, token), { symbols: [] }, token);\n    }\n    $resolveWorkspaceSymbol(handle, symbol, token) {\n        return this._withAdapter(handle, NavigateTypeAdapter, adapter => adapter.resolveWorkspaceSymbol(symbol, token), undefined, undefined);\n    }\n    $releaseWorkspaceSymbols(handle, id) {\n        this._withAdapter(handle, NavigateTypeAdapter, adapter => adapter.releaseWorkspaceSymbols(id), undefined, undefined);\n    }\n    registerRenameProvider(extension, selector, provider) {\n        const handle = this._addNewAdapter(( (new RenameAdapter(this._documents, provider, this._logService))), extension);\n        this._proxy.$registerRenameSupport(handle, this._transformDocumentSelector(selector, extension), RenameAdapter.supportsResolving(provider));\n        return this._createDisposable(handle);\n    }\n    $provideRenameEdits(handle, resource, position, newName, token) {\n        return this._withAdapter(handle, RenameAdapter, adapter => adapter.provideRenameEdits(URI.revive(resource), position, newName, token), undefined, token);\n    }\n    $resolveRenameLocation(handle, resource, position, token) {\n        return this._withAdapter(handle, RenameAdapter, adapter => adapter.resolveRenameLocation(URI.revive(resource), position, token), undefined, token);\n    }\n    registerNewSymbolNamesProvider(extension, selector, provider) {\n        const handle = this._addNewAdapter(( (new NewSymbolNamesAdapter(this._documents, provider, this._logService))), extension);\n        this._proxy.$registerNewSymbolNamesProvider(handle, this._transformDocumentSelector(selector, extension));\n        return this._createDisposable(handle);\n    }\n    $supportsAutomaticNewSymbolNamesTriggerKind(handle) {\n        return this._withAdapter(handle, NewSymbolNamesAdapter, adapter => adapter.supportsAutomaticNewSymbolNamesTriggerKind(), false, undefined);\n    }\n    $provideNewSymbolNames(handle, resource, range, triggerKind, token) {\n        return this._withAdapter(handle, NewSymbolNamesAdapter, adapter => adapter.provideNewSymbolNames(URI.revive(resource), range, triggerKind, token), undefined, token);\n    }\n    registerDocumentSemanticTokensProvider(extension, selector, provider, legend) {\n        const handle = this._addNewAdapter(( (new DocumentSemanticTokensAdapter(this._documents, provider))), extension);\n        const eventHandle = (typeof provider.onDidChangeSemanticTokens === 'function' ? this._nextHandle() : undefined);\n        this._proxy.$registerDocumentSemanticTokensProvider(handle, this._transformDocumentSelector(selector, extension), legend, eventHandle);\n        let result = this._createDisposable(handle);\n        if (eventHandle) {\n            const subscription = provider.onDidChangeSemanticTokens(_ => this._proxy.$emitDocumentSemanticTokensEvent(eventHandle));\n            result = Disposable.from(result, subscription);\n        }\n        return result;\n    }\n    $provideDocumentSemanticTokens(handle, resource, previousResultId, token) {\n        return this._withAdapter(handle, DocumentSemanticTokensAdapter, adapter => adapter.provideDocumentSemanticTokens(URI.revive(resource), previousResultId, token), null, token);\n    }\n    $releaseDocumentSemanticTokens(handle, semanticColoringResultId) {\n        this._withAdapter(handle, DocumentSemanticTokensAdapter, adapter => adapter.releaseDocumentSemanticColoring(semanticColoringResultId), undefined, undefined);\n    }\n    registerDocumentRangeSemanticTokensProvider(extension, selector, provider, legend) {\n        const handle = this._addNewAdapter(( (new DocumentRangeSemanticTokensAdapter(this._documents, provider))), extension);\n        this._proxy.$registerDocumentRangeSemanticTokensProvider(handle, this._transformDocumentSelector(selector, extension), legend);\n        return this._createDisposable(handle);\n    }\n    $provideDocumentRangeSemanticTokens(handle, resource, range, token) {\n        return this._withAdapter(handle, DocumentRangeSemanticTokensAdapter, adapter => adapter.provideDocumentRangeSemanticTokens(URI.revive(resource), range, token), null, token);\n    }\n    registerCompletionItemProvider(extension, selector, provider, triggerCharacters) {\n        const handle = this._addNewAdapter(( (new CompletionsAdapter(\n            this._documents,\n            this._commands.converter,\n            provider,\n            this._apiDeprecation,\n            extension\n        ))), extension);\n        this._proxy.$registerCompletionsProvider(handle, this._transformDocumentSelector(selector, extension), triggerCharacters, CompletionsAdapter.supportsResolving(provider), extension.identifier);\n        return this._createDisposable(handle);\n    }\n    $provideCompletionItems(handle, resource, position, context, token) {\n        return this._withAdapter(handle, CompletionsAdapter, adapter => adapter.provideCompletionItems(URI.revive(resource), position, context, token), undefined, token);\n    }\n    $resolveCompletionItem(handle, id, token) {\n        return this._withAdapter(handle, CompletionsAdapter, adapter => adapter.resolveCompletionItem(id, token), undefined, token);\n    }\n    $releaseCompletionItems(handle, id) {\n        this._withAdapter(handle, CompletionsAdapter, adapter => adapter.releaseCompletionItems(id), undefined, undefined);\n    }\n    registerInlineCompletionsProvider(extension, selector, provider, metadata) {\n        const adapter = ( (new InlineCompletionAdapter(extension, this._documents, provider, this._commands.converter)));\n        const handle = this._addNewAdapter(adapter, extension);\n        this._proxy.$registerInlineCompletionsSupport(handle, this._transformDocumentSelector(selector, extension), adapter.supportsHandleEvents, ExtensionIdentifier.toKey(extension.identifier.value), metadata?.yieldTo?.map(extId => ExtensionIdentifier.toKey(extId)) || []);\n        return this._createDisposable(handle);\n    }\n    $provideInlineCompletions(handle, resource, position, context, token) {\n        return this._withAdapter(handle, InlineCompletionAdapterBase, adapter => adapter.provideInlineCompletions(URI.revive(resource), position, context, token), undefined, token);\n    }\n    $provideInlineEditsForRange(handle, resource, range, context, token) {\n        return this._withAdapter(handle, InlineCompletionAdapterBase, adapter => adapter.provideInlineEditsForRange(URI.revive(resource), range, context, token), undefined, token);\n    }\n    $handleInlineCompletionDidShow(handle, pid, idx, updatedInsertText) {\n        this._withAdapter(handle, InlineCompletionAdapterBase, async (adapter) => {\n            adapter.handleDidShowCompletionItem(pid, idx, updatedInsertText);\n        }, undefined, undefined);\n    }\n    $handleInlineCompletionPartialAccept(handle, pid, idx, acceptedCharacters, info) {\n        this._withAdapter(handle, InlineCompletionAdapterBase, async (adapter) => {\n            adapter.handlePartialAccept(pid, idx, acceptedCharacters, info);\n        }, undefined, undefined);\n    }\n    $freeInlineCompletionsList(handle, pid) {\n        this._withAdapter(handle, InlineCompletionAdapterBase, async (adapter) => { adapter.disposeCompletions(pid); }, undefined, undefined);\n    }\n    registerInlineEditProvider(extension, selector, provider) {\n        const adapter = ( (new InlineEditAdapter(extension, this._documents, provider, this._commands.converter)));\n        const handle = this._addNewAdapter(adapter, extension);\n        this._proxy.$registerInlineEditProvider(handle, this._transformDocumentSelector(selector, extension), extension.identifier);\n        return this._createDisposable(handle);\n    }\n    $provideInlineEdit(handle, resource, context, token) {\n        return this._withAdapter(handle, InlineEditAdapter, adapter => adapter.provideInlineEdits(URI.revive(resource), context, token), undefined, token);\n    }\n    $freeInlineEdit(handle, pid) {\n        this._withAdapter(handle, InlineEditAdapter, async (adapter) => { adapter.disposeEdit(pid); }, undefined, undefined);\n    }\n    registerSignatureHelpProvider(extension, selector, provider, metadataOrTriggerChars) {\n        const metadata = Array.isArray(metadataOrTriggerChars)\n            ? { triggerCharacters: metadataOrTriggerChars, retriggerCharacters: [] }\n            : metadataOrTriggerChars;\n        const handle = this._addNewAdapter(( (new SignatureHelpAdapter(this._documents, provider))), extension);\n        this._proxy.$registerSignatureHelpProvider(handle, this._transformDocumentSelector(selector, extension), metadata);\n        return this._createDisposable(handle);\n    }\n    $provideSignatureHelp(handle, resource, position, context, token) {\n        return this._withAdapter(handle, SignatureHelpAdapter, adapter => adapter.provideSignatureHelp(URI.revive(resource), position, context, token), undefined, token);\n    }\n    $releaseSignatureHelp(handle, id) {\n        this._withAdapter(handle, SignatureHelpAdapter, adapter => adapter.releaseSignatureHelp(id), undefined, undefined);\n    }\n    registerInlayHintsProvider(extension, selector, provider) {\n        const eventHandle = typeof provider.onDidChangeInlayHints === 'function' ? this._nextHandle() : undefined;\n        const handle = this._addNewAdapter(( (new InlayHintsAdapter(\n            this._documents,\n            this._commands.converter,\n            provider,\n            this._logService,\n            extension\n        ))), extension);\n        this._proxy.$registerInlayHintsProvider(handle, this._transformDocumentSelector(selector, extension), typeof provider.resolveInlayHint === 'function', eventHandle, ExtHostLanguageFeatures._extLabel(extension));\n        let result = this._createDisposable(handle);\n        if (eventHandle !== undefined) {\n            const subscription = provider.onDidChangeInlayHints(uri => this._proxy.$emitInlayHintsEvent(eventHandle));\n            result = Disposable.from(result, subscription);\n        }\n        return result;\n    }\n    $provideInlayHints(handle, resource, range, token) {\n        return this._withAdapter(handle, InlayHintsAdapter, adapter => adapter.provideInlayHints(URI.revive(resource), range, token), undefined, token);\n    }\n    $resolveInlayHint(handle, id, token) {\n        return this._withAdapter(handle, InlayHintsAdapter, adapter => adapter.resolveInlayHint(id, token), undefined, token);\n    }\n    $releaseInlayHints(handle, id) {\n        this._withAdapter(handle, InlayHintsAdapter, adapter => adapter.releaseHints(id), undefined, undefined);\n    }\n    registerDocumentLinkProvider(extension, selector, provider) {\n        const handle = this._addNewAdapter(( (new LinkProviderAdapter(this._documents, provider))), extension);\n        this._proxy.$registerDocumentLinkProvider(handle, this._transformDocumentSelector(selector, extension), typeof provider.resolveDocumentLink === 'function');\n        return this._createDisposable(handle);\n    }\n    $provideDocumentLinks(handle, resource, token) {\n        return this._withAdapter(handle, LinkProviderAdapter, adapter => adapter.provideLinks(URI.revive(resource), token), undefined, token, resource.scheme === 'output');\n    }\n    $resolveDocumentLink(handle, id, token) {\n        return this._withAdapter(handle, LinkProviderAdapter, adapter => adapter.resolveLink(id, token), undefined, undefined, true);\n    }\n    $releaseDocumentLinks(handle, id) {\n        this._withAdapter(handle, LinkProviderAdapter, adapter => adapter.releaseLinks(id), undefined, undefined, true);\n    }\n    registerColorProvider(extension, selector, provider) {\n        const handle = this._addNewAdapter(( (new ColorProviderAdapter(this._documents, provider))), extension);\n        this._proxy.$registerDocumentColorProvider(handle, this._transformDocumentSelector(selector, extension));\n        return this._createDisposable(handle);\n    }\n    $provideDocumentColors(handle, resource, token) {\n        return this._withAdapter(handle, ColorProviderAdapter, adapter => adapter.provideColors(URI.revive(resource), token), [], token);\n    }\n    $provideColorPresentations(handle, resource, colorInfo, token) {\n        return this._withAdapter(handle, ColorProviderAdapter, adapter => adapter.provideColorPresentations(URI.revive(resource), colorInfo, token), undefined, token);\n    }\n    registerFoldingRangeProvider(extension, selector, provider) {\n        const handle = this._nextHandle();\n        const eventHandle = typeof provider.onDidChangeFoldingRanges === 'function' ? this._nextHandle() : undefined;\n        this._adapter.set(handle, ( (new AdapterData(\n             (new FoldingProviderAdapter(this._documents, provider)),\n            extension\n        ))));\n        this._proxy.$registerFoldingRangeProvider(handle, this._transformDocumentSelector(selector, extension), extension.identifier, eventHandle);\n        let result = this._createDisposable(handle);\n        if (eventHandle !== undefined) {\n            const subscription = provider.onDidChangeFoldingRanges(() => this._proxy.$emitFoldingRangeEvent(eventHandle));\n            result = Disposable.from(result, subscription);\n        }\n        return result;\n    }\n    $provideFoldingRanges(handle, resource, context, token) {\n        return this._withAdapter(handle, FoldingProviderAdapter, (adapter) => adapter.provideFoldingRanges(URI.revive(resource), context, token), undefined, token);\n    }\n    registerSelectionRangeProvider(extension, selector, provider) {\n        const handle = this._addNewAdapter(( (new SelectionRangeAdapter(this._documents, provider, this._logService))), extension);\n        this._proxy.$registerSelectionRangeProvider(handle, this._transformDocumentSelector(selector, extension));\n        return this._createDisposable(handle);\n    }\n    $provideSelectionRanges(handle, resource, positions, token) {\n        return this._withAdapter(handle, SelectionRangeAdapter, adapter => adapter.provideSelectionRanges(URI.revive(resource), positions, token), [], token);\n    }\n    registerCallHierarchyProvider(extension, selector, provider) {\n        const handle = this._addNewAdapter(( (new CallHierarchyAdapter(this._documents, provider))), extension);\n        this._proxy.$registerCallHierarchyProvider(handle, this._transformDocumentSelector(selector, extension));\n        return this._createDisposable(handle);\n    }\n    $prepareCallHierarchy(handle, resource, position, token) {\n        return this._withAdapter(handle, CallHierarchyAdapter, adapter => Promise.resolve(adapter.prepareSession(URI.revive(resource), position, token)), undefined, token);\n    }\n    $provideCallHierarchyIncomingCalls(handle, sessionId, itemId, token) {\n        return this._withAdapter(handle, CallHierarchyAdapter, adapter => adapter.provideCallsTo(sessionId, itemId, token), undefined, token);\n    }\n    $provideCallHierarchyOutgoingCalls(handle, sessionId, itemId, token) {\n        return this._withAdapter(handle, CallHierarchyAdapter, adapter => adapter.provideCallsFrom(sessionId, itemId, token), undefined, token);\n    }\n    $releaseCallHierarchy(handle, sessionId) {\n        this._withAdapter(handle, CallHierarchyAdapter, adapter => Promise.resolve(adapter.releaseSession(sessionId)), undefined, undefined);\n    }\n    registerTypeHierarchyProvider(extension, selector, provider) {\n        const handle = this._addNewAdapter(( (new TypeHierarchyAdapter(this._documents, provider))), extension);\n        this._proxy.$registerTypeHierarchyProvider(handle, this._transformDocumentSelector(selector, extension));\n        return this._createDisposable(handle);\n    }\n    $prepareTypeHierarchy(handle, resource, position, token) {\n        return this._withAdapter(handle, TypeHierarchyAdapter, adapter => Promise.resolve(adapter.prepareSession(URI.revive(resource), position, token)), undefined, token);\n    }\n    $provideTypeHierarchySupertypes(handle, sessionId, itemId, token) {\n        return this._withAdapter(handle, TypeHierarchyAdapter, adapter => adapter.provideSupertypes(sessionId, itemId, token), undefined, token);\n    }\n    $provideTypeHierarchySubtypes(handle, sessionId, itemId, token) {\n        return this._withAdapter(handle, TypeHierarchyAdapter, adapter => adapter.provideSubtypes(sessionId, itemId, token), undefined, token);\n    }\n    $releaseTypeHierarchy(handle, sessionId) {\n        this._withAdapter(handle, TypeHierarchyAdapter, adapter => Promise.resolve(adapter.releaseSession(sessionId)), undefined, undefined);\n    }\n    registerDocumentOnDropEditProvider(extension, selector, provider, metadata) {\n        const handle = this._nextHandle();\n        this._adapter.set(handle, ( (new AdapterData(\n             (new DocumentDropEditAdapter(this._proxy, this._documents, provider, handle, extension)),\n            extension\n        ))));\n        this._proxy.$registerDocumentOnDropEditProvider(handle, this._transformDocumentSelector(selector, extension), isProposedApiEnabled(extension, 'documentPaste') && metadata ? {\n            supportsResolve: !!provider.resolveDocumentDropEdit,\n            dropMimeTypes: metadata.dropMimeTypes,\n        } : undefined);\n        return this._createDisposable(handle);\n    }\n    $provideDocumentOnDropEdits(handle, requestId, resource, position, dataTransferDto, token) {\n        return this._withAdapter(handle, DocumentDropEditAdapter, adapter => Promise.resolve(adapter.provideDocumentOnDropEdits(requestId, URI.revive(resource), position, dataTransferDto, token)), undefined, undefined);\n    }\n    $resolveDropEdit(handle, id, token) {\n        return this._withAdapter(handle, DocumentDropEditAdapter, adapter => adapter.resolveDropEdit(id, token), {}, undefined);\n    }\n    $releaseDocumentOnDropEdits(handle, cacheId) {\n        this._withAdapter(handle, DocumentDropEditAdapter, adapter => Promise.resolve(adapter.releaseDropEdits(cacheId)), undefined, undefined);\n    }\n    registerMappedEditsProvider(extension, selector, provider) {\n        const handle = this._addNewAdapter(( (new MappedEditsAdapter(this._documents, provider))), extension);\n        this._proxy.$registerMappedEditsProvider(handle, this._transformDocumentSelector(selector, extension), extension.displayName ?? extension.name);\n        return this._createDisposable(handle);\n    }\n    $provideMappedEdits(handle, document, codeBlocks, context, token) {\n        return this._withAdapter(handle, MappedEditsAdapter, adapter => Promise.resolve(adapter.provideMappedEdits(document, codeBlocks, context, token)), null, token);\n    }\n    registerDocumentPasteEditProvider(extension, selector, provider, metadata) {\n        const handle = this._nextHandle();\n        this._adapter.set(handle, ( (new AdapterData(\n             (new DocumentPasteEditProvider(this._proxy, this._documents, provider, handle, extension)),\n            extension\n        ))));\n        this._proxy.$registerPasteEditProvider(handle, this._transformDocumentSelector(selector, extension), {\n            supportsCopy: !!provider.prepareDocumentPaste,\n            supportsPaste: !!provider.provideDocumentPasteEdits,\n            supportsResolve: !!provider.resolveDocumentPasteEdit,\n            providedPasteEditKinds: metadata.providedPasteEditKinds?.map(x => x.value),\n            copyMimeTypes: metadata.copyMimeTypes,\n            pasteMimeTypes: metadata.pasteMimeTypes,\n        });\n        return this._createDisposable(handle);\n    }\n    $prepareDocumentPaste(handle, resource, ranges, dataTransfer, token) {\n        return this._withAdapter(handle, DocumentPasteEditProvider, adapter => adapter.prepareDocumentPaste(URI.revive(resource), ranges, dataTransfer, token), undefined, token);\n    }\n    $providePasteEdits(handle, requestId, resource, ranges, dataTransferDto, context, token) {\n        return this._withAdapter(handle, DocumentPasteEditProvider, adapter => adapter.providePasteEdits(requestId, URI.revive(resource), ranges, dataTransferDto, context, token), undefined, token);\n    }\n    $resolvePasteEdit(handle, id, token) {\n        return this._withAdapter(handle, DocumentPasteEditProvider, adapter => adapter.resolvePasteEdit(id, token), {}, undefined);\n    }\n    $releasePasteEdits(handle, cacheId) {\n        this._withAdapter(handle, DocumentPasteEditProvider, adapter => Promise.resolve(adapter.releasePasteEdits(cacheId)), undefined, undefined);\n    }\n    static _serializeRegExp(regExp) {\n        return {\n            pattern: regExp.source,\n            flags: regExp.flags,\n        };\n    }\n    static _serializeIndentationRule(indentationRule) {\n        return {\n            decreaseIndentPattern: ExtHostLanguageFeatures._serializeRegExp(indentationRule.decreaseIndentPattern),\n            increaseIndentPattern: ExtHostLanguageFeatures._serializeRegExp(indentationRule.increaseIndentPattern),\n            indentNextLinePattern: indentationRule.indentNextLinePattern ? ExtHostLanguageFeatures._serializeRegExp(indentationRule.indentNextLinePattern) : undefined,\n            unIndentedLinePattern: indentationRule.unIndentedLinePattern ? ExtHostLanguageFeatures._serializeRegExp(indentationRule.unIndentedLinePattern) : undefined,\n        };\n    }\n    static _serializeOnEnterRule(onEnterRule) {\n        return {\n            beforeText: ExtHostLanguageFeatures._serializeRegExp(onEnterRule.beforeText),\n            afterText: onEnterRule.afterText ? ExtHostLanguageFeatures._serializeRegExp(onEnterRule.afterText) : undefined,\n            previousLineText: onEnterRule.previousLineText ? ExtHostLanguageFeatures._serializeRegExp(onEnterRule.previousLineText) : undefined,\n            action: onEnterRule.action\n        };\n    }\n    static _serializeOnEnterRules(onEnterRules) {\n        return (\n             (onEnterRules.map(ExtHostLanguageFeatures._serializeOnEnterRule))\n        );\n    }\n    static _serializeAutoClosingPair(autoClosingPair) {\n        return {\n            open: autoClosingPair.open,\n            close: autoClosingPair.close,\n            notIn: autoClosingPair.notIn ? ( (autoClosingPair.notIn.map(v => ( (SyntaxTokenType.toString(v)))))) : undefined,\n        };\n    }\n    static _serializeAutoClosingPairs(autoClosingPairs) {\n        return (\n             (autoClosingPairs.map(ExtHostLanguageFeatures._serializeAutoClosingPair))\n        );\n    }\n    setLanguageConfiguration(extension, languageId, configuration) {\n        const { wordPattern } = configuration;\n        if (wordPattern && regExpLeadsToEndlessLoop(wordPattern)) {\n            throw ( (new Error(\n                `Invalid language configuration: wordPattern '${wordPattern}' is not allowed to match the empty string.`\n            )));\n        }\n        if (wordPattern) {\n            this._documents.setWordDefinitionFor(languageId, wordPattern);\n        }\n        else {\n            this._documents.setWordDefinitionFor(languageId, undefined);\n        }\n        if (configuration.__electricCharacterSupport) {\n            this._apiDeprecation.report('LanguageConfiguration.__electricCharacterSupport', extension, `Do not use.`);\n        }\n        if (configuration.__characterPairSupport) {\n            this._apiDeprecation.report('LanguageConfiguration.__characterPairSupport', extension, `Do not use.`);\n        }\n        const handle = this._nextHandle();\n        const serializedConfiguration = {\n            comments: configuration.comments,\n            brackets: configuration.brackets,\n            wordPattern: configuration.wordPattern ? ExtHostLanguageFeatures._serializeRegExp(configuration.wordPattern) : undefined,\n            indentationRules: configuration.indentationRules ? ExtHostLanguageFeatures._serializeIndentationRule(configuration.indentationRules) : undefined,\n            onEnterRules: configuration.onEnterRules ? ExtHostLanguageFeatures._serializeOnEnterRules(configuration.onEnterRules) : undefined,\n            __electricCharacterSupport: configuration.__electricCharacterSupport,\n            __characterPairSupport: configuration.__characterPairSupport,\n            autoClosingPairs: configuration.autoClosingPairs ? ExtHostLanguageFeatures._serializeAutoClosingPairs(configuration.autoClosingPairs) : undefined,\n        };\n        this._proxy.$setLanguageConfiguration(handle, languageId, serializedConfiguration);\n        return this._createDisposable(handle);\n    }\n    $setWordDefinitions(wordDefinitions) {\n        for (const wordDefinition of wordDefinitions) {\n            this._documents.setWordDefinitionFor(wordDefinition.languageId, ( (new RegExp(wordDefinition.regexSource, wordDefinition.regexFlags))));\n        }\n    }\n}\nexport { ExtHostLanguageFeatures };\n","import { raceCancellation } from '../../../base/common/async.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { CancellationError } from '../../../base/common/errors.js';\nimport { toDisposable } from '../../../base/common/lifecycle.js';\nimport { revive } from '../../../base/common/marshalling.js';\nimport { generateUuid } from '../../../base/common/uuid.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { LanguageModelToolDescription, MarkdownString } from './extHostTypeConverters.js';\nclass ExtHostLanguageModelTools {\n    constructor(mainContext) {\n        this._registeredTools = ( new Map());\n        this._tokenCountFuncs = ( new Map());\n        this._allTools = ( new Map());\n        this._proxy = ( mainContext.getProxy(MainContext.MainThreadLanguageModelTools));\n        this._proxy.$getTools().then(tools => {\n            for (const tool of tools) {\n                this._allTools.set(tool.id, revive(tool));\n            }\n        });\n    }\n    async $countTokensForInvocation(callId, input, token) {\n        const fn = this._tokenCountFuncs.get(callId);\n        if (!fn) {\n            throw ( new Error(`Tool invocation call ${callId} not found`));\n        }\n        return await fn(input, token);\n    }\n    async invokeTool(toolId, options, token) {\n        if (!options.requestedContentTypes?.length) {\n            throw ( new Error(\n                'LanguageModelToolInvocationOptions.requestedContentTypes is required to be set'\n            ));\n        }\n        const callId = generateUuid();\n        if (options.tokenOptions) {\n            this._tokenCountFuncs.set(callId, options.tokenOptions.countTokens);\n        }\n        try {\n            const result = await this._proxy.$invokeTool({\n                toolId,\n                callId,\n                parameters: options.parameters,\n                tokenBudget: options.tokenOptions?.tokenBudget,\n                context: options.toolInvocationToken,\n                requestedContentTypes: options.requestedContentTypes,\n            }, token);\n            return result;\n        }\n        finally {\n            this._tokenCountFuncs.delete(callId);\n        }\n    }\n    $onDidChangeTools(tools) {\n        this._allTools.clear();\n        for (const tool of tools) {\n            this._allTools.set(tool.id, tool);\n        }\n    }\n    get tools() {\n        return ( Array.from(( this._allTools.values()))\n            .map(tool => LanguageModelToolDescription.to(tool)));\n    }\n    async $invokeTool(dto, token) {\n        const item = this._registeredTools.get(dto.toolId);\n        if (!item) {\n            throw ( new Error(`Unknown tool ${dto.toolId}`));\n        }\n        const options = { parameters: dto.parameters, toolInvocationToken: dto.context, requestedContentTypes: dto.requestedContentTypes };\n        if (dto.tokenBudget !== undefined) {\n            options.tokenOptions = {\n                tokenBudget: dto.tokenBudget,\n                countTokens: this._tokenCountFuncs.get(dto.callId) || ((value, token = CancellationToken.None) => this._proxy.$countTokensForInvocation(dto.callId, value, token))\n            };\n        }\n        const extensionResult = await raceCancellation(Promise.resolve(item.tool.invoke(options, token)), token);\n        if (!extensionResult) {\n            throw ( new CancellationError());\n        }\n        for (const key of ( Object.keys(extensionResult))) {\n            const value = extensionResult[key];\n            if (value instanceof Promise) {\n                throw ( new Error(`Tool result for '${key}' cannot be a Promise`));\n            }\n            else if (!options.requestedContentTypes.includes(key) && key !== 'toString') {\n                throw ( new Error(`Tool result for '${key}' was not requested from ${dto.toolId}.`));\n            }\n        }\n        return extensionResult;\n    }\n    async $provideToolConfirmationMessages(toolId, participantName, parameters, token) {\n        const item = this._registeredTools.get(toolId);\n        if (!item) {\n            throw ( new Error(`Unknown tool ${toolId}`));\n        }\n        if (!item.tool.provideToolConfirmationMessages) {\n            return undefined;\n        }\n        const result = await item.tool.provideToolConfirmationMessages({ participantName, parameters }, token);\n        if (!result) {\n            return undefined;\n        }\n        return {\n            title: result.title,\n            message: typeof result.message === 'string' ? result.message : MarkdownString.from(result.message),\n        };\n    }\n    async $provideToolInvocationMessage(toolId, parameters, token) {\n        const item = this._registeredTools.get(toolId);\n        if (!item) {\n            throw ( new Error(`Unknown tool ${toolId}`));\n        }\n        if (!item.tool.provideToolInvocationMessage) {\n            return undefined;\n        }\n        return await item.tool.provideToolInvocationMessage(parameters, token);\n    }\n    registerTool(extension, id, tool) {\n        this._registeredTools.set(id, { extension, tool });\n        this._proxy.$registerTool(id);\n        return toDisposable(() => {\n            this._registeredTools.delete(id);\n            this._proxy.$unregisterTool(id);\n        });\n    }\n}\nexport { ExtHostLanguageModelTools };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { AsyncIterableSource, AsyncIterableObject } from '../../../base/common/async.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { toErrorMessage } from '../../../base/common/errorMessage.js';\nimport { transformErrorForSerialization, CancellationError, transformErrorFromSerialization } from '../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { Iterable } from '../../../base/common/iterator.js';\nimport { toDisposable } from '../../../base/common/lifecycle.js';\nimport { localize } from '../../../nls.js';\nimport { ExtensionIdentifierMap, ExtensionIdentifier, ExtensionIdentifierSet } from '../../../platform/extensions/common/extensions.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { ILogService } from '../../../platform/log/common/log.service.js';\nimport { Progress } from '../../../platform/progress/common/progress.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { IExtHostAuthentication } from './extHostAuthentication.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\nimport { LanguageModelChatMessage } from './extHostTypeConverters.js';\nimport { LanguageModelError, LanguageModelChatMessageRole, LanguageModelToolResultPart, LanguageModelTextPart, LanguageModelToolCallPart } from './extHostTypes.js';\nimport { INTERNAL_AUTH_PROVIDER_PREFIX } from '../../services/authentication/common/authentication.js';\nimport { checkProposedApiEnabled } from '../../services/extensions/common/extensions.js';\nvar ExtHostLanguageModels_1;\nconst IExtHostLanguageModels = ( (createDecorator('IExtHostLanguageModels')));\nclass LanguageModelResponseStream {\n    constructor(option, stream) {\n        this.option = option;\n        this.stream = ( (new AsyncIterableSource()));\n        this.stream = stream ?? ( (new AsyncIterableSource()));\n    }\n}\nclass LanguageModelResponse {\n    constructor() {\n        this._responseStreams = ( (new Map()));\n        this._defaultStream = ( (new AsyncIterableSource()));\n        this._isDone = false;\n        const that = this;\n        this.apiObject = {\n            get stream() {\n                return that._defaultStream.asyncIterable;\n            },\n            get text() {\n                return ( (AsyncIterableObject.map(that._defaultStream.asyncIterable, part => {\n                    if (part instanceof LanguageModelTextPart) {\n                        return part.value;\n                    }\n                    else {\n                        return undefined;\n                    }\n                }))).coalesce();\n            },\n        };\n    }\n    *_streams() {\n        if (this._responseStreams.size > 0) {\n            for (const [, value] of this._responseStreams) {\n                yield value.stream;\n            }\n        }\n        else {\n            yield this._defaultStream;\n        }\n    }\n    handleFragment(fragment) {\n        if (this._isDone) {\n            return;\n        }\n        let res = this._responseStreams.get(fragment.index);\n        if (!res) {\n            if (this._responseStreams.size === 0) {\n                res = ( (new LanguageModelResponseStream(fragment.index, this._defaultStream)));\n            }\n            else {\n                res = ( (new LanguageModelResponseStream(fragment.index)));\n            }\n            this._responseStreams.set(fragment.index, res);\n        }\n        let out;\n        if (fragment.part.type === 'text') {\n            out = new LanguageModelTextPart(fragment.part.value);\n        }\n        else {\n            out = new LanguageModelToolCallPart(fragment.part.name, fragment.part.toolCallId, fragment.part.parameters);\n        }\n        res.stream.emitOne(out);\n    }\n    reject(err) {\n        this._isDone = true;\n        for (const stream of this._streams()) {\n            stream.reject(err);\n        }\n    }\n    resolve() {\n        this._isDone = true;\n        for (const stream of this._streams()) {\n            stream.resolve();\n        }\n    }\n}\nlet ExtHostLanguageModels = class ExtHostLanguageModels {\n    static { ExtHostLanguageModels_1 = this; }\n    static { this._idPool = 1; }\n    constructor(extHostRpc, _logService, _extHostAuthentication) {\n        this._logService = _logService;\n        this._extHostAuthentication = _extHostAuthentication;\n        this._onDidChangeModelAccess = ( (new Emitter()));\n        this._onDidChangeProviders = ( (new Emitter()));\n        this.onDidChangeProviders = this._onDidChangeProviders.event;\n        this._languageModels = ( (new Map()));\n        this._allLanguageModelData = ( (new Map()));\n        this._modelAccessList = ( (new ExtensionIdentifierMap()));\n        this._pendingRequest = ( (new Map()));\n        this._languageAccessInformationExtensions = ( (new Set()));\n        this._proxy = ( (extHostRpc.getProxy(MainContext.MainThreadLanguageModels)));\n    }\n    dispose() {\n        this._onDidChangeModelAccess.dispose();\n        this._onDidChangeProviders.dispose();\n    }\n    registerLanguageModel(extension, identifier, provider, metadata) {\n        const handle = ExtHostLanguageModels_1._idPool++;\n        this._languageModels.set(handle, { extension: extension.identifier, provider, languageModelId: identifier });\n        let auth;\n        if (metadata.auth) {\n            auth = {\n                providerLabel: extension.displayName || extension.name,\n                accountLabel: typeof metadata.auth === 'object' ? metadata.auth.label : undefined\n            };\n        }\n        this._proxy.$registerLanguageModelProvider(handle, `${ExtensionIdentifier.toKey(extension.identifier)}/${identifier}`, {\n            extension: extension.identifier,\n            id: identifier,\n            vendor: metadata.vendor ?? ExtensionIdentifier.toKey(extension.identifier),\n            name: metadata.name ?? '',\n            family: metadata.family ?? '',\n            version: metadata.version,\n            maxInputTokens: metadata.maxInputTokens,\n            maxOutputTokens: metadata.maxOutputTokens,\n            auth,\n            targetExtensions: metadata.extensions,\n            isDefault: metadata.isDefault,\n            isUserSelectable: metadata.isUserSelectable,\n        });\n        const responseReceivedListener = provider.onDidReceiveLanguageModelResponse2?.(({ extensionId, participant, tokenCount }) => {\n            this._proxy.$whenLanguageModelChatRequestMade(identifier, ( (new ExtensionIdentifier(extensionId))), participant, tokenCount);\n        });\n        return toDisposable(() => {\n            this._languageModels.delete(handle);\n            this._proxy.$unregisterProvider(handle);\n            responseReceivedListener?.dispose();\n        });\n    }\n    async $startChatRequest(handle, requestId, from, messages, options, token) {\n        const data = this._languageModels.get(handle);\n        if (!data) {\n            throw ( (new Error('Provider not found')));\n        }\n        const progress = ( (new Progress(async (fragment) => {\n            if (token.isCancellationRequested) {\n                this._logService.warn(`[CHAT](${data.extension.value}) CANNOT send progress because the REQUEST IS CANCELLED`);\n                return;\n            }\n            let part;\n            if (fragment.part instanceof LanguageModelToolCallPart) {\n                part = { type: 'tool_use', name: fragment.part.name, parameters: fragment.part.parameters, toolCallId: fragment.part.toolCallId };\n            }\n            else if (fragment.part instanceof LanguageModelTextPart) {\n                part = { type: 'text', value: fragment.part.value };\n            }\n            if (!part) {\n                this._logService.warn(`[CHAT](${data.extension.value}) UNKNOWN part ${JSON.stringify(fragment)}`);\n                return;\n            }\n            this._proxy.$reportResponsePart(requestId, { index: fragment.index, part });\n        })));\n        let p;\n        if (data.provider.provideLanguageModelResponse2) {\n            p = Promise.resolve(data.provider.provideLanguageModelResponse2(( (messages.map(LanguageModelChatMessage.to))), options, ExtensionIdentifier.toKey(from), progress, token));\n        }\n        else {\n            const progress2 = ( (new Progress(async (fragment) => {\n                progress.report({ index: fragment.index, part: new LanguageModelTextPart(fragment.part) });\n            })));\n            p = Promise.resolve(data.provider.provideLanguageModelResponse(( (messages.map(LanguageModelChatMessage.to))), options?.modelOptions ?? {}, ExtensionIdentifier.toKey(from), progress2, token));\n        }\n        p.then(() => {\n            this._proxy.$reportResponseDone(requestId, undefined);\n        }, err => {\n            this._proxy.$reportResponseDone(requestId, transformErrorForSerialization(err));\n        });\n    }\n    $provideTokenLength(handle, value, token) {\n        const data = this._languageModels.get(handle);\n        if (!data) {\n            return Promise.resolve(0);\n        }\n        return Promise.resolve(data.provider.provideTokenCount(value, token));\n    }\n    $acceptChatModelMetadata(data) {\n        if (data.added) {\n            for (const { identifier, metadata } of data.added) {\n                this._allLanguageModelData.set(identifier, { metadata, apiObjects: ( (new ExtensionIdentifierMap())) });\n            }\n        }\n        if (data.removed) {\n            for (const id of data.removed) {\n                this._allLanguageModelData.delete(id);\n                for (const [key, value] of this._pendingRequest) {\n                    if (value.languageModelId === id) {\n                        value.res.reject(( (new CancellationError())));\n                        this._pendingRequest.delete(key);\n                    }\n                }\n            }\n        }\n        data.added?.forEach(added => this._fakeAuthPopulate(added.metadata));\n        this._onDidChangeProviders.fire(undefined);\n    }\n    async getLanguageModelByIdentifier(extension, identifier) {\n        const data = this._allLanguageModelData.get(identifier);\n        if (!data) {\n            return;\n        }\n        if (this._isUsingAuth(extension.identifier, data.metadata)) {\n            await this._fakeAuthPopulate(data.metadata);\n        }\n        let apiObject = data.apiObjects.get(extension.identifier);\n        if (!apiObject) {\n            const that = this;\n            apiObject = {\n                id: data.metadata.id,\n                vendor: data.metadata.vendor,\n                family: data.metadata.family,\n                version: data.metadata.version,\n                name: data.metadata.name,\n                maxInputTokens: data.metadata.maxInputTokens,\n                countTokens(text, token) {\n                    if (!( (that._allLanguageModelData.has(identifier)))) {\n                        throw LanguageModelError.NotFound(identifier);\n                    }\n                    return that._computeTokenLength(identifier, text, token ?? CancellationToken.None);\n                },\n                sendRequest(messages, options, token) {\n                    if (!( (that._allLanguageModelData.has(identifier)))) {\n                        throw LanguageModelError.NotFound(identifier);\n                    }\n                    return that._sendChatRequest(extension, identifier, messages, options ?? {}, token ?? CancellationToken.None);\n                }\n            };\n            data.apiObjects.set(extension.identifier, apiObject);\n        }\n        return apiObject;\n    }\n    async selectLanguageModels(extension, selector) {\n        const models = await this._proxy.$selectChatModels({ ...selector, extension: extension.identifier });\n        const result = [];\n        for (const identifier of models) {\n            const model = await this.getLanguageModelByIdentifier(extension, identifier);\n            if (model) {\n                result.push(model);\n            }\n        }\n        return result;\n    }\n    async _sendChatRequest(extension, languageModelId, messages, options, token) {\n        const internalMessages = this._convertMessages(extension, messages);\n        const from = extension.identifier;\n        const metadata = this._allLanguageModelData.get(languageModelId)?.metadata;\n        if (!metadata || !( (this._allLanguageModelData.has(languageModelId)))) {\n            throw LanguageModelError.NotFound(`Language model '${languageModelId}' is unknown.`);\n        }\n        if (this._isUsingAuth(from, metadata)) {\n            const success = await this._getAuthAccess(extension, { identifier: metadata.extension, displayName: metadata.auth.providerLabel }, options.justification, false);\n            if (!success || !this._modelAccessList.get(from)?.has(metadata.extension)) {\n                throw LanguageModelError.NoPermissions(`Language model '${languageModelId}' cannot be used by '${from.value}'.`);\n            }\n        }\n        try {\n            const requestId = (Math.random() * 1e6) | 0;\n            const res = ( (new LanguageModelResponse()));\n            this._pendingRequest.set(requestId, { languageModelId, res });\n            try {\n                await this._proxy.$tryStartChatRequest(from, languageModelId, requestId, internalMessages, options, token);\n            }\n            catch (error) {\n                this._pendingRequest.delete(requestId);\n                throw error;\n            }\n            return res.apiObject;\n        }\n        catch (error) {\n            if (error.name === LanguageModelError.name) {\n                throw error;\n            }\n            throw new LanguageModelError(`Language model '${languageModelId}' errored: ${toErrorMessage(error)}`, 'Unknown', error);\n        }\n    }\n    _convertMessages(extension, messages) {\n        const internalMessages = [];\n        for (const message of messages) {\n            if (message.role === LanguageModelChatMessageRole.System) {\n                checkProposedApiEnabled(extension, 'languageModelSystem');\n            }\n            if (( (message.content2.some(part => part instanceof LanguageModelToolResultPart)))) {\n                checkProposedApiEnabled(extension, 'lmTools');\n            }\n            internalMessages.push(LanguageModelChatMessage.from(message));\n        }\n        return internalMessages;\n    }\n    async $acceptResponsePart(requestId, chunk) {\n        const data = this._pendingRequest.get(requestId);\n        if (data) {\n            data.res.handleFragment(chunk);\n        }\n    }\n    async $acceptResponseDone(requestId, error) {\n        const data = this._pendingRequest.get(requestId);\n        if (!data) {\n            return;\n        }\n        this._pendingRequest.delete(requestId);\n        if (error) {\n            data.res.reject(transformErrorFromSerialization(error));\n        }\n        else {\n            data.res.resolve();\n        }\n    }\n    async _getAuthAccess(from, to, justification, silent) {\n        const providerId = INTERNAL_AUTH_PROVIDER_PREFIX + to.identifier.value;\n        const session = await this._extHostAuthentication.getSession(from, providerId, [], { silent: true });\n        if (session) {\n            this.$updateModelAccesslist([{ from: from.identifier, to: to.identifier, enabled: true }]);\n            return true;\n        }\n        if (silent) {\n            return false;\n        }\n        try {\n            const detail = justification\n                ? ( localize(589, \"Justification: {1}\", to.displayName, justification))\n                : undefined;\n            await this._extHostAuthentication.getSession(from, providerId, [], { forceNewSession: { detail } });\n            this.$updateModelAccesslist([{ from: from.identifier, to: to.identifier, enabled: true }]);\n            return true;\n        }\n        catch (err) {\n            return false;\n        }\n    }\n    _isUsingAuth(from, toMetadata) {\n        return !!toMetadata.auth\n            && !ExtensionIdentifier.equals(toMetadata.extension, from);\n    }\n    async _fakeAuthPopulate(metadata) {\n        if (!metadata.auth) {\n            return;\n        }\n        for (const from of this._languageAccessInformationExtensions) {\n            try {\n                await this._getAuthAccess(from, { identifier: metadata.extension, displayName: '' }, undefined, true);\n            }\n            catch (err) {\n                this._logService.error('Fake Auth request failed');\n                this._logService.error(err);\n            }\n        }\n    }\n    async _computeTokenLength(languageModelId, value, token) {\n        const data = this._allLanguageModelData.get(languageModelId);\n        if (!data) {\n            throw LanguageModelError.NotFound(`Language model '${languageModelId}' is unknown.`);\n        }\n        const local = Iterable.find(( (this._languageModels.values())), candidate => candidate.languageModelId === languageModelId);\n        if (local) {\n            return local.provider.provideTokenCount(value, token);\n        }\n        return this._proxy.$countTokens(languageModelId, (typeof value === 'string' ? value : LanguageModelChatMessage.from(value)), token);\n    }\n    $updateModelAccesslist(data) {\n        const updated = ( (new Array()));\n        for (const { from, to, enabled } of data) {\n            const set = this._modelAccessList.get(from) ?? ( (new ExtensionIdentifierSet()));\n            const oldValue = ( (set.has(to)));\n            if (oldValue !== enabled) {\n                if (enabled) {\n                    set.add(to);\n                }\n                else {\n                    set.delete(to);\n                }\n                this._modelAccessList.set(from, set);\n                const newItem = { from, to };\n                updated.push(newItem);\n                this._onDidChangeModelAccess.fire(newItem);\n            }\n        }\n    }\n    createLanguageModelAccessInformation(from) {\n        this._languageAccessInformationExtensions.add(from);\n        const that = this;\n        const _onDidChangeAccess = Event.signal(Event.filter(this._onDidChangeModelAccess.event, e => ExtensionIdentifier.equals(e.from, from.identifier)));\n        const _onDidAddRemove = Event.signal(this._onDidChangeProviders.event);\n        return {\n            get onDidChange() {\n                return Event.any(_onDidChangeAccess, _onDidAddRemove);\n            },\n            canSendRequest(chat) {\n                let metadata;\n                out: for (const [_, value] of that._allLanguageModelData) {\n                    for (const candidate of ( (value.apiObjects.values()))) {\n                        if (candidate === chat) {\n                            metadata = value.metadata;\n                            break out;\n                        }\n                    }\n                }\n                if (!metadata) {\n                    return undefined;\n                }\n                if (!that._isUsingAuth(from.identifier, metadata)) {\n                    return true;\n                }\n                const list = that._modelAccessList.get(from.identifier);\n                if (!list) {\n                    return undefined;\n                }\n                return (\n                     (list.has(metadata.extension))\n                );\n            }\n        };\n    }\n};\nExtHostLanguageModels = ExtHostLanguageModels_1 = ( (__decorate([\n    ( (__param(0, IExtHostRpcService))),\n    ( (__param(1, ILogService))),\n    ( (__param(2, IExtHostAuthentication)))\n], ExtHostLanguageModels)));\nexport { ExtHostLanguageModels, IExtHostLanguageModels };\n","import { MainContext } from './extHost.protocol.js';\nimport { Position, Range as Range$1, TokenType, DocumentSelector } from './extHostTypeConverters.js';\nimport { StandardTokenType, Range, LanguageStatusSeverity } from './extHostTypes.js';\nimport Severity$1 from '../../../base/common/severity.js';\nimport { disposableTimeout } from '../../../base/common/async.js';\nimport { DisposableStore } from '../../../base/common/lifecycle.js';\nimport { checkProposedApiEnabled } from '../../services/extensions/common/extensions.js';\nclass ExtHostLanguages {\n    constructor(mainContext, _documents, _commands, _uriTransformer) {\n        this._documents = _documents;\n        this._commands = _commands;\n        this._uriTransformer = _uriTransformer;\n        this._languageIds = [];\n        this._handlePool = 0;\n        this._ids = ( new Set());\n        this._proxy = ( mainContext.getProxy(MainContext.MainThreadLanguages));\n    }\n    $acceptLanguageIds(ids) {\n        this._languageIds = ids;\n    }\n    async getLanguages() {\n        return this._languageIds.slice(0);\n    }\n    async changeLanguage(uri, languageId) {\n        await this._proxy.$changeLanguage(uri, languageId);\n        const data = this._documents.getDocumentData(uri);\n        if (!data) {\n            throw ( new Error(`document '${( uri.toString())}' NOT found`));\n        }\n        return data.document;\n    }\n    async tokenAtPosition(document, position) {\n        const versionNow = document.version;\n        const pos = Position.from(position);\n        const info = await this._proxy.$tokensAtPosition(document.uri, pos);\n        const defaultRange = {\n            type: StandardTokenType.Other,\n            range: document.getWordRangeAtPosition(position) ?? ( new Range(position.line, position.character, position.line, position.character))\n        };\n        if (!info) {\n            return defaultRange;\n        }\n        const result = {\n            range: Range$1.to(info.range),\n            type: TokenType.to(info.type)\n        };\n        if (!result.range.contains(position)) {\n            return defaultRange;\n        }\n        if (versionNow !== document.version) {\n            return defaultRange;\n        }\n        return result;\n    }\n    createLanguageStatusItem(extension, id, selector) {\n        const handle = this._handlePool++;\n        const proxy = this._proxy;\n        const ids = this._ids;\n        const fullyQualifiedId = `${extension.identifier.value}/${id}`;\n        if (( ids.has(fullyQualifiedId))) {\n            throw ( new Error(`LanguageStatusItem with id '${id}' ALREADY exists`));\n        }\n        ids.add(fullyQualifiedId);\n        const data = {\n            selector,\n            id,\n            name: extension.displayName ?? extension.name,\n            severity: LanguageStatusSeverity.Information,\n            command: undefined,\n            text: '',\n            detail: '',\n            busy: false\n        };\n        let soonHandle;\n        const commandDisposables = ( new DisposableStore());\n        const updateAsync = () => {\n            soonHandle?.dispose();\n            if (!( ids.has(fullyQualifiedId))) {\n                console.warn(`LanguageStatusItem (${id}) from ${extension.identifier.value} has been disposed and CANNOT be updated anymore`);\n                return;\n            }\n            soonHandle = disposableTimeout(() => {\n                commandDisposables.clear();\n                this._proxy.$setLanguageStatus(handle, {\n                    id: fullyQualifiedId,\n                    name: data.name ?? extension.displayName ?? extension.name,\n                    source: extension.displayName ?? extension.name,\n                    selector: DocumentSelector.from(data.selector, this._uriTransformer),\n                    label: data.text,\n                    detail: data.detail ?? '',\n                    severity: data.severity === LanguageStatusSeverity.Error ? Severity$1.Error : data.severity === LanguageStatusSeverity.Warning ? Severity$1.Warning : Severity$1.Info,\n                    command: data.command && this._commands.toInternal(data.command, commandDisposables),\n                    accessibilityInfo: data.accessibilityInformation,\n                    busy: data.busy\n                });\n            }, 0);\n        };\n        const result = {\n            dispose() {\n                commandDisposables.dispose();\n                soonHandle?.dispose();\n                proxy.$removeLanguageStatus(handle);\n                ids.delete(fullyQualifiedId);\n            },\n            get id() {\n                return data.id;\n            },\n            get name() {\n                return data.name;\n            },\n            set name(value) {\n                data.name = value;\n                updateAsync();\n            },\n            get selector() {\n                return data.selector;\n            },\n            set selector(value) {\n                data.selector = value;\n                updateAsync();\n            },\n            get text() {\n                return data.text;\n            },\n            set text(value) {\n                data.text = value;\n                updateAsync();\n            },\n            set text2(value) {\n                checkProposedApiEnabled(extension, 'languageStatusText');\n                data.text = value;\n                updateAsync();\n            },\n            get text2() {\n                checkProposedApiEnabled(extension, 'languageStatusText');\n                return data.text;\n            },\n            get detail() {\n                return data.detail;\n            },\n            set detail(value) {\n                data.detail = value;\n                updateAsync();\n            },\n            get severity() {\n                return data.severity;\n            },\n            set severity(value) {\n                data.severity = value;\n                updateAsync();\n            },\n            get accessibilityInformation() {\n                return data.accessibilityInformation;\n            },\n            set accessibilityInformation(value) {\n                data.accessibilityInformation = value;\n                updateAsync();\n            },\n            get command() {\n                return data.command;\n            },\n            set command(value) {\n                data.command = value;\n                updateAsync();\n            },\n            get busy() {\n                return data.busy;\n            },\n            set busy(value) {\n                data.busy = value;\n                updateAsync();\n            }\n        };\n        updateAsync();\n        return result;\n    }\n}\nexport { ExtHostLanguages };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { LANGUAGE_DEFAULT } from '../../../base/common/platform.js';\nimport { format2 } from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { ILogService } from '../../../platform/log/common/log.service.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { IExtHostInitDataService } from './extHostInitDataService.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\nlet ExtHostLocalizationService = class ExtHostLocalizationService {\n    constructor(initData, rpc, logService) {\n        this.logService = logService;\n        this.bundleCache = ( new Map());\n        this._proxy = ( rpc.getProxy(MainContext.MainThreadLocalization));\n        this.currentLanguage = initData.environment.appLanguage;\n        this.isDefaultLanguage = this.currentLanguage === LANGUAGE_DEFAULT;\n    }\n    getMessage(extensionId, details) {\n        const { message, args, comment } = details;\n        if (this.isDefaultLanguage) {\n            return format2(message, (args ?? {}));\n        }\n        let key = message;\n        if (comment && comment.length > 0) {\n            key += `/${Array.isArray(comment) ? comment.join('') : comment}`;\n        }\n        const str = this.bundleCache.get(extensionId)?.contents[key];\n        if (!str) {\n            this.logService.warn(`Using default string since no string found in i18n bundle that has the key: ${key}`);\n        }\n        return format2(str ?? message, (args ?? {}));\n    }\n    getBundle(extensionId) {\n        return this.bundleCache.get(extensionId)?.contents;\n    }\n    getBundleUri(extensionId) {\n        return this.bundleCache.get(extensionId)?.uri;\n    }\n    async initializeLocalizedMessages(extension) {\n        if (this.isDefaultLanguage\n            || (!extension.l10n && !extension.isBuiltin)) {\n            return;\n        }\n        if (( this.bundleCache.has(extension.identifier.value))) {\n            return;\n        }\n        let contents;\n        const bundleUri = await this.getBundleLocation(extension);\n        if (!bundleUri) {\n            this.logService.error(`No bundle location found for extension ${extension.identifier.value}`);\n            return;\n        }\n        try {\n            const response = await this._proxy.$fetchBundleContents(bundleUri);\n            const result = JSON.parse(response);\n            contents = extension.isBuiltin ? result.contents?.bundle : result;\n        }\n        catch (e) {\n            this.logService.error(`Failed to load translations for ${extension.identifier.value} from ${bundleUri}: ${e.message}`);\n            return;\n        }\n        if (contents) {\n            this.bundleCache.set(extension.identifier.value, {\n                contents,\n                uri: bundleUri\n            });\n        }\n    }\n    async getBundleLocation(extension) {\n        if (extension.isBuiltin) {\n            const uri = await this._proxy.$fetchBuiltInBundleUri(extension.identifier.value, this.currentLanguage);\n            return URI.revive(uri);\n        }\n        return extension.l10n\n            ? URI.joinPath(extension.extensionLocation, extension.l10n, `bundle.l10n.${this.currentLanguage}.json`)\n            : undefined;\n    }\n};\nExtHostLocalizationService = ( __decorate([\n    ( __param(0, IExtHostInitDataService)),\n    ( __param(1, IExtHostRpcService)),\n    ( __param(2, ILogService))\n], ExtHostLocalizationService));\nconst IExtHostLocalizationService = ( createDecorator('IExtHostLocalizationService'));\nexport { ExtHostLocalizationService, IExtHostLocalizationService };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { localize } from '../../../nls.js';\nimport { ILoggerService } from '../../../platform/log/common/log.service.js';\nimport { LogService } from '../../../platform/log/common/logService.js';\nimport { IExtHostInitDataService } from './extHostInitDataService.js';\nlet ExtHostLogService = class ExtHostLogService extends LogService {\n    constructor(isWorker, loggerService, initData) {\n        const id = initData.remote.isRemote ? 'remoteexthost' : isWorker ? 'workerexthost' : 'exthost';\n        const name = initData.remote.isRemote ? ( localize(709, \"Extension Host (Remote)\")) : isWorker ? ( localize(710, \"Extension Host (Worker)\")) : ( localize(711, \"Extension Host\"));\n        super(loggerService.createLogger(id, { name }));\n    }\n};\nExtHostLogService = ( (__decorate([\n    ( (__param(1, ILoggerService))),\n    ( (__param(2, IExtHostInitDataService)))\n], ExtHostLogService)));\nexport { ExtHostLogService };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { AbstractLoggerService, AbstractMessageLogger } from '../../../platform/log/common/log.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { IExtHostInitDataService } from './extHostInitDataService.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { revive } from '../../../base/common/marshalling.js';\nlet ExtHostLoggerService = class ExtHostLoggerService extends AbstractLoggerService {\n    constructor(rpc, initData) {\n        super(initData.logLevel, initData.logsLocation, ( initData.loggers.map(logger => revive(logger))));\n        this._proxy = ( rpc.getProxy(MainContext.MainThreadLogger));\n    }\n    $setLogLevel(logLevel, resource) {\n        if (resource) {\n            this.setLogLevel(URI.revive(resource), logLevel);\n        }\n        else {\n            this.setLogLevel(logLevel);\n        }\n    }\n    setVisibility(resource, visibility) {\n        super.setVisibility(resource, visibility);\n        this._proxy.$setVisibility(resource, visibility);\n    }\n    doCreateLogger(resource, logLevel, options) {\n        return ( new Logger(this._proxy, resource, logLevel, options));\n    }\n};\nExtHostLoggerService = ( __decorate([\n    ( __param(0, IExtHostRpcService)),\n    ( __param(1, IExtHostInitDataService))\n], ExtHostLoggerService));\nclass Logger extends AbstractMessageLogger {\n    constructor(proxy, file, logLevel, loggerOptions) {\n        super(loggerOptions?.logLevel === 'always');\n        this.proxy = proxy;\n        this.file = file;\n        this.isLoggerCreated = false;\n        this.buffer = [];\n        this.setLevel(logLevel);\n        this.proxy.$createLogger(file, loggerOptions)\n            .then(() => {\n            this.doLog(this.buffer);\n            this.isLoggerCreated = true;\n        });\n    }\n    log(level, message) {\n        const messages = [[level, message]];\n        if (this.isLoggerCreated) {\n            this.doLog(messages);\n        }\n        else {\n            this.buffer.push(...messages);\n        }\n    }\n    doLog(messages) {\n        this.proxy.$log(this.file, messages);\n    }\n    flush() {\n        this.proxy.$flush(this.file);\n    }\n}\nexport { ExtHostLoggerService };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { toDisposable, Disposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\nimport { VSBuffer } from '../../../base/common/buffer.js';\nconst IExtHostManagedSockets = ( createDecorator('IExtHostManagedSockets'));\nlet ExtHostManagedSockets = class ExtHostManagedSockets {\n    constructor(extHostRpc) {\n        this._remoteSocketIdCounter = 0;\n        this._factory = null;\n        this._managedRemoteSockets = ( new Map());\n        this._proxy = ( extHostRpc.getProxy(MainContext.MainThreadManagedSockets));\n    }\n    setFactory(socketFactoryId, makeConnection) {\n        for (const socket of ( this._managedRemoteSockets.values())) {\n            socket.dispose();\n        }\n        if (this._factory) {\n            this._proxy.$unregisterSocketFactory(this._factory.socketFactoryId);\n        }\n        this._factory = ( new ManagedSocketFactory(socketFactoryId, makeConnection));\n        this._proxy.$registerSocketFactory(this._factory.socketFactoryId);\n    }\n    async $openRemoteSocket(socketFactoryId) {\n        if (!this._factory || this._factory.socketFactoryId !== socketFactoryId) {\n            throw ( new Error(`No socket factory with id ${socketFactoryId}`));\n        }\n        const id = (++this._remoteSocketIdCounter);\n        const socket = await this._factory.makeConnection();\n        const disposable = ( new DisposableStore());\n        this._managedRemoteSockets.set(id, ( new ManagedSocket(id, socket, disposable)));\n        disposable.add(toDisposable(() => this._managedRemoteSockets.delete(id)));\n        disposable.add(socket.onDidEnd(() => {\n            this._proxy.$onDidManagedSocketEnd(id);\n            disposable.dispose();\n        }));\n        disposable.add(socket.onDidClose(e => {\n            this._proxy.$onDidManagedSocketClose(id, e?.stack ?? e?.message);\n            disposable.dispose();\n        }));\n        disposable.add(socket.onDidReceiveMessage(e => this._proxy.$onDidManagedSocketHaveData(id, VSBuffer.wrap(e))));\n        return id;\n    }\n    $remoteSocketWrite(socketId, buffer) {\n        this._managedRemoteSockets.get(socketId)?.actual.send(buffer.buffer);\n    }\n    $remoteSocketEnd(socketId) {\n        const socket = this._managedRemoteSockets.get(socketId);\n        if (socket) {\n            socket.actual.end();\n            socket.dispose();\n        }\n    }\n    async $remoteSocketDrain(socketId) {\n        await this._managedRemoteSockets.get(socketId)?.actual.drain?.();\n    }\n};\nExtHostManagedSockets = ( __decorate([\n    ( __param(0, IExtHostRpcService))\n], ExtHostManagedSockets));\nclass ManagedSocketFactory {\n    constructor(socketFactoryId, makeConnection) {\n        this.socketFactoryId = socketFactoryId;\n        this.makeConnection = makeConnection;\n    }\n}\nclass ManagedSocket extends Disposable {\n    constructor(socketId, actual, disposer) {\n        super();\n        this.socketId = socketId;\n        this.actual = actual;\n        this._register(disposer);\n    }\n}\nexport { ExtHostManagedSockets, IExtHostManagedSockets };\n","import { RunOnceScheduler, DeferredPromise } from '../../../base/common/async.js';\nclass ExtensionMemento {\n    constructor(id, global, storage) {\n        this._deferredPromises = ( new Map());\n        this._id = id;\n        this._shared = global;\n        this._storage = storage;\n        this._init = this._storage.initializeExtensionStorage(this._shared, this._id, Object.create(null)).then(value => {\n            this._value = value;\n            return this;\n        });\n        this._storageListener = this._storage.onDidChangeStorage(e => {\n            if (e.shared === this._shared && e.key === this._id) {\n                this._value = e.value;\n            }\n        });\n        this._scheduler = ( new RunOnceScheduler(() => {\n            const records = this._deferredPromises;\n            this._deferredPromises = ( new Map());\n            (async () => {\n                try {\n                    await this._storage.setValue(this._shared, this._id, this._value);\n                    for (const value of ( records.values())) {\n                        value.complete();\n                    }\n                }\n                catch (e) {\n                    for (const value of ( records.values())) {\n                        value.error(e);\n                    }\n                }\n            })();\n        }, 0));\n    }\n    keys() {\n        return ( Object.entries(this._value ?? {}).filter(([, value]) => value !== undefined).map(([key]) => key));\n    }\n    get whenReady() {\n        return this._init;\n    }\n    get(key, defaultValue) {\n        let value = this._value[key];\n        if (typeof value === 'undefined') {\n            value = defaultValue;\n        }\n        return value;\n    }\n    update(key, value) {\n        this._value[key] = value;\n        const record = this._deferredPromises.get(key);\n        if (record !== undefined) {\n            return record.p;\n        }\n        const promise = ( new DeferredPromise());\n        this._deferredPromises.set(key, promise);\n        if (!this._scheduler.isScheduled()) {\n            this._scheduler.schedule();\n        }\n        return promise.p;\n    }\n    dispose() {\n        this._storageListener.dispose();\n    }\n}\nclass ExtensionGlobalMemento extends ExtensionMemento {\n    setKeysForSync(keys) {\n        this._storage.registerExtensionStorageKeysToSync({ id: this._id, version: this._extension.version }, keys);\n    }\n    constructor(extensionDescription, storage) {\n        super(extensionDescription.identifier.value, true, storage);\n        this._extension = extensionDescription;\n    }\n}\nexport { ExtensionGlobalMemento, ExtensionMemento };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { ILogService } from '../../../platform/log/common/log.service.js';\nimport { checkProposedApiEnabled } from '../../services/extensions/common/extensions.js';\nfunction isMessageItem(item) {\n    return item && item.title;\n}\nlet ExtHostMessageService = class ExtHostMessageService {\n    constructor(mainContext, _logService) {\n        this._logService = _logService;\n        this._proxy = ( mainContext.getProxy(MainContext.MainThreadMessageService));\n    }\n    showMessage(extension, severity, message, optionsOrFirstItem, rest) {\n        const options = {\n            source: { identifier: extension.identifier, label: extension.displayName || extension.name }\n        };\n        let items;\n        if (typeof optionsOrFirstItem === 'string' || isMessageItem(optionsOrFirstItem)) {\n            items = [optionsOrFirstItem, ...rest];\n        }\n        else {\n            options.modal = optionsOrFirstItem?.modal;\n            options.useCustom = optionsOrFirstItem?.useCustom;\n            options.detail = optionsOrFirstItem?.detail;\n            items = rest;\n        }\n        if (options.useCustom) {\n            checkProposedApiEnabled(extension, 'resolvers');\n        }\n        const commands = [];\n        let hasCloseAffordance = false;\n        for (let handle = 0; handle < items.length; handle++) {\n            const command = items[handle];\n            if (typeof command === 'string') {\n                commands.push({ title: command, handle, isCloseAffordance: false });\n            }\n            else if (typeof command === 'object') {\n                const { title, isCloseAffordance } = command;\n                commands.push({ title, isCloseAffordance: !!isCloseAffordance, handle });\n                if (isCloseAffordance) {\n                    if (hasCloseAffordance) {\n                        this._logService.warn(`[${extension.identifier}] Only one message item can have 'isCloseAffordance':`, command);\n                    }\n                    else {\n                        hasCloseAffordance = true;\n                    }\n                }\n            }\n            else {\n                this._logService.warn(`[${extension.identifier}] Invalid message item:`, command);\n            }\n        }\n        return this._proxy.$showMessage(severity, message, options, commands).then(handle => {\n            if (typeof handle === 'number') {\n                return items[handle];\n            }\n            return undefined;\n        });\n    }\n};\nExtHostMessageService = ( __decorate([\n    ( __param(1, ILogService))\n], ExtHostMessageService));\nexport { ExtHostMessageService };\n","import { localize } from '../../../nls.js';\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { toDisposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport { ResourceMap, ResourceSet } from '../../../base/common/map.js';\nimport { isFalsyOrWhitespace } from '../../../base/common/strings.js';\nimport { assertIsDefined } from '../../../base/common/types.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { FileOperationError, FileType, FilePermission, etag, ETAG_DISABLED } from '../../../platform/files/common/files.js';\nimport { Cache } from './cache.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { ApiCommandArgument, ApiCommand, ApiCommandResult } from './extHostCommands.js';\nimport { NotebookExclusiveDocumentPattern, NotebookData, ViewColumn, NotebookRange, NotebookDocumentContentOptions, NotebookStatusBarItem } from './extHostTypeConverters.js';\nimport { Disposable, NotebookCellData } from './extHostTypes.js';\nimport { SerializableObjectWithBuffers } from '../../services/extensions/common/proxyIdentifier.js';\nimport { ExtHostNotebookDocument, ExtHostCell } from './extHostNotebookDocument.js';\nimport { ExtHostNotebookEditor } from './extHostNotebookEditor.js';\nimport { filter } from '../../../base/common/objects.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { CellSearchModel } from '../../contrib/search/common/cellSearchModel.js';\nimport { genericCellMatchesToTextSearchMatches } from '../../contrib/search/common/searchNotebookHelpers.js';\nimport { RegisteredEditorPriority, globMatchesResource } from '../../services/editor/common/editorResolverService.js';\nclass ExtHostNotebookController {\n    static { this._notebookStatusBarItemProviderHandlePool = 0; }\n    get activeNotebookEditor() {\n        return this._activeNotebookEditor?.apiEditor;\n    }\n    get visibleNotebookEditors() {\n        return ( this._visibleNotebookEditors.map(editor => editor.apiEditor));\n    }\n    constructor(mainContext, commands, _textDocumentsAndEditors, _textDocuments, _extHostFileSystem, _extHostSearch, _logService) {\n        this._textDocumentsAndEditors = _textDocumentsAndEditors;\n        this._textDocuments = _textDocuments;\n        this._extHostFileSystem = _extHostFileSystem;\n        this._extHostSearch = _extHostSearch;\n        this._logService = _logService;\n        this._notebookStatusBarItemProviders = ( new Map());\n        this._documents = ( new ResourceMap());\n        this._editors = ( new Map());\n        this._onDidChangeActiveNotebookEditor = ( new Emitter());\n        this.onDidChangeActiveNotebookEditor = this._onDidChangeActiveNotebookEditor.event;\n        this._visibleNotebookEditors = [];\n        this._onDidOpenNotebookDocument = ( new Emitter());\n        this.onDidOpenNotebookDocument = this._onDidOpenNotebookDocument.event;\n        this._onDidCloseNotebookDocument = ( new Emitter());\n        this.onDidCloseNotebookDocument = this._onDidCloseNotebookDocument.event;\n        this._onDidChangeVisibleNotebookEditors = ( new Emitter());\n        this.onDidChangeVisibleNotebookEditors = this._onDidChangeVisibleNotebookEditors.event;\n        this._statusBarCache = ( new Cache('NotebookCellStatusBarCache'));\n        this._handlePool = 0;\n        this._notebookSerializer = ( new Map());\n        this._notebookProxy = ( mainContext.getProxy(MainContext.MainThreadNotebook));\n        this._notebookDocumentsProxy = ( mainContext.getProxy(MainContext.MainThreadNotebookDocuments));\n        this._notebookEditorsProxy = ( mainContext.getProxy(MainContext.MainThreadNotebookEditors));\n        this._commandsConverter = commands.converter;\n        commands.registerArgumentProcessor({\n            processArgument: (arg) => {\n                if (arg && arg.$mid === 13 ) {\n                    const notebookUri = arg.notebookEditor?.notebookUri;\n                    const cellHandle = arg.cell.handle;\n                    const data = this._documents.get(notebookUri);\n                    const cell = data?.getCell(cellHandle);\n                    if (cell) {\n                        return cell.apiCell;\n                    }\n                }\n                if (arg && arg.$mid === 14 ) {\n                    const notebookUri = arg.uri;\n                    const data = this._documents.get(notebookUri);\n                    if (data) {\n                        return data.apiNotebook;\n                    }\n                }\n                return arg;\n            }\n        });\n        ExtHostNotebookController._registerApiCommands(commands);\n    }\n    getEditorById(editorId) {\n        const editor = this._editors.get(editorId);\n        if (!editor) {\n            throw ( new Error(`unknown text editor: ${editorId}. known editors: ${[...( this._editors.keys())]} `));\n        }\n        return editor;\n    }\n    getIdByEditor(editor) {\n        for (const [id, candidate] of this._editors) {\n            if (candidate.apiEditor === editor) {\n                return id;\n            }\n        }\n        return undefined;\n    }\n    get notebookDocuments() {\n        return [...( this._documents.values())];\n    }\n    getNotebookDocument(uri, relaxed) {\n        const result = this._documents.get(uri);\n        if (!result && !relaxed) {\n            throw ( new Error(`NO notebook document for '${uri}'`));\n        }\n        return result;\n    }\n    static _convertNotebookRegistrationData(extension, registration) {\n        if (!registration) {\n            return;\n        }\n        const viewOptionsFilenamePattern = ( registration.filenamePattern\n            .map(pattern => NotebookExclusiveDocumentPattern.from(pattern)))\n            .filter(pattern => pattern !== undefined);\n        if (registration.filenamePattern && !viewOptionsFilenamePattern) {\n            console.warn(`Notebook content provider view options file name pattern is invalid ${registration.filenamePattern}`);\n            return undefined;\n        }\n        return {\n            extension: extension.identifier,\n            providerDisplayName: extension.displayName || extension.name,\n            displayName: registration.displayName,\n            filenamePattern: viewOptionsFilenamePattern,\n            priority: registration.exclusive ? RegisteredEditorPriority.exclusive : undefined\n        };\n    }\n    registerNotebookCellStatusBarItemProvider(extension, notebookType, provider) {\n        const handle = ExtHostNotebookController._notebookStatusBarItemProviderHandlePool++;\n        const eventHandle = typeof provider.onDidChangeCellStatusBarItems === 'function' ? ExtHostNotebookController._notebookStatusBarItemProviderHandlePool++ : undefined;\n        this._notebookStatusBarItemProviders.set(handle, provider);\n        this._notebookProxy.$registerNotebookCellStatusBarItemProvider(handle, eventHandle, notebookType);\n        let subscription;\n        if (eventHandle !== undefined) {\n            subscription = provider.onDidChangeCellStatusBarItems(_ => this._notebookProxy.$emitCellStatusBarEvent(eventHandle));\n        }\n        return new Disposable(() => {\n            this._notebookStatusBarItemProviders.delete(handle);\n            this._notebookProxy.$unregisterNotebookCellStatusBarItemProvider(handle, eventHandle);\n            subscription?.dispose();\n        });\n    }\n    async createNotebookDocument(options) {\n        const canonicalUri = await this._notebookDocumentsProxy.$tryCreateNotebook({\n            viewType: options.viewType,\n            content: options.content && NotebookData.from(options.content)\n        });\n        return URI.revive(canonicalUri);\n    }\n    async openNotebookDocument(uri) {\n        const cached = this._documents.get(uri);\n        if (cached) {\n            return cached.apiNotebook;\n        }\n        const canonicalUri = await this._notebookDocumentsProxy.$tryOpenNotebook(uri);\n        const document = this._documents.get(URI.revive(canonicalUri));\n        return assertIsDefined(document?.apiNotebook);\n    }\n    async showNotebookDocument(notebook, options) {\n        let resolvedOptions;\n        if (typeof options === 'object') {\n            resolvedOptions = {\n                position: ViewColumn.from(options.viewColumn),\n                preserveFocus: options.preserveFocus,\n                selections: options.selections && ( options.selections.map(NotebookRange.from)),\n                pinned: typeof options.preview === 'boolean' ? !options.preview : undefined,\n                label: typeof options.asRepl === 'string' ?\n                    options.asRepl :\n                    typeof options.asRepl === 'object' ?\n                        options.asRepl.label :\n                        undefined,\n            };\n        }\n        else {\n            resolvedOptions = {\n                preserveFocus: false,\n                pinned: true\n            };\n        }\n        const viewType = !!options?.asRepl ? 'repl' : notebook.notebookType;\n        const editorId = await this._notebookEditorsProxy.$tryShowNotebookDocument(notebook.uri, viewType, resolvedOptions);\n        const editor = editorId && this._editors.get(editorId)?.apiEditor;\n        if (editor) {\n            return editor;\n        }\n        if (editorId) {\n            throw ( new Error(`Could NOT open editor for \"${( notebook.uri.toString())}\" because another editor opened in the meantime.`));\n        }\n        else {\n            throw ( new Error(`Could NOT open editor for \"${( notebook.uri.toString())}\".`));\n        }\n    }\n    async $provideNotebookCellStatusBarItems(handle, uri, index, token) {\n        const provider = this._notebookStatusBarItemProviders.get(handle);\n        const revivedUri = URI.revive(uri);\n        const document = this._documents.get(revivedUri);\n        if (!document || !provider) {\n            return;\n        }\n        const cell = document.getCellFromIndex(index);\n        if (!cell) {\n            return;\n        }\n        const result = await provider.provideCellStatusBarItems(cell.apiCell, token);\n        if (!result) {\n            return undefined;\n        }\n        const disposables = ( new DisposableStore());\n        const cacheId = this._statusBarCache.add([disposables]);\n        const resultArr = Array.isArray(result) ? result : [result];\n        const items = ( resultArr.map(\n            item => NotebookStatusBarItem.from(item, this._commandsConverter, disposables)\n        ));\n        return {\n            cacheId,\n            items\n        };\n    }\n    $releaseNotebookCellStatusBarItems(cacheId) {\n        this._statusBarCache.delete(cacheId);\n    }\n    registerNotebookSerializer(extension, viewType, serializer, options, registration) {\n        if (isFalsyOrWhitespace(viewType)) {\n            throw ( new Error(`viewType cannot be empty or just whitespace`));\n        }\n        const handle = this._handlePool++;\n        this._notebookSerializer.set(handle, { viewType, serializer, options });\n        this._notebookProxy.$registerNotebookSerializer(handle, { id: extension.identifier, location: extension.extensionLocation }, viewType, NotebookDocumentContentOptions.from(options), ExtHostNotebookController._convertNotebookRegistrationData(extension, registration));\n        return toDisposable(() => {\n            this._notebookProxy.$unregisterNotebookSerializer(handle);\n        });\n    }\n    async $dataToNotebook(handle, bytes, token) {\n        const serializer = this._notebookSerializer.get(handle);\n        if (!serializer) {\n            throw ( new Error('NO serializer found'));\n        }\n        const data = await serializer.serializer.deserializeNotebook(bytes.buffer, token);\n        return ( new SerializableObjectWithBuffers(NotebookData.from(data)));\n    }\n    async $notebookToData(handle, data, token) {\n        const serializer = this._notebookSerializer.get(handle);\n        if (!serializer) {\n            throw ( new Error('NO serializer found'));\n        }\n        const bytes = await serializer.serializer.serializeNotebook(NotebookData.to(data.value), token);\n        return VSBuffer.wrap(bytes);\n    }\n    async $saveNotebook(handle, uriComponents, versionId, options, token) {\n        const uri = URI.revive(uriComponents);\n        const serializer = this._notebookSerializer.get(handle);\n        this.trace(`enter saveNotebook(versionId: ${versionId}, ${( uri.toString())})`);\n        if (!serializer) {\n            throw ( new Error('NO serializer found'));\n        }\n        const document = this._documents.get(uri);\n        if (!document) {\n            throw ( new Error('Document NOT found'));\n        }\n        if (document.versionId !== versionId) {\n            throw ( new Error('Document version mismatch'));\n        }\n        if (!this._extHostFileSystem.value.isWritableFileSystem(uri.scheme)) {\n            throw new FileOperationError(localize(4800, \"Unable to modify read-only file '{0}'\", this._resourceForError(uri)), 6 );\n        }\n        const data = {\n            metadata: filter(document.apiNotebook.metadata, key => !(serializer.options?.transientDocumentMetadata ?? {})[key]),\n            cells: [],\n        };\n        for (const cell of document.apiNotebook.getCells()) {\n            const cellData = new NotebookCellData(cell.kind, cell.document.getText(), cell.document.languageId, cell.mime, !(serializer.options?.transientOutputs) ? [...cell.outputs] : [], cell.metadata, cell.executionSummary);\n            cellData.metadata = filter(cell.metadata, key => !(serializer.options?.transientCellMetadata ?? {})[key]);\n            data.cells.push(cellData);\n        }\n        await this._validateWriteFile(uri, options);\n        if (token.isCancellationRequested) {\n            throw ( new Error('canceled'));\n        }\n        const bytes = await serializer.serializer.serializeNotebook(data, token);\n        if (token.isCancellationRequested) {\n            throw ( new Error('canceled'));\n        }\n        this.trace(`serialized versionId: ${versionId} ${( uri.toString())}`);\n        await this._extHostFileSystem.value.writeFile(uri, bytes);\n        this.trace(`Finished write versionId: ${versionId} ${( uri.toString())}`);\n        const providerExtUri = this._extHostFileSystem.getFileSystemProviderExtUri(uri.scheme);\n        const stat = await this._extHostFileSystem.value.stat(uri);\n        const fileStats = {\n            name: providerExtUri.basename(uri),\n            isFile: (stat.type & FileType.File) !== 0,\n            isDirectory: (stat.type & FileType.Directory) !== 0,\n            isSymbolicLink: (stat.type & FileType.SymbolicLink) !== 0,\n            mtime: stat.mtime,\n            ctime: stat.ctime,\n            size: stat.size,\n            readonly: Boolean((stat.permissions ?? 0) & FilePermission.Readonly) || !this._extHostFileSystem.value.isWritableFileSystem(uri.scheme),\n            locked: Boolean((stat.permissions ?? 0) & FilePermission.Locked),\n            etag: etag({ mtime: stat.mtime, size: stat.size }),\n            children: undefined\n        };\n        this.trace(`exit saveNotebook(versionId: ${versionId}, ${( uri.toString())})`);\n        return fileStats;\n    }\n    async $searchInNotebooks(handle, textQuery, viewTypeFileTargets, otherViewTypeFileTargets, token) {\n        const serializer = this._notebookSerializer.get(handle)?.serializer;\n        if (!serializer) {\n            return {\n                limitHit: false,\n                results: []\n            };\n        }\n        const finalMatchedTargets = ( new ResourceSet());\n        const runFileQueries = async (includes, token, textQuery) => {\n            await Promise.all(( includes.map(async (include) => await Promise.all(( include.filenamePatterns.map(filePattern => {\n                const query = {\n                    _reason: textQuery._reason,\n                    folderQueries: textQuery.folderQueries,\n                    includePattern: textQuery.includePattern,\n                    excludePattern: textQuery.excludePattern,\n                    maxResults: textQuery.maxResults,\n                    type: 1 ,\n                    filePattern\n                };\n                return this._extHostSearch.doInternalFileSearchWithCustomCallback(query, token, (data) => {\n                    data.forEach(uri => {\n                        if (( finalMatchedTargets.has(uri))) {\n                            return;\n                        }\n                        const hasOtherMatches = ( otherViewTypeFileTargets.some(target => {\n                            if (include.isFromSettings && !target.isFromSettings) {\n                                return false;\n                            }\n                            else {\n                                return ( target.filenamePatterns.some(targetFilePattern => globMatchesResource(targetFilePattern, uri)));\n                            }\n                        }));\n                        if (hasOtherMatches) {\n                            return;\n                        }\n                        finalMatchedTargets.add(uri);\n                    });\n                }).catch(err => {\n                    if (err.code === 'ENOENT') {\n                        console.warn(`Could not find notebook search results, ignoring notebook results.`);\n                        return {\n                            limitHit: false,\n                            messages: [],\n                        };\n                    }\n                    else {\n                        throw err;\n                    }\n                });\n            }))))));\n            return;\n        };\n        await runFileQueries(viewTypeFileTargets, token, textQuery);\n        const results = ( new ResourceMap());\n        let limitHit = false;\n        const promises = ( Array.from(finalMatchedTargets).map(async (uri) => {\n            const cellMatches = [];\n            try {\n                if (token.isCancellationRequested) {\n                    return;\n                }\n                if (textQuery.maxResults && [...( results.values())].reduce((acc, value) => acc + value.cellResults.length, 0) > textQuery.maxResults) {\n                    limitHit = true;\n                    return;\n                }\n                const simpleCells = [];\n                const notebook = this._documents.get(uri);\n                if (notebook) {\n                    const cells = notebook.apiNotebook.getCells();\n                    cells.forEach(e => simpleCells.push({\n                        input: e.document.getText(),\n                        outputs: e.outputs.flatMap(value => ( value.items.map(output => ( output.data.toString()))))\n                    }));\n                }\n                else {\n                    const fileContent = await this._extHostFileSystem.value.readFile(uri);\n                    const bytes = VSBuffer.fromString(( fileContent.toString()));\n                    const notebook = await serializer.deserializeNotebook(bytes.buffer, token);\n                    if (token.isCancellationRequested) {\n                        return;\n                    }\n                    const data = NotebookData.from(notebook);\n                    data.cells.forEach(cell => simpleCells.push({\n                        input: cell.source,\n                        outputs: cell.outputs.flatMap(value => ( value.items.map(output => ( output.valueBytes.toString()))))\n                    }));\n                }\n                if (token.isCancellationRequested) {\n                    return;\n                }\n                simpleCells.forEach((cell, index) => {\n                    const target = textQuery.contentPattern.pattern;\n                    const cellModel = ( new CellSearchModel(cell.input, undefined, cell.outputs));\n                    const inputMatches = cellModel.findInInputs(target);\n                    const outputMatches = cellModel.findInOutputs(target);\n                    const webviewResults = ( outputMatches\n                        .flatMap(outputMatch => genericCellMatchesToTextSearchMatches(outputMatch.matches, outputMatch.textBuffer))\n                        .map((textMatch, index) => {\n                        textMatch.webviewIndex = index;\n                        return textMatch;\n                    }));\n                    if (inputMatches.length > 0 || outputMatches.length > 0) {\n                        const cellMatch = {\n                            index: index,\n                            contentResults: genericCellMatchesToTextSearchMatches(inputMatches, cellModel.inputTextBuffer),\n                            webviewResults\n                        };\n                        cellMatches.push(cellMatch);\n                    }\n                });\n                const fileMatch = {\n                    resource: uri, cellResults: cellMatches\n                };\n                results.set(uri, fileMatch);\n                return;\n            }\n            catch (e) {\n                return;\n            }\n        }));\n        await Promise.all(promises);\n        return {\n            limitHit,\n            results: [...( results.values())]\n        };\n    }\n    async _validateWriteFile(uri, options) {\n        const stat = await this._extHostFileSystem.value.stat(uri);\n        if (typeof options?.mtime === 'number' && typeof options.etag === 'string' && options.etag !== ETAG_DISABLED &&\n            typeof stat.mtime === 'number' && typeof stat.size === 'number' &&\n            options.mtime < stat.mtime && options.etag !== etag({ mtime: options.mtime , size: stat.size })) {\n            throw new FileOperationError(localize(4801, \"File Modified Since\"), 3 , options);\n        }\n        return;\n    }\n    _resourceForError(uri) {\n        return uri.scheme === Schemas.file ? uri.fsPath : ( uri.toString());\n    }\n    _createExtHostEditor(document, editorId, data) {\n        if (( this._editors.has(editorId))) {\n            throw ( new Error(`editor with id ALREADY EXSIST: ${editorId}`));\n        }\n        const editor = ( new ExtHostNotebookEditor(editorId, this._notebookEditorsProxy, document, ( data.visibleRanges.map(NotebookRange.to)), ( data.selections.map(NotebookRange.to)), typeof data.viewColumn === 'number' ? ViewColumn.to(data.viewColumn) : undefined, data.viewType));\n        this._editors.set(editorId, editor);\n    }\n    $acceptDocumentAndEditorsDelta(delta) {\n        if (delta.value.removedDocuments) {\n            for (const uri of delta.value.removedDocuments) {\n                const revivedUri = URI.revive(uri);\n                const document = this._documents.get(revivedUri);\n                if (document) {\n                    document.dispose();\n                    this._documents.delete(revivedUri);\n                    this._textDocumentsAndEditors.$acceptDocumentsAndEditorsDelta({ removedDocuments: ( document.apiNotebook.getCells().map(cell => cell.document.uri)) });\n                    this._onDidCloseNotebookDocument.fire(document.apiNotebook);\n                }\n                for (const editor of ( this._editors.values())) {\n                    if (( editor.notebookData.uri.toString()) === ( revivedUri.toString())) {\n                        this._editors.delete(editor.id);\n                    }\n                }\n            }\n        }\n        if (delta.value.addedDocuments) {\n            const addedCellDocuments = [];\n            for (const modelData of delta.value.addedDocuments) {\n                const uri = URI.revive(modelData.uri);\n                if (( this._documents.has(uri))) {\n                    throw ( new Error(`adding EXISTING notebook ${uri} `));\n                }\n                const document = ( new ExtHostNotebookDocument(\n                    this._notebookDocumentsProxy,\n                    this._textDocumentsAndEditors,\n                    this._textDocuments,\n                    uri,\n                    modelData\n                ));\n                addedCellDocuments.push(...( modelData.cells.map(cell => ExtHostCell.asModelAddData(cell))));\n                this._documents.get(uri)?.dispose();\n                this._documents.set(uri, document);\n                this._textDocumentsAndEditors.$acceptDocumentsAndEditorsDelta({ addedDocuments: addedCellDocuments });\n                this._onDidOpenNotebookDocument.fire(document.apiNotebook);\n            }\n        }\n        if (delta.value.addedEditors) {\n            for (const editorModelData of delta.value.addedEditors) {\n                if (( this._editors.has(editorModelData.id))) {\n                    return;\n                }\n                const revivedUri = URI.revive(editorModelData.documentUri);\n                const document = this._documents.get(revivedUri);\n                if (document) {\n                    this._createExtHostEditor(document, editorModelData.id, editorModelData);\n                }\n            }\n        }\n        if (delta.value.removedEditors) {\n            for (const editorid of delta.value.removedEditors) {\n                const editor = this._editors.get(editorid);\n                if (editor) {\n                    this._editors.delete(editorid);\n                    if (this._activeNotebookEditor?.id === editor.id) {\n                        this._activeNotebookEditor = undefined;\n                    }\n                }\n            }\n        }\n        if (delta.value.visibleEditors) {\n            this._visibleNotebookEditors = ( delta.value.visibleEditors.map(id => this._editors.get(id))).filter(editor => !!editor);\n            const visibleEditorsSet = ( new Set());\n            this._visibleNotebookEditors.forEach(editor => visibleEditorsSet.add(editor.id));\n            for (const editor of ( this._editors.values())) {\n                const newValue = ( visibleEditorsSet.has(editor.id));\n                editor._acceptVisibility(newValue);\n            }\n            this._visibleNotebookEditors = ( [...( this._editors.values())].map(e => e)).filter(e => e.visible);\n            this._onDidChangeVisibleNotebookEditors.fire(this.visibleNotebookEditors);\n        }\n        if (delta.value.newActiveEditor === null) {\n            this._activeNotebookEditor = undefined;\n        }\n        else if (delta.value.newActiveEditor) {\n            const activeEditor = this._editors.get(delta.value.newActiveEditor);\n            if (!activeEditor) {\n                console.error(`FAILED to find active notebook editor ${delta.value.newActiveEditor}`);\n            }\n            this._activeNotebookEditor = this._editors.get(delta.value.newActiveEditor);\n        }\n        if (delta.value.newActiveEditor !== undefined) {\n            this._onDidChangeActiveNotebookEditor.fire(this._activeNotebookEditor?.apiEditor);\n        }\n    }\n    static _registerApiCommands(extHostCommands) {\n        const notebookTypeArg = ApiCommandArgument.String.with('notebookType', 'A notebook type');\n        const commandDataToNotebook = ( new ApiCommand(\n            'vscode.executeDataToNotebook',\n            '_executeDataToNotebook',\n            'Invoke notebook serializer',\n            [notebookTypeArg, ( new ApiCommandArgument(\n                'data',\n                'Bytes to convert to data',\n                v => v instanceof Uint8Array,\n                v => VSBuffer.wrap(v)\n            ))],\n            ( new ApiCommandResult('Notebook Data', data => NotebookData.to(data.value)))\n        ));\n        const commandNotebookToData = ( new ApiCommand(\n            'vscode.executeNotebookToData',\n            '_executeNotebookToData',\n            'Invoke notebook serializer',\n            [notebookTypeArg, ( new ApiCommandArgument(\n                'NotebookData',\n                'Notebook data to convert to bytes',\n                v => true,\n                v => ( new SerializableObjectWithBuffers(NotebookData.from(v)))\n            ))],\n            ( new ApiCommandResult('Bytes', dto => dto.buffer))\n        ));\n        extHostCommands.registerApiCommand(commandDataToNotebook);\n        extHostCommands.registerApiCommand(commandNotebookToData);\n    }\n    trace(msg) {\n        this._logService.trace(`[Extension Host Notebook] ${msg}`);\n    }\n}\nexport { ExtHostNotebookController };\n","import { Schemas } from '../../../base/common/network.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { NotebookCellOutput, NotebookCellExecutionSummary, NotebookCellKind, NotebookCellOutputItem } from './extHostTypeConverters.js';\nimport { NotebookRange } from './extHostTypes.js';\nimport { isTextStreamMime, compressOutputItemStreams, NotebookCellsChangeType } from '../../contrib/notebook/common/notebookCommon.js';\nclass RawContentChangeEvent {\n    constructor(start, deletedCount, deletedItems, items) {\n        this.start = start;\n        this.deletedCount = deletedCount;\n        this.deletedItems = deletedItems;\n        this.items = items;\n    }\n    asApiEvent() {\n        return {\n            range: ( new NotebookRange(this.start, this.start + this.deletedCount)),\n            addedCells: ( this.items.map(cell => cell.apiCell)),\n            removedCells: this.deletedItems,\n        };\n    }\n}\nclass ExtHostCell {\n    static asModelAddData(cell) {\n        return {\n            EOL: cell.eol,\n            lines: cell.source,\n            languageId: cell.language,\n            uri: cell.uri,\n            isDirty: false,\n            versionId: 1\n        };\n    }\n    constructor(notebook, _extHostDocument, _cellData) {\n        this.notebook = notebook;\n        this._extHostDocument = _extHostDocument;\n        this._cellData = _cellData;\n        this.handle = _cellData.handle;\n        this.uri = URI.revive(_cellData.uri);\n        this.cellKind = _cellData.cellKind;\n        this._outputs = ( _cellData.outputs.map(NotebookCellOutput.to));\n        this._internalMetadata = _cellData.internalMetadata ?? {};\n        this._metadata = ( Object.freeze(_cellData.metadata ?? {}));\n        this._previousResult = ( Object.freeze(\n            NotebookCellExecutionSummary.to(_cellData.internalMetadata ?? {})\n        ));\n    }\n    get internalMetadata() {\n        return this._internalMetadata;\n    }\n    get apiCell() {\n        if (!this._apiCell) {\n            const that = this;\n            const data = this._extHostDocument.getDocument(this.uri);\n            if (!data) {\n                throw ( new Error(`MISSING extHostDocument for notebook cell: ${this.uri}`));\n            }\n            const apiCell = {\n                get index() { return that.notebook.getCellIndex(that); },\n                notebook: that.notebook.apiNotebook,\n                kind: NotebookCellKind.to(this._cellData.cellKind),\n                document: data.document,\n                get mime() { return that._mime; },\n                set mime(value) { that._mime = value; },\n                get outputs() { return that._outputs.slice(0); },\n                get metadata() { return that._metadata; },\n                get executionSummary() { return that._previousResult; }\n            };\n            this._apiCell = ( Object.freeze(apiCell));\n        }\n        return this._apiCell;\n    }\n    setOutputs(newOutputs) {\n        this._outputs = ( newOutputs.map(NotebookCellOutput.to));\n    }\n    setOutputItems(outputId, append, newOutputItems) {\n        const newItems = ( newOutputItems.map(NotebookCellOutputItem.to));\n        const output = this._outputs.find(op => op.id === outputId);\n        if (output) {\n            if (!append) {\n                output.items.length = 0;\n            }\n            output.items.push(...newItems);\n            if (output.items.length > 1 && output.items.every(item => isTextStreamMime(item.mime))) {\n                const mimeOutputs = ( new Map());\n                const mimeTypes = [];\n                output.items.forEach(item => {\n                    let items;\n                    if (( mimeOutputs.has(item.mime))) {\n                        items = mimeOutputs.get(item.mime);\n                    }\n                    else {\n                        items = [];\n                        mimeOutputs.set(item.mime, items);\n                        mimeTypes.push(item.mime);\n                    }\n                    items.push(item.data);\n                });\n                output.items.length = 0;\n                mimeTypes.forEach(mime => {\n                    const compressed = compressOutputItemStreams(mimeOutputs.get(mime));\n                    output.items.push({\n                        mime,\n                        data: compressed.data.buffer\n                    });\n                });\n            }\n        }\n    }\n    setMetadata(newMetadata) {\n        this._metadata = ( Object.freeze(newMetadata));\n    }\n    setInternalMetadata(newInternalMetadata) {\n        this._internalMetadata = newInternalMetadata;\n        this._previousResult = ( Object.freeze(NotebookCellExecutionSummary.to(newInternalMetadata)));\n    }\n    setMime(newMime) {\n    }\n}\nclass ExtHostNotebookDocument {\n    static { this._handlePool = 0; }\n    constructor(_proxy, _textDocumentsAndEditors, _textDocuments, uri, data) {\n        this._proxy = _proxy;\n        this._textDocumentsAndEditors = _textDocumentsAndEditors;\n        this._textDocuments = _textDocuments;\n        this.uri = uri;\n        this.handle = ExtHostNotebookDocument._handlePool++;\n        this._cells = [];\n        this._versionId = 0;\n        this._isDirty = false;\n        this._disposed = false;\n        this._notebookType = data.viewType;\n        this._metadata = ( Object.freeze(data.metadata ?? Object.create(null)));\n        this._spliceNotebookCells([[0, 0, data.cells]], true , undefined);\n        this._versionId = data.versionId;\n    }\n    dispose() {\n        this._disposed = true;\n    }\n    get versionId() {\n        return this._versionId;\n    }\n    get apiNotebook() {\n        if (!this._notebook) {\n            const that = this;\n            const apiObject = {\n                get uri() { return that.uri; },\n                get version() { return that._versionId; },\n                get notebookType() { return that._notebookType; },\n                get isDirty() { return that._isDirty; },\n                get isUntitled() { return that.uri.scheme === Schemas.untitled; },\n                get isClosed() { return that._disposed; },\n                get metadata() { return that._metadata; },\n                get cellCount() { return that._cells.length; },\n                cellAt(index) {\n                    index = that._validateIndex(index);\n                    return that._cells[index].apiCell;\n                },\n                getCells(range) {\n                    const cells = range ? that._getCells(range) : that._cells;\n                    return ( cells.map(cell => cell.apiCell));\n                },\n                save() {\n                    return that._save();\n                },\n                [Symbol.for('debug.description')]() {\n                    return `NotebookDocument(${( this.uri.toString())})`;\n                }\n            };\n            this._notebook = ( Object.freeze(apiObject));\n        }\n        return this._notebook;\n    }\n    acceptDocumentPropertiesChanged(data) {\n        if (data.metadata) {\n            this._metadata = ( Object.freeze({ ...this._metadata, ...data.metadata }));\n        }\n    }\n    acceptDirty(isDirty) {\n        this._isDirty = isDirty;\n    }\n    acceptModelChanged(event, isDirty, newMetadata) {\n        this._versionId = event.versionId;\n        this._isDirty = isDirty;\n        this.acceptDocumentPropertiesChanged({ metadata: newMetadata });\n        const result = {\n            notebook: this.apiNotebook,\n            metadata: newMetadata,\n            cellChanges: [],\n            contentChanges: [],\n        };\n        const relaxedCellChanges = [];\n        for (const rawEvent of event.rawEvents) {\n            if (rawEvent.kind === NotebookCellsChangeType.ModelChange) {\n                this._spliceNotebookCells(rawEvent.changes, false, result.contentChanges);\n            }\n            else if (rawEvent.kind === NotebookCellsChangeType.Move) {\n                this._moveCells(rawEvent.index, rawEvent.length, rawEvent.newIdx, result.contentChanges);\n            }\n            else if (rawEvent.kind === NotebookCellsChangeType.Output) {\n                this._setCellOutputs(rawEvent.index, rawEvent.outputs);\n                relaxedCellChanges.push({ cell: this._cells[rawEvent.index].apiCell, outputs: this._cells[rawEvent.index].apiCell.outputs });\n            }\n            else if (rawEvent.kind === NotebookCellsChangeType.OutputItem) {\n                this._setCellOutputItems(rawEvent.index, rawEvent.outputId, rawEvent.append, rawEvent.outputItems);\n                relaxedCellChanges.push({ cell: this._cells[rawEvent.index].apiCell, outputs: this._cells[rawEvent.index].apiCell.outputs });\n            }\n            else if (rawEvent.kind === NotebookCellsChangeType.ChangeCellLanguage) {\n                this._changeCellLanguage(rawEvent.index, rawEvent.language);\n                relaxedCellChanges.push({ cell: this._cells[rawEvent.index].apiCell, document: this._cells[rawEvent.index].apiCell.document });\n            }\n            else if (rawEvent.kind === NotebookCellsChangeType.ChangeCellContent) {\n                relaxedCellChanges.push({ cell: this._cells[rawEvent.index].apiCell, document: this._cells[rawEvent.index].apiCell.document });\n            }\n            else if (rawEvent.kind === NotebookCellsChangeType.ChangeCellMime) {\n                this._changeCellMime(rawEvent.index, rawEvent.mime);\n            }\n            else if (rawEvent.kind === NotebookCellsChangeType.ChangeCellMetadata) {\n                this._changeCellMetadata(rawEvent.index, rawEvent.metadata);\n                relaxedCellChanges.push({ cell: this._cells[rawEvent.index].apiCell, metadata: this._cells[rawEvent.index].apiCell.metadata });\n            }\n            else if (rawEvent.kind === NotebookCellsChangeType.ChangeCellInternalMetadata) {\n                this._changeCellInternalMetadata(rawEvent.index, rawEvent.internalMetadata);\n                relaxedCellChanges.push({ cell: this._cells[rawEvent.index].apiCell, executionSummary: this._cells[rawEvent.index].apiCell.executionSummary });\n            }\n        }\n        const map = ( new Map());\n        for (let i = 0; i < relaxedCellChanges.length; i++) {\n            const relaxedCellChange = relaxedCellChanges[i];\n            const existing = map.get(relaxedCellChange.cell);\n            if (existing === undefined) {\n                const newLen = result.cellChanges.push({\n                    document: undefined,\n                    executionSummary: undefined,\n                    metadata: undefined,\n                    outputs: undefined,\n                    ...relaxedCellChange,\n                });\n                map.set(relaxedCellChange.cell, newLen - 1);\n            }\n            else {\n                result.cellChanges[existing] = {\n                    ...result.cellChanges[existing],\n                    ...relaxedCellChange\n                };\n            }\n        }\n        return result;\n    }\n    _validateIndex(index) {\n        index = index | 0;\n        if (index < 0) {\n            return 0;\n        }\n        else if (index >= this._cells.length) {\n            return this._cells.length - 1;\n        }\n        else {\n            return index;\n        }\n    }\n    _validateRange(range) {\n        let start = range.start | 0;\n        let end = range.end | 0;\n        if (start < 0) {\n            start = 0;\n        }\n        if (end > this._cells.length) {\n            end = this._cells.length;\n        }\n        return range.with({ start, end });\n    }\n    _getCells(range) {\n        range = this._validateRange(range);\n        const result = [];\n        for (let i = range.start; i < range.end; i++) {\n            result.push(this._cells[i]);\n        }\n        return result;\n    }\n    async _save() {\n        if (this._disposed) {\n            return Promise.reject(( new Error('Notebook has been closed')));\n        }\n        return this._proxy.$trySaveNotebook(this.uri);\n    }\n    _spliceNotebookCells(splices, initialization, bucket) {\n        if (this._disposed) {\n            return;\n        }\n        const contentChangeEvents = [];\n        const addedCellDocuments = [];\n        const removedCellDocuments = [];\n        splices.reverse().forEach(splice => {\n            const cellDtos = splice[2];\n            const newCells = ( cellDtos.map(cell => {\n                const extCell = ( new ExtHostCell(this, this._textDocumentsAndEditors, cell));\n                if (!initialization) {\n                    addedCellDocuments.push(ExtHostCell.asModelAddData(cell));\n                }\n                return extCell;\n            }));\n            const changeEvent = ( new RawContentChangeEvent(splice[0], splice[1], [], newCells));\n            const deletedItems = this._cells.splice(splice[0], splice[1], ...newCells);\n            for (const cell of deletedItems) {\n                removedCellDocuments.push(cell.uri);\n                changeEvent.deletedItems.push(cell.apiCell);\n            }\n            contentChangeEvents.push(changeEvent);\n        });\n        this._textDocumentsAndEditors.acceptDocumentsAndEditorsDelta({\n            addedDocuments: addedCellDocuments,\n            removedDocuments: removedCellDocuments\n        });\n        if (bucket) {\n            for (const changeEvent of contentChangeEvents) {\n                bucket.push(changeEvent.asApiEvent());\n            }\n        }\n    }\n    _moveCells(index, length, newIdx, bucket) {\n        const cells = this._cells.splice(index, length);\n        this._cells.splice(newIdx, 0, ...cells);\n        const changes = [\n            ( new RawContentChangeEvent(index, length, ( cells.map(c => c.apiCell)), [])),\n            ( new RawContentChangeEvent(newIdx, 0, [], cells))\n        ];\n        for (const change of changes) {\n            bucket.push(change.asApiEvent());\n        }\n    }\n    _setCellOutputs(index, outputs) {\n        const cell = this._cells[index];\n        cell.setOutputs(outputs);\n    }\n    _setCellOutputItems(index, outputId, append, outputItems) {\n        const cell = this._cells[index];\n        cell.setOutputItems(outputId, append, outputItems);\n    }\n    _changeCellLanguage(index, newLanguageId) {\n        const cell = this._cells[index];\n        if (cell.apiCell.document.languageId !== newLanguageId) {\n            this._textDocuments.$acceptModelLanguageChanged(cell.uri, newLanguageId);\n        }\n    }\n    _changeCellMime(index, newMime) {\n        const cell = this._cells[index];\n        cell.apiCell.mime = newMime;\n    }\n    _changeCellMetadata(index, newMetadata) {\n        const cell = this._cells[index];\n        cell.setMetadata(newMetadata);\n    }\n    _changeCellInternalMetadata(index, newInternalMetadata) {\n        const cell = this._cells[index];\n        cell.setInternalMetadata(newInternalMetadata);\n    }\n    getCellFromApiCell(apiCell) {\n        return this._cells.find(cell => cell.apiCell === apiCell);\n    }\n    getCellFromIndex(index) {\n        return this._cells[index];\n    }\n    getCell(cellHandle) {\n        return this._cells.find(cell => cell.handle === cellHandle);\n    }\n    getCellIndex(cell) {\n        return this._cells.indexOf(cell);\n    }\n}\nexport { ExtHostCell, ExtHostNotebookDocument };\n","import { AsyncEmitter } from '../../../base/common/event.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { TextDocumentSaveReason, WorkspaceEdit as WorkspaceEdit$1 } from './extHostTypeConverters.js';\nimport { WorkspaceEdit } from './extHostTypes.js';\nimport { SerializableObjectWithBuffers } from '../../services/extensions/common/proxyIdentifier.js';\nclass ExtHostNotebookDocumentSaveParticipant {\n    constructor(_logService, _notebooksAndEditors, _mainThreadBulkEdits, _thresholds = { timeout: 1500, errors: 3 }) {\n        this._logService = _logService;\n        this._notebooksAndEditors = _notebooksAndEditors;\n        this._mainThreadBulkEdits = _mainThreadBulkEdits;\n        this._thresholds = _thresholds;\n        this._onWillSaveNotebookDocumentEvent = ( new AsyncEmitter());\n    }\n    dispose() {\n    }\n    getOnWillSaveNotebookDocumentEvent(extension) {\n        return (listener, thisArg, disposables) => {\n            const wrappedListener = function wrapped(e) { listener.call(thisArg, e); };\n            wrappedListener.extension = extension;\n            return this._onWillSaveNotebookDocumentEvent.event(wrappedListener, undefined, disposables);\n        };\n    }\n    async $participateInSave(resource, reason, token) {\n        const revivedUri = URI.revive(resource);\n        const document = this._notebooksAndEditors.getNotebookDocument(revivedUri);\n        if (!document) {\n            throw ( new Error('Unable to resolve notebook document'));\n        }\n        const edits = [];\n        await this._onWillSaveNotebookDocumentEvent.fireAsync({ notebook: document.apiNotebook, reason: TextDocumentSaveReason.to(reason) }, token, async (thenable, listener) => {\n            const now = Date.now();\n            const data = await await Promise.resolve(thenable);\n            if (Date.now() - now > this._thresholds.timeout) {\n                this._logService.warn('onWillSaveNotebookDocument-listener from extension', listener.extension.identifier);\n            }\n            if (token.isCancellationRequested) {\n                return;\n            }\n            if (data) {\n                if (data instanceof WorkspaceEdit) {\n                    edits.push(data);\n                }\n                else {\n                    this._logService.warn('onWillSaveNotebookDocument-listener from extension', listener.extension.identifier, 'ignored due to invalid data');\n                }\n            }\n            return;\n        });\n        if (token.isCancellationRequested) {\n            return false;\n        }\n        if (edits.length === 0) {\n            return true;\n        }\n        const dto = { edits: [] };\n        for (const edit of edits) {\n            const { edits } = WorkspaceEdit$1.from(edit);\n            dto.edits = dto.edits.concat(edits);\n        }\n        return this._mainThreadBulkEdits.$tryApplyWorkspaceEdit(( new SerializableObjectWithBuffers(dto)));\n    }\n}\nexport { ExtHostNotebookDocumentSaveParticipant };\n","import { Emitter } from '../../../base/common/event.js';\nimport { URI } from '../../../base/common/uri.js';\nclass ExtHostNotebookDocuments {\n    constructor(_notebooksAndEditors) {\n        this._notebooksAndEditors = _notebooksAndEditors;\n        this._onDidSaveNotebookDocument = ( new Emitter());\n        this.onDidSaveNotebookDocument = this._onDidSaveNotebookDocument.event;\n        this._onDidChangeNotebookDocument = ( new Emitter());\n        this.onDidChangeNotebookDocument = this._onDidChangeNotebookDocument.event;\n    }\n    $acceptModelChanged(uri, event, isDirty, newMetadata) {\n        const document = this._notebooksAndEditors.getNotebookDocument(URI.revive(uri));\n        const e = document.acceptModelChanged(event.value, isDirty, newMetadata);\n        this._onDidChangeNotebookDocument.fire(e);\n    }\n    $acceptDirtyStateChanged(uri, isDirty) {\n        const document = this._notebooksAndEditors.getNotebookDocument(URI.revive(uri));\n        document.acceptDirty(isDirty);\n    }\n    $acceptModelSaved(uri) {\n        const document = this._notebooksAndEditors.getNotebookDocument(URI.revive(uri));\n        this._onDidSaveNotebookDocument.fire(document.apiNotebook);\n    }\n}\nexport { ExtHostNotebookDocuments };\n","import { illegalArgument } from '../../../base/common/errors.js';\nimport { NotebookRange as NotebookRange$1 } from './extHostTypeConverters.js';\nimport { NotebookRange, NotebookEditorRevealType } from './extHostTypes.js';\nclass ExtHostNotebookEditor {\n    static { this.apiEditorsToExtHost = ( new WeakMap()); }\n    constructor(id, _proxy, notebookData, _visibleRanges, _selections, _viewColumn, viewType) {\n        this.id = id;\n        this._proxy = _proxy;\n        this.notebookData = notebookData;\n        this._visibleRanges = _visibleRanges;\n        this._selections = _selections;\n        this._viewColumn = _viewColumn;\n        this.viewType = viewType;\n        this._visible = false;\n    }\n    get apiEditor() {\n        if (!this._editor) {\n            const that = this;\n            this._editor = {\n                get notebook() {\n                    return that.notebookData.apiNotebook;\n                },\n                get selection() {\n                    return that._selections[0];\n                },\n                set selection(selection) {\n                    this.selections = [selection];\n                },\n                get selections() {\n                    return that._selections;\n                },\n                set selections(value) {\n                    if (!Array.isArray(value) || !value.every(NotebookRange.isNotebookRange)) {\n                        throw illegalArgument('selections');\n                    }\n                    that._selections = value;\n                    that._trySetSelections(value);\n                },\n                get visibleRanges() {\n                    return that._visibleRanges;\n                },\n                revealRange(range, revealType) {\n                    that._proxy.$tryRevealRange(that.id, NotebookRange$1.from(range), revealType ?? NotebookEditorRevealType.Default);\n                },\n                get viewColumn() {\n                    return that._viewColumn;\n                },\n                get replOptions() {\n                    if (that.viewType === 'repl') {\n                        return { appendIndex: this.notebook.cellCount - 1 };\n                    }\n                    return undefined;\n                },\n                [Symbol.for('debug.description')]() {\n                    return `NotebookEditor(${( this.notebook.uri.toString())})`;\n                }\n            };\n            ExtHostNotebookEditor.apiEditorsToExtHost.set(this._editor, this);\n        }\n        return this._editor;\n    }\n    get visible() {\n        return this._visible;\n    }\n    _acceptVisibility(value) {\n        this._visible = value;\n    }\n    _acceptVisibleRanges(value) {\n        this._visibleRanges = value;\n    }\n    _acceptSelections(selections) {\n        this._selections = selections;\n    }\n    _trySetSelections(value) {\n        this._proxy.$trySetSelections(this.id, ( value.map(NotebookRange$1.from)));\n    }\n    _acceptViewColumn(value) {\n        this._viewColumn = value;\n    }\n}\nexport { ExtHostNotebookEditor };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { ILogService } from '../../../platform/log/common/log.service.js';\nimport { NotebookRange, ViewColumn } from './extHostTypeConverters.js';\nlet ExtHostNotebookEditors = class ExtHostNotebookEditors {\n    constructor(_logService, _notebooksAndEditors) {\n        this._logService = _logService;\n        this._notebooksAndEditors = _notebooksAndEditors;\n        this._onDidChangeNotebookEditorSelection = ( new Emitter());\n        this._onDidChangeNotebookEditorVisibleRanges = ( new Emitter());\n        this.onDidChangeNotebookEditorSelection = this._onDidChangeNotebookEditorSelection.event;\n        this.onDidChangeNotebookEditorVisibleRanges = this._onDidChangeNotebookEditorVisibleRanges.event;\n    }\n    $acceptEditorPropertiesChanged(id, data) {\n        this._logService.debug('ExtHostNotebook#$acceptEditorPropertiesChanged', id, data);\n        const editor = this._notebooksAndEditors.getEditorById(id);\n        if (data.visibleRanges) {\n            editor._acceptVisibleRanges(( data.visibleRanges.ranges.map(NotebookRange.to)));\n        }\n        if (data.selections) {\n            editor._acceptSelections(( data.selections.selections.map(NotebookRange.to)));\n        }\n        if (data.visibleRanges) {\n            this._onDidChangeNotebookEditorVisibleRanges.fire({\n                notebookEditor: editor.apiEditor,\n                visibleRanges: editor.apiEditor.visibleRanges\n            });\n        }\n        if (data.selections) {\n            this._onDidChangeNotebookEditorSelection.fire(( Object.freeze({\n                notebookEditor: editor.apiEditor,\n                selections: editor.apiEditor.selections\n            })));\n        }\n    }\n    $acceptEditorViewColumns(data) {\n        for (const id in data) {\n            const editor = this._notebooksAndEditors.getEditorById(id);\n            editor._acceptViewColumn(ViewColumn.to(data[id]));\n        }\n    }\n};\nExtHostNotebookEditors = ( __decorate([\n    ( __param(0, ILogService))\n], ExtHostNotebookEditors));\nexport { ExtHostNotebookEditors };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { asArray } from '../../../base/common/arrays.js';\nimport { DeferredPromise, timeout } from '../../../base/common/async.js';\nimport { CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport { ResourceMap } from '../../../base/common/map.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { ExtensionIdentifier } from '../../../platform/extensions/common/extensions.js';\nimport { ILogService } from '../../../platform/log/common/log.service.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { ApiCommand, ApiCommandArgument, ApiCommandResult } from './extHostCommands.js';\nimport { NotebookCellOutput as NotebookCellOutput$1, NotebookCellOutputItem, NotebookKernelSourceAction, NotebookCellExecutionState, NotebookRendererScript } from './extHostTypeConverters.js';\nimport { NotebookCellOutput, NotebookCellExecutionState as NotebookCellExecutionState$1, NotebookControllerAffinity2, NotebookVariablesRequestKind } from './extHostTypes.js';\nimport { asWebviewUri } from '../../contrib/webview/common/webview.js';\nimport { CellExecutionUpdateType } from '../../contrib/notebook/common/notebookExecutionService.js';\nimport { checkProposedApiEnabled } from '../../services/extensions/common/extensions.js';\nimport { SerializableObjectWithBuffers } from '../../services/extensions/common/proxyIdentifier.js';\nimport { variablePageSize } from '../../contrib/notebook/common/notebookKernelService.js';\nlet ExtHostNotebookKernels = class ExtHostNotebookKernels {\n    constructor(mainContext, _initData, _extHostNotebook, _commands, _logService) {\n        this._initData = _initData;\n        this._extHostNotebook = _extHostNotebook;\n        this._commands = _commands;\n        this._logService = _logService;\n        this._activeExecutions = ( new ResourceMap());\n        this._activeNotebookExecutions = ( new ResourceMap());\n        this._kernelDetectionTask = ( new Map());\n        this._kernelDetectionTaskHandlePool = 0;\n        this._kernelSourceActionProviders = ( new Map());\n        this._kernelSourceActionProviderHandlePool = 0;\n        this._kernelData = ( new Map());\n        this._handlePool = 0;\n        this._onDidChangeCellExecutionState = ( new Emitter());\n        this.onDidChangeNotebookCellExecutionState = this._onDidChangeCellExecutionState.event;\n        this.id = 0;\n        this.variableStore = {};\n        this._proxy = ( mainContext.getProxy(MainContext.MainThreadNotebookKernels));\n        const selectKernelApiCommand = ( new ApiCommand(\n            'notebook.selectKernel',\n            '_notebook.selectKernel',\n            'Trigger kernel picker for specified notebook editor widget',\n            [\n                ( new ApiCommandArgument('options', 'Select kernel options', v => true, (v) => {\n                    if (v && 'notebookEditor' in v && 'id' in v) {\n                        const notebookEditorId = this._extHostNotebook.getIdByEditor(v.notebookEditor);\n                        return {\n                            id: v.id, extension: v.extension, notebookEditorId\n                        };\n                    }\n                    else if (v && 'notebookEditor' in v) {\n                        const notebookEditorId = this._extHostNotebook.getIdByEditor(v.notebookEditor);\n                        if (notebookEditorId === undefined) {\n                            throw ( new Error(\n                                `Cannot invoke 'notebook.selectKernel' for unrecognized notebook editor ${( v.notebookEditor.notebook.uri.toString())}`\n                            ));\n                        }\n                        return { notebookEditorId };\n                    }\n                    return v;\n                }))\n            ],\n            ApiCommandResult.Void\n        ));\n        const requestKernelVariablesApiCommand = ( new ApiCommand(\n            'vscode.executeNotebookVariableProvider',\n            '_executeNotebookVariableProvider',\n            'Execute notebook variable provider',\n            [ApiCommandArgument.Uri],\n            ( new ApiCommandResult('A promise that resolves to an array of variables', (value, apiArgs) => {\n                return ( value.map(variable => {\n                    return {\n                        variable: {\n                            name: variable.name,\n                            value: variable.value,\n                            expression: variable.expression,\n                            type: variable.type,\n                            language: variable.language\n                        },\n                        hasNamedChildren: variable.hasNamedChildren,\n                        indexedChildrenCount: variable.indexedChildrenCount\n                    };\n                }));\n            }))\n        ));\n        this._commands.registerApiCommand(selectKernelApiCommand);\n        this._commands.registerApiCommand(requestKernelVariablesApiCommand);\n    }\n    createNotebookController(extension, id, viewType, label, handler, preloads) {\n        for (const data of ( this._kernelData.values())) {\n            if (data.controller.id === id && ExtensionIdentifier.equals(extension.identifier, data.extensionId)) {\n                throw ( new Error(`notebook controller with id '${id}' ALREADY exist`));\n            }\n        }\n        const handle = this._handlePool++;\n        const that = this;\n        this._logService.trace(`NotebookController[${handle}], CREATED by ${extension.identifier.value}, ${id}`);\n        const _defaultExecutHandler = () => console.warn(`NO execute handler from notebook controller '${data.id}' of extension: '${extension.identifier}'`);\n        let isDisposed = false;\n        const onDidChangeSelection = ( new Emitter());\n        const onDidReceiveMessage = ( new Emitter());\n        const data = {\n            id: createKernelId(extension.identifier, id),\n            notebookType: viewType,\n            extensionId: extension.identifier,\n            extensionLocation: extension.extensionLocation,\n            label: label || extension.identifier.value,\n            preloads: preloads ? ( preloads.map(NotebookRendererScript.from)) : []\n        };\n        let _executeHandler = handler ?? _defaultExecutHandler;\n        let _interruptHandler;\n        let _variableProvider;\n        this._proxy.$addKernel(handle, data).catch(err => {\n            console.log(err);\n            isDisposed = true;\n        });\n        let tokenPool = 0;\n        const _update = () => {\n            if (isDisposed) {\n                return;\n            }\n            const myToken = ++tokenPool;\n            Promise.resolve().then(() => {\n                if (myToken === tokenPool) {\n                    this._proxy.$updateKernel(handle, data);\n                }\n            });\n        };\n        const associatedNotebooks = ( new ResourceMap());\n        const controller = {\n            get id() { return id; },\n            get notebookType() { return data.notebookType; },\n            onDidChangeSelectedNotebooks: onDidChangeSelection.event,\n            get label() {\n                return data.label;\n            },\n            set label(value) {\n                data.label = value ?? extension.displayName ?? extension.name;\n                _update();\n            },\n            get detail() {\n                return data.detail ?? '';\n            },\n            set detail(value) {\n                data.detail = value;\n                _update();\n            },\n            get description() {\n                return data.description ?? '';\n            },\n            set description(value) {\n                data.description = value;\n                _update();\n            },\n            get supportedLanguages() {\n                return data.supportedLanguages;\n            },\n            set supportedLanguages(value) {\n                data.supportedLanguages = value;\n                _update();\n            },\n            get supportsExecutionOrder() {\n                return data.supportsExecutionOrder ?? false;\n            },\n            set supportsExecutionOrder(value) {\n                data.supportsExecutionOrder = value;\n                _update();\n            },\n            get rendererScripts() {\n                return data.preloads ? ( data.preloads.map(NotebookRendererScript.to)) : [];\n            },\n            get executeHandler() {\n                return _executeHandler;\n            },\n            set executeHandler(value) {\n                _executeHandler = value ?? _defaultExecutHandler;\n            },\n            get interruptHandler() {\n                return _interruptHandler;\n            },\n            set interruptHandler(value) {\n                _interruptHandler = value;\n                data.supportsInterrupt = Boolean(value);\n                _update();\n            },\n            set variableProvider(value) {\n                checkProposedApiEnabled(extension, 'notebookVariableProvider');\n                _variableProvider = value;\n                data.hasVariableProvider = !!value;\n                value?.onDidChangeVariables(e => that._proxy.$variablesUpdated(e.uri));\n                _update();\n            },\n            get variableProvider() {\n                return _variableProvider;\n            },\n            createNotebookCellExecution(cell) {\n                if (isDisposed) {\n                    throw ( new Error('notebook controller is DISPOSED'));\n                }\n                if (!( associatedNotebooks.has(cell.notebook.uri))) {\n                    that._logService.trace(`NotebookController[${handle}] NOT associated to notebook, associated to THESE notebooks:`, ( Array.from(( associatedNotebooks.keys())).map(u => ( u.toString()))));\n                    throw ( new Error(`notebook controller is NOT associated to notebook: ${( cell.notebook.uri.toString())}`));\n                }\n                return that._createNotebookCellExecution(cell, createKernelId(extension.identifier, this.id));\n            },\n            createNotebookExecution(notebook) {\n                checkProposedApiEnabled(extension, 'notebookExecution');\n                if (isDisposed) {\n                    throw ( new Error('notebook controller is DISPOSED'));\n                }\n                if (!( associatedNotebooks.has(notebook.uri))) {\n                    that._logService.trace(`NotebookController[${handle}] NOT associated to notebook, associated to THESE notebooks:`, ( Array.from(( associatedNotebooks.keys())).map(u => ( u.toString()))));\n                    throw ( new Error(`notebook controller is NOT associated to notebook: ${( notebook.uri.toString())}`));\n                }\n                return that._createNotebookExecution(notebook, createKernelId(extension.identifier, this.id));\n            },\n            dispose: () => {\n                if (!isDisposed) {\n                    this._logService.trace(`NotebookController[${handle}], DISPOSED`);\n                    isDisposed = true;\n                    this._kernelData.delete(handle);\n                    onDidChangeSelection.dispose();\n                    onDidReceiveMessage.dispose();\n                    this._proxy.$removeKernel(handle);\n                }\n            },\n            updateNotebookAffinity(notebook, priority) {\n                if (priority === NotebookControllerAffinity2.Hidden) {\n                    checkProposedApiEnabled(extension, 'notebookControllerAffinityHidden');\n                }\n                that._proxy.$updateNotebookPriority(handle, notebook.uri, priority);\n            },\n            onDidReceiveMessage: onDidReceiveMessage.event,\n            postMessage(message, editor) {\n                checkProposedApiEnabled(extension, 'notebookMessaging');\n                return that._proxy.$postMessage(handle, editor && that._extHostNotebook.getIdByEditor(editor), message);\n            },\n            asWebviewUri(uri) {\n                checkProposedApiEnabled(extension, 'notebookMessaging');\n                return asWebviewUri(uri, that._initData.remote);\n            },\n        };\n        this._kernelData.set(handle, {\n            extensionId: extension.identifier,\n            controller,\n            onDidReceiveMessage,\n            onDidChangeSelection,\n            associatedNotebooks\n        });\n        return controller;\n    }\n    getIdByController(controller) {\n        for (const [_, candidate] of this._kernelData) {\n            if (candidate.controller === controller) {\n                return createKernelId(candidate.extensionId, controller.id);\n            }\n        }\n        return null;\n    }\n    createNotebookControllerDetectionTask(extension, viewType) {\n        const handle = this._kernelDetectionTaskHandlePool++;\n        const that = this;\n        this._logService.trace(`NotebookControllerDetectionTask[${handle}], CREATED by ${extension.identifier.value}`);\n        this._proxy.$addKernelDetectionTask(handle, viewType);\n        const detectionTask = {\n            dispose: () => {\n                this._kernelDetectionTask.delete(handle);\n                that._proxy.$removeKernelDetectionTask(handle);\n            }\n        };\n        this._kernelDetectionTask.set(handle, detectionTask);\n        return detectionTask;\n    }\n    registerKernelSourceActionProvider(extension, viewType, provider) {\n        const handle = this._kernelSourceActionProviderHandlePool++;\n        const eventHandle = typeof provider.onDidChangeNotebookKernelSourceActions === 'function' ? handle : undefined;\n        const that = this;\n        this._kernelSourceActionProviders.set(handle, provider);\n        this._logService.trace(`NotebookKernelSourceActionProvider[${handle}], CREATED by ${extension.identifier.value}`);\n        this._proxy.$addKernelSourceActionProvider(handle, handle, viewType);\n        let subscription;\n        if (eventHandle !== undefined) {\n            subscription = provider.onDidChangeNotebookKernelSourceActions(_ => this._proxy.$emitNotebookKernelSourceActionsChangeEvent(eventHandle));\n        }\n        return {\n            dispose: () => {\n                this._kernelSourceActionProviders.delete(handle);\n                that._proxy.$removeKernelSourceActionProvider(handle, handle);\n                subscription?.dispose();\n            }\n        };\n    }\n    async $provideKernelSourceActions(handle, token) {\n        const provider = this._kernelSourceActionProviders.get(handle);\n        if (provider) {\n            const disposables = ( new DisposableStore());\n            const ret = await provider.provideNotebookKernelSourceActions(token);\n            return ( (ret ?? []).map(\n                item => NotebookKernelSourceAction.from(item, this._commands.converter, disposables)\n            ));\n        }\n        return [];\n    }\n    $acceptNotebookAssociation(handle, uri, value) {\n        const obj = this._kernelData.get(handle);\n        if (obj) {\n            const notebook = this._extHostNotebook.getNotebookDocument(URI.revive(uri));\n            if (value) {\n                obj.associatedNotebooks.set(notebook.uri, true);\n            }\n            else {\n                obj.associatedNotebooks.delete(notebook.uri);\n            }\n            this._logService.trace(`NotebookController[${handle}] ASSOCIATE notebook`, ( notebook.uri.toString()), value);\n            obj.onDidChangeSelection.fire({\n                selected: value,\n                notebook: notebook.apiNotebook\n            });\n        }\n    }\n    async $executeCells(handle, uri, handles) {\n        const obj = this._kernelData.get(handle);\n        if (!obj) {\n            return;\n        }\n        const document = this._extHostNotebook.getNotebookDocument(URI.revive(uri));\n        const cells = [];\n        for (const cellHandle of handles) {\n            const cell = document.getCell(cellHandle);\n            if (cell) {\n                cells.push(cell.apiCell);\n            }\n        }\n        try {\n            this._logService.trace(`NotebookController[${handle}] EXECUTE cells`, ( document.uri.toString()), cells.length);\n            await obj.controller.executeHandler.call(obj.controller, cells, document.apiNotebook, obj.controller);\n        }\n        catch (err) {\n            this._logService.error(`NotebookController[${handle}] execute cells FAILED`, err);\n            console.error(err);\n        }\n    }\n    async $cancelCells(handle, uri, handles) {\n        const obj = this._kernelData.get(handle);\n        if (!obj) {\n            return;\n        }\n        const document = this._extHostNotebook.getNotebookDocument(URI.revive(uri));\n        if (obj.controller.interruptHandler) {\n            await obj.controller.interruptHandler.call(obj.controller, document.apiNotebook);\n        }\n        else {\n            for (const cellHandle of handles) {\n                const cell = document.getCell(cellHandle);\n                if (cell) {\n                    this._activeExecutions.get(cell.uri)?.cancel();\n                }\n            }\n        }\n        if (obj.controller.interruptHandler) {\n            const items = this._activeNotebookExecutions.get(document.uri);\n            this._activeNotebookExecutions.delete(document.uri);\n            if (handles.length && Array.isArray(items) && items.length) {\n                items.forEach(d => d.dispose());\n            }\n        }\n    }\n    async $provideVariables(handle, requestId, notebookUri, parentId, kind, start, token) {\n        const obj = this._kernelData.get(handle);\n        if (!obj) {\n            return;\n        }\n        const document = this._extHostNotebook.getNotebookDocument(URI.revive(notebookUri));\n        const variableProvider = obj.controller.variableProvider;\n        if (!variableProvider) {\n            return;\n        }\n        let parent = undefined;\n        if (parentId !== undefined) {\n            parent = this.variableStore[parentId];\n            if (!parent) {\n                return;\n            }\n        }\n        else {\n            this.variableStore = {};\n        }\n        const requestKind = kind === 'named' ? NotebookVariablesRequestKind.Named : NotebookVariablesRequestKind.Indexed;\n        const variableResults = variableProvider.provideVariables(document.apiNotebook, parent, requestKind, start, token);\n        let resultCount = 0;\n        for await (const result of variableResults) {\n            if (token.isCancellationRequested) {\n                return;\n            }\n            const variable = {\n                id: this.id++,\n                name: result.variable.name,\n                value: result.variable.value,\n                type: result.variable.type,\n                interfaces: result.variable.interfaces,\n                language: result.variable.language,\n                expression: result.variable.expression,\n                hasNamedChildren: result.hasNamedChildren,\n                indexedChildrenCount: result.indexedChildrenCount,\n                extensionId: obj.extensionId.value,\n            };\n            this.variableStore[variable.id] = result.variable;\n            this._proxy.$receiveVariable(requestId, variable);\n            if (resultCount++ >= variablePageSize) {\n                return;\n            }\n        }\n    }\n    $acceptKernelMessageFromRenderer(handle, editorId, message) {\n        const obj = this._kernelData.get(handle);\n        if (!obj) {\n            return;\n        }\n        const editor = this._extHostNotebook.getEditorById(editorId);\n        obj.onDidReceiveMessage.fire(( Object.freeze({ editor: editor.apiEditor, message })));\n    }\n    $cellExecutionChanged(uri, cellHandle, state) {\n        const document = this._extHostNotebook.getNotebookDocument(URI.revive(uri));\n        const cell = document.getCell(cellHandle);\n        if (cell) {\n            const newState = state ? NotebookCellExecutionState.to(state) : NotebookCellExecutionState$1.Idle;\n            if (newState !== undefined) {\n                this._onDidChangeCellExecutionState.fire({\n                    cell: cell.apiCell,\n                    state: newState\n                });\n            }\n        }\n    }\n    _createNotebookCellExecution(cell, controllerId) {\n        if (cell.index < 0) {\n            throw ( new Error('CANNOT execute cell that has been REMOVED from notebook'));\n        }\n        const notebook = this._extHostNotebook.getNotebookDocument(cell.notebook.uri);\n        const cellObj = notebook.getCellFromApiCell(cell);\n        if (!cellObj) {\n            throw ( new Error('invalid cell'));\n        }\n        if (( this._activeExecutions.has(cellObj.uri))) {\n            throw ( new Error(`duplicate execution for ${cellObj.uri}`));\n        }\n        const execution = ( new NotebookCellExecutionTask(controllerId, cellObj, this._proxy));\n        this._activeExecutions.set(cellObj.uri, execution);\n        const listener = execution.onDidChangeState(() => {\n            if (execution.state === NotebookCellExecutionTaskState.Resolved) {\n                execution.dispose();\n                listener.dispose();\n                this._activeExecutions.delete(cellObj.uri);\n            }\n        });\n        return execution.asApiObject();\n    }\n    _createNotebookExecution(nb, controllerId) {\n        const notebook = this._extHostNotebook.getNotebookDocument(nb.uri);\n        const runningCell = nb.getCells().find(cell => {\n            const apiCell = notebook.getCellFromApiCell(cell);\n            return apiCell && ( this._activeExecutions.has(apiCell.uri));\n        });\n        if (runningCell) {\n            throw ( new Error(`duplicate cell execution for ${runningCell.document.uri}`));\n        }\n        if (( this._activeNotebookExecutions.has(notebook.uri))) {\n            throw ( new Error(`duplicate notebook execution for ${notebook.uri}`));\n        }\n        const execution = ( new NotebookExecutionTask(controllerId, notebook, this._proxy));\n        const listener = execution.onDidChangeState(() => {\n            if (execution.state === NotebookExecutionTaskState.Resolved) {\n                execution.dispose();\n                listener.dispose();\n                this._activeNotebookExecutions.delete(notebook.uri);\n            }\n        });\n        this._activeNotebookExecutions.set(notebook.uri, [execution, listener]);\n        return execution.asApiObject();\n    }\n};\nExtHostNotebookKernels = ( __decorate([\n    ( __param(4, ILogService))\n], ExtHostNotebookKernels));\nvar NotebookCellExecutionTaskState;\n( (function(NotebookCellExecutionTaskState) {\n    NotebookCellExecutionTaskState[NotebookCellExecutionTaskState[\"Init\"] = 0] = \"Init\";\n    NotebookCellExecutionTaskState[NotebookCellExecutionTaskState[\"Started\"] = 1] = \"Started\";\n    NotebookCellExecutionTaskState[NotebookCellExecutionTaskState[\"Resolved\"] = 2] = \"Resolved\";\n})(NotebookCellExecutionTaskState || (NotebookCellExecutionTaskState = {})));\nclass NotebookCellExecutionTask extends Disposable {\n    static { this.HANDLE = 0; }\n    get state() { return this._state; }\n    constructor(controllerId, _cell, _proxy) {\n        super();\n        this._cell = _cell;\n        this._proxy = _proxy;\n        this._handle = NotebookCellExecutionTask.HANDLE++;\n        this._onDidChangeState = ( new Emitter());\n        this.onDidChangeState = this._onDidChangeState.event;\n        this._state = NotebookCellExecutionTaskState.Init;\n        this._tokenSource = this._register(( new CancellationTokenSource()));\n        this._collector = ( new TimeoutBasedCollector(10, updates => this.update(updates)));\n        this._executionOrder = _cell.internalMetadata.executionOrder;\n        this._proxy.$createExecution(this._handle, controllerId, this._cell.notebook.uri, this._cell.handle);\n    }\n    cancel() {\n        this._tokenSource.cancel();\n    }\n    async updateSoon(update) {\n        await this._collector.addItem(update);\n    }\n    async update(update) {\n        const updates = Array.isArray(update) ? update : [update];\n        return this._proxy.$updateExecution(this._handle, ( new SerializableObjectWithBuffers(updates)));\n    }\n    verifyStateForOutput() {\n        if (this._state === NotebookCellExecutionTaskState.Init) {\n            throw ( new Error('Must call start before modifying cell output'));\n        }\n        if (this._state === NotebookCellExecutionTaskState.Resolved) {\n            throw ( new Error('Cannot modify cell output after calling resolve'));\n        }\n    }\n    cellIndexToHandle(cellOrCellIndex) {\n        let cell = this._cell;\n        if (cellOrCellIndex) {\n            cell = this._cell.notebook.getCellFromApiCell(cellOrCellIndex);\n        }\n        if (!cell) {\n            throw ( new Error('INVALID cell'));\n        }\n        return cell.handle;\n    }\n    validateAndConvertOutputs(items) {\n        return ( items.map(output => {\n            const newOutput = NotebookCellOutput.ensureUniqueMimeTypes(output.items, true);\n            if (newOutput === output.items) {\n                return NotebookCellOutput$1.from(output);\n            }\n            return NotebookCellOutput$1.from({\n                items: newOutput,\n                id: output.id,\n                metadata: output.metadata\n            });\n        }));\n    }\n    async updateOutputs(outputs, cell, append) {\n        const handle = this.cellIndexToHandle(cell);\n        const outputDtos = this.validateAndConvertOutputs(asArray(outputs));\n        return this.updateSoon({\n            editType: CellExecutionUpdateType.Output,\n            cellHandle: handle,\n            append,\n            outputs: outputDtos\n        });\n    }\n    async updateOutputItems(items, output, append) {\n        items = NotebookCellOutput.ensureUniqueMimeTypes(asArray(items), true);\n        return this.updateSoon({\n            editType: CellExecutionUpdateType.OutputItems,\n            items: ( items.map(NotebookCellOutputItem.from)),\n            outputId: output.id,\n            append\n        });\n    }\n    asApiObject() {\n        const that = this;\n        const result = {\n            get token() { return that._tokenSource.token; },\n            get cell() { return that._cell.apiCell; },\n            get executionOrder() { return that._executionOrder; },\n            set executionOrder(v) {\n                that._executionOrder = v;\n                that.update([{\n                        editType: CellExecutionUpdateType.ExecutionState,\n                        executionOrder: that._executionOrder\n                    }]);\n            },\n            start(startTime) {\n                if (that._state === NotebookCellExecutionTaskState.Resolved || that._state === NotebookCellExecutionTaskState.Started) {\n                    throw ( new Error('Cannot call start again'));\n                }\n                that._state = NotebookCellExecutionTaskState.Started;\n                that._onDidChangeState.fire();\n                that.update({\n                    editType: CellExecutionUpdateType.ExecutionState,\n                    runStartTime: startTime\n                });\n            },\n            end(success, endTime, executionError) {\n                if (that._state === NotebookCellExecutionTaskState.Resolved) {\n                    throw ( new Error('Cannot call resolve twice'));\n                }\n                that._state = NotebookCellExecutionTaskState.Resolved;\n                that._onDidChangeState.fire();\n                that._collector.flush();\n                const error = executionError ? {\n                    message: executionError.message,\n                    stack: executionError.stack,\n                    location: executionError?.location ? {\n                        startLineNumber: executionError.location.start.line,\n                        startColumn: executionError.location.start.character,\n                        endLineNumber: executionError.location.end.line,\n                        endColumn: executionError.location.end.character\n                    } : undefined,\n                    uri: executionError.uri\n                } : undefined;\n                that._proxy.$completeExecution(that._handle, ( new SerializableObjectWithBuffers({\n                    runEndTime: endTime,\n                    lastRunSuccess: success,\n                    error\n                })));\n            },\n            clearOutput(cell) {\n                that.verifyStateForOutput();\n                return that.updateOutputs([], cell, false);\n            },\n            appendOutput(outputs, cell) {\n                that.verifyStateForOutput();\n                return that.updateOutputs(outputs, cell, true);\n            },\n            replaceOutput(outputs, cell) {\n                that.verifyStateForOutput();\n                return that.updateOutputs(outputs, cell, false);\n            },\n            appendOutputItems(items, output) {\n                that.verifyStateForOutput();\n                return that.updateOutputItems(items, output, true);\n            },\n            replaceOutputItems(items, output) {\n                that.verifyStateForOutput();\n                return that.updateOutputItems(items, output, false);\n            }\n        };\n        return ( Object.freeze(result));\n    }\n}\nvar NotebookExecutionTaskState;\n( (function(NotebookExecutionTaskState) {\n    NotebookExecutionTaskState[NotebookExecutionTaskState[\"Init\"] = 0] = \"Init\";\n    NotebookExecutionTaskState[NotebookExecutionTaskState[\"Started\"] = 1] = \"Started\";\n    NotebookExecutionTaskState[NotebookExecutionTaskState[\"Resolved\"] = 2] = \"Resolved\";\n})(NotebookExecutionTaskState || (NotebookExecutionTaskState = {})));\nclass NotebookExecutionTask extends Disposable {\n    static { this.HANDLE = 0; }\n    get state() { return this._state; }\n    constructor(controllerId, _notebook, _proxy) {\n        super();\n        this._notebook = _notebook;\n        this._proxy = _proxy;\n        this._handle = NotebookExecutionTask.HANDLE++;\n        this._onDidChangeState = ( new Emitter());\n        this.onDidChangeState = this._onDidChangeState.event;\n        this._state = NotebookExecutionTaskState.Init;\n        this._tokenSource = this._register(( new CancellationTokenSource()));\n        this._proxy.$createNotebookExecution(this._handle, controllerId, this._notebook.uri);\n    }\n    cancel() {\n        this._tokenSource.cancel();\n    }\n    asApiObject() {\n        const result = {\n            start: () => {\n                if (this._state === NotebookExecutionTaskState.Resolved || this._state === NotebookExecutionTaskState.Started) {\n                    throw ( new Error('Cannot call start again'));\n                }\n                this._state = NotebookExecutionTaskState.Started;\n                this._onDidChangeState.fire();\n                this._proxy.$beginNotebookExecution(this._handle);\n            },\n            end: () => {\n                if (this._state === NotebookExecutionTaskState.Resolved) {\n                    throw ( new Error('Cannot call resolve twice'));\n                }\n                this._state = NotebookExecutionTaskState.Resolved;\n                this._onDidChangeState.fire();\n                this._proxy.$completeNotebookExecution(this._handle);\n            },\n        };\n        return ( Object.freeze(result));\n    }\n}\nclass TimeoutBasedCollector {\n    constructor(delay, callback) {\n        this.delay = delay;\n        this.callback = callback;\n        this.batch = [];\n        this.startedTimer = Date.now();\n    }\n    addItem(item) {\n        this.batch.push(item);\n        if (!this.currentDeferred) {\n            this.currentDeferred = ( new DeferredPromise());\n            this.startedTimer = Date.now();\n            timeout(this.delay).then(() => {\n                return this.flush();\n            });\n        }\n        if (Date.now() - this.startedTimer > this.delay) {\n            return this.flush();\n        }\n        return this.currentDeferred.p;\n    }\n    flush() {\n        if (this.batch.length === 0 || !this.currentDeferred) {\n            return Promise.resolve();\n        }\n        const deferred = this.currentDeferred;\n        this.currentDeferred = undefined;\n        const batch = this.batch;\n        this.batch = [];\n        return this.callback(batch)\n            .finally(() => deferred.complete());\n    }\n}\nfunction createKernelId(extensionIdentifier, id) {\n    return `${extensionIdentifier.value}/${id}`;\n}\nexport { ExtHostNotebookKernels, createKernelId };\n","import { Emitter } from '../../../base/common/event.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { ExtHostNotebookEditor } from './extHostNotebookEditor.js';\nclass ExtHostNotebookRenderers {\n    constructor(mainContext, _extHostNotebook) {\n        this._extHostNotebook = _extHostNotebook;\n        this._rendererMessageEmitters = ( new Map());\n        this.proxy = ( mainContext.getProxy(MainContext.MainThreadNotebookRenderers));\n    }\n    $postRendererMessage(editorId, rendererId, message) {\n        const editor = this._extHostNotebook.getEditorById(editorId);\n        this._rendererMessageEmitters.get(rendererId)?.fire({ editor: editor.apiEditor, message });\n    }\n    createRendererMessaging(manifest, rendererId) {\n        if (!manifest.contributes?.notebookRenderer?.some(r => r.id === rendererId)) {\n            throw ( new Error(\n                `Extensions may only call createRendererMessaging() for renderers they contribute (got ${rendererId})`\n            ));\n        }\n        const messaging = {\n            onDidReceiveMessage: (listener, thisArg, disposables) => {\n                return this.getOrCreateEmitterFor(rendererId).event(listener, thisArg, disposables);\n            },\n            postMessage: (message, editorOrAlias) => {\n                if (( ExtHostNotebookEditor.apiEditorsToExtHost.has(message))) {\n                    [message, editorOrAlias] = [editorOrAlias, message];\n                }\n                const extHostEditor = editorOrAlias && ExtHostNotebookEditor.apiEditorsToExtHost.get(editorOrAlias);\n                return this.proxy.$postMessage(extHostEditor?.id, rendererId, message);\n            },\n        };\n        return messaging;\n    }\n    getOrCreateEmitterFor(rendererId) {\n        let emitter = this._rendererMessageEmitters.get(rendererId);\n        if (emitter) {\n            return emitter;\n        }\n        emitter = ( new Emitter({\n            onDidRemoveLastListener: () => {\n                emitter?.dispose();\n                this._rendererMessageEmitters.delete(rendererId);\n            }\n        }));\n        this._rendererMessageEmitters.set(rendererId, emitter);\n        return emitter;\n    }\n}\nexport { ExtHostNotebookRenderers };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\nimport { ExtensionIdentifier } from '../../../platform/extensions/common/extensions.js';\nimport { AbstractMessageLogger, log, parseLogLevel } from '../../../platform/log/common/log.js';\nimport { ILoggerService, ILogService } from '../../../platform/log/common/log.service.js';\nimport { OutputChannelUpdateMode } from '../../services/output/common/output.js';\nimport { IExtHostConsumerFileSystem } from './extHostFileSystemConsumer.js';\nimport { IExtHostInitDataService } from './extHostInitDataService.js';\nimport { IExtHostFileSystemInfo } from './extHostFileSystemInfo.js';\nimport { toLocalISOString } from '../../../base/common/date.js';\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport { isString } from '../../../base/common/types.js';\nimport { toFileSystemProviderErrorCode, FileSystemProviderErrorCode } from '../../../platform/files/common/files.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { DisposableStore } from '../../../base/common/lifecycle.js';\nclass ExtHostOutputChannel extends AbstractMessageLogger {\n    get disposed() { return this._disposed; }\n    constructor(id, name, logger, proxy, extension) {\n        super();\n        this.id = id;\n        this.name = name;\n        this.logger = logger;\n        this.proxy = proxy;\n        this.extension = extension;\n        this.offset = 0;\n        this._disposed = false;\n        this.visible = false;\n        this.setLevel(logger.getLevel());\n        this._register(logger.onDidChangeLogLevel(level => this.setLevel(level)));\n    }\n    get logLevel() {\n        return this.getLevel();\n    }\n    appendLine(value) {\n        this.append(value + '\\n');\n    }\n    append(value) {\n        this.info(value);\n    }\n    clear() {\n        const till = this.offset;\n        this.logger.flush();\n        this.proxy.$update(this.id, OutputChannelUpdateMode.Clear, till);\n    }\n    replace(value) {\n        const till = this.offset;\n        this.info(value);\n        this.proxy.$update(this.id, OutputChannelUpdateMode.Replace, till);\n        if (this.visible) {\n            this.logger.flush();\n        }\n    }\n    show(columnOrPreserveFocus, preserveFocus) {\n        this.logger.flush();\n        this.proxy.$reveal(this.id, !!(typeof columnOrPreserveFocus === 'boolean' ? columnOrPreserveFocus : preserveFocus));\n    }\n    hide() {\n        this.proxy.$close(this.id);\n    }\n    log(level, message) {\n        this.offset += VSBuffer.fromString(message).byteLength;\n        log(this.logger, level, message);\n        if (this.visible) {\n            this.logger.flush();\n            this.proxy.$update(this.id, OutputChannelUpdateMode.Append);\n        }\n    }\n    dispose() {\n        super.dispose();\n        if (!this._disposed) {\n            this.proxy.$dispose(this.id);\n            this._disposed = true;\n        }\n    }\n}\nclass ExtHostLogOutputChannel extends ExtHostOutputChannel {\n    appendLine(value) {\n        this.append(value);\n    }\n}\nlet ExtHostOutputService = class ExtHostOutputService {\n    constructor(extHostRpc, initData, extHostFileSystem, extHostFileSystemInfo, loggerService, logService) {\n        this.initData = initData;\n        this.extHostFileSystem = extHostFileSystem;\n        this.extHostFileSystemInfo = extHostFileSystemInfo;\n        this.loggerService = loggerService;\n        this.logService = logService;\n        this.extensionLogDirectoryPromise = ( new Map());\n        this.namePool = 1;\n        this.channels = ( new Map());\n        this.visibleChannelId = null;\n        this.proxy = ( extHostRpc.getProxy(MainContext.MainThreadOutputService));\n        this.outputsLocation = this.extHostFileSystemInfo.extUri.joinPath(initData.logsLocation, `output_logging_${toLocalISOString(( new Date())).replace(/-|:|\\.\\d+Z$/g, '')}`);\n    }\n    $setVisibleChannel(visibleChannelId) {\n        this.visibleChannelId = visibleChannelId;\n        for (const [id, channel] of this.channels) {\n            channel.visible = id === this.visibleChannelId;\n        }\n    }\n    createOutputChannel(name, options, extension) {\n        name = name.trim();\n        if (!name) {\n            throw ( new Error('illegal argument `name`. must not be falsy'));\n        }\n        const log = typeof options === 'object' && options.log;\n        const languageId = isString(options) ? options : undefined;\n        if (isString(languageId) && !languageId.trim()) {\n            throw ( new Error('illegal argument `languageId`. must not be empty'));\n        }\n        let logLevel;\n        const logLevelValue = this.initData.environment.extensionLogLevel?.find(([identifier]) => ExtensionIdentifier.equals(extension.identifier, identifier))?.[1];\n        if (logLevelValue) {\n            logLevel = parseLogLevel(logLevelValue);\n        }\n        const extHostOutputChannel = log ? this.doCreateLogOutputChannel(name, logLevel, extension) : this.doCreateOutputChannel(name, languageId, extension);\n        extHostOutputChannel.then(channel => {\n            this.channels.set(channel.id, channel);\n            channel.visible = channel.id === this.visibleChannelId;\n        });\n        return log ? this.createExtHostLogOutputChannel(name, logLevel ?? this.logService.getLevel(), extHostOutputChannel) : this.createExtHostOutputChannel(name, extHostOutputChannel);\n    }\n    async doCreateOutputChannel(name, languageId, extension) {\n        if (!this.outputDirectoryPromise) {\n            this.outputDirectoryPromise = this.extHostFileSystem.value.createDirectory(this.outputsLocation).then(() => this.outputsLocation);\n        }\n        const outputDir = await this.outputDirectoryPromise;\n        const file = this.extHostFileSystemInfo.extUri.joinPath(outputDir, `${this.namePool++}-${name.replace(/[\\\\/:\\*\\?\"<>\\|]/g, '')}.log`);\n        const logger = this.loggerService.createLogger(file, { logLevel: 'always', donotRotate: true, donotUseFormatters: true, hidden: true });\n        const id = await this.proxy.$register(name, file, languageId, extension.identifier.value);\n        return ( new ExtHostOutputChannel(id, name, logger, this.proxy, extension));\n    }\n    async doCreateLogOutputChannel(name, logLevel, extension) {\n        const extensionLogDir = await this.createExtensionLogDirectory(extension);\n        const fileName = name.replace(/[\\\\/:\\*\\?\"<>\\|]/g, '');\n        const file = this.extHostFileSystemInfo.extUri.joinPath(extensionLogDir, `${fileName}.log`);\n        const id = `${extension.identifier.value}.${fileName}`;\n        const logger = this.loggerService.createLogger(file, { id, name, logLevel, extensionId: extension.identifier.value });\n        return ( new ExtHostLogOutputChannel(id, name, logger, this.proxy, extension));\n    }\n    createExtensionLogDirectory(extension) {\n        let extensionLogDirectoryPromise = this.extensionLogDirectoryPromise.get(extension.identifier.value);\n        if (!extensionLogDirectoryPromise) {\n            const extensionLogDirectory = this.extHostFileSystemInfo.extUri.joinPath(this.initData.logsLocation, extension.identifier.value);\n            this.extensionLogDirectoryPromise.set(extension.identifier.value, extensionLogDirectoryPromise = (async () => {\n                try {\n                    await this.extHostFileSystem.value.createDirectory(extensionLogDirectory);\n                }\n                catch (err) {\n                    if (toFileSystemProviderErrorCode(err) !== FileSystemProviderErrorCode.FileExists) {\n                        throw err;\n                    }\n                }\n                return extensionLogDirectory;\n            })());\n        }\n        return extensionLogDirectoryPromise;\n    }\n    createExtHostOutputChannel(name, channelPromise) {\n        let disposed = false;\n        const validate = () => {\n            if (disposed) {\n                throw ( new Error('Channel has been closed'));\n            }\n        };\n        return {\n            get name() { return name; },\n            append(value) {\n                validate();\n                channelPromise.then(channel => channel.append(value));\n            },\n            appendLine(value) {\n                validate();\n                channelPromise.then(channel => channel.appendLine(value));\n            },\n            clear() {\n                validate();\n                channelPromise.then(channel => channel.clear());\n            },\n            replace(value) {\n                validate();\n                channelPromise.then(channel => channel.replace(value));\n            },\n            show(columnOrPreserveFocus, preserveFocus) {\n                validate();\n                channelPromise.then(channel => channel.show(columnOrPreserveFocus, preserveFocus));\n            },\n            hide() {\n                validate();\n                channelPromise.then(channel => channel.hide());\n            },\n            dispose() {\n                disposed = true;\n                channelPromise.then(channel => channel.dispose());\n            }\n        };\n    }\n    createExtHostLogOutputChannel(name, logLevel, channelPromise) {\n        const disposables = ( new DisposableStore());\n        const validate = () => {\n            if (disposables.isDisposed) {\n                throw ( new Error('Channel has been closed'));\n            }\n        };\n        const onDidChangeLogLevel = disposables.add(( new Emitter()));\n        function setLogLevel(newLogLevel) {\n            logLevel = newLogLevel;\n            onDidChangeLogLevel.fire(newLogLevel);\n        }\n        channelPromise.then(channel => {\n            disposables.add(channel);\n            if (channel.logLevel !== logLevel) {\n                setLogLevel(channel.logLevel);\n            }\n            disposables.add(channel.onDidChangeLogLevel(e => setLogLevel(e)));\n        });\n        return {\n            ...this.createExtHostOutputChannel(name, channelPromise),\n            get logLevel() { return logLevel; },\n            onDidChangeLogLevel: onDidChangeLogLevel.event,\n            trace(value, ...args) {\n                validate();\n                channelPromise.then(channel => channel.trace(value, ...args));\n            },\n            debug(value, ...args) {\n                validate();\n                channelPromise.then(channel => channel.debug(value, ...args));\n            },\n            info(value, ...args) {\n                validate();\n                channelPromise.then(channel => channel.info(value, ...args));\n            },\n            warn(value, ...args) {\n                validate();\n                channelPromise.then(channel => channel.warn(value, ...args));\n            },\n            error(value, ...args) {\n                validate();\n                channelPromise.then(channel => channel.error(value, ...args));\n            },\n            dispose() {\n                disposables.dispose();\n            }\n        };\n    }\n};\nExtHostOutputService = ( __decorate([\n    ( __param(0, IExtHostRpcService)),\n    ( __param(1, IExtHostInitDataService)),\n    ( __param(2, IExtHostConsumerFileSystem)),\n    ( __param(3, IExtHostFileSystemInfo)),\n    ( __param(4, ILoggerService)),\n    ( __param(5, ILogService))\n], ExtHostOutputService));\nconst IExtHostOutputService = ( createDecorator('IExtHostOutputService'));\nexport { ExtHostOutputService, IExtHostOutputService };\n","import { toDisposable } from '../../../base/common/lifecycle.js';\nimport { isString } from '../../../base/common/types.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { checkProposedApiEnabled } from '../../services/extensions/common/extensions.js';\nimport { MainContext } from './extHost.protocol.js';\nclass ExtHostProfileContentHandlers {\n    constructor(mainContext) {\n        this.handlers = ( new Map());\n        this.proxy = ( mainContext.getProxy(MainContext.MainThreadProfileContentHandlers));\n    }\n    registerProfileContentHandler(extension, id, handler) {\n        checkProposedApiEnabled(extension, 'profileContentHandlers');\n        if (( this.handlers.has(id))) {\n            throw ( new Error(`Handler with id '${id}' already registered`));\n        }\n        this.handlers.set(id, handler);\n        this.proxy.$registerProfileContentHandler(id, handler.name, handler.description, extension.identifier.value);\n        return toDisposable(() => {\n            this.handlers.delete(id);\n            this.proxy.$unregisterProfileContentHandler(id);\n        });\n    }\n    async $saveProfile(id, name, content, token) {\n        const handler = this.handlers.get(id);\n        if (!handler) {\n            throw ( new Error(`Unknown handler with id: ${id}`));\n        }\n        return handler.saveProfile(name, content, token);\n    }\n    async $readProfile(id, idOrUri, token) {\n        const handler = this.handlers.get(id);\n        if (!handler) {\n            throw ( new Error(`Unknown handler with id: ${id}`));\n        }\n        return handler.readProfile(isString(idOrUri) ? idOrUri : URI.revive(idOrUri), token);\n    }\n}\nexport { ExtHostProfileContentHandlers };\n","import { __decorate } from '../../../../../../external/tslib/tslib.es6.js';\nimport { ProgressLocation } from './extHostTypeConverters.js';\nimport { Progress } from '../../../platform/progress/common/progress.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { throttle } from '../../../base/common/decorators.js';\nimport { onUnexpectedExternalError } from '../../../base/common/errors.js';\nclass ExtHostProgress {\n    constructor(proxy) {\n        this._handles = 0;\n        this._mapHandleToCancellationSource = ( new Map());\n        this._proxy = proxy;\n    }\n    async withProgress(extension, options, task) {\n        const handle = this._handles++;\n        const { title, location, cancellable } = options;\n        const source = { label: extension.displayName || extension.name, id: extension.identifier.value };\n        this._proxy.$startProgress(handle, { location: ProgressLocation.from(location), title, source, cancellable }, !extension.isUnderDevelopment ? extension.identifier.value : undefined).catch(onUnexpectedExternalError);\n        return this._withProgress(handle, task, !!cancellable);\n    }\n    _withProgress(handle, task, cancellable) {\n        let source;\n        if (cancellable) {\n            source = ( new CancellationTokenSource());\n            this._mapHandleToCancellationSource.set(handle, source);\n        }\n        const progressEnd = (handle) => {\n            this._proxy.$progressEnd(handle);\n            this._mapHandleToCancellationSource.delete(handle);\n            source?.dispose();\n        };\n        let p;\n        try {\n            p = task(( new ProgressCallback(this._proxy, handle)), cancellable && source ? source.token : CancellationToken.None);\n        }\n        catch (err) {\n            progressEnd(handle);\n            throw err;\n        }\n        p.then(result => progressEnd(handle), err => progressEnd(handle));\n        return p;\n    }\n    $acceptProgressCanceled(handle) {\n        const source = this._mapHandleToCancellationSource.get(handle);\n        if (source) {\n            source.cancel();\n            this._mapHandleToCancellationSource.delete(handle);\n        }\n    }\n}\nfunction mergeProgress(result, currentValue) {\n    result.message = currentValue.message;\n    if (typeof currentValue.increment === 'number') {\n        if (typeof result.increment === 'number') {\n            result.increment += currentValue.increment;\n        }\n        else {\n            result.increment = currentValue.increment;\n        }\n    }\n    return result;\n}\nclass ProgressCallback extends Progress {\n    constructor(_proxy, _handle) {\n        super(p => this.throttledReport(p));\n        this._proxy = _proxy;\n        this._handle = _handle;\n    }\n    throttledReport(p) {\n        this._proxy.$progressReport(this._handle, p);\n    }\n}\nProgressCallback.__decorator = ( __decorate([\n    throttle(100, (result, currentValue) => mergeProgress(result, currentValue), () => Object.create(null))\n], ProgressCallback.prototype, \"throttledReport\", null));\nexport { ExtHostProgress };\n","import { URI } from '../../../base/common/uri.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { asPromise } from '../../../base/common/async.js';\nimport { DocumentSelector } from './extHostTypeConverters.js';\nclass ExtHostQuickDiff {\n    static { this.handlePool = 0; }\n    constructor(mainContext, uriTransformer) {\n        this.uriTransformer = uriTransformer;\n        this.providers = ( new Map());\n        this.proxy = ( mainContext.getProxy(MainContext.MainThreadQuickDiff));\n    }\n    $provideOriginalResource(handle, uriComponents, token) {\n        const uri = URI.revive(uriComponents);\n        const provider = this.providers.get(handle);\n        if (!provider) {\n            return Promise.resolve(null);\n        }\n        return asPromise(() => provider.provideOriginalResource(uri, token))\n            .then(r => r || null);\n    }\n    registerQuickDiffProvider(selector, quickDiffProvider, label, rootUri) {\n        const handle = ExtHostQuickDiff.handlePool++;\n        this.providers.set(handle, quickDiffProvider);\n        this.proxy.$registerQuickDiffProvider(handle, DocumentSelector.from(selector, this.uriTransformer), label, rootUri);\n        return {\n            dispose: () => {\n                this.proxy.$unregisterQuickDiffProvider(handle);\n                this.providers.delete(handle);\n            }\n        };\n    }\n}\nexport { ExtHostQuickDiff };\n","import { CancellationToken } from '../../../base/common/cancellation.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { dispose } from '../../../base/common/lifecycle.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { QuickPickItemKind, InputBoxValidationSeverity, QuickInputButtons, ThemeIcon as ThemeIcon$1 } from './extHostTypes.js';\nimport { isCancellationError } from '../../../base/common/errors.js';\nimport { coalesce } from '../../../base/common/arrays.js';\nimport Severity$1 from '../../../base/common/severity.js';\nimport { ThemeIcon } from '../../../base/common/themables.js';\nimport { isProposedApiEnabled } from '../../services/extensions/common/extensions.js';\nimport { MarkdownString } from './extHostTypeConverters.js';\nfunction createExtHostQuickOpen(mainContext, workspace, commands) {\n    const proxy = ( mainContext.getProxy(MainContext.MainThreadQuickOpen));\n    class ExtHostQuickOpenImpl {\n        constructor(workspace, commands) {\n            this._sessions = ( new Map());\n            this._instances = 0;\n            this._workspace = workspace;\n            this._commands = commands;\n        }\n        showQuickPick(extension, itemsOrItemsPromise, options, token = CancellationToken.None) {\n            this._onDidSelectItem = undefined;\n            const itemsPromise = Promise.resolve(itemsOrItemsPromise);\n            const instance = ++this._instances;\n            const quickPickWidget = proxy.$show(instance, {\n                title: options?.title,\n                placeHolder: options?.placeHolder,\n                matchOnDescription: options?.matchOnDescription,\n                matchOnDetail: options?.matchOnDetail,\n                ignoreFocusLost: options?.ignoreFocusOut,\n                canPickMany: options?.canPickMany,\n            }, token);\n            const widgetClosedMarker = {};\n            const widgetClosedPromise = quickPickWidget.then(() => widgetClosedMarker);\n            return Promise.race([widgetClosedPromise, itemsPromise]).then(result => {\n                if (result === widgetClosedMarker) {\n                    return undefined;\n                }\n                const allowedTooltips = isProposedApiEnabled(extension, 'quickPickItemTooltip');\n                return itemsPromise.then(items => {\n                    const pickItems = [];\n                    for (let handle = 0; handle < items.length; handle++) {\n                        const item = items[handle];\n                        if (typeof item === 'string') {\n                            pickItems.push({ label: item, handle });\n                        }\n                        else if (item.kind === QuickPickItemKind.Separator) {\n                            pickItems.push({ type: 'separator', label: item.label });\n                        }\n                        else {\n                            if (item.tooltip && !allowedTooltips) {\n                                console.warn(`Extension '${extension.identifier.value}' uses a tooltip which is proposed API that is only available when running out of dev or with the following command line switch: --enable-proposed-api ${extension.identifier.value}`);\n                            }\n                            const icon = (item.iconPath) ? getIconPathOrClass(item.iconPath) : undefined;\n                            pickItems.push({\n                                label: item.label,\n                                iconPath: icon?.iconPath,\n                                iconClass: icon?.iconClass,\n                                description: item.description,\n                                detail: item.detail,\n                                picked: item.picked,\n                                alwaysShow: item.alwaysShow,\n                                tooltip: allowedTooltips ? MarkdownString.fromStrict(item.tooltip) : undefined,\n                                handle\n                            });\n                        }\n                    }\n                    if (options && typeof options.onDidSelectItem === 'function') {\n                        this._onDidSelectItem = (handle) => {\n                            options.onDidSelectItem(items[handle]);\n                        };\n                    }\n                    proxy.$setItems(instance, pickItems);\n                    return quickPickWidget.then(handle => {\n                        if (typeof handle === 'number') {\n                            return items[handle];\n                        }\n                        else if (Array.isArray(handle)) {\n                            return ( handle.map(h => items[h]));\n                        }\n                        return undefined;\n                    });\n                });\n            }).then(undefined, err => {\n                if (isCancellationError(err)) {\n                    return undefined;\n                }\n                proxy.$setError(instance, err);\n                return Promise.reject(err);\n            });\n        }\n        $onItemSelected(handle) {\n            this._onDidSelectItem?.(handle);\n        }\n        showInput(options, token = CancellationToken.None) {\n            this._validateInput = options?.validateInput;\n            return proxy.$input(options, typeof this._validateInput === 'function', token)\n                .then(undefined, err => {\n                if (isCancellationError(err)) {\n                    return undefined;\n                }\n                return Promise.reject(err);\n            });\n        }\n        async $validateInput(input) {\n            if (!this._validateInput) {\n                return;\n            }\n            const result = await this._validateInput(input);\n            if (!result || typeof result === 'string') {\n                return result;\n            }\n            let severity;\n            switch (result.severity) {\n                case InputBoxValidationSeverity.Info:\n                    severity = Severity$1.Info;\n                    break;\n                case InputBoxValidationSeverity.Warning:\n                    severity = Severity$1.Warning;\n                    break;\n                case InputBoxValidationSeverity.Error:\n                    severity = Severity$1.Error;\n                    break;\n                default:\n                    severity = result.message ? Severity$1.Error : Severity$1.Ignore;\n                    break;\n            }\n            return {\n                content: result.message,\n                severity\n            };\n        }\n        async showWorkspaceFolderPick(options, token = CancellationToken.None) {\n            const selectedFolder = await this._commands.executeCommand('_workbench.pickWorkspaceFolder', [options]);\n            if (!selectedFolder) {\n                return undefined;\n            }\n            const workspaceFolders = await this._workspace.getWorkspaceFolders2();\n            if (!workspaceFolders) {\n                return undefined;\n            }\n            return workspaceFolders.find(folder => ( folder.uri.toString()) === ( selectedFolder.uri.toString()));\n        }\n        createQuickPick(extension) {\n            const session = ( new ExtHostQuickPick(extension, () => this._sessions.delete(session._id)));\n            this._sessions.set(session._id, session);\n            return session;\n        }\n        createInputBox(extension) {\n            const session = ( new ExtHostInputBox(extension, () => this._sessions.delete(session._id)));\n            this._sessions.set(session._id, session);\n            return session;\n        }\n        $onDidChangeValue(sessionId, value) {\n            const session = this._sessions.get(sessionId);\n            session?._fireDidChangeValue(value);\n        }\n        $onDidAccept(sessionId) {\n            const session = this._sessions.get(sessionId);\n            session?._fireDidAccept();\n        }\n        $onDidChangeActive(sessionId, handles) {\n            const session = this._sessions.get(sessionId);\n            if (session instanceof ExtHostQuickPick) {\n                session._fireDidChangeActive(handles);\n            }\n        }\n        $onDidChangeSelection(sessionId, handles) {\n            const session = this._sessions.get(sessionId);\n            if (session instanceof ExtHostQuickPick) {\n                session._fireDidChangeSelection(handles);\n            }\n        }\n        $onDidTriggerButton(sessionId, handle) {\n            const session = this._sessions.get(sessionId);\n            session?._fireDidTriggerButton(handle);\n        }\n        $onDidTriggerItemButton(sessionId, itemHandle, buttonHandle) {\n            const session = this._sessions.get(sessionId);\n            if (session instanceof ExtHostQuickPick) {\n                session._fireDidTriggerItemButton(itemHandle, buttonHandle);\n            }\n        }\n        $onDidHide(sessionId) {\n            const session = this._sessions.get(sessionId);\n            session?._fireDidHide();\n        }\n    }\n    class ExtHostQuickInput {\n        static { this._nextId = 1; }\n        constructor(_extension, _onDidDispose) {\n            this._extension = _extension;\n            this._onDidDispose = _onDidDispose;\n            this._id = ExtHostQuickPick._nextId++;\n            this._visible = false;\n            this._expectingHide = false;\n            this._enabled = true;\n            this._busy = false;\n            this._ignoreFocusOut = true;\n            this._value = '';\n            this._buttons = [];\n            this._handlesToButtons = ( new Map());\n            this._onDidAcceptEmitter = ( new Emitter());\n            this._onDidChangeValueEmitter = ( new Emitter());\n            this._onDidTriggerButtonEmitter = ( new Emitter());\n            this._onDidHideEmitter = ( new Emitter());\n            this._pendingUpdate = { id: this._id };\n            this._disposed = false;\n            this._disposables = [\n                this._onDidTriggerButtonEmitter,\n                this._onDidHideEmitter,\n                this._onDidAcceptEmitter,\n                this._onDidChangeValueEmitter\n            ];\n            this.onDidChangeValue = this._onDidChangeValueEmitter.event;\n            this.onDidAccept = this._onDidAcceptEmitter.event;\n            this.onDidTriggerButton = this._onDidTriggerButtonEmitter.event;\n            this.onDidHide = this._onDidHideEmitter.event;\n        }\n        get title() {\n            return this._title;\n        }\n        set title(title) {\n            this._title = title;\n            this.update({ title });\n        }\n        get step() {\n            return this._steps;\n        }\n        set step(step) {\n            this._steps = step;\n            this.update({ step });\n        }\n        get totalSteps() {\n            return this._totalSteps;\n        }\n        set totalSteps(totalSteps) {\n            this._totalSteps = totalSteps;\n            this.update({ totalSteps });\n        }\n        get enabled() {\n            return this._enabled;\n        }\n        set enabled(enabled) {\n            this._enabled = enabled;\n            this.update({ enabled });\n        }\n        get busy() {\n            return this._busy;\n        }\n        set busy(busy) {\n            this._busy = busy;\n            this.update({ busy });\n        }\n        get ignoreFocusOut() {\n            return this._ignoreFocusOut;\n        }\n        set ignoreFocusOut(ignoreFocusOut) {\n            this._ignoreFocusOut = ignoreFocusOut;\n            this.update({ ignoreFocusOut });\n        }\n        get value() {\n            return this._value;\n        }\n        set value(value) {\n            this._value = value;\n            this.update({ value });\n        }\n        get placeholder() {\n            return this._placeholder;\n        }\n        set placeholder(placeholder) {\n            this._placeholder = placeholder;\n            this.update({ placeholder });\n        }\n        get buttons() {\n            return this._buttons;\n        }\n        set buttons(buttons) {\n            const allowedButtonLocation = isProposedApiEnabled(this._extension, 'quickInputButtonLocation');\n            if (!allowedButtonLocation && ( buttons.some(button => button.location))) {\n                console.warn(`Extension '${this._extension.identifier.value}' uses a button location which is proposed API that is only available when running out of dev or with the following command line switch: --enable-proposed-api ${this._extension.identifier.value}`);\n            }\n            this._buttons = buttons.slice();\n            this._handlesToButtons.clear();\n            buttons.forEach((button, i) => {\n                const handle = button === QuickInputButtons.Back ? -1 : i;\n                this._handlesToButtons.set(handle, button);\n            });\n            this.update({\n                buttons: ( buttons.map((button, i) => {\n                    return {\n                        ...getIconPathOrClass(button.iconPath),\n                        tooltip: button.tooltip,\n                        handle: button === QuickInputButtons.Back ? -1 : i,\n                        location: allowedButtonLocation ? button.location : undefined\n                    };\n                }))\n            });\n        }\n        show() {\n            this._visible = true;\n            this._expectingHide = true;\n            this.update({ visible: true });\n        }\n        hide() {\n            this._visible = false;\n            this.update({ visible: false });\n        }\n        _fireDidAccept() {\n            this._onDidAcceptEmitter.fire();\n        }\n        _fireDidChangeValue(value) {\n            this._value = value;\n            this._onDidChangeValueEmitter.fire(value);\n        }\n        _fireDidTriggerButton(handle) {\n            const button = this._handlesToButtons.get(handle);\n            if (button) {\n                this._onDidTriggerButtonEmitter.fire(button);\n            }\n        }\n        _fireDidHide() {\n            if (this._expectingHide) {\n                this._expectingHide = this._visible;\n                this._onDidHideEmitter.fire();\n            }\n        }\n        dispose() {\n            if (this._disposed) {\n                return;\n            }\n            this._disposed = true;\n            this._fireDidHide();\n            this._disposables = dispose(this._disposables);\n            if (this._updateTimeout) {\n                clearTimeout(this._updateTimeout);\n                this._updateTimeout = undefined;\n            }\n            this._onDidDispose();\n            proxy.$dispose(this._id);\n        }\n        update(properties) {\n            if (this._disposed) {\n                return;\n            }\n            for (const key of ( Object.keys(properties))) {\n                const value = properties[key];\n                this._pendingUpdate[key] = value === undefined ? null : value;\n            }\n            if ('visible' in this._pendingUpdate) {\n                if (this._updateTimeout) {\n                    clearTimeout(this._updateTimeout);\n                    this._updateTimeout = undefined;\n                }\n                this.dispatchUpdate();\n            }\n            else if (this._visible && !this._updateTimeout) {\n                this._updateTimeout = setTimeout(() => {\n                    this._updateTimeout = undefined;\n                    this.dispatchUpdate();\n                }, 0);\n            }\n        }\n        dispatchUpdate() {\n            proxy.$createOrUpdate(this._pendingUpdate);\n            this._pendingUpdate = { id: this._id };\n        }\n    }\n    function getIconUris(iconPath) {\n        if (iconPath instanceof ThemeIcon$1) {\n            return { id: iconPath.id };\n        }\n        const dark = getDarkIconUri(iconPath);\n        const light = getLightIconUri(iconPath);\n        return {\n            dark: typeof dark === 'string' ? URI.file(dark) : dark,\n            light: typeof light === 'string' ? URI.file(light) : light\n        };\n    }\n    function getLightIconUri(iconPath) {\n        return typeof iconPath === 'object' && 'light' in iconPath ? iconPath.light : iconPath;\n    }\n    function getDarkIconUri(iconPath) {\n        return typeof iconPath === 'object' && 'dark' in iconPath ? iconPath.dark : iconPath;\n    }\n    function getIconPathOrClass(icon) {\n        const iconPathOrIconClass = getIconUris(icon);\n        let iconPath;\n        let iconClass;\n        if ('id' in iconPathOrIconClass) {\n            iconClass = ThemeIcon.asClassName(iconPathOrIconClass);\n        }\n        else {\n            iconPath = iconPathOrIconClass;\n        }\n        return {\n            iconPath,\n            iconClass\n        };\n    }\n    class ExtHostQuickPick extends ExtHostQuickInput {\n        constructor(extension, onDispose) {\n            super(extension, onDispose);\n            this._items = [];\n            this._handlesToItems = ( new Map());\n            this._itemsToHandles = ( new Map());\n            this._canSelectMany = false;\n            this._matchOnDescription = true;\n            this._matchOnDetail = true;\n            this._sortByLabel = true;\n            this._keepScrollPosition = false;\n            this._activeItems = [];\n            this._onDidChangeActiveEmitter = ( new Emitter());\n            this._selectedItems = [];\n            this._onDidChangeSelectionEmitter = ( new Emitter());\n            this._onDidTriggerItemButtonEmitter = ( new Emitter());\n            this.onDidChangeActive = this._onDidChangeActiveEmitter.event;\n            this.onDidChangeSelection = this._onDidChangeSelectionEmitter.event;\n            this.onDidTriggerItemButton = this._onDidTriggerItemButtonEmitter.event;\n            this._disposables.push(this._onDidChangeActiveEmitter, this._onDidChangeSelectionEmitter, this._onDidTriggerItemButtonEmitter);\n            this.update({ type: 'quickPick' });\n        }\n        get items() {\n            return this._items;\n        }\n        set items(items) {\n            this._items = items.slice();\n            this._handlesToItems.clear();\n            this._itemsToHandles.clear();\n            items.forEach((item, i) => {\n                this._handlesToItems.set(i, item);\n                this._itemsToHandles.set(item, i);\n            });\n            const allowedTooltips = isProposedApiEnabled(this._extension, 'quickPickItemTooltip');\n            const pickItems = [];\n            for (let handle = 0; handle < items.length; handle++) {\n                const item = items[handle];\n                if (item.kind === QuickPickItemKind.Separator) {\n                    pickItems.push({ type: 'separator', label: item.label });\n                }\n                else {\n                    if (item.tooltip && !allowedTooltips) {\n                        console.warn(`Extension '${this._extension.identifier.value}' uses a tooltip which is proposed API that is only available when running out of dev or with the following command line switch: --enable-proposed-api ${this._extension.identifier.value}`);\n                    }\n                    const icon = (item.iconPath) ? getIconPathOrClass(item.iconPath) : undefined;\n                    pickItems.push({\n                        handle,\n                        label: item.label,\n                        iconPath: icon?.iconPath,\n                        iconClass: icon?.iconClass,\n                        description: item.description,\n                        detail: item.detail,\n                        picked: item.picked,\n                        alwaysShow: item.alwaysShow,\n                        tooltip: allowedTooltips ? MarkdownString.fromStrict(item.tooltip) : undefined,\n                        buttons: item.buttons?.map((button, i) => {\n                            return {\n                                ...getIconPathOrClass(button.iconPath),\n                                tooltip: button.tooltip,\n                                handle: i\n                            };\n                        }),\n                    });\n                }\n            }\n            this.update({\n                items: pickItems,\n            });\n        }\n        get canSelectMany() {\n            return this._canSelectMany;\n        }\n        set canSelectMany(canSelectMany) {\n            this._canSelectMany = canSelectMany;\n            this.update({ canSelectMany });\n        }\n        get matchOnDescription() {\n            return this._matchOnDescription;\n        }\n        set matchOnDescription(matchOnDescription) {\n            this._matchOnDescription = matchOnDescription;\n            this.update({ matchOnDescription });\n        }\n        get matchOnDetail() {\n            return this._matchOnDetail;\n        }\n        set matchOnDetail(matchOnDetail) {\n            this._matchOnDetail = matchOnDetail;\n            this.update({ matchOnDetail });\n        }\n        get sortByLabel() {\n            return this._sortByLabel;\n        }\n        set sortByLabel(sortByLabel) {\n            this._sortByLabel = sortByLabel;\n            this.update({ sortByLabel });\n        }\n        get keepScrollPosition() {\n            return this._keepScrollPosition;\n        }\n        set keepScrollPosition(keepScrollPosition) {\n            this._keepScrollPosition = keepScrollPosition;\n            this.update({ keepScrollPosition });\n        }\n        get activeItems() {\n            return this._activeItems;\n        }\n        set activeItems(activeItems) {\n            this._activeItems = activeItems.filter(item => ( this._itemsToHandles.has(item)));\n            this.update({ activeItems: ( this._activeItems.map(item => this._itemsToHandles.get(item))) });\n        }\n        get selectedItems() {\n            return this._selectedItems;\n        }\n        set selectedItems(selectedItems) {\n            this._selectedItems = selectedItems.filter(item => ( this._itemsToHandles.has(item)));\n            this.update({ selectedItems: ( this._selectedItems.map(item => this._itemsToHandles.get(item))) });\n        }\n        _fireDidChangeActive(handles) {\n            const items = coalesce(( handles.map(handle => this._handlesToItems.get(handle))));\n            this._activeItems = items;\n            this._onDidChangeActiveEmitter.fire(items);\n        }\n        _fireDidChangeSelection(handles) {\n            const items = coalesce(( handles.map(handle => this._handlesToItems.get(handle))));\n            this._selectedItems = items;\n            this._onDidChangeSelectionEmitter.fire(items);\n        }\n        _fireDidTriggerItemButton(itemHandle, buttonHandle) {\n            const item = this._handlesToItems.get(itemHandle);\n            if (!item || !item.buttons || !item.buttons.length) {\n                return;\n            }\n            const button = item.buttons[buttonHandle];\n            if (button) {\n                this._onDidTriggerItemButtonEmitter.fire({\n                    button,\n                    item\n                });\n            }\n        }\n    }\n    class ExtHostInputBox extends ExtHostQuickInput {\n        constructor(extension, onDispose) {\n            super(extension, onDispose);\n            this._password = false;\n            this.update({ type: 'inputBox' });\n        }\n        get password() {\n            return this._password;\n        }\n        set password(password) {\n            this._password = password;\n            this.update({ password });\n        }\n        get prompt() {\n            return this._prompt;\n        }\n        set prompt(prompt) {\n            this._prompt = prompt;\n            this.update({ prompt });\n        }\n        get valueSelection() {\n            return this._valueSelection;\n        }\n        set valueSelection(valueSelection) {\n            this._valueSelection = valueSelection;\n            this.update({ valueSelection });\n        }\n        get validationMessage() {\n            return this._validationMessage;\n        }\n        set validationMessage(validationMessage) {\n            this._validationMessage = validationMessage;\n            if (!validationMessage) {\n                this.update({ validationMessage: undefined, severity: Severity$1.Ignore });\n            }\n            else if (typeof validationMessage === 'string') {\n                this.update({ validationMessage, severity: Severity$1.Error });\n            }\n            else {\n                this.update({ validationMessage: validationMessage.message, severity: validationMessage.severity ?? Severity$1.Error });\n            }\n        }\n    }\n    return ( new ExtHostQuickOpenImpl(workspace, commands));\n}\nexport { createExtHostQuickOpen };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { mark } from '../../../base/common/performance.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { IExtHostConfiguration } from './extHostConfiguration.js';\nimport { nullExtensionDescription } from '../../services/extensions/common/extensions.js';\nimport { ExtensionIdentifierMap } from '../../../platform/extensions/common/extensions.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\nimport { IExtHostInitDataService } from './extHostInitDataService.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nimport { IExtHostExtensionService } from './extHostExtensionService.js';\nimport { ILogService } from '../../../platform/log/common/log.service.js';\nimport { escapeRegExpCharacters } from '../../../base/common/strings.js';\nvar NodeModuleAliasingModuleFactory_1;\nlet RequireInterceptor = class RequireInterceptor {\n    constructor(_apiFactory, _extensionRegistry, _instaService, _extHostConfiguration, _extHostExtensionService, _initData, _logService) {\n        this._apiFactory = _apiFactory;\n        this._extensionRegistry = _extensionRegistry;\n        this._instaService = _instaService;\n        this._extHostConfiguration = _extHostConfiguration;\n        this._extHostExtensionService = _extHostExtensionService;\n        this._initData = _initData;\n        this._logService = _logService;\n        this._factories = ( new Map());\n        this._alternatives = [];\n    }\n    async install() {\n        this._installInterceptor();\n        mark('code/extHost/willWaitForConfig');\n        const configProvider = await this._extHostConfiguration.getConfigProvider();\n        mark('code/extHost/didWaitForConfig');\n        const extensionPaths = await this._extHostExtensionService.getExtensionPathIndex();\n        this.register(( new VSCodeNodeModuleFactory(\n            this._apiFactory,\n            extensionPaths,\n            this._extensionRegistry,\n            configProvider,\n            this._logService\n        )));\n        this.register(this._instaService.createInstance(NodeModuleAliasingModuleFactory));\n        if (this._initData.remote.isRemote) {\n            this.register(this._instaService.createInstance(OpenNodeModuleFactory, extensionPaths, this._initData.environment.appUriScheme));\n        }\n    }\n    register(interceptor) {\n        if ('nodeModuleName' in interceptor) {\n            if (Array.isArray(interceptor.nodeModuleName)) {\n                for (const moduleName of interceptor.nodeModuleName) {\n                    this._factories.set(moduleName, interceptor);\n                }\n            }\n            else {\n                this._factories.set(interceptor.nodeModuleName, interceptor);\n            }\n        }\n        if (typeof interceptor.alternativeModuleName === 'function') {\n            this._alternatives.push((moduleName) => {\n                return interceptor.alternativeModuleName(moduleName);\n            });\n        }\n    }\n};\nRequireInterceptor = ( __decorate([\n    ( __param(2, IInstantiationService)),\n    ( __param(3, IExtHostConfiguration)),\n    ( __param(4, IExtHostExtensionService)),\n    ( __param(5, IExtHostInitDataService)),\n    ( __param(6, ILogService))\n], RequireInterceptor));\nlet NodeModuleAliasingModuleFactory = class NodeModuleAliasingModuleFactory {\n    static { NodeModuleAliasingModuleFactory_1 = this; }\n    static { this.aliased = ( new Map([\n        ['vscode-ripgrep', '@vscode/ripgrep'],\n        ['vscode-windows-registry', '@vscode/windows-registry'],\n    ])); }\n    constructor(initData) {\n        if (initData.environment.appRoot && NodeModuleAliasingModuleFactory_1.aliased.size) {\n            const root = escapeRegExpCharacters(this.forceForwardSlashes(initData.environment.appRoot.fsPath));\n            const npmIdChrs = `[a-z0-9_.-]`;\n            const npmModuleName = `@${npmIdChrs}+\\\\/${npmIdChrs}+|${npmIdChrs}+`;\n            const moduleFolders = 'node_modules|node_modules\\\\.asar(?:\\\\.unpacked)?';\n            this.re = ( new RegExp(`^(${root}/${moduleFolders}\\\\/)(${npmModuleName})(.*)$`, 'i'));\n        }\n    }\n    alternativeModuleName(name) {\n        if (!this.re) {\n            return;\n        }\n        const result = this.re.exec(this.forceForwardSlashes(name));\n        if (!result) {\n            return;\n        }\n        const [, prefix, moduleName, suffix] = result;\n        const dealiased = NodeModuleAliasingModuleFactory_1.aliased.get(moduleName);\n        if (dealiased === undefined) {\n            return;\n        }\n        console.warn(`${moduleName} as been renamed to ${dealiased}, please update your imports`);\n        return prefix + dealiased + suffix;\n    }\n    forceForwardSlashes(str) {\n        return str.replace(/\\\\/g, '/');\n    }\n};\nNodeModuleAliasingModuleFactory = NodeModuleAliasingModuleFactory_1 = ( __decorate([\n    ( __param(0, IExtHostInitDataService))\n], NodeModuleAliasingModuleFactory));\nclass VSCodeNodeModuleFactory {\n    constructor(_apiFactory, _extensionPaths, _extensionRegistry, _configProvider, _logService) {\n        this._apiFactory = _apiFactory;\n        this._extensionPaths = _extensionPaths;\n        this._extensionRegistry = _extensionRegistry;\n        this._configProvider = _configProvider;\n        this._logService = _logService;\n        this.nodeModuleName = 'vscode';\n        this._extApiImpl = ( new ExtensionIdentifierMap());\n    }\n    load(_request, parent) {\n        const ext = this._extensionPaths.findSubstr(parent);\n        if (ext) {\n            let apiImpl = this._extApiImpl.get(ext.identifier);\n            if (!apiImpl) {\n                apiImpl = this._apiFactory(ext, this._extensionRegistry, this._configProvider);\n                this._extApiImpl.set(ext.identifier, apiImpl);\n            }\n            return apiImpl;\n        }\n        if (!this._defaultApiImpl) {\n            let extensionPathsPretty = '';\n            this._extensionPaths.forEach((value, index) => extensionPathsPretty += `\\t${index} -> ${value.identifier.value}\\n`);\n            this._logService.warn(`Could not identify extension for 'vscode' require call from ${parent}. These are the extension path mappings: \\n${extensionPathsPretty}`);\n            this._defaultApiImpl = this._apiFactory(nullExtensionDescription, this._extensionRegistry, this._configProvider);\n        }\n        return this._defaultApiImpl;\n    }\n}\nlet OpenNodeModuleFactory = class OpenNodeModuleFactory {\n    constructor(_extensionPaths, _appUriScheme, rpcService) {\n        this._extensionPaths = _extensionPaths;\n        this._appUriScheme = _appUriScheme;\n        this.nodeModuleName = ['open', 'opn'];\n        this._mainThreadTelemetry = ( rpcService.getProxy(MainContext.MainThreadTelemetry));\n        const mainThreadWindow = ( rpcService.getProxy(MainContext.MainThreadWindow));\n        this._impl = (target, options) => {\n            const uri = ( URI.parse(target));\n            if (options) {\n                return this.callOriginal(target, options);\n            }\n            if (uri.scheme === 'http' || uri.scheme === 'https') {\n                return mainThreadWindow.$openUri(uri, target, { allowTunneling: true });\n            }\n            else if (uri.scheme === 'mailto' || uri.scheme === this._appUriScheme) {\n                return mainThreadWindow.$openUri(uri, target, {});\n            }\n            return this.callOriginal(target, options);\n        };\n    }\n    load(request, parent, original) {\n        const extension = this._extensionPaths.findSubstr(parent);\n        if (extension) {\n            this._extensionId = extension.identifier.value;\n            this.sendShimmingTelemetry();\n        }\n        this._original = original(request);\n        return this._impl;\n    }\n    callOriginal(target, options) {\n        this.sendNoForwardTelemetry();\n        return this._original(target, options);\n    }\n    sendShimmingTelemetry() {\n        if (!this._extensionId) {\n            return;\n        }\n        this._mainThreadTelemetry.$publicLog2('shimming.open', { extension: this._extensionId });\n    }\n    sendNoForwardTelemetry() {\n        if (!this._extensionId) {\n            return;\n        }\n        this._mainThreadTelemetry.$publicLog2('shimming.open.call.noForward', { extension: this._extensionId });\n    }\n};\nOpenNodeModuleFactory = ( __decorate([\n    ( __param(2, IExtHostRpcService))\n], OpenNodeModuleFactory));\nexport { RequireInterceptor };\n","import { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nconst IExtHostRpcService = ( createDecorator('IExtHostRpcService'));\nclass ExtHostRpcService {\n    constructor(rpcProtocol) {\n        this.getProxy = rpcProtocol.getProxy.bind(rpcProtocol);\n        this.set = rpcProtocol.set.bind(rpcProtocol);\n        this.dispose = rpcProtocol.dispose.bind(rpcProtocol);\n        this.assertRegistered = rpcProtocol.assertRegistered.bind(rpcProtocol);\n        this.drain = rpcProtocol.drain.bind(rpcProtocol);\n    }\n}\nexport { ExtHostRpcService, IExtHostRpcService };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { debounce } from '../../../base/common/decorators.js';\nimport { DisposableStore, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { asPromise } from '../../../base/common/async.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { sortedDiff, equals } from '../../../base/common/arrays.js';\nimport { comparePaths } from '../../../base/common/comparers.js';\nimport { ILogService } from '../../../platform/log/common/log.service.js';\nimport { ExtensionIdentifierMap } from '../../../platform/extensions/common/extensions.js';\nimport { ThemeIcon } from '../../../base/common/themables.js';\nimport { MarkdownString } from './extHostTypeConverters.js';\nimport { isProposedApiEnabled, checkProposedApiEnabled } from '../../services/extensions/common/extensions.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { isLinux } from '../../../base/common/platform.js';\nvar ExtHostSCM_1;\nfunction isUri(thing) {\n    return thing instanceof URI;\n}\nfunction uriEquals(a, b) {\n    if (a.scheme === Schemas.file && b.scheme === Schemas.file && isLinux) {\n        return ( a.toString()) === ( b.toString());\n    }\n    return ( a.toString()).toLowerCase() === ( b.toString()).toLowerCase();\n}\nfunction getIconResource(decorations) {\n    if (!decorations) {\n        return undefined;\n    }\n    else if (typeof decorations.iconPath === 'string') {\n        return URI.file(decorations.iconPath);\n    }\n    else if (URI.isUri(decorations.iconPath)) {\n        return decorations.iconPath;\n    }\n    else if (ThemeIcon.isThemeIcon(decorations.iconPath)) {\n        return decorations.iconPath;\n    }\n    else {\n        return undefined;\n    }\n}\nfunction getHistoryItemIconDto(icon) {\n    if (!icon) {\n        return undefined;\n    }\n    else if (URI.isUri(icon)) {\n        return icon;\n    }\n    else if (ThemeIcon.isThemeIcon(icon)) {\n        return icon;\n    }\n    else {\n        const iconDto = icon;\n        return { light: iconDto.light, dark: iconDto.dark };\n    }\n}\nfunction toSCMHistoryItemDto(historyItem) {\n    const references = historyItem.references?.map(r => ({\n        ...r, icon: getHistoryItemIconDto(r.icon)\n    }));\n    return { ...historyItem, references };\n}\nfunction toSCMHistoryItemRefDto(historyItemRef) {\n    return historyItemRef ? { ...historyItemRef, icon: getHistoryItemIconDto(historyItemRef.icon) } : undefined;\n}\nfunction compareResourceThemableDecorations(a, b) {\n    if (!a.iconPath && !b.iconPath) {\n        return 0;\n    }\n    else if (!a.iconPath) {\n        return -1;\n    }\n    else if (!b.iconPath) {\n        return 1;\n    }\n    const aPath = typeof a.iconPath === 'string' ? a.iconPath : URI.isUri(a.iconPath) ? a.iconPath.fsPath : a.iconPath.id;\n    const bPath = typeof b.iconPath === 'string' ? b.iconPath : URI.isUri(b.iconPath) ? b.iconPath.fsPath : b.iconPath.id;\n    return comparePaths(aPath, bPath);\n}\nfunction compareResourceStatesDecorations(a, b) {\n    let result = 0;\n    if (a.strikeThrough !== b.strikeThrough) {\n        return a.strikeThrough ? 1 : -1;\n    }\n    if (a.faded !== b.faded) {\n        return a.faded ? 1 : -1;\n    }\n    if (a.tooltip !== b.tooltip) {\n        return (a.tooltip || '').localeCompare(b.tooltip || '');\n    }\n    result = compareResourceThemableDecorations(a, b);\n    if (result !== 0) {\n        return result;\n    }\n    if (a.light && b.light) {\n        result = compareResourceThemableDecorations(a.light, b.light);\n    }\n    else if (a.light) {\n        return 1;\n    }\n    else if (b.light) {\n        return -1;\n    }\n    if (result !== 0) {\n        return result;\n    }\n    if (a.dark && b.dark) {\n        result = compareResourceThemableDecorations(a.dark, b.dark);\n    }\n    else if (a.dark) {\n        return 1;\n    }\n    else if (b.dark) {\n        return -1;\n    }\n    return result;\n}\nfunction compareCommands(a, b) {\n    if (a.command !== b.command) {\n        return a.command < b.command ? -1 : 1;\n    }\n    if (a.title !== b.title) {\n        return a.title < b.title ? -1 : 1;\n    }\n    if (a.tooltip !== b.tooltip) {\n        if (a.tooltip !== undefined && b.tooltip !== undefined) {\n            return a.tooltip < b.tooltip ? -1 : 1;\n        }\n        else if (a.tooltip !== undefined) {\n            return 1;\n        }\n        else if (b.tooltip !== undefined) {\n            return -1;\n        }\n    }\n    if (a.arguments === b.arguments) {\n        return 0;\n    }\n    else if (!a.arguments) {\n        return -1;\n    }\n    else if (!b.arguments) {\n        return 1;\n    }\n    else if (a.arguments.length !== b.arguments.length) {\n        return a.arguments.length - b.arguments.length;\n    }\n    for (let i = 0; i < a.arguments.length; i++) {\n        const aArg = a.arguments[i];\n        const bArg = b.arguments[i];\n        if (aArg === bArg) {\n            continue;\n        }\n        if (isUri(aArg) && isUri(bArg) && uriEquals(aArg, bArg)) {\n            continue;\n        }\n        return aArg < bArg ? -1 : 1;\n    }\n    return 0;\n}\nfunction compareResourceStates(a, b) {\n    let result = comparePaths(a.resourceUri.fsPath, b.resourceUri.fsPath, true);\n    if (result !== 0) {\n        return result;\n    }\n    if (a.command && b.command) {\n        result = compareCommands(a.command, b.command);\n    }\n    else if (a.command) {\n        return 1;\n    }\n    else if (b.command) {\n        return -1;\n    }\n    if (result !== 0) {\n        return result;\n    }\n    if (a.decorations && b.decorations) {\n        result = compareResourceStatesDecorations(a.decorations, b.decorations);\n    }\n    else if (a.decorations) {\n        return 1;\n    }\n    else if (b.decorations) {\n        return -1;\n    }\n    if (result !== 0) {\n        return result;\n    }\n    if (a.multiFileDiffEditorModifiedUri && b.multiFileDiffEditorModifiedUri) {\n        result = comparePaths(a.multiFileDiffEditorModifiedUri.fsPath, b.multiFileDiffEditorModifiedUri.fsPath, true);\n    }\n    else if (a.multiFileDiffEditorModifiedUri) {\n        return 1;\n    }\n    else if (b.multiFileDiffEditorModifiedUri) {\n        return -1;\n    }\n    if (result !== 0) {\n        return result;\n    }\n    if (a.multiDiffEditorOriginalUri && b.multiDiffEditorOriginalUri) {\n        result = comparePaths(a.multiDiffEditorOriginalUri.fsPath, b.multiDiffEditorOriginalUri.fsPath, true);\n    }\n    else if (a.multiDiffEditorOriginalUri) {\n        return 1;\n    }\n    else if (b.multiDiffEditorOriginalUri) {\n        return -1;\n    }\n    return result;\n}\nfunction compareArgs(a, b) {\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction commandEquals(a, b) {\n    return a.command === b.command\n        && a.title === b.title\n        && a.tooltip === b.tooltip\n        && (a.arguments && b.arguments ? compareArgs(a.arguments, b.arguments) : a.arguments === b.arguments);\n}\nfunction commandListEquals(a, b) {\n    return equals(a, b, commandEquals);\n}\nclass ExtHostSCMInputBox {\n    #proxy;\n    #extHostDocuments;\n    get value() {\n        return this._value;\n    }\n    set value(value) {\n        value = value ?? '';\n        this.#proxy.$setInputBoxValue(this._sourceControlHandle, value);\n        this.updateValue(value);\n    }\n    get onDidChange() {\n        return this._onDidChange.event;\n    }\n    get placeholder() {\n        return this._placeholder;\n    }\n    set placeholder(placeholder) {\n        this.#proxy.$setInputBoxPlaceholder(this._sourceControlHandle, placeholder);\n        this._placeholder = placeholder;\n    }\n    get validateInput() {\n        checkProposedApiEnabled(this._extension, 'scmValidation');\n        return this._validateInput;\n    }\n    set validateInput(fn) {\n        checkProposedApiEnabled(this._extension, 'scmValidation');\n        if (fn && typeof fn !== 'function') {\n            throw ( new Error(\n                `[${this._extension.identifier.value}]: Invalid SCM input box validation function`\n            ));\n        }\n        this._validateInput = fn;\n        this.#proxy.$setValidationProviderIsEnabled(this._sourceControlHandle, !!fn);\n    }\n    get enabled() {\n        return this._enabled;\n    }\n    set enabled(enabled) {\n        enabled = !!enabled;\n        if (this._enabled === enabled) {\n            return;\n        }\n        this._enabled = enabled;\n        this.#proxy.$setInputBoxEnablement(this._sourceControlHandle, enabled);\n    }\n    get visible() {\n        return this._visible;\n    }\n    set visible(visible) {\n        visible = !!visible;\n        if (this._visible === visible) {\n            return;\n        }\n        this._visible = visible;\n        this.#proxy.$setInputBoxVisibility(this._sourceControlHandle, visible);\n    }\n    get document() {\n        checkProposedApiEnabled(this._extension, 'scmTextDocument');\n        return this.#extHostDocuments.getDocument(this._documentUri);\n    }\n    constructor(_extension, _extHostDocuments, proxy, _sourceControlHandle, _documentUri) {\n        this._extension = _extension;\n        this._sourceControlHandle = _sourceControlHandle;\n        this._documentUri = _documentUri;\n        this._value = '';\n        this._onDidChange = ( new Emitter());\n        this._placeholder = '';\n        this._enabled = true;\n        this._visible = true;\n        this.#extHostDocuments = _extHostDocuments;\n        this.#proxy = proxy;\n    }\n    showValidationMessage(message, type) {\n        checkProposedApiEnabled(this._extension, 'scmValidation');\n        this.#proxy.$showValidationMessage(this._sourceControlHandle, message, type);\n    }\n    $onInputBoxValueChange(value) {\n        this.updateValue(value);\n    }\n    updateValue(value) {\n        this._value = value;\n        this._onDidChange.fire(value);\n    }\n}\nclass ExtHostSourceControlResourceGroup {\n    static { this._handlePool = 0; }\n    get disposed() { return this._disposed; }\n    get id() { return this._id; }\n    get label() { return this._label; }\n    set label(label) {\n        this._label = label;\n        this._proxy.$updateGroupLabel(this._sourceControlHandle, this.handle, label);\n    }\n    get hideWhenEmpty() { return this._hideWhenEmpty; }\n    set hideWhenEmpty(hideWhenEmpty) {\n        this._hideWhenEmpty = hideWhenEmpty;\n        this._proxy.$updateGroup(this._sourceControlHandle, this.handle, this.features);\n    }\n    get features() {\n        return {\n            hideWhenEmpty: this.hideWhenEmpty\n        };\n    }\n    get resourceStates() { return [...this._resourceStates]; }\n    set resourceStates(resources) {\n        this._resourceStates = [...resources];\n        this._onDidUpdateResourceStates.fire();\n    }\n    constructor(_proxy, _commands, _sourceControlHandle, _id, _label, multiDiffEditorEnableViewChanges, _extension) {\n        this._proxy = _proxy;\n        this._commands = _commands;\n        this._sourceControlHandle = _sourceControlHandle;\n        this._id = _id;\n        this._label = _label;\n        this.multiDiffEditorEnableViewChanges = multiDiffEditorEnableViewChanges;\n        this._extension = _extension;\n        this._resourceHandlePool = 0;\n        this._resourceStates = [];\n        this._resourceStatesMap = ( new Map());\n        this._resourceStatesCommandsMap = ( new Map());\n        this._resourceStatesDisposablesMap = ( new Map());\n        this._onDidUpdateResourceStates = ( new Emitter());\n        this.onDidUpdateResourceStates = this._onDidUpdateResourceStates.event;\n        this._disposed = false;\n        this._onDidDispose = ( new Emitter());\n        this.onDidDispose = this._onDidDispose.event;\n        this._handlesSnapshot = [];\n        this._resourceSnapshot = [];\n        this._hideWhenEmpty = undefined;\n        this.handle = ExtHostSourceControlResourceGroup._handlePool++;\n    }\n    getResourceState(handle) {\n        return this._resourceStatesMap.get(handle);\n    }\n    $executeResourceCommand(handle, preserveFocus) {\n        const command = this._resourceStatesCommandsMap.get(handle);\n        if (!command) {\n            return Promise.resolve(undefined);\n        }\n        return asPromise(() => this._commands.executeCommand(command.command, ...(command.arguments || []), preserveFocus));\n    }\n    _takeResourceStateSnapshot() {\n        const snapshot = [...this._resourceStates].sort(compareResourceStates);\n        const diffs = sortedDiff(this._resourceSnapshot, snapshot, compareResourceStates);\n        const splices = ( diffs.map(diff => {\n            const toInsert = ( diff.toInsert.map(r => {\n                const handle = this._resourceHandlePool++;\n                this._resourceStatesMap.set(handle, r);\n                const sourceUri = r.resourceUri;\n                let command;\n                if (r.command) {\n                    if (r.command.command === 'vscode.open' || r.command.command === 'vscode.diff' || r.command.command === 'vscode.changes') {\n                        const disposables = ( new DisposableStore());\n                        command = this._commands.converter.toInternal(r.command, disposables);\n                        this._resourceStatesDisposablesMap.set(handle, disposables);\n                    }\n                    else {\n                        this._resourceStatesCommandsMap.set(handle, r.command);\n                    }\n                }\n                const hasScmMultiDiffEditorProposalEnabled = isProposedApiEnabled(this._extension, 'scmMultiDiffEditor');\n                const multiFileDiffEditorOriginalUri = hasScmMultiDiffEditorProposalEnabled ? r.multiDiffEditorOriginalUri : undefined;\n                const multiFileDiffEditorModifiedUri = hasScmMultiDiffEditorProposalEnabled ? r.multiFileDiffEditorModifiedUri : undefined;\n                const icon = getIconResource(r.decorations);\n                const lightIcon = r.decorations && getIconResource(r.decorations.light) || icon;\n                const darkIcon = r.decorations && getIconResource(r.decorations.dark) || icon;\n                const icons = [lightIcon, darkIcon];\n                const tooltip = (r.decorations && r.decorations.tooltip) || '';\n                const strikeThrough = r.decorations && !!r.decorations.strikeThrough;\n                const faded = r.decorations && !!r.decorations.faded;\n                const contextValue = r.contextValue || '';\n                const rawResource = [handle, sourceUri, icons, tooltip, strikeThrough, faded, contextValue, command, multiFileDiffEditorOriginalUri, multiFileDiffEditorModifiedUri];\n                return { rawResource, handle };\n            }));\n            return { start: diff.start, deleteCount: diff.deleteCount, toInsert };\n        }));\n        const rawResourceSplices = ( splices\n            .map(({ start, deleteCount, toInsert }) => [start, deleteCount, ( toInsert.map(i => i.rawResource))]));\n        const reverseSplices = splices.reverse();\n        for (const { start, deleteCount, toInsert } of reverseSplices) {\n            const handles = ( toInsert.map(i => i.handle));\n            const handlesToDelete = this._handlesSnapshot.splice(start, deleteCount, ...handles);\n            for (const handle of handlesToDelete) {\n                this._resourceStatesMap.delete(handle);\n                this._resourceStatesCommandsMap.delete(handle);\n                this._resourceStatesDisposablesMap.get(handle)?.dispose();\n                this._resourceStatesDisposablesMap.delete(handle);\n            }\n        }\n        this._resourceSnapshot = snapshot;\n        return rawResourceSplices;\n    }\n    dispose() {\n        this._disposed = true;\n        this._onDidDispose.fire();\n    }\n}\nclass ExtHostSourceControl {\n    static { this._handlePool = 0; }\n    #proxy;\n    get id() {\n        return this._id;\n    }\n    get label() {\n        return this._label;\n    }\n    get rootUri() {\n        return this._rootUri;\n    }\n    get inputBox() { return this._inputBox; }\n    get count() {\n        return this._count;\n    }\n    set count(count) {\n        if (this._count === count) {\n            return;\n        }\n        this._count = count;\n        this.#proxy.$updateSourceControl(this.handle, { count });\n    }\n    get quickDiffProvider() {\n        return this._quickDiffProvider;\n    }\n    set quickDiffProvider(quickDiffProvider) {\n        this._quickDiffProvider = quickDiffProvider;\n        let quickDiffLabel = undefined;\n        if (isProposedApiEnabled(this._extension, 'quickDiffProvider')) {\n            quickDiffLabel = quickDiffProvider?.label;\n        }\n        this.#proxy.$updateSourceControl(this.handle, { hasQuickDiffProvider: !!quickDiffProvider, quickDiffLabel });\n    }\n    get historyProvider() {\n        checkProposedApiEnabled(this._extension, 'scmHistoryProvider');\n        return this._historyProvider;\n    }\n    set historyProvider(historyProvider) {\n        checkProposedApiEnabled(this._extension, 'scmHistoryProvider');\n        this._historyProvider = historyProvider;\n        this._historyProviderDisposable.value = ( new DisposableStore());\n        this.#proxy.$updateSourceControl(this.handle, { hasHistoryProvider: !!historyProvider });\n        if (historyProvider) {\n            this._historyProviderDisposable.value.add(historyProvider.onDidChangeCurrentHistoryItemRefs(() => {\n                const historyItemRef = toSCMHistoryItemRefDto(historyProvider?.currentHistoryItemRef);\n                const historyItemRemoteRef = toSCMHistoryItemRefDto(historyProvider?.currentHistoryItemRemoteRef);\n                const historyItemBaseRef = toSCMHistoryItemRefDto(historyProvider?.currentHistoryItemBaseRef);\n                this.#proxy.$onDidChangeHistoryProviderCurrentHistoryItemRefs(this.handle, historyItemRef, historyItemRemoteRef, historyItemBaseRef);\n            }));\n            this._historyProviderDisposable.value.add(historyProvider.onDidChangeHistoryItemRefs((e) => {\n                if (e.added.length === 0 && e.modified.length === 0 && e.removed.length === 0) {\n                    return;\n                }\n                const added = ( e.added.map(ref => ({ ...ref, icon: getHistoryItemIconDto(ref.icon) })));\n                const modified = ( e.modified.map(ref => ({ ...ref, icon: getHistoryItemIconDto(ref.icon) })));\n                const removed = ( e.removed.map(ref => ({ ...ref, icon: getHistoryItemIconDto(ref.icon) })));\n                this.#proxy.$onDidChangeHistoryProviderHistoryItemRefs(this.handle, { added, modified, removed, silent: e.silent });\n            }));\n        }\n    }\n    get commitTemplate() {\n        return this._commitTemplate;\n    }\n    set commitTemplate(commitTemplate) {\n        if (commitTemplate === this._commitTemplate) {\n            return;\n        }\n        this._commitTemplate = commitTemplate;\n        this.#proxy.$updateSourceControl(this.handle, { commitTemplate });\n    }\n    get acceptInputCommand() {\n        return this._acceptInputCommand;\n    }\n    set acceptInputCommand(acceptInputCommand) {\n        this._acceptInputDisposables.value = ( new DisposableStore());\n        this._acceptInputCommand = acceptInputCommand;\n        const internal = this._commands.converter.toInternal(acceptInputCommand, this._acceptInputDisposables.value);\n        this.#proxy.$updateSourceControl(this.handle, { acceptInputCommand: internal });\n    }\n    get actionButton() {\n        checkProposedApiEnabled(this._extension, 'scmActionButton');\n        return this._actionButton;\n    }\n    set actionButton(actionButton) {\n        checkProposedApiEnabled(this._extension, 'scmActionButton');\n        this._actionButtonDisposables.value = ( new DisposableStore());\n        this._actionButton = actionButton;\n        const internal = actionButton !== undefined ?\n            {\n                command: this._commands.converter.toInternal(actionButton.command, this._actionButtonDisposables.value),\n                secondaryCommands: actionButton.secondaryCommands?.map(commandGroup => {\n                    return ( commandGroup.map(\n                        command => this._commands.converter.toInternal(command, this._actionButtonDisposables.value)\n                    ));\n                }),\n                description: actionButton.description,\n                enabled: actionButton.enabled\n            } : undefined;\n        this.#proxy.$updateSourceControl(this.handle, { actionButton: internal ?? null });\n    }\n    get statusBarCommands() {\n        return this._statusBarCommands;\n    }\n    set statusBarCommands(statusBarCommands) {\n        if (this._statusBarCommands && statusBarCommands && commandListEquals(this._statusBarCommands, statusBarCommands)) {\n            return;\n        }\n        this._statusBarDisposables.value = ( new DisposableStore());\n        this._statusBarCommands = statusBarCommands;\n        const internal = ( (statusBarCommands || []).map(\n            c => this._commands.converter.toInternal(c, this._statusBarDisposables.value)\n        ));\n        this.#proxy.$updateSourceControl(this.handle, { statusBarCommands: internal });\n    }\n    get selected() {\n        return this._selected;\n    }\n    constructor(_extension, _extHostDocuments, proxy, _commands, _id, _label, _rootUri) {\n        this._extension = _extension;\n        this._commands = _commands;\n        this._id = _id;\n        this._label = _label;\n        this._rootUri = _rootUri;\n        this._groups = ( new Map());\n        this._count = undefined;\n        this._quickDiffProvider = undefined;\n        this._historyProviderDisposable = ( new MutableDisposable());\n        this._commitTemplate = undefined;\n        this._acceptInputDisposables = ( new MutableDisposable());\n        this._acceptInputCommand = undefined;\n        this._actionButtonDisposables = ( new MutableDisposable());\n        this._statusBarDisposables = ( new MutableDisposable());\n        this._statusBarCommands = undefined;\n        this._selected = false;\n        this._onDidChangeSelection = ( new Emitter());\n        this.onDidChangeSelection = this._onDidChangeSelection.event;\n        this.handle = ExtHostSourceControl._handlePool++;\n        this.createdResourceGroups = ( new Map());\n        this.updatedResourceGroups = ( new Set());\n        this.#proxy = proxy;\n        const inputBoxDocumentUri = ( URI.from({\n            scheme: Schemas.vscodeSourceControl,\n            path: `${_id}/scm${this.handle}/input`,\n            query: _rootUri ? `rootUri=${encodeURIComponent(( _rootUri.toString()))}` : undefined\n        }));\n        this._inputBox = ( new ExtHostSCMInputBox(\n            _extension,\n            _extHostDocuments,\n            this.#proxy,\n            this.handle,\n            inputBoxDocumentUri\n        ));\n        this.#proxy.$registerSourceControl(this.handle, _id, _label, _rootUri, inputBoxDocumentUri);\n    }\n    createResourceGroup(id, label, options) {\n        const multiDiffEditorEnableViewChanges = isProposedApiEnabled(this._extension, 'scmMultiDiffEditor') && options?.multiDiffEditorEnableViewChanges === true;\n        const group = ( new ExtHostSourceControlResourceGroup(\n            this.#proxy,\n            this._commands,\n            this.handle,\n            id,\n            label,\n            multiDiffEditorEnableViewChanges,\n            this._extension\n        ));\n        const disposable = Event.once(group.onDidDispose)(() => this.createdResourceGroups.delete(group));\n        this.createdResourceGroups.set(group, disposable);\n        this.eventuallyAddResourceGroups();\n        return group;\n    }\n    eventuallyAddResourceGroups() {\n        const groups = [];\n        const splices = [];\n        for (const [group, disposable] of this.createdResourceGroups) {\n            disposable.dispose();\n            const updateListener = group.onDidUpdateResourceStates(() => {\n                this.updatedResourceGroups.add(group);\n                this.eventuallyUpdateResourceStates();\n            });\n            Event.once(group.onDidDispose)(() => {\n                this.updatedResourceGroups.delete(group);\n                updateListener.dispose();\n                this._groups.delete(group.handle);\n                this.#proxy.$unregisterGroup(this.handle, group.handle);\n            });\n            groups.push([group.handle, group.id, group.label, group.features, group.multiDiffEditorEnableViewChanges]);\n            const snapshot = group._takeResourceStateSnapshot();\n            if (snapshot.length > 0) {\n                splices.push([group.handle, snapshot]);\n            }\n            this._groups.set(group.handle, group);\n        }\n        this.#proxy.$registerGroups(this.handle, groups, splices);\n        this.createdResourceGroups.clear();\n    }\n    eventuallyUpdateResourceStates() {\n        const splices = [];\n        this.updatedResourceGroups.forEach(group => {\n            const snapshot = group._takeResourceStateSnapshot();\n            if (snapshot.length === 0) {\n                return;\n            }\n            splices.push([group.handle, snapshot]);\n        });\n        if (splices.length > 0) {\n            this.#proxy.$spliceResourceStates(this.handle, splices);\n        }\n        this.updatedResourceGroups.clear();\n    }\n    getResourceGroup(handle) {\n        return this._groups.get(handle);\n    }\n    setSelectionState(selected) {\n        this._selected = selected;\n        this._onDidChangeSelection.fire(selected);\n    }\n    dispose() {\n        this._acceptInputDisposables.dispose();\n        this._actionButtonDisposables.dispose();\n        this._statusBarDisposables.dispose();\n        this._groups.forEach(group => group.dispose());\n        this.#proxy.$unregisterSourceControl(this.handle);\n    }\n}\nExtHostSourceControl.__decorator = ( __decorate([\n    debounce(100)\n], ExtHostSourceControl.prototype, \"eventuallyAddResourceGroups\", null));\nExtHostSourceControl.__decorator = ( __decorate([\n    debounce(100)\n], ExtHostSourceControl.prototype, \"eventuallyUpdateResourceStates\", null));\nlet ExtHostSCM = class ExtHostSCM {\n    static { ExtHostSCM_1 = this; }\n    static { this._handlePool = 0; }\n    get onDidChangeActiveProvider() { return this._onDidChangeActiveProvider.event; }\n    constructor(mainContext, _commands, _extHostDocuments, logService) {\n        this._commands = _commands;\n        this._extHostDocuments = _extHostDocuments;\n        this.logService = logService;\n        this._sourceControls = ( new Map());\n        this._sourceControlsByExtension = ( new ExtensionIdentifierMap());\n        this._onDidChangeActiveProvider = ( new Emitter());\n        this._proxy = ( mainContext.getProxy(MainContext.MainThreadSCM));\n        this._telemetry = ( mainContext.getProxy(MainContext.MainThreadTelemetry));\n        _commands.registerArgumentProcessor({\n            processArgument: arg => {\n                if (arg && arg.$mid === 3 ) {\n                    const sourceControl = this._sourceControls.get(arg.sourceControlHandle);\n                    if (!sourceControl) {\n                        return arg;\n                    }\n                    const group = sourceControl.getResourceGroup(arg.groupHandle);\n                    if (!group) {\n                        return arg;\n                    }\n                    return group.getResourceState(arg.handle);\n                }\n                else if (arg && arg.$mid === 4 ) {\n                    const sourceControl = this._sourceControls.get(arg.sourceControlHandle);\n                    if (!sourceControl) {\n                        return arg;\n                    }\n                    return sourceControl.getResourceGroup(arg.groupHandle);\n                }\n                else if (arg && arg.$mid === 5 ) {\n                    const sourceControl = this._sourceControls.get(arg.handle);\n                    if (!sourceControl) {\n                        return arg;\n                    }\n                    return sourceControl;\n                }\n                return arg;\n            }\n        });\n    }\n    createSourceControl(extension, id, label, rootUri) {\n        this.logService.trace('ExtHostSCM#createSourceControl', extension.identifier.value, id, label, rootUri);\n        this._telemetry.$publicLog2('api/scm/createSourceControl', {\n            extensionId: extension.identifier.value,\n        });\n        const handle = ExtHostSCM_1._handlePool++;\n        const sourceControl = ( new ExtHostSourceControl(\n            extension,\n            this._extHostDocuments,\n            this._proxy,\n            this._commands,\n            id,\n            label,\n            rootUri\n        ));\n        this._sourceControls.set(handle, sourceControl);\n        const sourceControls = this._sourceControlsByExtension.get(extension.identifier) || [];\n        sourceControls.push(sourceControl);\n        this._sourceControlsByExtension.set(extension.identifier, sourceControls);\n        return sourceControl;\n    }\n    getLastInputBox(extension) {\n        this.logService.trace('ExtHostSCM#getLastInputBox', extension.identifier.value);\n        const sourceControls = this._sourceControlsByExtension.get(extension.identifier);\n        const sourceControl = sourceControls && sourceControls[sourceControls.length - 1];\n        return sourceControl && sourceControl.inputBox;\n    }\n    $provideOriginalResource(sourceControlHandle, uriComponents, token) {\n        const uri = URI.revive(uriComponents);\n        this.logService.trace('ExtHostSCM#$provideOriginalResource', sourceControlHandle, ( uri.toString()));\n        const sourceControl = this._sourceControls.get(sourceControlHandle);\n        if (!sourceControl || !sourceControl.quickDiffProvider || !sourceControl.quickDiffProvider.provideOriginalResource) {\n            return Promise.resolve(null);\n        }\n        return asPromise(() => sourceControl.quickDiffProvider.provideOriginalResource(uri, token))\n            .then(r => r || null);\n    }\n    $onInputBoxValueChange(sourceControlHandle, value) {\n        this.logService.trace('ExtHostSCM#$onInputBoxValueChange', sourceControlHandle);\n        const sourceControl = this._sourceControls.get(sourceControlHandle);\n        if (!sourceControl) {\n            return Promise.resolve(undefined);\n        }\n        sourceControl.inputBox.$onInputBoxValueChange(value);\n        return Promise.resolve(undefined);\n    }\n    $executeResourceCommand(sourceControlHandle, groupHandle, handle, preserveFocus) {\n        this.logService.trace('ExtHostSCM#$executeResourceCommand', sourceControlHandle, groupHandle, handle);\n        const sourceControl = this._sourceControls.get(sourceControlHandle);\n        if (!sourceControl) {\n            return Promise.resolve(undefined);\n        }\n        const group = sourceControl.getResourceGroup(groupHandle);\n        if (!group) {\n            return Promise.resolve(undefined);\n        }\n        return group.$executeResourceCommand(handle, preserveFocus);\n    }\n    $validateInput(sourceControlHandle, value, cursorPosition) {\n        this.logService.trace('ExtHostSCM#$validateInput', sourceControlHandle);\n        const sourceControl = this._sourceControls.get(sourceControlHandle);\n        if (!sourceControl) {\n            return Promise.resolve(undefined);\n        }\n        if (!sourceControl.inputBox.validateInput) {\n            return Promise.resolve(undefined);\n        }\n        return asPromise(() => sourceControl.inputBox.validateInput(value, cursorPosition)).then(result => {\n            if (!result) {\n                return Promise.resolve(undefined);\n            }\n            const message = MarkdownString.fromStrict(result.message);\n            if (!message) {\n                return Promise.resolve(undefined);\n            }\n            return Promise.resolve([message, result.type]);\n        });\n    }\n    $setSelectedSourceControl(selectedSourceControlHandle) {\n        this.logService.trace('ExtHostSCM#$setSelectedSourceControl', selectedSourceControlHandle);\n        if (selectedSourceControlHandle !== undefined) {\n            this._sourceControls.get(selectedSourceControlHandle)?.setSelectionState(true);\n        }\n        if (this._selectedSourceControlHandle !== undefined) {\n            this._sourceControls.get(this._selectedSourceControlHandle)?.setSelectionState(false);\n        }\n        this._selectedSourceControlHandle = selectedSourceControlHandle;\n        return Promise.resolve(undefined);\n    }\n    async $resolveHistoryItemRefsCommonAncestor(sourceControlHandle, historyItemRefs, token) {\n        const historyProvider = this._sourceControls.get(sourceControlHandle)?.historyProvider;\n        return (await historyProvider?.resolveHistoryItemRefsCommonAncestor(historyItemRefs, token)) ?? undefined;\n    }\n    async $provideHistoryItemRefs(sourceControlHandle, historyItemRefs, token) {\n        const historyProvider = this._sourceControls.get(sourceControlHandle)?.historyProvider;\n        const refs = await historyProvider?.provideHistoryItemRefs(historyItemRefs, token);\n        return refs?.map(ref => ({ ...ref, icon: getHistoryItemIconDto(ref.icon) })) ?? undefined;\n    }\n    async $provideHistoryItems(sourceControlHandle, options, token) {\n        const historyProvider = this._sourceControls.get(sourceControlHandle)?.historyProvider;\n        const historyItems = await historyProvider?.provideHistoryItems(options, token);\n        return historyItems?.map(item => toSCMHistoryItemDto(item)) ?? undefined;\n    }\n    async $provideHistoryItemChanges(sourceControlHandle, historyItemId, historyItemParentId, token) {\n        const historyProvider = this._sourceControls.get(sourceControlHandle)?.historyProvider;\n        return (await historyProvider?.provideHistoryItemChanges(historyItemId, historyItemParentId, token)) ?? undefined;\n    }\n};\nExtHostSCM = ExtHostSCM_1 = ( __decorate([\n    ( __param(3, ILogService))\n], ExtHostSCM));\nexport { ExtHostSCM, ExtHostSCMInputBox };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { toDisposable } from '../../../base/common/lifecycle.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { FileSearchManager } from '../../services/search/common/fileSearchManager.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\nimport { IURITransformerService } from './extHostUriTransformerService.js';\nimport { ILogService } from '../../../platform/log/common/log.service.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { TextSearchManager } from '../../services/search/common/textSearchManager.js';\nimport { revive } from '../../../base/common/marshalling.js';\nimport { OldTextSearchProviderConverter, OldAITextSearchProviderConverter, OldFileSearchProviderConverter } from '../../services/search/common/searchExtConversionTypes.js';\nconst IExtHostSearch = ( createDecorator('IExtHostSearch'));\nlet ExtHostSearch = class ExtHostSearch {\n    constructor(extHostRpc, _uriTransformer, _logService) {\n        this.extHostRpc = extHostRpc;\n        this._uriTransformer = _uriTransformer;\n        this._logService = _logService;\n        this._proxy = ( this.extHostRpc.getProxy(MainContext.MainThreadSearch));\n        this._handlePool = 0;\n        this._textSearchProvider = ( new Map());\n        this._textSearchUsedSchemes = ( new Set());\n        this._aiTextSearchProvider = ( new Map());\n        this._aiTextSearchUsedSchemes = ( new Set());\n        this._fileSearchProvider = ( new Map());\n        this._fileSearchUsedSchemes = ( new Set());\n        this._fileSearchManager = ( new FileSearchManager());\n    }\n    _transformScheme(scheme) {\n        return this._uriTransformer.transformOutgoingScheme(scheme);\n    }\n    registerTextSearchProviderOld(scheme, provider) {\n        if (( this._textSearchUsedSchemes.has(scheme))) {\n            throw ( new Error(`a text search provider for the scheme '${scheme}' is already registered`));\n        }\n        this._textSearchUsedSchemes.add(scheme);\n        const handle = this._handlePool++;\n        this._textSearchProvider.set(handle, ( new OldTextSearchProviderConverter(provider)));\n        this._proxy.$registerTextSearchProvider(handle, this._transformScheme(scheme));\n        return toDisposable(() => {\n            this._textSearchUsedSchemes.delete(scheme);\n            this._textSearchProvider.delete(handle);\n            this._proxy.$unregisterProvider(handle);\n        });\n    }\n    registerTextSearchProvider(scheme, provider) {\n        if (( this._textSearchUsedSchemes.has(scheme))) {\n            throw ( new Error(`a text search provider for the scheme '${scheme}' is already registered`));\n        }\n        this._textSearchUsedSchemes.add(scheme);\n        const handle = this._handlePool++;\n        this._textSearchProvider.set(handle, provider);\n        this._proxy.$registerTextSearchProvider(handle, this._transformScheme(scheme));\n        return toDisposable(() => {\n            this._textSearchUsedSchemes.delete(scheme);\n            this._textSearchProvider.delete(handle);\n            this._proxy.$unregisterProvider(handle);\n        });\n    }\n    registerAITextSearchProviderOld(scheme, provider) {\n        if (( this._aiTextSearchUsedSchemes.has(scheme))) {\n            throw ( new Error(\n                `an AI text search provider for the scheme '${scheme}'is already registered`\n            ));\n        }\n        this._aiTextSearchUsedSchemes.add(scheme);\n        const handle = this._handlePool++;\n        this._aiTextSearchProvider.set(handle, ( new OldAITextSearchProviderConverter(provider)));\n        this._proxy.$registerAITextSearchProvider(handle, this._transformScheme(scheme));\n        return toDisposable(() => {\n            this._aiTextSearchUsedSchemes.delete(scheme);\n            this._aiTextSearchProvider.delete(handle);\n            this._proxy.$unregisterProvider(handle);\n        });\n    }\n    registerAITextSearchProvider(scheme, provider) {\n        if (( this._aiTextSearchUsedSchemes.has(scheme))) {\n            throw ( new Error(\n                `an AI text search provider for the scheme '${scheme}'is already registered`\n            ));\n        }\n        this._aiTextSearchUsedSchemes.add(scheme);\n        const handle = this._handlePool++;\n        this._aiTextSearchProvider.set(handle, provider);\n        this._proxy.$registerAITextSearchProvider(handle, this._transformScheme(scheme));\n        return toDisposable(() => {\n            this._aiTextSearchUsedSchemes.delete(scheme);\n            this._aiTextSearchProvider.delete(handle);\n            this._proxy.$unregisterProvider(handle);\n        });\n    }\n    registerFileSearchProviderOld(scheme, provider) {\n        if (( this._fileSearchUsedSchemes.has(scheme))) {\n            throw ( new Error(`a file search provider for the scheme '${scheme}' is already registered`));\n        }\n        this._fileSearchUsedSchemes.add(scheme);\n        const handle = this._handlePool++;\n        this._fileSearchProvider.set(handle, ( new OldFileSearchProviderConverter(provider)));\n        this._proxy.$registerFileSearchProvider(handle, this._transformScheme(scheme));\n        return toDisposable(() => {\n            this._fileSearchUsedSchemes.delete(scheme);\n            this._fileSearchProvider.delete(handle);\n            this._proxy.$unregisterProvider(handle);\n        });\n    }\n    registerFileSearchProvider(scheme, provider) {\n        if (( this._fileSearchUsedSchemes.has(scheme))) {\n            throw ( new Error(`a file search provider for the scheme '${scheme}' is already registered`));\n        }\n        this._fileSearchUsedSchemes.add(scheme);\n        const handle = this._handlePool++;\n        this._fileSearchProvider.set(handle, provider);\n        this._proxy.$registerFileSearchProvider(handle, this._transformScheme(scheme));\n        return toDisposable(() => {\n            this._fileSearchUsedSchemes.delete(scheme);\n            this._fileSearchProvider.delete(handle);\n            this._proxy.$unregisterProvider(handle);\n        });\n    }\n    $provideFileSearchResults(handle, session, rawQuery, token) {\n        const query = reviveQuery(rawQuery);\n        const provider = this._fileSearchProvider.get(handle);\n        if (provider) {\n            return this._fileSearchManager.fileSearch(query, provider, batch => {\n                this._proxy.$handleFileMatch(handle, session, ( batch.map(p => p.resource)));\n            }, token);\n        }\n        else {\n            throw ( new Error('unknown provider: ' + handle));\n        }\n    }\n    async doInternalFileSearchWithCustomCallback(query, token, handleFileMatch) {\n        return { messages: [] };\n    }\n    $clearCache(cacheKey) {\n        this._fileSearchManager.clearCache(cacheKey);\n        return Promise.resolve(undefined);\n    }\n    $provideTextSearchResults(handle, session, rawQuery, token) {\n        const provider = this._textSearchProvider.get(handle);\n        if (!provider || !provider.provideTextSearchResults) {\n            throw ( new Error(`Unknown Text Search Provider ${handle}`));\n        }\n        const query = reviveQuery(rawQuery);\n        const engine = this.createTextSearchManager(query, provider);\n        return engine.search(progress => this._proxy.$handleTextMatch(handle, session, progress), token);\n    }\n    $provideAITextSearchResults(handle, session, rawQuery, token) {\n        const provider = this._aiTextSearchProvider.get(handle);\n        if (!provider || !provider.provideAITextSearchResults) {\n            throw ( new Error(`Unknown AI Text Search Provider ${handle}`));\n        }\n        const query = reviveQuery(rawQuery);\n        const engine = this.createAITextSearchManager(query, provider);\n        return engine.search(progress => this._proxy.$handleTextMatch(handle, session, progress), token);\n    }\n    $enableExtensionHostSearch() { }\n    async $getAIName(handle) {\n        const provider = this._aiTextSearchProvider.get(handle);\n        if (!provider || !provider.provideAITextSearchResults) {\n            return undefined;\n        }\n        return provider.name ?? 'AI';\n    }\n    createTextSearchManager(query, provider) {\n        return ( new TextSearchManager({ query, provider }, {\n            readdir: resource => Promise.resolve([]),\n            toCanonicalName: encoding => encoding\n        }, 'textSearchProvider'));\n    }\n    createAITextSearchManager(query, provider) {\n        return ( new TextSearchManager({ query, provider }, {\n            readdir: resource => Promise.resolve([]),\n            toCanonicalName: encoding => encoding\n        }, 'aiTextSearchProvider'));\n    }\n};\nExtHostSearch = ( __decorate([\n    ( __param(0, IExtHostRpcService)),\n    ( __param(1, IURITransformerService)),\n    ( __param(2, ILogService))\n], ExtHostSearch));\nfunction reviveQuery(rawQuery) {\n    return {\n        ...rawQuery,\n        ...{\n            folderQueries: rawQuery.folderQueries && ( rawQuery.folderQueries.map(reviveFolderQuery)),\n            extraFileResources: rawQuery.extraFileResources && ( rawQuery.extraFileResources.map(components => URI.revive(components)))\n        }\n    };\n}\nfunction reviveFolderQuery(rawFolderQuery) {\n    return revive(rawFolderQuery);\n}\nexport { ExtHostSearch, IExtHostSearch, reviveQuery };\n","import { MainContext } from './extHost.protocol.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nclass ExtHostSecretState {\n    constructor(mainContext) {\n        this._onDidChangePassword = ( new Emitter());\n        this.onDidChangePassword = this._onDidChangePassword.event;\n        this._proxy = ( mainContext.getProxy(MainContext.MainThreadSecretState));\n    }\n    async $onDidChangePassword(e) {\n        this._onDidChangePassword.fire(e);\n    }\n    get(extensionId, key) {\n        return this._proxy.$getPassword(extensionId, key);\n    }\n    store(extensionId, key, value) {\n        return this._proxy.$setPassword(extensionId, key, value);\n    }\n    delete(extensionId, key) {\n        return this._proxy.$deletePassword(extensionId, key);\n    }\n}\nconst IExtHostSecretState = ( createDecorator('IExtHostSecretState'));\nexport { ExtHostSecretState, IExtHostSecretState };\n","import { ExtensionIdentifier } from '../../../platform/extensions/common/extensions.js';\nimport { Event } from '../../../base/common/event.js';\nimport { DisposableStore } from '../../../base/common/lifecycle.js';\nclass ExtensionSecrets {\n    #secretState;\n    constructor(extensionDescription, secretState) {\n        this.disposables = ( new DisposableStore());\n        this._id = ExtensionIdentifier.toKey(extensionDescription.identifier);\n        this.#secretState = secretState;\n        this.onDidChange = ( Event.map(\n            Event.filter(this.#secretState.onDidChangePassword, e => e.extensionId === this._id),\n            e => ({ key: e.key }),\n            this.disposables\n        ));\n    }\n    dispose() {\n        this.disposables.dispose();\n    }\n    get(key) {\n        return this.#secretState.get(this._id, key);\n    }\n    store(key, value) {\n        return this.#secretState.store(this._id, key, value);\n    }\n    delete(key) {\n        return this.#secretState.delete(this._id, key);\n    }\n}\nexport { ExtensionSecrets };\n","import { MainContext } from './extHost.protocol.js';\nimport { Range, DocumentSelector } from './extHostTypeConverters.js';\nimport { URI } from '../../../base/common/uri.js';\nclass ExtHostShare {\n    static { this.handlePool = 0; }\n    constructor(mainContext, uriTransformer) {\n        this.uriTransformer = uriTransformer;\n        this.providers = ( new Map());\n        this.proxy = ( mainContext.getProxy(MainContext.MainThreadShare));\n    }\n    async $provideShare(handle, shareableItem, token) {\n        const provider = this.providers.get(handle);\n        const result = await provider?.provideShare({ selection: Range.to(shareableItem.selection), resourceUri: URI.revive(shareableItem.resourceUri) }, token);\n        return result ?? undefined;\n    }\n    registerShareProvider(selector, provider) {\n        const handle = ExtHostShare.handlePool++;\n        this.providers.set(handle, provider);\n        this.proxy.$registerShareProvider(handle, DocumentSelector.from(selector, this.uriTransformer), provider.id, provider.label, provider.priority);\n        return {\n            dispose: () => {\n                this.proxy.$unregisterShareProvider(handle);\n                this.providers.delete(handle);\n            }\n        };\n    }\n}\nexport { ExtHostShare };\n","import { CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { toDisposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport { MainContext } from './extHost.protocol.js';\nclass ExtHostSpeech {\n    static { this.ID_POOL = 1; }\n    constructor(mainContext) {\n        this.providers = ( new Map());\n        this.sessions = ( new Map());\n        this.synthesizers = ( new Map());\n        this.proxy = ( mainContext.getProxy(MainContext.MainThreadSpeech));\n    }\n    async $createSpeechToTextSession(handle, session, language) {\n        const provider = this.providers.get(handle);\n        if (!provider) {\n            return;\n        }\n        const disposables = ( new DisposableStore());\n        const cts = ( new CancellationTokenSource());\n        this.sessions.set(session, cts);\n        const speechToTextSession = await provider.provideSpeechToTextSession(cts.token, language ? { language } : undefined);\n        if (!speechToTextSession) {\n            return;\n        }\n        disposables.add(speechToTextSession.onDidChange(e => {\n            if (cts.token.isCancellationRequested) {\n                return;\n            }\n            this.proxy.$emitSpeechToTextEvent(session, e);\n        }));\n        disposables.add(cts.token.onCancellationRequested(() => disposables.dispose()));\n    }\n    async $cancelSpeechToTextSession(session) {\n        this.sessions.get(session)?.dispose(true);\n        this.sessions.delete(session);\n    }\n    async $createTextToSpeechSession(handle, session, language) {\n        const provider = this.providers.get(handle);\n        if (!provider) {\n            return;\n        }\n        const disposables = ( new DisposableStore());\n        const cts = ( new CancellationTokenSource());\n        this.sessions.set(session, cts);\n        const textToSpeech = await provider.provideTextToSpeechSession(cts.token, language ? { language } : undefined);\n        if (!textToSpeech) {\n            return;\n        }\n        this.synthesizers.set(session, textToSpeech);\n        disposables.add(textToSpeech.onDidChange(e => {\n            if (cts.token.isCancellationRequested) {\n                return;\n            }\n            this.proxy.$emitTextToSpeechEvent(session, e);\n        }));\n        disposables.add(cts.token.onCancellationRequested(() => disposables.dispose()));\n    }\n    async $synthesizeSpeech(session, text) {\n        this.synthesizers.get(session)?.synthesize(text);\n    }\n    async $cancelTextToSpeechSession(session) {\n        this.sessions.get(session)?.dispose(true);\n        this.sessions.delete(session);\n        this.synthesizers.delete(session);\n    }\n    async $createKeywordRecognitionSession(handle, session) {\n        const provider = this.providers.get(handle);\n        if (!provider) {\n            return;\n        }\n        const disposables = ( new DisposableStore());\n        const cts = ( new CancellationTokenSource());\n        this.sessions.set(session, cts);\n        const keywordRecognitionSession = await provider.provideKeywordRecognitionSession(cts.token);\n        if (!keywordRecognitionSession) {\n            return;\n        }\n        disposables.add(keywordRecognitionSession.onDidChange(e => {\n            if (cts.token.isCancellationRequested) {\n                return;\n            }\n            this.proxy.$emitKeywordRecognitionEvent(session, e);\n        }));\n        disposables.add(cts.token.onCancellationRequested(() => disposables.dispose()));\n    }\n    async $cancelKeywordRecognitionSession(session) {\n        this.sessions.get(session)?.dispose(true);\n        this.sessions.delete(session);\n    }\n    registerProvider(extension, identifier, provider) {\n        const handle = ExtHostSpeech.ID_POOL++;\n        this.providers.set(handle, provider);\n        this.proxy.$registerProvider(handle, identifier, { extension, displayName: extension.value });\n        return toDisposable(() => {\n            this.proxy.$unregisterProvider(handle);\n            this.providers.delete(handle);\n        });\n    }\n}\nexport { ExtHostSpeech };\n","import { Disposable, ThemeColor, asStatusBarItemIdentifier, StatusBarAlignment } from './extHostTypes.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { localize } from '../../../nls.js';\nimport { DisposableStore } from '../../../base/common/lifecycle.js';\nimport { MarkdownString } from './extHostTypeConverters.js';\nimport { isNumber } from '../../../base/common/types.js';\nclass ExtHostStatusBarEntry {\n    static { this.ID_GEN = 0; }\n    static { this.ALLOWED_BACKGROUND_COLORS = ( (new Map([\n        ['statusBarItem.errorBackground', ( (new ThemeColor('statusBarItem.errorForeground')))],\n        ['statusBarItem.warningBackground', ( (new ThemeColor('statusBarItem.warningForeground')))]\n    ]))); }\n    #proxy;\n    #commands;\n    constructor(proxy, commands, staticItems, extension, id, alignment = StatusBarAlignment.Left, priority) {\n        this._disposed = false;\n        this._text = '';\n        this._staleCommandRegistrations = ( (new DisposableStore()));\n        this.#proxy = proxy;\n        this.#commands = commands;\n        if (id && extension) {\n            this._entryId = asStatusBarItemIdentifier(extension.identifier, id);\n            const item = staticItems.get(this._entryId);\n            if (item) {\n                alignment = item.alignLeft ? StatusBarAlignment.Left : StatusBarAlignment.Right;\n                priority = item.priority;\n                this._visible = true;\n                this.name = item.name;\n                this.text = item.text;\n                this.tooltip = item.tooltip;\n                this.command = item.command;\n                this.accessibilityInformation = item.accessibilityInformation;\n            }\n        }\n        else {\n            this._entryId = String(ExtHostStatusBarEntry.ID_GEN++);\n        }\n        this._extension = extension;\n        this._id = id;\n        this._alignment = alignment;\n        this._priority = this.validatePriority(priority);\n    }\n    validatePriority(priority) {\n        if (!isNumber(priority)) {\n            return undefined;\n        }\n        if (priority === Number.POSITIVE_INFINITY) {\n            return Number.MAX_VALUE;\n        }\n        if (priority === Number.NEGATIVE_INFINITY) {\n            return -Number.MAX_VALUE;\n        }\n        return priority;\n    }\n    get id() {\n        return this._id ?? this._extension.identifier.value;\n    }\n    get alignment() {\n        return this._alignment;\n    }\n    get priority() {\n        return this._priority;\n    }\n    get text() {\n        return this._text;\n    }\n    get name() {\n        return this._name;\n    }\n    get tooltip() {\n        return this._tooltip;\n    }\n    get color() {\n        return this._color;\n    }\n    get backgroundColor() {\n        return this._backgroundColor;\n    }\n    get command() {\n        return this._command?.fromApi;\n    }\n    get accessibilityInformation() {\n        return this._accessibilityInformation;\n    }\n    set text(text) {\n        this._text = text;\n        this.update();\n    }\n    set name(name) {\n        this._name = name;\n        this.update();\n    }\n    set tooltip(tooltip) {\n        this._tooltip = tooltip;\n        this.update();\n    }\n    set color(color) {\n        this._color = color;\n        this.update();\n    }\n    set backgroundColor(color) {\n        if (color && !( (ExtHostStatusBarEntry.ALLOWED_BACKGROUND_COLORS.has(color.id)))) {\n            color = undefined;\n        }\n        this._backgroundColor = color;\n        this.update();\n    }\n    set command(command) {\n        if (this._command?.fromApi === command) {\n            return;\n        }\n        if (this._latestCommandRegistration) {\n            this._staleCommandRegistrations.add(this._latestCommandRegistration);\n        }\n        this._latestCommandRegistration = ( (new DisposableStore()));\n        if (typeof command === 'string') {\n            this._command = {\n                fromApi: command,\n                internal: this.#commands.toInternal({ title: '', command }, this._latestCommandRegistration),\n            };\n        }\n        else if (command) {\n            this._command = {\n                fromApi: command,\n                internal: this.#commands.toInternal(command, this._latestCommandRegistration),\n            };\n        }\n        else {\n            this._command = undefined;\n        }\n        this.update();\n    }\n    set accessibilityInformation(accessibilityInformation) {\n        this._accessibilityInformation = accessibilityInformation;\n        this.update();\n    }\n    show() {\n        this._visible = true;\n        this.update();\n    }\n    hide() {\n        clearTimeout(this._timeoutHandle);\n        this._visible = false;\n        this.#proxy.$disposeEntry(this._entryId);\n    }\n    update() {\n        if (this._disposed || !this._visible) {\n            return;\n        }\n        clearTimeout(this._timeoutHandle);\n        this._timeoutHandle = setTimeout(() => {\n            this._timeoutHandle = undefined;\n            let id;\n            if (this._extension) {\n                if (this._id) {\n                    id = `${this._extension.identifier.value}.${this._id}`;\n                }\n                else {\n                    id = this._extension.identifier.value;\n                }\n            }\n            else {\n                id = this._id;\n            }\n            let name;\n            if (this._name) {\n                name = this._name;\n            }\n            else {\n                name = ( localize(\n                    4802,\n                    \"{0} (Extension)\",\n                    this._extension.displayName || this._extension.name\n                ));\n            }\n            let color = this._color;\n            if (this._backgroundColor) {\n                color = ExtHostStatusBarEntry.ALLOWED_BACKGROUND_COLORS.get(this._backgroundColor.id);\n            }\n            const tooltip = MarkdownString.fromStrict(this._tooltip);\n            this.#proxy.$setEntry(this._entryId, id, this._extension?.identifier.value, name, this._text, tooltip, this._command?.internal, color, this._backgroundColor, this._alignment === StatusBarAlignment.Left, this._priority, this._accessibilityInformation);\n            this._staleCommandRegistrations.clear();\n        }, 0);\n    }\n    dispose() {\n        this.hide();\n        this._disposed = true;\n    }\n}\nclass StatusBarMessage {\n    constructor(statusBar) {\n        this._messages = [];\n        this._item = statusBar.createStatusBarEntry(undefined, 'status.extensionMessage', StatusBarAlignment.Left, Number.MIN_VALUE);\n        this._item.name = ( localize(4803, \"Extension Status\"));\n    }\n    dispose() {\n        this._messages.length = 0;\n        this._item.dispose();\n    }\n    setMessage(message) {\n        const data = { message };\n        this._messages.unshift(data);\n        this._update();\n        return (\n             (new Disposable(() => {\n                const idx = this._messages.indexOf(data);\n                if (idx >= 0) {\n                    this._messages.splice(idx, 1);\n                    this._update();\n                }\n            }))\n        );\n    }\n    _update() {\n        if (this._messages.length > 0) {\n            this._item.text = this._messages[0].message;\n            this._item.show();\n        }\n        else {\n            this._item.hide();\n        }\n    }\n}\nclass ExtHostStatusBar {\n    constructor(mainContext, commands) {\n        this._existingItems = ( (new Map()));\n        this._proxy = ( (mainContext.getProxy(MainContext.MainThreadStatusBar)));\n        this._commands = commands;\n        this._statusMessage = ( (new StatusBarMessage(this)));\n    }\n    $acceptStaticEntries(added) {\n        for (const item of added) {\n            this._existingItems.set(item.entryId, item);\n        }\n    }\n    createStatusBarEntry(extension, id, alignment, priority) {\n        return (\n             (new ExtHostStatusBarEntry(\n                this._proxy,\n                this._commands,\n                this._existingItems,\n                extension,\n                id,\n                alignment,\n                priority\n            ))\n        );\n    }\n    setStatusBarMessage(text, timeoutOrThenable) {\n        const d = this._statusMessage.setMessage(text);\n        let handle;\n        if (typeof timeoutOrThenable === 'number') {\n            handle = setTimeout(() => d.dispose(), timeoutOrThenable);\n        }\n        else if (typeof timeoutOrThenable !== 'undefined') {\n            timeoutOrThenable.then(() => d.dispose(), () => d.dispose());\n        }\n        return (\n             (new Disposable(() => {\n                d.dispose();\n                clearTimeout(handle);\n            }))\n        );\n    }\n}\nexport { ExtHostStatusBar, ExtHostStatusBarEntry };\n","import { MainContext } from './extHost.protocol.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nclass ExtHostStorage {\n    constructor(mainContext, _logService) {\n        this._logService = _logService;\n        this._onDidChangeStorage = ( new Emitter());\n        this.onDidChangeStorage = this._onDidChangeStorage.event;\n        this._proxy = ( mainContext.getProxy(MainContext.MainThreadStorage));\n    }\n    registerExtensionStorageKeysToSync(extension, keys) {\n        this._proxy.$registerExtensionStorageKeysToSync(extension, keys);\n    }\n    async initializeExtensionStorage(shared, key, defaultValue) {\n        const value = await this._proxy.$initializeExtensionStorage(shared, key);\n        let parsedValue;\n        if (value) {\n            parsedValue = this.safeParseValue(shared, key, value);\n        }\n        return parsedValue || defaultValue;\n    }\n    setValue(shared, key, value) {\n        return this._proxy.$setValue(shared, key, value);\n    }\n    $acceptValue(shared, key, value) {\n        const parsedValue = this.safeParseValue(shared, key, value);\n        if (parsedValue) {\n            this._onDidChangeStorage.fire({ shared, key, value: parsedValue });\n        }\n    }\n    safeParseValue(shared, key, value) {\n        try {\n            return JSON.parse(value);\n        }\n        catch (error) {\n            this._logService.error(`[extHostStorage] unexpected error parsing storage contents (extensionId: ${key}, global: ${shared}): ${error}`);\n        }\n        return undefined;\n    }\n}\nconst IExtHostStorage = ( createDecorator('IExtHostStorage'));\nexport { ExtHostStorage, IExtHostStorage };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { IExtHostInitDataService } from './extHostInitDataService.js';\nimport { ILogService } from '../../../platform/log/common/log.service.js';\nimport { IExtHostConsumerFileSystem } from './extHostFileSystemConsumer.js';\nimport { URI } from '../../../base/common/uri.js';\nconst IExtensionStoragePaths = ( createDecorator('IExtensionStoragePaths'));\nlet ExtensionStoragePaths = class ExtensionStoragePaths {\n    constructor(initData, _logService, _extHostFileSystem) {\n        this._logService = _logService;\n        this._extHostFileSystem = _extHostFileSystem;\n        this._workspace = initData.workspace ?? undefined;\n        this._environment = initData.environment;\n        this.whenReady = this._getOrCreateWorkspaceStoragePath().then(value => this._value = value);\n    }\n    async _getWorkspaceStorageURI(storageName) {\n        return URI.joinPath(this._environment.workspaceStorageHome, storageName);\n    }\n    async _getOrCreateWorkspaceStoragePath() {\n        if (!this._workspace) {\n            return Promise.resolve(undefined);\n        }\n        const storageName = this._workspace.id;\n        const storageUri = await this._getWorkspaceStorageURI(storageName);\n        try {\n            await this._extHostFileSystem.value.stat(storageUri);\n            this._logService.trace('[ExtHostStorage] storage dir already exists', storageUri);\n            return storageUri;\n        }\n        catch {\n        }\n        try {\n            this._logService.trace('[ExtHostStorage] creating dir and metadata-file', storageUri);\n            await this._extHostFileSystem.value.createDirectory(storageUri);\n            await this._extHostFileSystem.value.writeFile(URI.joinPath(storageUri, 'meta.json'), ( new TextEncoder()).encode(JSON.stringify({\n                id: this._workspace.id,\n                configuration: URI.revive(this._workspace.configuration)?.toString(),\n                name: this._workspace.name\n            }, undefined, 2)));\n            return storageUri;\n        }\n        catch (e) {\n            this._logService.error('[ExtHostStorage]', e);\n            return undefined;\n        }\n    }\n    workspaceValue(extension) {\n        if (this._value) {\n            return URI.joinPath(this._value, extension.identifier.value);\n        }\n        return undefined;\n    }\n    globalValue(extension) {\n        return URI.joinPath(this._environment.globalStorageHome, extension.identifier.value.toLowerCase());\n    }\n    onWillDeactivateAll() {\n    }\n};\nExtensionStoragePaths = ( __decorate([\n    ( __param(0, IExtHostInitDataService)),\n    ( __param(1, ILogService)),\n    ( __param(2, IExtHostConsumerFileSystem))\n], ExtensionStoragePaths));\nexport { ExtensionStoragePaths, IExtensionStoragePaths };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { asPromise } from '../../../base/common/async.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { Disposable, ProcessExecution, ShellExecution, CustomExecution, Task, TaskGroup, TaskScope } from './extHostTypes.js';\nimport { IExtHostWorkspace } from './extHostWorkspace.js';\nimport { IExtHostDocumentsAndEditors } from './extHostDocumentsAndEditors.js';\nimport { IExtHostConfiguration } from './extHostConfiguration.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { IExtHostTerminalService } from './extHostTerminalService.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\nimport { IExtHostInitDataService } from './extHostInitDataService.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { PlatformToString } from '../../../base/common/platform.js';\nimport { ILogService } from '../../../platform/log/common/log.service.js';\nimport { IExtHostApiDeprecationService } from './extHostApiDeprecationService.js';\nimport '../../contrib/tasks/common/tasks.js';\nimport { NotSupportedError, ErrorNoTelemetry } from '../../../base/common/errors.js';\nimport { asArray } from '../../../base/common/arrays.js';\nvar TaskDefinitionDTO;\n( (function(TaskDefinitionDTO) {\n    function from(value) {\n        if (value === undefined || value === null) {\n            return undefined;\n        }\n        return value;\n    }\n    TaskDefinitionDTO.from = from;\n    function to(value) {\n        if (value === undefined || value === null) {\n            return undefined;\n        }\n        return value;\n    }\n    TaskDefinitionDTO.to = to;\n})(TaskDefinitionDTO || (TaskDefinitionDTO = {})));\nvar TaskPresentationOptionsDTO;\n( (function(TaskPresentationOptionsDTO) {\n    function from(value) {\n        if (value === undefined || value === null) {\n            return undefined;\n        }\n        return value;\n    }\n    TaskPresentationOptionsDTO.from = from;\n    function to(value) {\n        if (value === undefined || value === null) {\n            return undefined;\n        }\n        return value;\n    }\n    TaskPresentationOptionsDTO.to = to;\n})(TaskPresentationOptionsDTO || (TaskPresentationOptionsDTO = {})));\nvar ProcessExecutionOptionsDTO;\n( (function(ProcessExecutionOptionsDTO) {\n    function from(value) {\n        if (value === undefined || value === null) {\n            return undefined;\n        }\n        return value;\n    }\n    ProcessExecutionOptionsDTO.from = from;\n    function to(value) {\n        if (value === undefined || value === null) {\n            return undefined;\n        }\n        return value;\n    }\n    ProcessExecutionOptionsDTO.to = to;\n})(ProcessExecutionOptionsDTO || (ProcessExecutionOptionsDTO = {})));\nvar ProcessExecutionDTO;\n( (function(ProcessExecutionDTO) {\n    function is(value) {\n        if (value) {\n            const candidate = value;\n            return candidate && !!candidate.process;\n        }\n        else {\n            return false;\n        }\n    }\n    ProcessExecutionDTO.is = is;\n    function from(value) {\n        if (value === undefined || value === null) {\n            return undefined;\n        }\n        const result = {\n            process: value.process,\n            args: value.args\n        };\n        if (value.options) {\n            result.options = ProcessExecutionOptionsDTO.from(value.options);\n        }\n        return result;\n    }\n    ProcessExecutionDTO.from = from;\n    function to(value) {\n        if (value === undefined || value === null) {\n            return undefined;\n        }\n        return new ProcessExecution(value.process, value.args, value.options);\n    }\n    ProcessExecutionDTO.to = to;\n})(ProcessExecutionDTO || (ProcessExecutionDTO = {})));\nvar ShellExecutionOptionsDTO;\n( (function(ShellExecutionOptionsDTO) {\n    function from(value) {\n        if (value === undefined || value === null) {\n            return undefined;\n        }\n        return value;\n    }\n    ShellExecutionOptionsDTO.from = from;\n    function to(value) {\n        if (value === undefined || value === null) {\n            return undefined;\n        }\n        return value;\n    }\n    ShellExecutionOptionsDTO.to = to;\n})(ShellExecutionOptionsDTO || (ShellExecutionOptionsDTO = {})));\nvar ShellExecutionDTO;\n( (function(ShellExecutionDTO) {\n    function is(value) {\n        if (value) {\n            const candidate = value;\n            return candidate && (!!candidate.commandLine || !!candidate.command);\n        }\n        else {\n            return false;\n        }\n    }\n    ShellExecutionDTO.is = is;\n    function from(value) {\n        if (value === undefined || value === null) {\n            return undefined;\n        }\n        const result = {};\n        if (value.commandLine !== undefined) {\n            result.commandLine = value.commandLine;\n        }\n        else {\n            result.command = value.command;\n            result.args = value.args;\n        }\n        if (value.options) {\n            result.options = ShellExecutionOptionsDTO.from(value.options);\n        }\n        return result;\n    }\n    ShellExecutionDTO.from = from;\n    function to(value) {\n        if (value === undefined || value === null || (value.command === undefined && value.commandLine === undefined)) {\n            return undefined;\n        }\n        if (value.commandLine) {\n            return new ShellExecution(value.commandLine, value.options);\n        }\n        else {\n            return new ShellExecution(value.command, value.args ? value.args : [], value.options);\n        }\n    }\n    ShellExecutionDTO.to = to;\n})(ShellExecutionDTO || (ShellExecutionDTO = {})));\nvar CustomExecutionDTO;\n( (function(CustomExecutionDTO) {\n    function is(value) {\n        if (value) {\n            const candidate = value;\n            return candidate && candidate.customExecution === 'customExecution';\n        }\n        else {\n            return false;\n        }\n    }\n    CustomExecutionDTO.is = is;\n    function from(value) {\n        return {\n            customExecution: 'customExecution'\n        };\n    }\n    CustomExecutionDTO.from = from;\n    function to(taskId, providedCustomExeutions) {\n        return providedCustomExeutions.get(taskId);\n    }\n    CustomExecutionDTO.to = to;\n})(CustomExecutionDTO || (CustomExecutionDTO = {})));\nvar TaskGroupDTO;\n( (function(TaskGroupDTO) {\n    function from(value) {\n        if (value === undefined || value === null) {\n            return undefined;\n        }\n        return { _id: value.id, isDefault: value.isDefault };\n    }\n    TaskGroupDTO.from = from;\n})(TaskGroupDTO || (TaskGroupDTO = {})));\nvar TaskDTO;\n( (function(TaskDTO) {\n    function fromMany(tasks, extension) {\n        if (tasks === undefined || tasks === null) {\n            return [];\n        }\n        const result = [];\n        for (const task of tasks) {\n            const converted = from(task, extension);\n            if (converted) {\n                result.push(converted);\n            }\n        }\n        return result;\n    }\n    TaskDTO.fromMany = fromMany;\n    function from(value, extension) {\n        if (value === undefined || value === null) {\n            return undefined;\n        }\n        let execution;\n        if (value.execution instanceof ProcessExecution) {\n            execution = ProcessExecutionDTO.from(value.execution);\n        }\n        else if (value.execution instanceof ShellExecution) {\n            execution = ShellExecutionDTO.from(value.execution);\n        }\n        else if (value.execution && value.execution instanceof CustomExecution) {\n            execution = CustomExecutionDTO.from(value.execution);\n        }\n        const definition = TaskDefinitionDTO.from(value.definition);\n        let scope;\n        if (value.scope) {\n            if (typeof value.scope === 'number') {\n                scope = value.scope;\n            }\n            else {\n                scope = value.scope.uri;\n            }\n        }\n        else {\n            scope = TaskScope.Workspace;\n        }\n        if (!definition || !scope) {\n            return undefined;\n        }\n        const result = {\n            _id: value._id,\n            definition,\n            name: value.name,\n            source: {\n                extensionId: extension.identifier.value,\n                label: value.source,\n                scope: scope\n            },\n            execution: execution,\n            isBackground: value.isBackground,\n            group: TaskGroupDTO.from(value.group),\n            presentationOptions: TaskPresentationOptionsDTO.from(value.presentationOptions),\n            problemMatchers: asArray(value.problemMatchers),\n            hasDefinedMatchers: value.hasDefinedMatchers,\n            runOptions: value.runOptions ? value.runOptions : { reevaluateOnRerun: true },\n            detail: value.detail\n        };\n        return result;\n    }\n    TaskDTO.from = from;\n    async function to(value, workspace, providedCustomExeutions) {\n        if (value === undefined || value === null) {\n            return undefined;\n        }\n        let execution;\n        if (ProcessExecutionDTO.is(value.execution)) {\n            execution = ProcessExecutionDTO.to(value.execution);\n        }\n        else if (ShellExecutionDTO.is(value.execution)) {\n            execution = ShellExecutionDTO.to(value.execution);\n        }\n        else if (CustomExecutionDTO.is(value.execution)) {\n            execution = CustomExecutionDTO.to(value._id, providedCustomExeutions);\n        }\n        const definition = TaskDefinitionDTO.to(value.definition);\n        let scope;\n        if (value.source) {\n            if (value.source.scope !== undefined) {\n                if (typeof value.source.scope === 'number') {\n                    scope = value.source.scope;\n                }\n                else {\n                    scope = await workspace.resolveWorkspaceFolder(URI.revive(value.source.scope));\n                }\n            }\n            else {\n                scope = TaskScope.Workspace;\n            }\n        }\n        if (!definition || !scope) {\n            return undefined;\n        }\n        const result = new Task(definition, scope, value.name, value.source.label, execution, value.problemMatchers);\n        if (value.isBackground !== undefined) {\n            result.isBackground = value.isBackground;\n        }\n        if (value.group !== undefined) {\n            result.group = TaskGroup.from(value.group._id);\n            if (result.group && value.group.isDefault) {\n                result.group = new TaskGroup(result.group.id, result.group.label);\n                if (value.group.isDefault === true) {\n                    result.group.isDefault = value.group.isDefault;\n                }\n            }\n        }\n        if (value.presentationOptions) {\n            result.presentationOptions = TaskPresentationOptionsDTO.to(value.presentationOptions);\n        }\n        if (value._id) {\n            result._id = value._id;\n        }\n        if (value.detail) {\n            result.detail = value.detail;\n        }\n        return result;\n    }\n    TaskDTO.to = to;\n})(TaskDTO || (TaskDTO = {})));\nvar TaskFilterDTO;\n( (function(TaskFilterDTO) {\n    function from(value) {\n        return value;\n    }\n    TaskFilterDTO.from = from;\n    function to(value) {\n        if (!value) {\n            return undefined;\n        }\n        return Object.assign(Object.create(null), value);\n    }\n    TaskFilterDTO.to = to;\n})(TaskFilterDTO || (TaskFilterDTO = {})));\nclass TaskExecutionImpl {\n    #tasks;\n    constructor(tasks, _id, _task) {\n        this._id = _id;\n        this._task = _task;\n        this.#tasks = tasks;\n    }\n    get task() {\n        return this._task;\n    }\n    terminate() {\n        this.#tasks.terminateTask(this);\n    }\n    fireDidStartProcess(value) {\n    }\n    fireDidEndProcess(value) {\n    }\n}\nlet ExtHostTaskBase = class ExtHostTaskBase {\n    constructor(extHostRpc, initData, workspaceService, editorService, configurationService, extHostTerminalService, logService, deprecationService) {\n        this._onDidExecuteTask = ( new Emitter());\n        this._onDidTerminateTask = ( new Emitter());\n        this._onDidTaskProcessStarted = ( new Emitter());\n        this._onDidTaskProcessEnded = ( new Emitter());\n        this._proxy = ( extHostRpc.getProxy(MainContext.MainThreadTask));\n        this._workspaceProvider = workspaceService;\n        this._editorService = editorService;\n        this._configurationService = configurationService;\n        this._terminalService = extHostTerminalService;\n        this._handleCounter = 0;\n        this._handlers = ( new Map());\n        this._taskExecutions = ( new Map());\n        this._taskExecutionPromises = ( new Map());\n        this._providedCustomExecutions2 = ( new Map());\n        this._notProvidedCustomExecutions = ( new Set());\n        this._activeCustomExecutions2 = ( new Map());\n        this._logService = logService;\n        this._deprecationService = deprecationService;\n        this._proxy.$registerSupportedExecutions(true);\n    }\n    registerTaskProvider(extension, type, provider) {\n        if (!provider) {\n            return new Disposable(() => { });\n        }\n        const handle = this.nextHandle();\n        this._handlers.set(handle, { type, provider, extension });\n        this._proxy.$registerTaskProvider(handle, type);\n        return new Disposable(() => {\n            this._handlers.delete(handle);\n            this._proxy.$unregisterTaskProvider(handle);\n        });\n    }\n    registerTaskSystem(scheme, info) {\n        this._proxy.$registerTaskSystem(scheme, info);\n    }\n    fetchTasks(filter) {\n        return this._proxy.$fetchTasks(TaskFilterDTO.from(filter)).then(async (values) => {\n            const result = [];\n            for (const value of values) {\n                const task = await TaskDTO.to(value, this._workspaceProvider, this._providedCustomExecutions2);\n                if (task) {\n                    result.push(task);\n                }\n            }\n            return result;\n        });\n    }\n    get taskExecutions() {\n        const result = [];\n        this._taskExecutions.forEach(value => result.push(value));\n        return result;\n    }\n    terminateTask(execution) {\n        if (!(execution instanceof TaskExecutionImpl)) {\n            throw ( new Error('No valid task execution provided'));\n        }\n        return this._proxy.$terminateTask(execution._id);\n    }\n    get onDidStartTask() {\n        return this._onDidExecuteTask.event;\n    }\n    async $onDidStartTask(execution, terminalId, resolvedDefinition) {\n        const customExecution = this._providedCustomExecutions2.get(execution.id);\n        if (customExecution) {\n            this._activeCustomExecutions2.set(execution.id, customExecution);\n            this._terminalService.attachPtyToTerminal(terminalId, await customExecution.callback(resolvedDefinition));\n        }\n        this._lastStartedTask = execution.id;\n        this._onDidExecuteTask.fire({\n            execution: await this.getTaskExecution(execution)\n        });\n    }\n    get onDidEndTask() {\n        return this._onDidTerminateTask.event;\n    }\n    async $OnDidEndTask(execution) {\n        if (!( this._taskExecutionPromises.has(execution.id))) {\n            return;\n        }\n        const _execution = await this.getTaskExecution(execution);\n        this._taskExecutionPromises.delete(execution.id);\n        this._taskExecutions.delete(execution.id);\n        this.customExecutionComplete(execution);\n        this._onDidTerminateTask.fire({\n            execution: _execution\n        });\n    }\n    get onDidStartTaskProcess() {\n        return this._onDidTaskProcessStarted.event;\n    }\n    async $onDidStartTaskProcess(value) {\n        const execution = await this.getTaskExecution(value.id);\n        this._onDidTaskProcessStarted.fire({\n            execution: execution,\n            processId: value.processId\n        });\n    }\n    get onDidEndTaskProcess() {\n        return this._onDidTaskProcessEnded.event;\n    }\n    async $onDidEndTaskProcess(value) {\n        const execution = await this.getTaskExecution(value.id);\n        this._onDidTaskProcessEnded.fire({\n            execution: execution,\n            exitCode: value.exitCode\n        });\n    }\n    $provideTasks(handle, validTypes) {\n        const handler = this._handlers.get(handle);\n        if (!handler) {\n            return Promise.reject(( new Error('no handler found')));\n        }\n        const taskIdPromises = [];\n        const fetchPromise = asPromise(() => handler.provider.provideTasks(CancellationToken.None)).then(value => {\n            return this.provideTasksInternal(validTypes, taskIdPromises, handler, value);\n        });\n        return ( new Promise((resolve) => {\n            fetchPromise.then((result) => {\n                Promise.all(taskIdPromises).then(() => {\n                    resolve(result);\n                });\n            });\n        }));\n    }\n    async $resolveTask(handle, taskDTO) {\n        const handler = this._handlers.get(handle);\n        if (!handler) {\n            return Promise.reject(( new Error('no handler found')));\n        }\n        if (taskDTO.definition.type !== handler.type) {\n            throw ( new Error(\n                `Unexpected: Task of type [${taskDTO.definition.type}] cannot be resolved by provider of type [${handler.type}].`\n            ));\n        }\n        const task = await TaskDTO.to(taskDTO, this._workspaceProvider, this._providedCustomExecutions2);\n        if (!task) {\n            throw ( new Error('Unexpected: Task cannot be resolved.'));\n        }\n        const resolvedTask = await handler.provider.resolveTask(task, CancellationToken.None);\n        if (!resolvedTask) {\n            return;\n        }\n        this.checkDeprecation(resolvedTask, handler);\n        const resolvedTaskDTO = TaskDTO.from(resolvedTask, handler.extension);\n        if (!resolvedTaskDTO) {\n            throw ( new Error('Unexpected: Task cannot be resolved.'));\n        }\n        if (resolvedTask.definition !== task.definition) {\n            throw ( new Error(\n                'Unexpected: The resolved task definition must be the same object as the original task definition. The task definition cannot be changed.'\n            ));\n        }\n        if (CustomExecutionDTO.is(resolvedTaskDTO.execution)) {\n            await this.addCustomExecution(resolvedTaskDTO, resolvedTask, true);\n        }\n        return await this.resolveTaskInternal(resolvedTaskDTO);\n    }\n    nextHandle() {\n        return this._handleCounter++;\n    }\n    async addCustomExecution(taskDTO, task, isProvided) {\n        const taskId = await this._proxy.$createTaskId(taskDTO);\n        if (!isProvided && !( this._providedCustomExecutions2.has(taskId))) {\n            this._notProvidedCustomExecutions.add(taskId);\n            this._activeCustomExecutions2.set(taskId, task.execution);\n        }\n        this._providedCustomExecutions2.set(taskId, task.execution);\n    }\n    async getTaskExecution(execution, task) {\n        if (typeof execution === 'string') {\n            const taskExecution = this._taskExecutionPromises.get(execution);\n            if (!taskExecution) {\n                throw ( new ErrorNoTelemetry('Unexpected: The specified task is missing an execution'));\n            }\n            return taskExecution;\n        }\n        const result = this._taskExecutionPromises.get(execution.id);\n        if (result) {\n            return result;\n        }\n        let executionPromise;\n        if (!task) {\n            executionPromise = TaskDTO.to(execution.task, this._workspaceProvider, this._providedCustomExecutions2).then(t => {\n                if (!t) {\n                    throw ( new ErrorNoTelemetry('Unexpected: Task does not exist.'));\n                }\n                return ( new TaskExecutionImpl(this, execution.id, t));\n            });\n        }\n        else {\n            executionPromise = Promise.resolve(( new TaskExecutionImpl(this, execution.id, task)));\n        }\n        this._taskExecutionPromises.set(execution.id, executionPromise);\n        return executionPromise.then(taskExecution => {\n            this._taskExecutions.set(execution.id, taskExecution);\n            return taskExecution;\n        });\n    }\n    checkDeprecation(task, handler) {\n        const tTask = task;\n        if (tTask._deprecated) {\n            this._deprecationService.report('Task.constructor', handler.extension, 'Use the Task constructor that takes a `scope` instead.');\n        }\n    }\n    customExecutionComplete(execution) {\n        const extensionCallback2 = this._activeCustomExecutions2.get(execution.id);\n        if (extensionCallback2) {\n            this._activeCustomExecutions2.delete(execution.id);\n        }\n        if (( this._notProvidedCustomExecutions.has(execution.id)) && (this._lastStartedTask !== execution.id)) {\n            this._providedCustomExecutions2.delete(execution.id);\n            this._notProvidedCustomExecutions.delete(execution.id);\n        }\n        const iterator = ( this._notProvidedCustomExecutions.values());\n        let iteratorResult = iterator.next();\n        while (!iteratorResult.done) {\n            if (!( this._activeCustomExecutions2.has(iteratorResult.value)) && (this._lastStartedTask !== iteratorResult.value)) {\n                this._providedCustomExecutions2.delete(iteratorResult.value);\n                this._notProvidedCustomExecutions.delete(iteratorResult.value);\n            }\n            iteratorResult = iterator.next();\n        }\n    }\n};\nExtHostTaskBase = ( __decorate([\n    ( __param(0, IExtHostRpcService)),\n    ( __param(1, IExtHostInitDataService)),\n    ( __param(2, IExtHostWorkspace)),\n    ( __param(3, IExtHostDocumentsAndEditors)),\n    ( __param(4, IExtHostConfiguration)),\n    ( __param(5, IExtHostTerminalService)),\n    ( __param(6, ILogService)),\n    ( __param(7, IExtHostApiDeprecationService))\n], ExtHostTaskBase));\nlet WorkerExtHostTask = class WorkerExtHostTask extends ExtHostTaskBase {\n    constructor(extHostRpc, initData, workspaceService, editorService, configurationService, extHostTerminalService, logService, deprecationService) {\n        super(extHostRpc, initData, workspaceService, editorService, configurationService, extHostTerminalService, logService, deprecationService);\n        this.registerTaskSystem(Schemas.vscodeRemote, {\n            scheme: Schemas.vscodeRemote,\n            authority: '',\n            platform: PlatformToString(0 )\n        });\n    }\n    async executeTask(extension, task) {\n        if (!task.execution) {\n            throw ( new Error('Tasks to execute must include an execution'));\n        }\n        const dto = TaskDTO.from(task, extension);\n        if (dto === undefined) {\n            throw ( new Error('Task is not valid'));\n        }\n        if (CustomExecutionDTO.is(dto.execution)) {\n            await this.addCustomExecution(dto, task, false);\n        }\n        else {\n            throw ( new NotSupportedError());\n        }\n        const execution = await this.getTaskExecution(await this._proxy.$getTaskExecution(dto), task);\n        this._proxy.$executeTask(dto).catch(error => { throw ( new Error(error)); });\n        return execution;\n    }\n    provideTasksInternal(validTypes, taskIdPromises, handler, value) {\n        const taskDTOs = [];\n        if (value) {\n            for (const task of value) {\n                this.checkDeprecation(task, handler);\n                if (!task.definition || !validTypes[task.definition.type]) {\n                    const source = task.source ? task.source : 'No task source';\n                    this._logService.warn(`The task [${source}, ${task.name}] uses an undefined task type. The task will be ignored in the future.`);\n                }\n                const taskDTO = TaskDTO.from(task, handler.extension);\n                if (taskDTO && CustomExecutionDTO.is(taskDTO.execution)) {\n                    taskDTOs.push(taskDTO);\n                    taskIdPromises.push(this.addCustomExecution(taskDTO, task, true));\n                }\n                else {\n                    this._logService.warn('Only custom execution tasks supported.');\n                }\n            }\n        }\n        return {\n            tasks: taskDTOs,\n            extension: handler.extension\n        };\n    }\n    async resolveTaskInternal(resolvedTaskDTO) {\n        if (CustomExecutionDTO.is(resolvedTaskDTO.execution)) {\n            return resolvedTaskDTO;\n        }\n        else {\n            this._logService.warn('Only custom execution tasks supported.');\n        }\n        return undefined;\n    }\n    async $resolveVariables(uriComponents, toResolve) {\n        const result = {\n            process: undefined,\n            variables: Object.create(null)\n        };\n        return result;\n    }\n    async $jsonTasksSupported() {\n        return false;\n    }\n    async $findExecutable(command, cwd, paths) {\n        return undefined;\n    }\n};\nWorkerExtHostTask = ( __decorate([\n    ( __param(0, IExtHostRpcService)),\n    ( __param(1, IExtHostInitDataService)),\n    ( __param(2, IExtHostWorkspace)),\n    ( __param(3, IExtHostDocumentsAndEditors)),\n    ( __param(4, IExtHostConfiguration)),\n    ( __param(5, IExtHostTerminalService)),\n    ( __param(6, ILogService)),\n    ( __param(7, IExtHostApiDeprecationService))\n], WorkerExtHostTask));\nconst IExtHostTask = ( createDecorator('IExtHostTask'));\nexport { CustomExecutionDTO, ExtHostTaskBase, IExtHostTask, TaskDTO, WorkerExtHostTask };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { isLogLevel, LogLevel } from '../../../platform/log/common/log.js';\nimport { ILoggerService } from '../../../platform/log/common/log.service.js';\nimport { IExtHostInitDataService } from './extHostInitDataService.js';\nimport { UIKind } from '../../services/extensions/common/extensionHostProtocol.js';\nimport { getRemoteName } from '../../../platform/remote/common/remoteHosts.js';\nimport { extensionTelemetryLogChannelId, cleanRemoteAuthority, cleanData } from '../../../platform/telemetry/common/telemetryUtils.js';\nimport { mixin } from '../../../base/common/objects.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { localize } from '../../../nls.js';\nlet ExtHostTelemetry = class ExtHostTelemetry extends Disposable {\n    constructor(initData, loggerService) {\n        super();\n        this.initData = initData;\n        this.loggerService = loggerService;\n        this._onDidChangeTelemetryEnabled = this._register(( (new Emitter())));\n        this.onDidChangeTelemetryEnabled = this._onDidChangeTelemetryEnabled.event;\n        this._onDidChangeTelemetryConfiguration = this._register(( (new Emitter())));\n        this.onDidChangeTelemetryConfiguration = this._onDidChangeTelemetryConfiguration.event;\n        this._productConfig = { usage: true, error: true };\n        this._level = 0 ;\n        this._telemetryIsSupported = false;\n        this._inLoggingOnlyMode = false;\n        this._telemetryLoggers = ( (new Map()));\n        this.extHostTelemetryLogFile = URI.revive(this.initData.environment.extensionTelemetryLogResource);\n        this._inLoggingOnlyMode = this.initData.environment.isExtensionTelemetryLoggingOnly;\n        this._outputLogger = loggerService.createLogger(this.extHostTelemetryLogFile, { id: extensionTelemetryLogChannelId, name: ( localize(\n            588,\n            \"Extension Telemetry{0}\",\n            this._inLoggingOnlyMode ? ' (Not Sent)' : ''\n        )), hidden: true });\n        this._register(this._outputLogger);\n        this._register(loggerService.onDidChangeLogLevel(arg => {\n            if (isLogLevel(arg)) {\n                this.updateLoggerVisibility();\n            }\n        }));\n        this._outputLogger.info('Below are logs for extension telemetry events sent to the telemetry output channel API once the log level is set to trace.');\n        this._outputLogger.info('===========================================================');\n    }\n    updateLoggerVisibility() {\n        this.loggerService.setVisibility(this.extHostTelemetryLogFile, this._telemetryIsSupported && this.loggerService.getLogLevel() === LogLevel.Trace);\n    }\n    getTelemetryConfiguration() {\n        return this._level === 3 ;\n    }\n    getTelemetryDetails() {\n        return {\n            isCrashEnabled: this._level >= 1 ,\n            isErrorsEnabled: this._productConfig.error ? this._level >= 2  : false,\n            isUsageEnabled: this._productConfig.usage ? this._level >= 3  : false\n        };\n    }\n    instantiateLogger(extension, sender, options) {\n        const telemetryDetails = this.getTelemetryDetails();\n        const logger = ( (new ExtHostTelemetryLogger(\n            sender,\n            options,\n            extension,\n            this._outputLogger,\n            this._inLoggingOnlyMode,\n            this.getBuiltInCommonProperties(extension),\n            { isUsageEnabled: telemetryDetails.isUsageEnabled, isErrorsEnabled: telemetryDetails.isErrorsEnabled }\n        )));\n        const loggers = this._telemetryLoggers.get(extension.identifier.value) ?? [];\n        this._telemetryLoggers.set(extension.identifier.value, [...loggers, logger]);\n        return logger.apiTelemetryLogger;\n    }\n    $initializeTelemetryLevel(level, supportsTelemetry, productConfig) {\n        this._level = level;\n        this._telemetryIsSupported = supportsTelemetry;\n        this._productConfig = productConfig ?? { usage: true, error: true };\n        this.updateLoggerVisibility();\n    }\n    getBuiltInCommonProperties(extension) {\n        const commonProperties = Object.create(null);\n        commonProperties['common.extname'] = `${extension.publisher}.${extension.name}`;\n        commonProperties['common.extversion'] = extension.version;\n        commonProperties['common.vscodemachineid'] = this.initData.telemetryInfo.machineId;\n        commonProperties['common.vscodesessionid'] = this.initData.telemetryInfo.sessionId;\n        commonProperties['common.sqmid'] = this.initData.telemetryInfo.sqmId;\n        commonProperties['common.devDeviceId'] = this.initData.telemetryInfo.devDeviceId;\n        commonProperties['common.vscodeversion'] = this.initData.version;\n        commonProperties['common.isnewappinstall'] = isNewAppInstall(this.initData.telemetryInfo.firstSessionDate);\n        commonProperties['common.product'] = this.initData.environment.appHost;\n        switch (this.initData.uiKind) {\n            case UIKind.Web:\n                commonProperties['common.uikind'] = 'web';\n                break;\n            case UIKind.Desktop:\n                commonProperties['common.uikind'] = 'desktop';\n                break;\n            default:\n                commonProperties['common.uikind'] = 'unknown';\n        }\n        commonProperties['common.remotename'] = getRemoteName(cleanRemoteAuthority(this.initData.remote.authority));\n        return commonProperties;\n    }\n    $onDidChangeTelemetryLevel(level) {\n        this._oldTelemetryEnablement = this.getTelemetryConfiguration();\n        this._level = level;\n        const telemetryDetails = this.getTelemetryDetails();\n        this._telemetryLoggers.forEach((loggers, key) => {\n            const newLoggers = loggers.filter(l => !l.isDisposed);\n            if (newLoggers.length === 0) {\n                this._telemetryLoggers.delete(key);\n            }\n            else {\n                this._telemetryLoggers.set(key, newLoggers);\n            }\n        });\n        this._telemetryLoggers.forEach(loggers => {\n            for (const logger of loggers) {\n                logger.updateTelemetryEnablements(telemetryDetails.isUsageEnabled, telemetryDetails.isErrorsEnabled);\n            }\n        });\n        if (this._oldTelemetryEnablement !== this.getTelemetryConfiguration()) {\n            this._onDidChangeTelemetryEnabled.fire(this.getTelemetryConfiguration());\n        }\n        this._onDidChangeTelemetryConfiguration.fire(this.getTelemetryDetails());\n        this.updateLoggerVisibility();\n    }\n    onExtensionError(extension, error) {\n        const loggers = this._telemetryLoggers.get(extension.value);\n        const nonDisposedLoggers = loggers?.filter(l => !l.isDisposed);\n        if (!nonDisposedLoggers) {\n            this._telemetryLoggers.delete(extension.value);\n            return false;\n        }\n        let errorEmitted = false;\n        for (const logger of nonDisposedLoggers) {\n            if (logger.ignoreUnhandledExtHostErrors) {\n                continue;\n            }\n            logger.logError(error);\n            errorEmitted = true;\n        }\n        return errorEmitted;\n    }\n};\nExtHostTelemetry = ( (__decorate([\n    ( (__param(0, IExtHostInitDataService))),\n    ( (__param(1, ILoggerService)))\n], ExtHostTelemetry)));\nclass ExtHostTelemetryLogger {\n    static validateSender(sender) {\n        if (typeof sender !== 'object') {\n            throw ( (new TypeError('TelemetrySender argument is invalid')));\n        }\n        if (typeof sender.sendEventData !== 'function') {\n            throw ( (new TypeError('TelemetrySender.sendEventData must be a function')));\n        }\n        if (typeof sender.sendErrorData !== 'function') {\n            throw ( (new TypeError('TelemetrySender.sendErrorData must be a function')));\n        }\n        if (typeof sender.flush !== 'undefined' && typeof sender.flush !== 'function') {\n            throw ( (new TypeError('TelemetrySender.flush must be a function or undefined')));\n        }\n    }\n    constructor(sender, options, _extension, _logger, _inLoggingOnlyMode, _commonProperties, telemetryEnablements) {\n        this._extension = _extension;\n        this._logger = _logger;\n        this._inLoggingOnlyMode = _inLoggingOnlyMode;\n        this._commonProperties = _commonProperties;\n        this._onDidChangeEnableStates = ( (new Emitter()));\n        this.ignoreUnhandledExtHostErrors = options?.ignoreUnhandledErrors ?? false;\n        this._ignoreBuiltinCommonProperties = options?.ignoreBuiltInCommonProperties ?? false;\n        this._additionalCommonProperties = options?.additionalCommonProperties;\n        this._sender = sender;\n        this._telemetryEnablements = { isUsageEnabled: telemetryEnablements.isUsageEnabled, isErrorsEnabled: telemetryEnablements.isErrorsEnabled };\n    }\n    updateTelemetryEnablements(isUsageEnabled, isErrorsEnabled) {\n        if (this._apiObject) {\n            this._telemetryEnablements = { isUsageEnabled, isErrorsEnabled };\n            this._onDidChangeEnableStates.fire(this._apiObject);\n        }\n    }\n    mixInCommonPropsAndCleanData(data) {\n        let updatedData = 'properties' in data ? (data.properties ?? {}) : data;\n        updatedData = cleanData(updatedData, []);\n        if (this._additionalCommonProperties) {\n            updatedData = mixin(updatedData, this._additionalCommonProperties);\n        }\n        if (!this._ignoreBuiltinCommonProperties) {\n            updatedData = mixin(updatedData, this._commonProperties);\n        }\n        if ('properties' in data) {\n            data.properties = updatedData;\n        }\n        else {\n            data = updatedData;\n        }\n        return data;\n    }\n    logEvent(eventName, data) {\n        if (!this._sender) {\n            return;\n        }\n        if (this._extension.publisher === 'vscode') {\n            eventName = this._extension.name + '/' + eventName;\n        }\n        else {\n            eventName = this._extension.identifier.value + '/' + eventName;\n        }\n        data = this.mixInCommonPropsAndCleanData(data || {});\n        if (!this._inLoggingOnlyMode) {\n            this._sender?.sendEventData(eventName, data);\n        }\n        this._logger.trace(eventName, data);\n    }\n    logUsage(eventName, data) {\n        if (!this._telemetryEnablements.isUsageEnabled) {\n            return;\n        }\n        this.logEvent(eventName, data);\n    }\n    logError(eventNameOrException, data) {\n        if (!this._telemetryEnablements.isErrorsEnabled || !this._sender) {\n            return;\n        }\n        if (typeof eventNameOrException === 'string') {\n            this.logEvent(eventNameOrException, data);\n        }\n        else {\n            const errorData = {\n                name: eventNameOrException.name,\n                message: eventNameOrException.message,\n                stack: eventNameOrException.stack,\n                cause: eventNameOrException.cause\n            };\n            const cleanedErrorData = cleanData(errorData, []);\n            const cleanedError = ( (new Error(cleanedErrorData.message, {\n                cause: cleanedErrorData.cause\n            })));\n            cleanedError.stack = cleanedErrorData.stack;\n            cleanedError.name = cleanedErrorData.name;\n            data = this.mixInCommonPropsAndCleanData(data || {});\n            if (!this._inLoggingOnlyMode) {\n                this._sender.sendErrorData(cleanedError, data);\n            }\n            this._logger.trace('exception', data);\n        }\n    }\n    get apiTelemetryLogger() {\n        if (!this._apiObject) {\n            const that = this;\n            const obj = {\n                logUsage: that.logUsage.bind(that),\n                get isUsageEnabled() {\n                    return that._telemetryEnablements.isUsageEnabled;\n                },\n                get isErrorsEnabled() {\n                    return that._telemetryEnablements.isErrorsEnabled;\n                },\n                logError: that.logError.bind(that),\n                dispose: that.dispose.bind(that),\n                onDidChangeEnableStates: that._onDidChangeEnableStates.event.bind(that)\n            };\n            this._apiObject = ( (Object.freeze(obj)));\n        }\n        return this._apiObject;\n    }\n    get isDisposed() {\n        return !this._sender;\n    }\n    dispose() {\n        if (this._sender?.flush) {\n            let tempSender = this._sender;\n            this._sender = undefined;\n            Promise.resolve(tempSender.flush()).then(tempSender = undefined);\n            this._apiObject = undefined;\n        }\n        else {\n            this._sender = undefined;\n        }\n    }\n}\nfunction isNewAppInstall(firstSessionDate) {\n    const installAge = Date.now() - ( (new Date(firstSessionDate))).getTime();\n    return isNaN(installAge) ? false : installAge < 1000 * 60 * 60 * 24;\n}\nconst IExtHostTelemetry = ( (createDecorator('IExtHostTelemetry')));\nexport { ExtHostTelemetry, ExtHostTelemetryLogger, IExtHostTelemetry, isNewAppInstall };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\nimport { Disposable, MutableDisposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport { Disposable as Disposable$1, EnvironmentVariableMutatorType } from './extHostTypes.js';\nimport { localize } from '../../../nls.js';\nimport { NotSupportedError } from '../../../base/common/errors.js';\nimport { serializeEnvironmentVariableCollection, serializeEnvironmentDescriptionMap } from '../../../platform/terminal/common/environmentVariableShared.js';\nimport { CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { generateUuid } from '../../../base/common/uuid.js';\nimport { TerminalDataBufferer } from '../../../platform/terminal/common/terminalDataBuffering.js';\nimport { ThemeColor } from '../../../base/common/themables.js';\nimport { Promises } from '../../../base/common/async.js';\nimport { TerminalQuickFix, ViewColumn } from './extHostTypeConverters.js';\nimport { IExtHostCommands } from './extHostCommands.js';\nconst IExtHostTerminalService = ( (createDecorator('IExtHostTerminalService')));\nclass ExtHostTerminal extends Disposable {\n    constructor(_proxy, _id, _creationOptions, _name) {\n        super();\n        this._proxy = _proxy;\n        this._id = _id;\n        this._creationOptions = _creationOptions;\n        this._name = _name;\n        this._disposed = false;\n        this._state = { isInteractedWith: false };\n        this.isOpen = false;\n        this._onWillDispose = this._register(( (new Emitter())));\n        this.onWillDispose = this._onWillDispose.event;\n        this._creationOptions = ( (Object.freeze(this._creationOptions)));\n        this._pidPromise = ( (new Promise(c => this._pidPromiseComplete = c)));\n        const that = this;\n        this.value = {\n            get name() {\n                return that._name || '';\n            },\n            get processId() {\n                return that._pidPromise;\n            },\n            get creationOptions() {\n                return that._creationOptions;\n            },\n            get exitStatus() {\n                return that._exitStatus;\n            },\n            get state() {\n                return that._state;\n            },\n            get selection() {\n                return that._selection;\n            },\n            get shellIntegration() {\n                return that.shellIntegration;\n            },\n            sendText(text, shouldExecute = true) {\n                that._checkDisposed();\n                that._proxy.$sendText(that._id, text, shouldExecute);\n            },\n            show(preserveFocus) {\n                that._checkDisposed();\n                that._proxy.$show(that._id, preserveFocus);\n            },\n            hide() {\n                that._checkDisposed();\n                that._proxy.$hide(that._id);\n            },\n            dispose() {\n                if (!that._disposed) {\n                    that._disposed = true;\n                    that._proxy.$dispose(that._id);\n                }\n            },\n            get dimensions() {\n                if (that._cols === undefined || that._rows === undefined) {\n                    return undefined;\n                }\n                return {\n                    columns: that._cols,\n                    rows: that._rows\n                };\n            }\n        };\n    }\n    dispose() {\n        this._onWillDispose.fire();\n        super.dispose();\n    }\n    async create(options, internalOptions) {\n        if (typeof this._id !== 'string') {\n            throw ( (new Error('Terminal has already been created')));\n        }\n        await this._proxy.$createTerminal(this._id, {\n            name: options.name,\n            shellPath: options.shellPath ?? undefined,\n            shellArgs: options.shellArgs ?? undefined,\n            cwd: options.cwd ?? internalOptions?.cwd ?? undefined,\n            env: options.env ?? undefined,\n            icon: asTerminalIcon(options.iconPath) ?? undefined,\n            color: ThemeColor.isThemeColor(options.color) ? options.color.id : undefined,\n            initialText: options.message ?? undefined,\n            strictEnv: options.strictEnv ?? undefined,\n            hideFromUser: options.hideFromUser ?? undefined,\n            forceShellIntegration: internalOptions?.forceShellIntegration ?? undefined,\n            isFeatureTerminal: internalOptions?.isFeatureTerminal ?? undefined,\n            isExtensionOwnedTerminal: true,\n            useShellEnvironment: internalOptions?.useShellEnvironment ?? undefined,\n            location: internalOptions?.location || this._serializeParentTerminal(options.location, internalOptions?.resolvedExtHostIdentifier),\n            isTransient: options.isTransient ?? undefined,\n        });\n    }\n    async createExtensionTerminal(location, internalOptions, parentTerminal, iconPath, color) {\n        if (typeof this._id !== 'string') {\n            throw ( (new Error('Terminal has already been created')));\n        }\n        await this._proxy.$createTerminal(this._id, {\n            name: this._name,\n            isExtensionCustomPtyTerminal: true,\n            icon: iconPath,\n            color: ThemeColor.isThemeColor(color) ? color.id : undefined,\n            location: internalOptions?.location || this._serializeParentTerminal(location, parentTerminal),\n            isTransient: true\n        });\n        if (typeof this._id === 'string') {\n            throw ( (new Error('Terminal creation failed')));\n        }\n        return this._id;\n    }\n    _serializeParentTerminal(location, parentTerminal) {\n        if (typeof location === 'object') {\n            if ('parentTerminal' in location && location.parentTerminal && parentTerminal) {\n                return { parentTerminal };\n            }\n            if ('viewColumn' in location) {\n                return { viewColumn: ViewColumn.from(location.viewColumn), preserveFocus: location.preserveFocus };\n            }\n            return undefined;\n        }\n        return location;\n    }\n    _checkDisposed() {\n        if (this._disposed) {\n            throw ( (new Error('Terminal has already been disposed')));\n        }\n    }\n    set name(name) {\n        this._name = name;\n    }\n    setExitStatus(code, reason) {\n        this._exitStatus = ( (Object.freeze({ code, reason })));\n    }\n    setDimensions(cols, rows) {\n        if (cols === this._cols && rows === this._rows) {\n            return false;\n        }\n        if (cols === 0 || rows === 0) {\n            return false;\n        }\n        this._cols = cols;\n        this._rows = rows;\n        return true;\n    }\n    setInteractedWith() {\n        if (!this._state.isInteractedWith) {\n            this._state = { isInteractedWith: true };\n            return true;\n        }\n        return false;\n    }\n    setSelection(selection) {\n        this._selection = selection;\n    }\n    _setProcessId(processId) {\n        if (this._pidPromiseComplete) {\n            this._pidPromiseComplete(processId);\n            this._pidPromiseComplete = undefined;\n        }\n        else {\n            this._pidPromise.then(pid => {\n                if (pid !== processId) {\n                    this._pidPromise = Promise.resolve(processId);\n                }\n            });\n        }\n    }\n}\nclass ExtHostPseudoterminal {\n    get onProcessReady() { return this._onProcessReady.event; }\n    constructor(_pty) {\n        this._pty = _pty;\n        this.id = 0;\n        this.shouldPersist = false;\n        this._onProcessData = ( (new Emitter()));\n        this.onProcessData = this._onProcessData.event;\n        this._onProcessReady = ( (new Emitter()));\n        this._onDidChangeProperty = ( (new Emitter()));\n        this.onDidChangeProperty = this._onDidChangeProperty.event;\n        this._onProcessExit = ( (new Emitter()));\n        this.onProcessExit = this._onProcessExit.event;\n    }\n    refreshProperty(property) {\n        throw ( (new Error(\n            `refreshProperty is not suppported in extension owned terminals. property: ${property}`\n        )));\n    }\n    updateProperty(property, value) {\n        throw ( (new Error(\n            `updateProperty is not suppported in extension owned terminals. property: ${property}, value: ${value}`\n        )));\n    }\n    async start() {\n        return undefined;\n    }\n    shutdown() {\n        this._pty.close();\n    }\n    input(data) {\n        this._pty.handleInput?.(data);\n    }\n    resize(cols, rows) {\n        this._pty.setDimensions?.({ columns: cols, rows });\n    }\n    clearBuffer() {\n    }\n    async processBinary(data) {\n    }\n    acknowledgeDataEvent(charCount) {\n    }\n    async setUnicodeVersion(version) {\n    }\n    getInitialCwd() {\n        return Promise.resolve('');\n    }\n    getCwd() {\n        return Promise.resolve('');\n    }\n    startSendingEvents(initialDimensions) {\n        this._pty.onDidWrite(e => this._onProcessData.fire(e));\n        this._pty.onDidClose?.((e = undefined) => {\n            this._onProcessExit.fire(e === void 0 ? undefined : e);\n        });\n        this._pty.onDidOverrideDimensions?.(e => {\n            if (e) {\n                this._onDidChangeProperty.fire({ type: \"overrideDimensions\" , value: { cols: e.columns, rows: e.rows } });\n            }\n        });\n        this._pty.onDidChangeName?.(title => {\n            this._onDidChangeProperty.fire({ type: \"title\" , value: title });\n        });\n        this._pty.open(initialDimensions ? initialDimensions : undefined);\n        if (initialDimensions) {\n            this._pty.setDimensions?.(initialDimensions);\n        }\n        this._onProcessReady.fire({ pid: -1, cwd: '', windowsPty: undefined });\n    }\n}\nlet nextLinkId = 1;\nlet BaseExtHostTerminalService = class BaseExtHostTerminalService extends Disposable {\n    get activeTerminal() { return this._activeTerminal?.value; }\n    get terminals() { return (\n         (this._terminals.map(term => term.value))\n    ); }\n    constructor(supportsProcesses, _extHostCommands, extHostRpc) {\n        super();\n        this._extHostCommands = _extHostCommands;\n        this._terminals = [];\n        this._terminalProcesses = ( (new Map()));\n        this._terminalProcessDisposables = {};\n        this._extensionTerminalAwaitingStart = {};\n        this._getTerminalPromises = {};\n        this._environmentVariableCollections = ( (new Map()));\n        this._lastQuickFixCommands = this._register(( (new MutableDisposable())));\n        this._linkProviders = ( (new Set()));\n        this._profileProviders = ( (new Map()));\n        this._quickFixProviders = ( (new Map()));\n        this._terminalLinkCache = ( (new Map()));\n        this._terminalLinkCancellationSource = ( (new Map()));\n        this._onDidCloseTerminal = ( (new Emitter()));\n        this.onDidCloseTerminal = this._onDidCloseTerminal.event;\n        this._onDidOpenTerminal = ( (new Emitter()));\n        this.onDidOpenTerminal = this._onDidOpenTerminal.event;\n        this._onDidChangeActiveTerminal = ( (new Emitter()));\n        this.onDidChangeActiveTerminal = this._onDidChangeActiveTerminal.event;\n        this._onDidChangeTerminalDimensions = ( (new Emitter()));\n        this.onDidChangeTerminalDimensions = this._onDidChangeTerminalDimensions.event;\n        this._onDidChangeTerminalState = ( (new Emitter()));\n        this.onDidChangeTerminalState = this._onDidChangeTerminalState.event;\n        this._onDidChangeShell = ( (new Emitter()));\n        this.onDidChangeShell = this._onDidChangeShell.event;\n        this._onDidWriteTerminalData = ( (new Emitter({\n            onWillAddFirstListener: () => this._proxy.$startSendingDataEvents(),\n            onDidRemoveLastListener: () => this._proxy.$stopSendingDataEvents()\n        })));\n        this.onDidWriteTerminalData = this._onDidWriteTerminalData.event;\n        this._onDidExecuteCommand = ( (new Emitter({\n            onWillAddFirstListener: () => this._proxy.$startSendingCommandEvents(),\n            onDidRemoveLastListener: () => this._proxy.$stopSendingCommandEvents()\n        })));\n        this.onDidExecuteTerminalCommand = this._onDidExecuteCommand.event;\n        this._proxy = ( (extHostRpc.getProxy(MainContext.MainThreadTerminalService)));\n        this._bufferer = ( (new TerminalDataBufferer(this._proxy.$sendProcessData)));\n        this._proxy.$registerProcessSupport(supportsProcesses);\n        this._extHostCommands.registerArgumentProcessor({\n            processArgument: arg => {\n                const deserialize = (arg) => {\n                    const cast = arg;\n                    return this.getTerminalById(cast.instanceId)?.value;\n                };\n                switch (arg?.$mid) {\n                    case 15 : return deserialize(arg);\n                    default: {\n                        if (Array.isArray(arg)) {\n                            for (let i = 0; i < arg.length; i++) {\n                                if (arg[i].$mid === 15 ) {\n                                    arg[i] = deserialize(arg[i]);\n                                }\n                                else {\n                                    break;\n                                }\n                            }\n                        }\n                        return arg;\n                    }\n                }\n            }\n        });\n        this._register({\n            dispose: () => {\n                for (const [_, terminalProcess] of this._terminalProcesses) {\n                    terminalProcess.shutdown(true);\n                }\n            }\n        });\n    }\n    getDefaultShell(useAutomationShell) {\n        const profile = useAutomationShell ? this._defaultAutomationProfile : this._defaultProfile;\n        return profile?.path || '';\n    }\n    getDefaultShellArgs(useAutomationShell) {\n        const profile = useAutomationShell ? this._defaultAutomationProfile : this._defaultProfile;\n        return profile?.args || [];\n    }\n    createExtensionTerminal(options, internalOptions) {\n        const terminal = ( (new ExtHostTerminal(this._proxy, generateUuid(), options, options.name)));\n        const p = ( (new ExtHostPseudoterminal(options.pty)));\n        terminal.createExtensionTerminal(options.location, internalOptions, this._serializeParentTerminal(options, internalOptions).resolvedExtHostIdentifier, asTerminalIcon(options.iconPath), asTerminalColor(options.color)).then(id => {\n            const disposable = this._setupExtHostProcessListeners(id, p);\n            this._terminalProcessDisposables[id] = disposable;\n        });\n        this._terminals.push(terminal);\n        return terminal.value;\n    }\n    _serializeParentTerminal(options, internalOptions) {\n        internalOptions = internalOptions ? internalOptions : {};\n        if (options.location && typeof options.location === 'object' && 'parentTerminal' in options.location) {\n            const parentTerminal = options.location.parentTerminal;\n            if (parentTerminal) {\n                const parentExtHostTerminal = this._terminals.find(t => t.value === parentTerminal);\n                if (parentExtHostTerminal) {\n                    internalOptions.resolvedExtHostIdentifier = parentExtHostTerminal._id;\n                }\n            }\n        }\n        else if (options.location && typeof options.location !== 'object') {\n            internalOptions.location = options.location;\n        }\n        else if (internalOptions.location && typeof internalOptions.location === 'object' && 'splitActiveTerminal' in internalOptions.location) {\n            internalOptions.location = { splitActiveTerminal: true };\n        }\n        return internalOptions;\n    }\n    attachPtyToTerminal(id, pty) {\n        const terminal = this.getTerminalById(id);\n        if (!terminal) {\n            throw ( (new Error(`Cannot resolve terminal with id ${id} for virtual process`)));\n        }\n        const p = ( (new ExtHostPseudoterminal(pty)));\n        const disposable = this._setupExtHostProcessListeners(id, p);\n        this._terminalProcessDisposables[id] = disposable;\n    }\n    async $acceptActiveTerminalChanged(id) {\n        const original = this._activeTerminal;\n        if (id === null) {\n            this._activeTerminal = undefined;\n            if (original !== this._activeTerminal) {\n                this._onDidChangeActiveTerminal.fire(this._activeTerminal);\n            }\n            return;\n        }\n        const terminal = this.getTerminalById(id);\n        if (terminal) {\n            this._activeTerminal = terminal;\n            if (original !== this._activeTerminal) {\n                this._onDidChangeActiveTerminal.fire(this._activeTerminal.value);\n            }\n        }\n    }\n    async $acceptTerminalProcessData(id, data) {\n        const terminal = this.getTerminalById(id);\n        if (terminal) {\n            this._onDidWriteTerminalData.fire({ terminal: terminal.value, data });\n        }\n    }\n    async $acceptTerminalDimensions(id, cols, rows) {\n        const terminal = this.getTerminalById(id);\n        if (terminal) {\n            if (terminal.setDimensions(cols, rows)) {\n                this._onDidChangeTerminalDimensions.fire({\n                    terminal: terminal.value,\n                    dimensions: terminal.value.dimensions\n                });\n            }\n        }\n    }\n    async $acceptDidExecuteCommand(id, command) {\n        const terminal = this.getTerminalById(id);\n        if (terminal) {\n            this._onDidExecuteCommand.fire({ terminal: terminal.value, ...command });\n        }\n    }\n    async $acceptTerminalMaximumDimensions(id, cols, rows) {\n        this._terminalProcesses.get(id)?.resize(cols, rows);\n    }\n    async $acceptTerminalTitleChange(id, name) {\n        const terminal = this.getTerminalById(id);\n        if (terminal) {\n            terminal.name = name;\n        }\n    }\n    async $acceptTerminalClosed(id, exitCode, exitReason) {\n        const index = this._getTerminalObjectIndexById(this._terminals, id);\n        if (index !== null) {\n            const terminal = this._terminals.splice(index, 1)[0];\n            terminal.setExitStatus(exitCode, exitReason);\n            this._onDidCloseTerminal.fire(terminal.value);\n        }\n    }\n    $acceptTerminalOpened(id, extHostTerminalId, name, shellLaunchConfigDto) {\n        if (extHostTerminalId) {\n            const index = this._getTerminalObjectIndexById(this._terminals, extHostTerminalId);\n            if (index !== null) {\n                this._terminals[index]._id = id;\n                this._onDidOpenTerminal.fire(this.terminals[index]);\n                this._terminals[index].isOpen = true;\n                return;\n            }\n        }\n        const creationOptions = {\n            name: shellLaunchConfigDto.name,\n            shellPath: shellLaunchConfigDto.executable,\n            shellArgs: shellLaunchConfigDto.args,\n            cwd: typeof shellLaunchConfigDto.cwd === 'string' ? shellLaunchConfigDto.cwd : URI.revive(shellLaunchConfigDto.cwd),\n            env: shellLaunchConfigDto.env,\n            hideFromUser: shellLaunchConfigDto.hideFromUser\n        };\n        const terminal = ( (new ExtHostTerminal(this._proxy, id, creationOptions, name)));\n        this._terminals.push(terminal);\n        this._onDidOpenTerminal.fire(terminal.value);\n        terminal.isOpen = true;\n    }\n    async $acceptTerminalProcessId(id, processId) {\n        const terminal = this.getTerminalById(id);\n        terminal?._setProcessId(processId);\n    }\n    async $startExtensionTerminal(id, initialDimensions) {\n        const terminal = this.getTerminalById(id);\n        if (!terminal) {\n            return { message: ( localize(585, \"Could not find the terminal with id {0} on the extension host\", id)) };\n        }\n        if (!terminal.isOpen) {\n            await ( (new Promise(r => {\n                const listener = this.onDidOpenTerminal(async (e) => {\n                    if (e === terminal.value) {\n                        listener.dispose();\n                        r();\n                    }\n                });\n            })));\n        }\n        const terminalProcess = this._terminalProcesses.get(id);\n        if (terminalProcess) {\n            terminalProcess.startSendingEvents(initialDimensions);\n        }\n        else {\n            this._extensionTerminalAwaitingStart[id] = { initialDimensions };\n        }\n        return undefined;\n    }\n    _setupExtHostProcessListeners(id, p) {\n        const disposables = ( (new DisposableStore()));\n        disposables.add(p.onProcessReady(e => this._proxy.$sendProcessReady(id, e.pid, e.cwd, e.windowsPty)));\n        disposables.add(p.onDidChangeProperty(property => this._proxy.$sendProcessProperty(id, property)));\n        this._bufferer.startBuffering(id, p.onProcessData);\n        disposables.add(p.onProcessExit(exitCode => this._onProcessExit(id, exitCode)));\n        this._terminalProcesses.set(id, p);\n        const awaitingStart = this._extensionTerminalAwaitingStart[id];\n        if (awaitingStart && p instanceof ExtHostPseudoterminal) {\n            p.startSendingEvents(awaitingStart.initialDimensions);\n            delete this._extensionTerminalAwaitingStart[id];\n        }\n        return disposables;\n    }\n    $acceptProcessAckDataEvent(id, charCount) {\n        this._terminalProcesses.get(id)?.acknowledgeDataEvent(charCount);\n    }\n    $acceptProcessInput(id, data) {\n        this._terminalProcesses.get(id)?.input(data);\n    }\n    $acceptTerminalInteraction(id) {\n        const terminal = this.getTerminalById(id);\n        if (terminal?.setInteractedWith()) {\n            this._onDidChangeTerminalState.fire(terminal.value);\n        }\n    }\n    $acceptTerminalSelection(id, selection) {\n        this.getTerminalById(id)?.setSelection(selection);\n    }\n    $acceptProcessResize(id, cols, rows) {\n        try {\n            this._terminalProcesses.get(id)?.resize(cols, rows);\n        }\n        catch (error) {\n            if (error.code !== 'EPIPE' && error.code !== 'ERR_IPC_CHANNEL_CLOSED') {\n                throw (error);\n            }\n        }\n    }\n    $acceptProcessShutdown(id, immediate) {\n        this._terminalProcesses.get(id)?.shutdown(immediate);\n    }\n    $acceptProcessRequestInitialCwd(id) {\n        this._terminalProcesses.get(id)?.getInitialCwd().then(initialCwd => this._proxy.$sendProcessProperty(id, { type: \"initialCwd\" , value: initialCwd }));\n    }\n    $acceptProcessRequestCwd(id) {\n        this._terminalProcesses.get(id)?.getCwd().then(cwd => this._proxy.$sendProcessProperty(id, { type: \"cwd\" , value: cwd }));\n    }\n    $acceptProcessRequestLatency(id) {\n        return Promise.resolve(id);\n    }\n    registerLinkProvider(provider) {\n        this._linkProviders.add(provider);\n        if (this._linkProviders.size === 1) {\n            this._proxy.$startLinkProvider();\n        }\n        return (\n             (new Disposable$1(() => {\n                this._linkProviders.delete(provider);\n                if (this._linkProviders.size === 0) {\n                    this._proxy.$stopLinkProvider();\n                }\n            }))\n        );\n    }\n    registerProfileProvider(extension, id, provider) {\n        if (( (this._profileProviders.has(id)))) {\n            throw ( (new Error(`Terminal profile provider \"${id}\" already registered`)));\n        }\n        this._profileProviders.set(id, provider);\n        this._proxy.$registerProfileProvider(id, extension.identifier.value);\n        return (\n             (new Disposable$1(() => {\n                this._profileProviders.delete(id);\n                this._proxy.$unregisterProfileProvider(id);\n            }))\n        );\n    }\n    registerTerminalQuickFixProvider(id, extensionId, provider) {\n        if (( (this._quickFixProviders.has(id)))) {\n            throw ( (new Error(`Terminal quick fix provider \"${id}\" is already registered`)));\n        }\n        this._quickFixProviders.set(id, provider);\n        this._proxy.$registerQuickFixProvider(id, extensionId);\n        return (\n             (new Disposable$1(() => {\n                this._quickFixProviders.delete(id);\n                this._proxy.$unregisterQuickFixProvider(id);\n            }))\n        );\n    }\n    async $provideTerminalQuickFixes(id, matchResult) {\n        const token = ( (new CancellationTokenSource())).token;\n        if (token.isCancellationRequested) {\n            return;\n        }\n        const provider = this._quickFixProviders.get(id);\n        if (!provider) {\n            return;\n        }\n        const quickFixes = await provider.provideTerminalQuickFixes(matchResult, token);\n        if (quickFixes === null || (Array.isArray(quickFixes) && quickFixes.length === 0)) {\n            return undefined;\n        }\n        const store = ( (new DisposableStore()));\n        this._lastQuickFixCommands.value = store;\n        if (!Array.isArray(quickFixes)) {\n            return quickFixes ? TerminalQuickFix.from(quickFixes, this._extHostCommands.converter, store) : undefined;\n        }\n        const result = [];\n        for (const fix of quickFixes) {\n            const converted = TerminalQuickFix.from(fix, this._extHostCommands.converter, store);\n            if (converted) {\n                result.push(converted);\n            }\n        }\n        return result;\n    }\n    async $createContributedProfileTerminal(id, options) {\n        const token = ( (new CancellationTokenSource())).token;\n        let profile = await this._profileProviders.get(id)?.provideTerminalProfile(token);\n        if (token.isCancellationRequested) {\n            return;\n        }\n        if (profile && !('options' in profile)) {\n            profile = { options: profile };\n        }\n        if (!profile || !('options' in profile)) {\n            throw ( (new Error(`No terminal profile options provided for id \"${id}\"`)));\n        }\n        if ('pty' in profile.options) {\n            this.createExtensionTerminal(profile.options, options);\n            return;\n        }\n        this.createTerminalFromOptions(profile.options, options);\n    }\n    async $provideLinks(terminalId, line) {\n        const terminal = this.getTerminalById(terminalId);\n        if (!terminal) {\n            return [];\n        }\n        this._terminalLinkCache.delete(terminalId);\n        const oldToken = this._terminalLinkCancellationSource.get(terminalId);\n        oldToken?.dispose(true);\n        const cancellationSource = ( (new CancellationTokenSource()));\n        this._terminalLinkCancellationSource.set(terminalId, cancellationSource);\n        const result = [];\n        const context = { terminal: terminal.value, line };\n        const promises = [];\n        for (const provider of this._linkProviders) {\n            promises.push(Promises.withAsyncBody(async (r) => {\n                cancellationSource.token.onCancellationRequested(() => r({ provider, links: [] }));\n                const links = (await provider.provideTerminalLinks(context, cancellationSource.token)) || [];\n                if (!cancellationSource.token.isCancellationRequested) {\n                    r({ provider, links });\n                }\n            }));\n        }\n        const provideResults = await Promise.all(promises);\n        if (cancellationSource.token.isCancellationRequested) {\n            return [];\n        }\n        const cacheLinkMap = ( (new Map()));\n        for (const provideResult of provideResults) {\n            if (provideResult && provideResult.links.length > 0) {\n                result.push(...( (provideResult.links.map(providerLink => {\n                    const link = {\n                        id: nextLinkId++,\n                        startIndex: providerLink.startIndex,\n                        length: providerLink.length,\n                        label: providerLink.tooltip\n                    };\n                    cacheLinkMap.set(link.id, {\n                        provider: provideResult.provider,\n                        link: providerLink\n                    });\n                    return link;\n                }))));\n            }\n        }\n        this._terminalLinkCache.set(terminalId, cacheLinkMap);\n        return result;\n    }\n    $activateLink(terminalId, linkId) {\n        const cachedLink = this._terminalLinkCache.get(terminalId)?.get(linkId);\n        if (!cachedLink) {\n            return;\n        }\n        cachedLink.provider.handleTerminalLink(cachedLink.link);\n    }\n    _onProcessExit(id, exitCode) {\n        this._bufferer.stopBuffering(id);\n        this._terminalProcesses.delete(id);\n        delete this._extensionTerminalAwaitingStart[id];\n        const processDiposable = this._terminalProcessDisposables[id];\n        if (processDiposable) {\n            processDiposable.dispose();\n            delete this._terminalProcessDisposables[id];\n        }\n        this._proxy.$sendProcessExit(id, exitCode);\n    }\n    getTerminalById(id) {\n        return this._getTerminalObjectById(this._terminals, id);\n    }\n    getTerminalIdByApiObject(terminal) {\n        const index = this._terminals.findIndex(item => {\n            return item.value === terminal;\n        });\n        return index >= 0 ? index : null;\n    }\n    _getTerminalObjectById(array, id) {\n        const index = this._getTerminalObjectIndexById(array, id);\n        return index !== null ? array[index] : null;\n    }\n    _getTerminalObjectIndexById(array, id) {\n        const index = array.findIndex(item => {\n            return item._id === id;\n        });\n        return index >= 0 ? index : null;\n    }\n    getEnvironmentVariableCollection(extension) {\n        let collection = this._environmentVariableCollections.get(extension.identifier.value);\n        if (!collection) {\n            collection = this._register(( (new UnifiedEnvironmentVariableCollection())));\n            this._setEnvironmentVariableCollection(extension.identifier.value, collection);\n        }\n        return collection.getScopedEnvironmentVariableCollection(undefined);\n    }\n    _syncEnvironmentVariableCollection(extensionIdentifier, collection) {\n        const serialized = serializeEnvironmentVariableCollection(collection.map);\n        const serializedDescription = serializeEnvironmentDescriptionMap(collection.descriptionMap);\n        this._proxy.$setEnvironmentVariableCollection(extensionIdentifier, collection.persistent, serialized.length === 0 ? undefined : serialized, serializedDescription);\n    }\n    $initEnvironmentVariableCollections(collections) {\n        collections.forEach(entry => {\n            const extensionIdentifier = entry[0];\n            const collection = this._register(( (new UnifiedEnvironmentVariableCollection(entry[1]))));\n            this._setEnvironmentVariableCollection(extensionIdentifier, collection);\n        });\n    }\n    $acceptDefaultProfile(profile, automationProfile) {\n        const oldProfile = this._defaultProfile;\n        this._defaultProfile = profile;\n        this._defaultAutomationProfile = automationProfile;\n        if (oldProfile?.path !== profile.path) {\n            this._onDidChangeShell.fire(profile.path);\n        }\n    }\n    _setEnvironmentVariableCollection(extensionIdentifier, collection) {\n        this._environmentVariableCollections.set(extensionIdentifier, collection);\n        this._register(collection.onDidChangeCollection(() => {\n            this._syncEnvironmentVariableCollection(extensionIdentifier, collection);\n        }));\n    }\n};\nBaseExtHostTerminalService = ( (__decorate([\n    ( (__param(1, IExtHostCommands))),\n    ( (__param(2, IExtHostRpcService)))\n], BaseExtHostTerminalService)));\nclass UnifiedEnvironmentVariableCollection extends Disposable {\n    get persistent() { return this._persistent; }\n    set persistent(value) {\n        this._persistent = value;\n        this._onDidChangeCollection.fire();\n    }\n    get onDidChangeCollection() { return this._onDidChangeCollection && this._onDidChangeCollection.event; }\n    constructor(serialized) {\n        super();\n        this.map = ( (new Map()));\n        this.scopedCollections = ( (new Map()));\n        this.descriptionMap = ( (new Map()));\n        this._persistent = true;\n        this._onDidChangeCollection = ( (new Emitter()));\n        this.map = ( (new Map(serialized)));\n    }\n    getScopedEnvironmentVariableCollection(scope) {\n        const scopedCollectionKey = this.getScopeKey(scope);\n        let scopedCollection = this.scopedCollections.get(scopedCollectionKey);\n        if (!scopedCollection) {\n            scopedCollection = ( (new ScopedEnvironmentVariableCollection(this, scope)));\n            this.scopedCollections.set(scopedCollectionKey, scopedCollection);\n            this._register(scopedCollection.onDidChangeCollection(() => this._onDidChangeCollection.fire()));\n        }\n        return scopedCollection;\n    }\n    replace(variable, value, options, scope) {\n        this._setIfDiffers(variable, { value, type: EnvironmentVariableMutatorType.Replace, options: options ?? { applyAtProcessCreation: true }, scope });\n    }\n    append(variable, value, options, scope) {\n        this._setIfDiffers(variable, { value, type: EnvironmentVariableMutatorType.Append, options: options ?? { applyAtProcessCreation: true }, scope });\n    }\n    prepend(variable, value, options, scope) {\n        this._setIfDiffers(variable, { value, type: EnvironmentVariableMutatorType.Prepend, options: options ?? { applyAtProcessCreation: true }, scope });\n    }\n    _setIfDiffers(variable, mutator) {\n        if (mutator.options && mutator.options.applyAtProcessCreation === false && !mutator.options.applyAtShellIntegration) {\n            throw ( (new Error(\n                'EnvironmentVariableMutatorOptions must apply at either process creation or shell integration'\n            )));\n        }\n        const key = this.getKey(variable, mutator.scope);\n        const current = this.map.get(key);\n        const newOptions = mutator.options ? {\n            applyAtProcessCreation: mutator.options.applyAtProcessCreation ?? false,\n            applyAtShellIntegration: mutator.options.applyAtShellIntegration ?? false,\n        } : {\n            applyAtProcessCreation: true\n        };\n        if (!current ||\n            current.value !== mutator.value ||\n            current.type !== mutator.type ||\n            current.options?.applyAtProcessCreation !== newOptions.applyAtProcessCreation ||\n            current.options?.applyAtShellIntegration !== newOptions.applyAtShellIntegration ||\n            current.scope?.workspaceFolder?.index !== mutator.scope?.workspaceFolder?.index) {\n            const key = this.getKey(variable, mutator.scope);\n            const value = {\n                variable,\n                ...mutator,\n                options: newOptions\n            };\n            this.map.set(key, value);\n            this._onDidChangeCollection.fire();\n        }\n    }\n    get(variable, scope) {\n        const key = this.getKey(variable, scope);\n        const value = this.map.get(key);\n        return value ? convertMutator(value) : undefined;\n    }\n    getKey(variable, scope) {\n        const scopeKey = this.getScopeKey(scope);\n        return scopeKey.length ? `${variable}:::${scopeKey}` : variable;\n    }\n    getScopeKey(scope) {\n        return this.getWorkspaceKey(scope?.workspaceFolder) ?? '';\n    }\n    getWorkspaceKey(workspaceFolder) {\n        return workspaceFolder ? ( (workspaceFolder.uri.toString())) : undefined;\n    }\n    getVariableMap(scope) {\n        const map = ( (new Map()));\n        for (const [_, value] of this.map) {\n            if (this.getScopeKey(value.scope) === this.getScopeKey(scope)) {\n                map.set(value.variable, convertMutator(value));\n            }\n        }\n        return map;\n    }\n    delete(variable, scope) {\n        const key = this.getKey(variable, scope);\n        this.map.delete(key);\n        this._onDidChangeCollection.fire();\n    }\n    clear(scope) {\n        if (scope?.workspaceFolder) {\n            for (const [key, mutator] of this.map) {\n                if (mutator.scope?.workspaceFolder?.index === scope.workspaceFolder.index) {\n                    this.map.delete(key);\n                }\n            }\n            this.clearDescription(scope);\n        }\n        else {\n            this.map.clear();\n            this.descriptionMap.clear();\n        }\n        this._onDidChangeCollection.fire();\n    }\n    setDescription(description, scope) {\n        const key = this.getScopeKey(scope);\n        const current = this.descriptionMap.get(key);\n        if (!current || current.description !== description) {\n            let descriptionStr;\n            if (typeof description === 'string') {\n                descriptionStr = description;\n            }\n            else {\n                descriptionStr = description?.value.split('\\n\\n')[0];\n            }\n            const value = { description: descriptionStr, scope };\n            this.descriptionMap.set(key, value);\n            this._onDidChangeCollection.fire();\n        }\n    }\n    getDescription(scope) {\n        const key = this.getScopeKey(scope);\n        return this.descriptionMap.get(key)?.description;\n    }\n    clearDescription(scope) {\n        const key = this.getScopeKey(scope);\n        this.descriptionMap.delete(key);\n    }\n}\nclass ScopedEnvironmentVariableCollection {\n    get persistent() { return this.collection.persistent; }\n    set persistent(value) {\n        this.collection.persistent = value;\n    }\n    get onDidChangeCollection() { return this._onDidChangeCollection && this._onDidChangeCollection.event; }\n    constructor(collection, scope) {\n        this.collection = collection;\n        this.scope = scope;\n        this._onDidChangeCollection = ( (new Emitter()));\n    }\n    getScoped(scope) {\n        return this.collection.getScopedEnvironmentVariableCollection(scope);\n    }\n    replace(variable, value, options) {\n        this.collection.replace(variable, value, options, this.scope);\n    }\n    append(variable, value, options) {\n        this.collection.append(variable, value, options, this.scope);\n    }\n    prepend(variable, value, options) {\n        this.collection.prepend(variable, value, options, this.scope);\n    }\n    get(variable) {\n        return this.collection.get(variable, this.scope);\n    }\n    forEach(callback, thisArg) {\n        this.collection.getVariableMap(this.scope).forEach((value, variable) => callback.call(thisArg, variable, value, this), this.scope);\n    }\n    [Symbol.iterator]() {\n        return this.collection.getVariableMap(this.scope).entries();\n    }\n    delete(variable) {\n        this.collection.delete(variable, this.scope);\n        this._onDidChangeCollection.fire(undefined);\n    }\n    clear() {\n        this.collection.clear(this.scope);\n    }\n    set description(description) {\n        this.collection.setDescription(description, this.scope);\n    }\n    get description() {\n        return this.collection.getDescription(this.scope);\n    }\n}\nlet WorkerExtHostTerminalService = class WorkerExtHostTerminalService extends BaseExtHostTerminalService {\n    constructor(extHostCommands, extHostRpc) {\n        super(false, extHostCommands, extHostRpc);\n    }\n    createTerminal(name, shellPath, shellArgs) {\n        throw ( (new NotSupportedError()));\n    }\n    createTerminalFromOptions(options, internalOptions) {\n        throw ( (new NotSupportedError()));\n    }\n};\nWorkerExtHostTerminalService = ( (__decorate([\n    ( (__param(0, IExtHostCommands))),\n    ( (__param(1, IExtHostRpcService)))\n], WorkerExtHostTerminalService)));\nfunction asTerminalIcon(iconPath) {\n    if (!iconPath || typeof iconPath === 'string') {\n        return undefined;\n    }\n    if (!('id' in iconPath)) {\n        return iconPath;\n    }\n    return {\n        id: iconPath.id,\n        color: iconPath.color\n    };\n}\nfunction asTerminalColor(color) {\n    return ThemeColor.isThemeColor(color) ? color : undefined;\n}\nfunction convertMutator(mutator) {\n    const newMutator = { ...mutator };\n    delete newMutator.scope;\n    newMutator.options = newMutator.options ?? undefined;\n    delete newMutator.variable;\n    return newMutator;\n}\nexport { BaseExtHostTerminalService, ExtHostTerminal, IExtHostTerminalService, WorkerExtHostTerminalService };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { TerminalShellExecutionCommandLineConfidence } from './extHostTypes.js';\nimport { Disposable, toDisposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\nimport { IExtHostTerminalService } from './extHostTerminalService.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { AsyncIterableObject, Barrier } from '../../../base/common/async.js';\nconst IExtHostTerminalShellIntegration = ( createDecorator('IExtHostTerminalShellIntegration'));\nlet ExtHostTerminalShellIntegration = class ExtHostTerminalShellIntegration extends Disposable {\n    constructor(extHostRpc, _extHostTerminalService) {\n        super();\n        this._extHostTerminalService = _extHostTerminalService;\n        this._activeShellIntegrations = ( new Map());\n        this._onDidChangeTerminalShellIntegration = ( new Emitter());\n        this.onDidChangeTerminalShellIntegration = this._onDidChangeTerminalShellIntegration.event;\n        this._onDidStartTerminalShellExecution = ( new Emitter());\n        this.onDidStartTerminalShellExecution = this._onDidStartTerminalShellExecution.event;\n        this._onDidEndTerminalShellExecution = ( new Emitter());\n        this.onDidEndTerminalShellExecution = this._onDidEndTerminalShellExecution.event;\n        this._proxy = ( extHostRpc.getProxy(MainContext.MainThreadTerminalShellIntegration));\n        this._register(toDisposable(() => {\n            for (const [_, integration] of this._activeShellIntegrations) {\n                integration.dispose();\n            }\n            this._activeShellIntegrations.clear();\n        }));\n    }\n    $shellIntegrationChange(instanceId) {\n        const terminal = this._extHostTerminalService.getTerminalById(instanceId);\n        if (!terminal) {\n            return;\n        }\n        const apiTerminal = terminal.value;\n        let shellIntegration = this._activeShellIntegrations.get(instanceId);\n        if (!shellIntegration) {\n            shellIntegration = ( new InternalTerminalShellIntegration(terminal.value, this._onDidStartTerminalShellExecution));\n            this._activeShellIntegrations.set(instanceId, shellIntegration);\n            shellIntegration.store.add(terminal.onWillDispose(() => this._activeShellIntegrations.get(instanceId)?.dispose()));\n            shellIntegration.store.add(shellIntegration.onDidRequestShellExecution(commandLine => this._proxy.$executeCommand(instanceId, commandLine)));\n            shellIntegration.store.add(shellIntegration.onDidRequestEndExecution(e => this._onDidEndTerminalShellExecution.fire(e)));\n            shellIntegration.store.add(shellIntegration.onDidRequestChangeShellIntegration(e => this._onDidChangeTerminalShellIntegration.fire(e)));\n            terminal.shellIntegration = shellIntegration.value;\n        }\n        this._onDidChangeTerminalShellIntegration.fire({\n            terminal: apiTerminal,\n            shellIntegration: shellIntegration.value\n        });\n    }\n    $shellExecutionStart(instanceId, commandLineValue, commandLineConfidence, isTrusted, cwd) {\n        if (!( this._activeShellIntegrations.has(instanceId))) {\n            this.$shellIntegrationChange(instanceId);\n        }\n        const commandLine = {\n            value: commandLineValue,\n            confidence: commandLineConfidence,\n            isTrusted\n        };\n        this._activeShellIntegrations.get(instanceId)?.startShellExecution(commandLine, URI.revive(cwd));\n    }\n    $shellExecutionEnd(instanceId, commandLineValue, commandLineConfidence, isTrusted, exitCode) {\n        const commandLine = {\n            value: commandLineValue,\n            confidence: commandLineConfidence,\n            isTrusted\n        };\n        this._activeShellIntegrations.get(instanceId)?.endShellExecution(commandLine, exitCode);\n    }\n    $shellExecutionData(instanceId, data) {\n        this._activeShellIntegrations.get(instanceId)?.emitData(data);\n    }\n    $cwdChange(instanceId, cwd) {\n        this._activeShellIntegrations.get(instanceId)?.setCwd(URI.revive(cwd));\n    }\n    $closeTerminal(instanceId) {\n        this._activeShellIntegrations.get(instanceId)?.dispose();\n        this._activeShellIntegrations.delete(instanceId);\n    }\n};\nExtHostTerminalShellIntegration = ( __decorate([\n    ( __param(0, IExtHostRpcService)),\n    ( __param(1, IExtHostTerminalService))\n], ExtHostTerminalShellIntegration));\nclass InternalTerminalShellIntegration extends Disposable {\n    get currentExecution() { return this._currentExecution; }\n    constructor(_terminal, _onDidStartTerminalShellExecution) {\n        super();\n        this._terminal = _terminal;\n        this._onDidStartTerminalShellExecution = _onDidStartTerminalShellExecution;\n        this._ignoreNextExecution = false;\n        this.store = this._register(( new DisposableStore()));\n        this._onDidRequestChangeShellIntegration = this._register(( new Emitter()));\n        this.onDidRequestChangeShellIntegration = this._onDidRequestChangeShellIntegration.event;\n        this._onDidRequestShellExecution = this._register(( new Emitter()));\n        this.onDidRequestShellExecution = this._onDidRequestShellExecution.event;\n        this._onDidRequestEndExecution = this._register(( new Emitter()));\n        this.onDidRequestEndExecution = this._onDidRequestEndExecution.event;\n        const that = this;\n        this.value = {\n            get cwd() {\n                return that._cwd;\n            },\n            executeCommand(commandLineOrExecutable, args) {\n                let commandLineValue = commandLineOrExecutable;\n                if (args) {\n                    commandLineValue += ` \"${( args.map(e => `${e.replaceAll('\"', '\\\\\"')}`)).join('\" \"')}\"`;\n                }\n                that._onDidRequestShellExecution.fire(commandLineValue);\n                const commandLine = {\n                    value: commandLineValue,\n                    confidence: TerminalShellExecutionCommandLineConfidence.High,\n                    isTrusted: true\n                };\n                const execution = that.startShellExecution(commandLine, that._cwd, true).value;\n                that._ignoreNextExecution = true;\n                return execution;\n            }\n        };\n    }\n    startShellExecution(commandLine, cwd, fireEventInMicrotask) {\n        if (this._ignoreNextExecution && this._currentExecution) {\n            this._ignoreNextExecution = false;\n        }\n        else {\n            if (this._currentExecution) {\n                this._currentExecution.endExecution(undefined);\n                this._onDidRequestEndExecution.fire({ terminal: this._terminal, shellIntegration: this.value, execution: this._currentExecution.value, exitCode: undefined });\n            }\n            const currentExecution = this._currentExecution = ( new InternalTerminalShellExecution(commandLine, cwd ?? this._cwd));\n            if (fireEventInMicrotask) {\n                queueMicrotask(() => this._onDidStartTerminalShellExecution.fire({ terminal: this._terminal, shellIntegration: this.value, execution: currentExecution.value }));\n            }\n            else {\n                this._onDidStartTerminalShellExecution.fire({ terminal: this._terminal, shellIntegration: this.value, execution: this._currentExecution.value });\n            }\n        }\n        return this._currentExecution;\n    }\n    emitData(data) {\n        this.currentExecution?.emitData(data);\n    }\n    endShellExecution(commandLine, exitCode) {\n        if (this._currentExecution) {\n            this._currentExecution.endExecution(commandLine);\n            this._onDidRequestEndExecution.fire({ terminal: this._terminal, shellIntegration: this.value, execution: this._currentExecution.value, exitCode });\n            this._currentExecution = undefined;\n        }\n    }\n    setCwd(cwd) {\n        let wasChanged = false;\n        if (URI.isUri(this._cwd)) {\n            wasChanged = !URI.isUri(cwd) || ( this._cwd.toString()) !== ( cwd.toString());\n        }\n        else if (this._cwd !== cwd) {\n            wasChanged = true;\n        }\n        if (wasChanged) {\n            this._cwd = cwd;\n            this._onDidRequestChangeShellIntegration.fire({ terminal: this._terminal, shellIntegration: this.value });\n        }\n    }\n}\nclass InternalTerminalShellExecution {\n    constructor(_commandLine, cwd) {\n        this._commandLine = _commandLine;\n        this.cwd = cwd;\n        this._ended = false;\n        const that = this;\n        this.value = {\n            get commandLine() {\n                return that._commandLine;\n            },\n            get cwd() {\n                return that.cwd;\n            },\n            read() {\n                return that._createDataStream();\n            }\n        };\n    }\n    _createDataStream() {\n        if (!this._dataStream) {\n            if (this._ended) {\n                return AsyncIterableObject.EMPTY;\n            }\n            this._dataStream = ( new ShellExecutionDataStream());\n        }\n        return this._dataStream.createIterable();\n    }\n    emitData(data) {\n        this._dataStream?.emitData(data);\n    }\n    endExecution(commandLine) {\n        if (commandLine) {\n            this._commandLine = commandLine;\n        }\n        this._dataStream?.endExecution();\n        this._dataStream = undefined;\n        this._ended = true;\n    }\n}\nclass ShellExecutionDataStream extends Disposable {\n    constructor() {\n        super(...arguments);\n        this._emitters = [];\n    }\n    createIterable() {\n        if (!this._barrier) {\n            this._barrier = ( new Barrier());\n        }\n        const barrier = this._barrier;\n        const iterable = ( new AsyncIterableObject(async (emitter) => {\n            this._emitters.push(emitter);\n            await barrier.wait();\n        }));\n        return iterable;\n    }\n    emitData(data) {\n        for (const emitter of this._emitters) {\n            emitter.emitOne(data);\n        }\n    }\n    endExecution() {\n        this._barrier?.open();\n        this._barrier = undefined;\n    }\n}\nexport { ExtHostTerminalShellIntegration, IExtHostTerminalShellIntegration };\n","import { Range } from '../../../editor/common/core/range.js';\nimport { createPrivateApiFor, getPrivateApiFor } from './extHostTestingPrivateApi.js';\nimport { TestId } from '../../contrib/testing/common/testId.js';\nimport { createTestItemChildren, TestItemCollection } from '../../contrib/testing/common/testItemCollection.js';\nimport { denamespaceTestTag } from '../../contrib/testing/common/testTypes.js';\nimport { TestTag, Range as Range$1, MarkdownString, TestItem } from './extHostTypeConverters.js';\nimport { URI } from '../../../base/common/uri.js';\nconst testItemPropAccessor = (api, defaultValue, equals, toUpdate) => {\n    let value = defaultValue;\n    return {\n        enumerable: true,\n        configurable: false,\n        get() {\n            return value;\n        },\n        set(newValue) {\n            if (!equals(value, newValue)) {\n                const oldValue = value;\n                value = newValue;\n                api.listener?.(toUpdate(newValue, oldValue));\n            }\n        },\n    };\n};\nconst strictEqualComparator = (a, b) => a === b;\nconst propComparators = {\n    range: (a, b) => {\n        if (a === b) {\n            return true;\n        }\n        if (!a || !b) {\n            return false;\n        }\n        return a.isEqual(b);\n    },\n    label: strictEqualComparator,\n    description: strictEqualComparator,\n    sortText: strictEqualComparator,\n    busy: strictEqualComparator,\n    error: strictEqualComparator,\n    canResolveChildren: strictEqualComparator,\n    tags: (a, b) => {\n        if (a.length !== b.length) {\n            return false;\n        }\n        if (( a.some(t1 => !b.find(t2 => t1.id === t2.id)))) {\n            return false;\n        }\n        return true;\n    },\n};\nconst evSetProps = (fn) => v => ({ op: 4 , update: fn(v) });\nconst makePropDescriptors = (api, label) => ({\n    range: (() => {\n        let value;\n        const updateProps = evSetProps(r => ({ range: Range.lift(Range$1.from(r)) }));\n        return {\n            enumerable: true,\n            configurable: false,\n            get() {\n                return value;\n            },\n            set(newValue) {\n                api.listener?.({ op: 6  });\n                if (!propComparators.range(value, newValue)) {\n                    value = newValue;\n                    api.listener?.(updateProps(newValue));\n                }\n            },\n        };\n    })(),\n    label: testItemPropAccessor(api, label, propComparators.label, evSetProps(label => ({ label }))),\n    description: testItemPropAccessor(api, undefined, propComparators.description, evSetProps(description => ({ description }))),\n    sortText: testItemPropAccessor(api, undefined, propComparators.sortText, evSetProps(sortText => ({ sortText }))),\n    canResolveChildren: testItemPropAccessor(api, false, propComparators.canResolveChildren, state => ({\n        op: 2 ,\n        state,\n    })),\n    busy: testItemPropAccessor(api, false, propComparators.busy, evSetProps(busy => ({ busy }))),\n    error: testItemPropAccessor(api, undefined, propComparators.error, evSetProps(error => ({ error: MarkdownString.fromStrict(error) || null }))),\n    tags: testItemPropAccessor(api, [], propComparators.tags, (current, previous) => ({\n        op: 1 ,\n        new: ( current.map(TestTag.from)),\n        old: ( previous.map(TestTag.from)),\n    })),\n});\nconst toItemFromPlain = (item) => {\n    const testId = TestId.fromString(item.extId);\n    const testItem = ( new TestItemImpl(\n        testId.controllerId,\n        testId.localId,\n        item.label,\n        URI.revive(item.uri) || undefined\n    ));\n    testItem.range = Range$1.to(item.range || undefined);\n    testItem.description = item.description || undefined;\n    testItem.sortText = item.sortText || undefined;\n    testItem.tags = ( item.tags.map(t => TestTag.to({ id: denamespaceTestTag(t).tagId })));\n    return testItem;\n};\nconst toItemFromContext = (context) => {\n    let node;\n    for (const test of context.tests) {\n        const next = toItemFromPlain(test.item);\n        getPrivateApiFor(next).parent = node;\n        node = next;\n    }\n    return node;\n};\nclass TestItemImpl {\n    constructor(controllerId, id, label, uri) {\n        if (id.includes(\"\\0\" )) {\n            throw ( new Error(`Test IDs may not include the ${JSON.stringify(id)} symbol`));\n        }\n        const api = createPrivateApiFor(this, controllerId);\n        Object.defineProperties(this, {\n            id: {\n                value: id,\n                enumerable: true,\n                writable: false,\n            },\n            uri: {\n                value: uri,\n                enumerable: true,\n                writable: false,\n            },\n            parent: {\n                enumerable: false,\n                get() {\n                    return api.parent instanceof TestItemRootImpl ? undefined : api.parent;\n                },\n            },\n            children: {\n                value: createTestItemChildren(api, getPrivateApiFor, TestItemImpl),\n                enumerable: true,\n                writable: false,\n            },\n            ...makePropDescriptors(api, label),\n        });\n    }\n}\nclass TestItemRootImpl extends TestItemImpl {\n    constructor(controllerId, label) {\n        super(controllerId, controllerId, label, undefined);\n        this._isRoot = true;\n    }\n}\nclass ExtHostTestItemCollection extends TestItemCollection {\n    constructor(controllerId, controllerLabel, editors) {\n        super({\n            controllerId,\n            getDocumentVersion: uri => uri && editors.getDocument(uri)?.version,\n            getApiFor: getPrivateApiFor,\n            getChildren: (item) => item.children,\n            root: ( new TestItemRootImpl(controllerId, controllerLabel)),\n            toITestItem: TestItem.from,\n        });\n    }\n}\nexport { ExtHostTestItemCollection, TestItemImpl, TestItemRootImpl, toItemFromContext };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { createSingleCallFunction } from '../../../base/common/functional.js';\nimport { hash } from '../../../base/common/hash.js';\nimport { Disposable, toDisposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport { isDefined } from '../../../base/common/types.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { generateUuid } from '../../../base/common/uuid.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { ILogService } from '../../../platform/log/common/log.service.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { IExtHostCommands } from './extHostCommands.js';\nimport { IExtHostDocumentsAndEditors } from './extHostDocumentsAndEditors.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\nimport { toItemFromContext, ExtHostTestItemCollection, TestItemImpl, TestItemRootImpl } from './extHostTestItem.js';\nimport { TestMessage, Position, location, TestCoverage, TestResults, TestTag, TestItem, Range } from './extHostTypeConverters.js';\nimport { TestRunProfileKind, TestRunRequest, FileCoverage } from './extHostTypes.js';\nimport { TestId } from '../../contrib/testing/common/testId.js';\nimport { InvalidTestItemError } from '../../contrib/testing/common/testItemCollection.js';\nimport { TestsDiffOp, isStartControllerTests, AbstractIncrementalTestCollection } from '../../contrib/testing/common/testTypes.js';\nimport { checkProposedApiEnabled } from '../../services/extensions/common/extensions.js';\nlet followupCounter = 0;\nconst testResultInternalIDs = ( new WeakMap());\nconst IExtHostTesting = ( createDecorator('IExtHostTesting'));\nlet ExtHostTesting = class ExtHostTesting extends Disposable {\n    constructor(rpc, logService, commands, editors) {\n        super();\n        this.logService = logService;\n        this.commands = commands;\n        this.editors = editors;\n        this.resultsChangedEmitter = this._register(( new Emitter()));\n        this.controllers = ( new Map());\n        this.defaultProfilesChangedEmitter = this._register(( new Emitter()));\n        this.followupProviders = ( new Set());\n        this.testFollowups = ( new Map());\n        this.onResultsChanged = this.resultsChangedEmitter.event;\n        this.results = [];\n        this.proxy = ( rpc.getProxy(MainContext.MainThreadTesting));\n        this.observer = ( new TestObservers(this.proxy));\n        this.runTracker = ( new TestRunCoordinator(this.proxy, logService));\n        commands.registerArgumentProcessor({\n            processArgument: arg => {\n                switch (arg?.$mid) {\n                    case 16 : {\n                        const cast = arg;\n                        const targetTest = cast.tests[cast.tests.length - 1].item.extId;\n                        const controller = this.controllers.get(TestId.root(targetTest));\n                        return controller?.collection.tree.get(targetTest)?.actual ?? toItemFromContext(arg);\n                    }\n                    case 18 : {\n                        const { test, message } = arg;\n                        const extId = test.item.extId;\n                        return {\n                            test: this.controllers.get(TestId.root(extId))?.collection.tree.get(extId)?.actual\n                                ?? toItemFromContext({ $mid: 16 , tests: [test] }),\n                            message: TestMessage.to(message),\n                        };\n                    }\n                    default: return arg;\n                }\n            }\n        });\n        commands.registerCommand(false, 'testing.getExplorerSelection', async () => {\n            const inner = await commands.executeCommand(\"_testing.getExplorerSelection\" );\n            const lookup = (i) => {\n                const controller = this.controllers.get(TestId.root(i));\n                if (!controller) {\n                    return undefined;\n                }\n                return TestId.isRoot(i) ? controller.controller : controller.collection.tree.get(i)?.actual;\n            };\n            return {\n                include: inner?.include.map(lookup).filter(isDefined) || [],\n                exclude: inner?.exclude.map(lookup).filter(isDefined) || [],\n            };\n        });\n    }\n    createTestController(extension, controllerId, label, refreshHandler) {\n        if (( this.controllers.has(controllerId))) {\n            throw ( new Error(`Attempt to insert a duplicate controller with ID \"${controllerId}\"`));\n        }\n        const disposable = ( new DisposableStore());\n        const collection = disposable.add(( new ExtHostTestItemCollection(controllerId, label, this.editors)));\n        collection.root.label = label;\n        const profiles = ( new Map());\n        const activeProfiles = ( new Set());\n        const proxy = this.proxy;\n        const getCapability = () => {\n            let cap = 0;\n            if (refreshHandler) {\n                cap |= 2 ;\n            }\n            const rcp = info.relatedCodeProvider;\n            if (rcp) {\n                if (rcp?.provideRelatedTests) {\n                    cap |= 8 ;\n                }\n                if (rcp?.provideRelatedCode) {\n                    cap |= 4 ;\n                }\n            }\n            return cap;\n        };\n        const controller = {\n            items: collection.root.children,\n            get label() {\n                return label;\n            },\n            set label(value) {\n                label = value;\n                collection.root.label = value;\n                proxy.$updateController(controllerId, { label });\n            },\n            get refreshHandler() {\n                return refreshHandler;\n            },\n            set refreshHandler(value) {\n                refreshHandler = value;\n                proxy.$updateController(controllerId, { capabilities: getCapability() });\n            },\n            get id() {\n                return controllerId;\n            },\n            get relatedCodeProvider() {\n                return info.relatedCodeProvider;\n            },\n            set relatedCodeProvider(value) {\n                checkProposedApiEnabled(extension, 'testRelatedCode');\n                info.relatedCodeProvider = value;\n                proxy.$updateController(controllerId, { capabilities: getCapability() });\n            },\n            createRunProfile: (label, group, runHandler, isDefault, tag, supportsContinuousRun) => {\n                let profileId = hash(label);\n                while (( profiles.has(profileId))) {\n                    profileId++;\n                }\n                return ( new TestRunProfileImpl(\n                    this.proxy,\n                    profiles,\n                    activeProfiles,\n                    this.defaultProfilesChangedEmitter.event,\n                    controllerId,\n                    profileId,\n                    label,\n                    group,\n                    runHandler,\n                    isDefault,\n                    tag,\n                    supportsContinuousRun\n                ));\n            },\n            createTestItem(id, label, uri) {\n                return ( new TestItemImpl(controllerId, id, label, uri));\n            },\n            createTestRun: (request, name, persist = true) => {\n                return this.runTracker.createTestRun(extension, controllerId, collection, request, name, persist);\n            },\n            invalidateTestResults: items => {\n                if (items === undefined) {\n                    this.proxy.$markTestRetired(undefined);\n                }\n                else {\n                    const itemsArr = items instanceof Array ? items : [items];\n                    this.proxy.$markTestRetired(( itemsArr.map(i => ( TestId.fromExtHostTestItem(i, controllerId).toString()))));\n                }\n            },\n            set resolveHandler(fn) {\n                collection.resolveHandler = fn;\n            },\n            get resolveHandler() {\n                return collection.resolveHandler;\n            },\n            dispose: () => {\n                disposable.dispose();\n            },\n        };\n        const info = { controller, collection, profiles, extension, activeProfiles };\n        proxy.$registerTestController(controllerId, label, getCapability());\n        disposable.add(toDisposable(() => proxy.$unregisterTestController(controllerId)));\n        this.controllers.set(controllerId, info);\n        disposable.add(toDisposable(() => this.controllers.delete(controllerId)));\n        disposable.add(collection.onDidGenerateDiff(diff => proxy.$publishDiff(controllerId, ( diff.map(TestsDiffOp.serialize)))));\n        return controller;\n    }\n    createTestObserver() {\n        return this.observer.checkout();\n    }\n    async runTests(req, token = CancellationToken.None) {\n        const profile = tryGetProfileFromTestRunReq(req);\n        if (!profile) {\n            throw ( new Error('The request passed to `vscode.test.runTests` must include a profile'));\n        }\n        const controller = this.controllers.get(profile.controllerId);\n        if (!controller) {\n            throw ( new Error('Controller not found'));\n        }\n        await this.proxy.$runTests({\n            preserveFocus: req.preserveFocus ?? true,\n            group: profileGroupToBitset[profile.kind],\n            targets: [{\n                    testIds: req.include?.map(t => ( TestId.fromExtHostTestItem(t, controller.collection.root.id).toString())) ?? [controller.collection.root.id],\n                    profileId: profile.profileId,\n                    controllerId: profile.controllerId,\n                }],\n            exclude: req.exclude?.map(t => t.id),\n        }, token);\n    }\n    registerTestFollowupProvider(provider) {\n        this.followupProviders.add(provider);\n        return { dispose: () => { this.followupProviders.delete(provider); } };\n    }\n    async $getTestsRelatedToCode(uri, _position, token) {\n        const doc = this.editors.getDocument(URI.revive(uri));\n        if (!doc) {\n            return [];\n        }\n        const position = Position.to(_position);\n        const related = [];\n        await Promise.all(( [...( this.controllers.values())].map(async (c) => {\n            let tests;\n            try {\n                tests = await c.relatedCodeProvider?.provideRelatedTests?.(doc.document, position, token);\n            }\n            catch (e) {\n                if (!token.isCancellationRequested) {\n                    this.logService.warn(`Error thrown while providing related tests for ${c.controller.label}`, e);\n                }\n            }\n            if (tests) {\n                for (const test of tests) {\n                    related.push(( TestId.fromExtHostTestItem(test, c.controller.id).toString()));\n                }\n                c.collection.flushDiff();\n            }\n        })));\n        return related;\n    }\n    async $getCodeRelatedToTest(testId, token) {\n        const controller = this.controllers.get(TestId.root(testId));\n        if (!controller) {\n            return [];\n        }\n        const test = controller.collection.tree.get(testId);\n        if (!test) {\n            return [];\n        }\n        const locations = await controller.relatedCodeProvider?.provideRelatedCode?.(test.actual, token);\n        return locations?.map(location.from) ?? [];\n    }\n    $syncTests() {\n        for (const { collection } of ( this.controllers.values())) {\n            collection.flushDiff();\n        }\n        return Promise.resolve();\n    }\n    async $getCoverageDetails(coverageId, testId, token) {\n        const details = await this.runTracker.getCoverageDetails(coverageId, testId, token);\n        return details?.map(TestCoverage.fromDetails);\n    }\n    async $disposeRun(runId) {\n        this.runTracker.disposeTestRun(runId);\n    }\n    $configureRunProfile(controllerId, profileId) {\n        this.controllers.get(controllerId)?.profiles.get(profileId)?.configureHandler?.();\n    }\n    $setDefaultRunProfiles(profiles) {\n        const evt = ( new Map());\n        for (const [controllerId, profileIds] of Object.entries(profiles)) {\n            const ctrl = this.controllers.get(controllerId);\n            if (!ctrl) {\n                continue;\n            }\n            const changes = ( new Map());\n            const added = profileIds.filter(id => !( ctrl.activeProfiles.has(id)));\n            const removed = [...ctrl.activeProfiles].filter(id => !profileIds.includes(id));\n            for (const id of added) {\n                changes.set(id, true);\n                ctrl.activeProfiles.add(id);\n            }\n            for (const id of removed) {\n                changes.set(id, false);\n                ctrl.activeProfiles.delete(id);\n            }\n            if (changes.size) {\n                evt.set(controllerId, changes);\n            }\n        }\n        this.defaultProfilesChangedEmitter.fire(evt);\n    }\n    async $refreshTests(controllerId, token) {\n        await this.controllers.get(controllerId)?.controller.refreshHandler?.(token);\n    }\n    $publishTestResults(results) {\n        this.results = ( Object.freeze(( results\n            .map(r => {\n            const o = TestResults.to(r);\n            const taskWithCoverage = r.tasks.findIndex(t => t.hasCoverage);\n            if (taskWithCoverage !== -1) {\n                o.getDetailedCoverage = (uri, token = CancellationToken.None) => this.proxy.$getCoverageDetails(r.id, taskWithCoverage, uri, token).then(r => ( r.map(TestCoverage.to)));\n            }\n            testResultInternalIDs.set(o, r.id);\n            return o;\n        }))\n            .concat(this.results)\n            .sort((a, b) => b.completedAt - a.completedAt)\n            .slice(0, 32)));\n        this.resultsChangedEmitter.fire();\n    }\n    async $expandTest(testId, levels) {\n        const collection = this.controllers.get(TestId.fromString(testId).controllerId)?.collection;\n        if (collection) {\n            await collection.expand(testId, levels < 0 ? Infinity : levels);\n            collection.flushDiff();\n        }\n    }\n    $acceptDiff(diff) {\n        this.observer.applyDiff(( diff.map(d => TestsDiffOp.deserialize({ asCanonicalUri: u => u }, d))));\n    }\n    async $runControllerTests(reqs, token) {\n        return Promise.all(( reqs.map(req => this.runControllerTestRequest(req, false, token))));\n    }\n    async $startContinuousRun(reqs, token) {\n        const cts = ( new CancellationTokenSource(token));\n        const res = await Promise.all(( reqs.map(req => this.runControllerTestRequest(req, true, cts.token))));\n        if (!token.isCancellationRequested && !( res.some(r => r.error))) {\n            await ( new Promise(r => token.onCancellationRequested(r)));\n        }\n        cts.dispose(true);\n        return res;\n    }\n    async $provideTestFollowups(req, token) {\n        const results = this.results.find(r => testResultInternalIDs.get(r) === req.resultId);\n        const test = results && findTestInResultSnapshot(TestId.fromString(req.extId), results?.results);\n        if (!test) {\n            return [];\n        }\n        let followups = [];\n        await Promise.all(( [...this.followupProviders].map(async (provider) => {\n            try {\n                const r = await provider.provideFollowup(results, test, req.taskIndex, req.messageIndex, token);\n                if (r) {\n                    followups = followups.concat(r);\n                }\n            }\n            catch (e) {\n                this.logService.error(`Error thrown while providing followup for test message`, e);\n            }\n        })));\n        if (token.isCancellationRequested) {\n            return [];\n        }\n        return ( followups.map(command => {\n            const id = followupCounter++;\n            this.testFollowups.set(id, command);\n            return { title: command.title, id };\n        }));\n    }\n    $disposeTestFollowups(id) {\n        for (const i of id) {\n            this.testFollowups.delete(i);\n        }\n    }\n    $executeTestFollowup(id) {\n        const command = this.testFollowups.get(id);\n        if (!command) {\n            return Promise.resolve();\n        }\n        return this.commands.executeCommand(command.command, ...(command.arguments || []));\n    }\n    $cancelExtensionTestRun(runId, taskId) {\n        if (runId === undefined) {\n            this.runTracker.cancelAllRuns();\n        }\n        else {\n            this.runTracker.cancelRunById(runId, taskId);\n        }\n    }\n    getMetadataForRun(run) {\n        for (const tracker of this.runTracker.trackers) {\n            const taskId = tracker.getTaskIdForRun(run);\n            if (taskId) {\n                return { taskId, runId: tracker.id };\n            }\n        }\n        return undefined;\n    }\n    async runControllerTestRequest(req, isContinuous, token) {\n        const lookup = this.controllers.get(req.controllerId);\n        if (!lookup) {\n            return {};\n        }\n        const { collection, profiles, extension } = lookup;\n        const profile = profiles.get(req.profileId);\n        if (!profile) {\n            return {};\n        }\n        const includeTests = ( req.testIds\n            .map((testId) => collection.tree.get(testId)))\n            .filter(isDefined);\n        const excludeTests = ( req.excludeExtIds\n            .map(id => lookup.collection.tree.get(id)))\n            .filter(isDefined)\n            .filter(exclude => ( includeTests.some(\n            include => include.fullId.compare(exclude.fullId) === 2\n        )));\n        if (!includeTests.length) {\n            return {};\n        }\n        const publicReq = ( new TestRunRequest(( includeTests.some(i => i.actual instanceof TestItemRootImpl)) ? undefined : ( includeTests.map(t => t.actual)), ( excludeTests.map(t => t.actual)), profile, isContinuous));\n        const tracker = isStartControllerTests(req) && this.runTracker.prepareForMainThreadTestRun(extension, publicReq, TestRunDto.fromInternal(req, lookup.collection), profile, token);\n        try {\n            await profile.runHandler(publicReq, token);\n            return {};\n        }\n        catch (e) {\n            return { error: String(e) };\n        }\n        finally {\n            if (tracker) {\n                if (tracker.hasRunningTasks && !token.isCancellationRequested) {\n                    await Event.toPromise(tracker.onEnd);\n                }\n            }\n        }\n    }\n};\nExtHostTesting = ( __decorate([\n    ( __param(0, IExtHostRpcService)),\n    ( __param(1, ILogService)),\n    ( __param(2, IExtHostCommands)),\n    ( __param(3, IExtHostDocumentsAndEditors))\n], ExtHostTesting));\nconst RUN_CANCEL_DEADLINE = 10_000;\nclass TestRunTracker extends Disposable {\n    get hasRunningTasks() {\n        return this.running > 0;\n    }\n    get id() {\n        return this.dto.id;\n    }\n    constructor(dto, proxy, logService, profile, extension, parentToken) {\n        super();\n        this.dto = dto;\n        this.proxy = proxy;\n        this.logService = logService;\n        this.profile = profile;\n        this.extension = extension;\n        this.state = 0 ;\n        this.running = 0;\n        this.tasks = ( new Map());\n        this.sharedTestIds = ( new Set());\n        this.endEmitter = this._register(( new Emitter()));\n        this.publishedCoverage = ( new Map());\n        this.onEnd = this.endEmitter.event;\n        this.cts = this._register(( new CancellationTokenSource(parentToken)));\n        const forciblyEnd = this._register(( new RunOnceScheduler(() => this.forciblyEndTasks(), RUN_CANCEL_DEADLINE)));\n        this._register(this.cts.token.onCancellationRequested(() => forciblyEnd.schedule()));\n        const didDisposeEmitter = ( new Emitter());\n        this.onDidDispose = didDisposeEmitter.event;\n        this._register(toDisposable(() => {\n            didDisposeEmitter.fire();\n            didDisposeEmitter.dispose();\n        }));\n    }\n    getTaskIdForRun(run) {\n        for (const [taskId, { run: r }] of this.tasks) {\n            if (r === run) {\n                return taskId;\n            }\n        }\n        return undefined;\n    }\n    cancel(taskId) {\n        if (taskId) {\n            this.tasks.get(taskId)?.cts.cancel();\n        }\n        else if (this.state === 0 ) {\n            this.cts.cancel();\n            this.state = 1 ;\n        }\n        else if (this.state === 1 ) {\n            this.forciblyEndTasks();\n        }\n    }\n    async getCoverageDetails(id, testId, token) {\n        const [, taskId] = TestId.fromString(id).path;\n        const coverage = this.publishedCoverage.get(id);\n        if (!coverage) {\n            return [];\n        }\n        const { report, extIds } = coverage;\n        const task = this.tasks.get(taskId);\n        if (!task) {\n            throw ( new Error('unreachable: run task was not found'));\n        }\n        let testItem;\n        if (testId && report instanceof FileCoverage) {\n            const index = extIds.indexOf(testId);\n            if (index === -1) {\n                return [];\n            }\n            testItem = report.fromTests[index];\n        }\n        const details = testItem\n            ? this.profile?.loadDetailedCoverageForTest?.(task.run, report, testItem, token)\n            : this.profile?.loadDetailedCoverage?.(task.run, report, token);\n        return (await details) ?? [];\n    }\n    createRun(name) {\n        const runId = this.dto.id;\n        const ctrlId = this.dto.controllerId;\n        const taskId = generateUuid();\n        const guardTestMutation = (fn) => (test, ...args) => {\n            if (ended) {\n                this.logService.warn(`Setting the state of test \"${test.id}\" is a no-op after the run ends.`);\n                return;\n            }\n            this.ensureTestIsKnown(test);\n            fn(test, ...args);\n        };\n        const appendMessages = (test, messages) => {\n            const converted = messages instanceof Array\n                ? ( messages.map(TestMessage.from))\n                : [TestMessage.from(messages)];\n            if (test.uri && test.range) {\n                const defaultLocation = { range: Range.from(test.range), uri: test.uri };\n                for (const message of converted) {\n                    message.location = message.location || defaultLocation;\n                }\n            }\n            this.proxy.$appendTestMessagesInRun(runId, taskId, ( TestId.fromExtHostTestItem(test, ctrlId).toString()), converted);\n        };\n        let ended = false;\n        const cts = this._register(( new CancellationTokenSource(this.cts.token)));\n        const run = {\n            isPersisted: this.dto.isPersisted,\n            token: cts.token,\n            name,\n            onDidDispose: this.onDidDispose,\n            addCoverage: (coverage) => {\n                if (ended) {\n                    return;\n                }\n                const fromTests = coverage instanceof FileCoverage ? coverage.fromTests : [];\n                if (fromTests.length) {\n                    checkProposedApiEnabled(this.extension, 'attributableCoverage');\n                    for (const test of fromTests) {\n                        this.ensureTestIsKnown(test);\n                    }\n                }\n                const uriStr = ( coverage.uri.toString());\n                const id = ( ( new TestId([runId, taskId, uriStr])).toString());\n                this.publishedCoverage.set(id, { report: coverage, extIds: ( fromTests.map(t => ( TestId.fromExtHostTestItem(t, ctrlId).toString()))) });\n                this.proxy.$appendCoverage(runId, taskId, TestCoverage.fromFile(ctrlId, id, coverage));\n            },\n            enqueued: guardTestMutation(test => {\n                this.proxy.$updateTestStateInRun(runId, taskId, ( TestId.fromExtHostTestItem(test, ctrlId).toString()), 1 );\n            }),\n            skipped: guardTestMutation(test => {\n                this.proxy.$updateTestStateInRun(runId, taskId, ( TestId.fromExtHostTestItem(test, ctrlId).toString()), 5 );\n            }),\n            started: guardTestMutation(test => {\n                this.proxy.$updateTestStateInRun(runId, taskId, ( TestId.fromExtHostTestItem(test, ctrlId).toString()), 2 );\n            }),\n            errored: guardTestMutation((test, messages, duration) => {\n                appendMessages(test, messages);\n                this.proxy.$updateTestStateInRun(runId, taskId, ( TestId.fromExtHostTestItem(test, ctrlId).toString()), 6 , duration);\n            }),\n            failed: guardTestMutation((test, messages, duration) => {\n                appendMessages(test, messages);\n                this.proxy.$updateTestStateInRun(runId, taskId, ( TestId.fromExtHostTestItem(test, ctrlId).toString()), 4 , duration);\n            }),\n            passed: guardTestMutation((test, duration) => {\n                this.proxy.$updateTestStateInRun(runId, taskId, ( TestId.fromExtHostTestItem(test, this.dto.controllerId).toString()), 3 , duration);\n            }),\n            appendOutput: (output, location$1, test) => {\n                if (ended) {\n                    return;\n                }\n                if (test) {\n                    this.ensureTestIsKnown(test);\n                }\n                this.proxy.$appendOutputToRun(runId, taskId, VSBuffer.fromString(output), location$1 && location.from(location$1), test && ( TestId.fromExtHostTestItem(test, ctrlId).toString()));\n            },\n            end: () => {\n                if (ended) {\n                    return;\n                }\n                ended = true;\n                this.proxy.$finishedTestRunTask(runId, taskId);\n                if (!--this.running) {\n                    this.markEnded();\n                }\n            }\n        };\n        this.running++;\n        this.tasks.set(taskId, { run, cts });\n        this.proxy.$startedTestRunTask(runId, {\n            id: taskId,\n            ctrlId: this.dto.controllerId,\n            name: name || this.extension.displayName || this.extension.identifier.value,\n            running: true,\n        });\n        return run;\n    }\n    forciblyEndTasks() {\n        for (const { run } of ( this.tasks.values())) {\n            run.end();\n        }\n    }\n    markEnded() {\n        if (this.state !== 2 ) {\n            this.state = 2 ;\n            this.endEmitter.fire();\n        }\n    }\n    ensureTestIsKnown(test) {\n        if (!(test instanceof TestItemImpl)) {\n            throw ( new InvalidTestItemError(test.id));\n        }\n        if (( this.sharedTestIds.has(( TestId.fromExtHostTestItem(test, this.dto.controllerId).toString())))) {\n            return;\n        }\n        const chain = [];\n        const root = this.dto.colllection.root;\n        while (true) {\n            const converted = TestItem.from(test);\n            chain.unshift(converted);\n            if (( this.sharedTestIds.has(converted.extId))) {\n                break;\n            }\n            this.sharedTestIds.add(converted.extId);\n            if (test === root) {\n                break;\n            }\n            test = test.parent || root;\n        }\n        this.proxy.$addTestsToRun(this.dto.controllerId, this.dto.id, chain);\n    }\n    dispose() {\n        this.markEnded();\n        super.dispose();\n    }\n}\nclass TestRunCoordinator {\n    get trackers() {\n        return ( this.tracked.values());\n    }\n    constructor(proxy, logService) {\n        this.proxy = proxy;\n        this.logService = logService;\n        this.tracked = ( new Map());\n        this.trackedById = ( new Map());\n    }\n    getCoverageDetails(id, testId, token) {\n        const runId = TestId.root(id);\n        return this.trackedById.get(runId)?.getCoverageDetails(id, testId, token) || [];\n    }\n    disposeTestRun(runId) {\n        this.trackedById.get(runId)?.dispose();\n        this.trackedById.delete(runId);\n        for (const [req, { id }] of this.tracked) {\n            if (id === runId) {\n                this.tracked.delete(req);\n            }\n        }\n    }\n    prepareForMainThreadTestRun(extension, req, dto, profile, token) {\n        return this.getTracker(req, dto, profile, extension, token);\n    }\n    cancelRunById(runId, taskId) {\n        this.trackedById.get(runId)?.cancel(taskId);\n    }\n    cancelAllRuns() {\n        for (const tracker of ( this.tracked.values())) {\n            tracker.cancel();\n        }\n    }\n    createTestRun(extension, controllerId, collection, request, name, persist) {\n        const existing = this.tracked.get(request);\n        if (existing) {\n            return existing.createRun(name);\n        }\n        const dto = TestRunDto.fromPublic(controllerId, collection, request, persist);\n        const profile = tryGetProfileFromTestRunReq(request);\n        this.proxy.$startedExtensionTestRun({\n            controllerId,\n            continuous: !!request.continuous,\n            profile: profile && { group: profileGroupToBitset[profile.kind], id: profile.profileId },\n            exclude: request.exclude?.map(t => ( TestId.fromExtHostTestItem(t, collection.root.id).toString())) ?? [],\n            id: dto.id,\n            include: request.include?.map(t => ( TestId.fromExtHostTestItem(t, collection.root.id).toString())) ?? [collection.root.id],\n            preserveFocus: request.preserveFocus ?? true,\n            persist\n        });\n        const tracker = this.getTracker(request, dto, request.profile, extension);\n        Event.once(tracker.onEnd)(() => {\n            this.proxy.$finishedExtensionTestRun(dto.id);\n        });\n        return tracker.createRun(name);\n    }\n    getTracker(req, dto, profile, extension, token) {\n        const tracker = ( new TestRunTracker(dto, this.proxy, this.logService, profile, extension, token));\n        this.tracked.set(req, tracker);\n        this.trackedById.set(tracker.id, tracker);\n        return tracker;\n    }\n}\nconst tryGetProfileFromTestRunReq = (request) => {\n    if (!request.profile) {\n        return undefined;\n    }\n    if (!(request.profile instanceof TestRunProfileImpl)) {\n        throw ( new Error(\n            `TestRunRequest.profile is not an instance created from TestController.createRunProfile`\n        ));\n    }\n    return request.profile;\n};\nclass TestRunDto {\n    static fromPublic(controllerId, collection, request, persist) {\n        return ( new TestRunDto(controllerId, generateUuid(), persist, collection));\n    }\n    static fromInternal(request, collection) {\n        return ( new TestRunDto(request.controllerId, request.runId, true, collection));\n    }\n    constructor(controllerId, id, isPersisted, colllection) {\n        this.controllerId = controllerId;\n        this.id = id;\n        this.isPersisted = isPersisted;\n        this.colllection = colllection;\n    }\n}\nclass MirroredChangeCollector {\n    get isEmpty() {\n        return this.added.size === 0 && this.removed.size === 0 && this.updated.size === 0;\n    }\n    constructor(emitter) {\n        this.emitter = emitter;\n        this.added = ( new Set());\n        this.updated = ( new Set());\n        this.removed = ( new Set());\n        this.alreadyRemoved = ( new Set());\n    }\n    add(node) {\n        this.added.add(node);\n    }\n    update(node) {\n        Object.assign(node.revived, TestItem.toPlain(node.item));\n        if (!( this.added.has(node))) {\n            this.updated.add(node);\n        }\n    }\n    remove(node) {\n        if (( this.added.has(node))) {\n            this.added.delete(node);\n            return;\n        }\n        this.updated.delete(node);\n        const parentId = TestId.parentId(node.item.extId);\n        if (parentId && ( this.alreadyRemoved.has(( parentId.toString())))) {\n            this.alreadyRemoved.add(node.item.extId);\n            return;\n        }\n        this.removed.add(node);\n    }\n    getChangeEvent() {\n        const { added, updated, removed } = this;\n        return {\n            get added() { return ( [...added].map(n => n.revived)); },\n            get updated() { return ( [...updated].map(n => n.revived)); },\n            get removed() { return ( [...removed].map(n => n.revived)); },\n        };\n    }\n    complete() {\n        if (!this.isEmpty) {\n            this.emitter.fire(this.getChangeEvent());\n        }\n    }\n}\nclass MirroredTestCollection extends AbstractIncrementalTestCollection {\n    constructor() {\n        super(...arguments);\n        this.changeEmitter = ( new Emitter());\n        this.onDidChangeTests = this.changeEmitter.event;\n    }\n    get rootTests() {\n        return this.roots;\n    }\n    getMirroredTestDataById(itemId) {\n        return this.items.get(itemId);\n    }\n    getMirroredTestDataByReference(item) {\n        return this.items.get(item.id);\n    }\n    createItem(item, parent) {\n        return {\n            ...item,\n            revived: TestItem.toPlain(item.item),\n            depth: parent ? parent.depth + 1 : 0,\n            children: ( new Set()),\n        };\n    }\n    createChangeCollector() {\n        return ( new MirroredChangeCollector(this.changeEmitter));\n    }\n}\nclass TestObservers {\n    constructor(proxy) {\n        this.proxy = proxy;\n    }\n    checkout() {\n        if (!this.current) {\n            this.current = this.createObserverData();\n        }\n        const current = this.current;\n        current.observers++;\n        return {\n            onDidChangeTest: current.tests.onDidChangeTests,\n            get tests() { return ( [...current.tests.rootTests].map(t => t.revived)); },\n            dispose: createSingleCallFunction(() => {\n                if (--current.observers === 0) {\n                    this.proxy.$unsubscribeFromDiffs();\n                    this.current = undefined;\n                }\n            }),\n        };\n    }\n    getMirroredTestDataByReference(ref) {\n        return this.current?.tests.getMirroredTestDataByReference(ref);\n    }\n    applyDiff(diff) {\n        this.current?.tests.apply(diff);\n    }\n    createObserverData() {\n        const tests = ( new MirroredTestCollection({ asCanonicalUri: u => u }));\n        this.proxy.$subscribeToDiffs();\n        return { observers: 0, tests, };\n    }\n}\nconst updateProfile = (impl, proxy, initial, update) => {\n    if (initial) {\n        Object.assign(initial, update);\n    }\n    else {\n        proxy.$updateTestRunConfig(impl.controllerId, impl.profileId, update);\n    }\n};\nclass TestRunProfileImpl {\n    #proxy;\n    #activeProfiles;\n    #onDidChangeDefaultProfiles;\n    #initialPublish;\n    #profiles;\n    get label() {\n        return this._label;\n    }\n    set label(label) {\n        if (label !== this._label) {\n            this._label = label;\n            updateProfile(this, this.#proxy, this.#initialPublish, { label });\n        }\n    }\n    get supportsContinuousRun() {\n        return this._supportsContinuousRun;\n    }\n    set supportsContinuousRun(supports) {\n        if (supports !== this._supportsContinuousRun) {\n            this._supportsContinuousRun = supports;\n            updateProfile(this, this.#proxy, this.#initialPublish, { supportsContinuousRun: supports });\n        }\n    }\n    get isDefault() {\n        return ( this.#activeProfiles.has(this.profileId));\n    }\n    set isDefault(isDefault) {\n        if (isDefault !== this.isDefault) {\n            if (isDefault) {\n                this.#activeProfiles.add(this.profileId);\n            }\n            else {\n                this.#activeProfiles.delete(this.profileId);\n            }\n            updateProfile(this, this.#proxy, this.#initialPublish, { isDefault });\n        }\n    }\n    get tag() {\n        return this._tag;\n    }\n    set tag(tag) {\n        if (tag?.id !== this._tag?.id) {\n            this._tag = tag;\n            updateProfile(this, this.#proxy, this.#initialPublish, {\n                tag: tag ? TestTag.namespace(this.controllerId, tag.id) : null,\n            });\n        }\n    }\n    get configureHandler() {\n        return this._configureHandler;\n    }\n    set configureHandler(handler) {\n        if (handler !== this._configureHandler) {\n            this._configureHandler = handler;\n            updateProfile(this, this.#proxy, this.#initialPublish, { hasConfigurationHandler: !!handler });\n        }\n    }\n    get onDidChangeDefault() {\n        return Event.chain(this.#onDidChangeDefaultProfiles, $ => ( $\n            .map(ev => ev.get(this.controllerId)?.get(this.profileId)))\n            .filter(isDefined));\n    }\n    constructor(proxy, profiles, activeProfiles, onDidChangeActiveProfiles, controllerId, profileId, _label, kind, runHandler, _isDefault = false, _tag = undefined, _supportsContinuousRun = false) {\n        this.controllerId = controllerId;\n        this.profileId = profileId;\n        this._label = _label;\n        this.kind = kind;\n        this.runHandler = runHandler;\n        this._tag = _tag;\n        this._supportsContinuousRun = _supportsContinuousRun;\n        this.#proxy = proxy;\n        this.#profiles = profiles;\n        this.#activeProfiles = activeProfiles;\n        this.#onDidChangeDefaultProfiles = onDidChangeActiveProfiles;\n        profiles.set(profileId, this);\n        const groupBitset = profileGroupToBitset[kind];\n        if (typeof groupBitset !== 'number') {\n            throw ( new Error(`Unknown TestRunProfile.group ${kind}`));\n        }\n        if (_isDefault) {\n            activeProfiles.add(profileId);\n        }\n        this.#initialPublish = {\n            profileId: profileId,\n            controllerId,\n            tag: _tag ? TestTag.namespace(this.controllerId, _tag.id) : null,\n            label: _label,\n            group: groupBitset,\n            isDefault: _isDefault,\n            hasConfigurationHandler: false,\n            supportsContinuousRun: _supportsContinuousRun,\n        };\n        queueMicrotask(() => {\n            if (this.#initialPublish) {\n                this.#proxy.$publishTestRunProfile(this.#initialPublish);\n                this.#initialPublish = undefined;\n            }\n        });\n    }\n    dispose() {\n        if (this.#profiles?.delete(this.profileId)) {\n            this.#profiles = undefined;\n            this.#proxy.$removeTestProfile(this.controllerId, this.profileId);\n        }\n        this.#initialPublish = undefined;\n    }\n}\nconst profileGroupToBitset = {\n    [TestRunProfileKind.Coverage]: 8 ,\n    [TestRunProfileKind.Debug]: 4 ,\n    [TestRunProfileKind.Run]: 2 ,\n};\nfunction findTestInResultSnapshot(extId, snapshot) {\n    for (let i = 0; i < extId.path.length; i++) {\n        const item = snapshot.find(s => s.id === extId.path[i]);\n        if (!item) {\n            return undefined;\n        }\n        if (i === extId.path.length - 1) {\n            return item;\n        }\n        snapshot = item.children;\n    }\n    return undefined;\n}\nexport { ExtHostTesting, IExtHostTesting, TestRunCoordinator, TestRunDto, TestRunProfileImpl };\n","import { InvalidTestItemError } from '../../contrib/testing/common/testItemCollection.js';\nconst eventPrivateApis = ( new WeakMap());\nconst createPrivateApiFor = (impl, controllerId) => {\n    const api = { controllerId };\n    eventPrivateApis.set(impl, api);\n    return api;\n};\nconst getPrivateApiFor = (impl) => {\n    const api = eventPrivateApis.get(impl);\n    if (!api) {\n        throw ( new InvalidTestItemError(impl?.id || '<unknown>'));\n    }\n    return api;\n};\nexport { createPrivateApiFor, getPrivateApiFor };\n","import { ok } from '../../../base/common/assert.js';\nimport { ReadonlyError, illegalArgument } from '../../../base/common/errors.js';\nimport { IdGenerator } from '../../../base/common/idGenerator.js';\nimport { DecorationRenderOptions, Position as Position$1, Range as Range$1, isDecorationOptionsArr, fromRangeOrRangeWithMessage, ViewColumn, EndOfLine, TextEditorLineNumbersStyle, Selection as Selection$1 } from './extHostTypeConverters.js';\nimport { Selection, Position, Range, TextEditorRevealType, EndOfLine as EndOfLine$1 } from './extHostTypes.js';\nclass TextEditorDecorationType {\n    static { this._Keys = ( new IdGenerator('TextEditorDecorationType')); }\n    constructor(proxy, extension, options) {\n        const key = TextEditorDecorationType._Keys.nextId();\n        proxy.$registerTextEditorDecorationType(extension.identifier, key, DecorationRenderOptions.from(options));\n        this.value = ( Object.freeze({\n            key,\n            dispose() {\n                proxy.$removeTextEditorDecorationType(key);\n            }\n        }));\n    }\n}\nclass TextEditorEdit {\n    constructor(document, options) {\n        this._collectedEdits = [];\n        this._setEndOfLine = undefined;\n        this._finalized = false;\n        this._document = document;\n        this._documentVersionId = document.version;\n        this._undoStopBefore = options.undoStopBefore;\n        this._undoStopAfter = options.undoStopAfter;\n    }\n    finalize() {\n        this._finalized = true;\n        return {\n            documentVersionId: this._documentVersionId,\n            edits: this._collectedEdits,\n            setEndOfLine: this._setEndOfLine,\n            undoStopBefore: this._undoStopBefore,\n            undoStopAfter: this._undoStopAfter\n        };\n    }\n    _throwIfFinalized() {\n        if (this._finalized) {\n            throw ( new Error('Edit is only valid while callback runs'));\n        }\n    }\n    replace(location, value) {\n        this._throwIfFinalized();\n        let range = null;\n        if (location instanceof Position) {\n            range = ( new Range(location, location));\n        }\n        else if (location instanceof Range) {\n            range = location;\n        }\n        else {\n            throw ( new Error('Unrecognized location'));\n        }\n        this._pushEdit(range, value, false);\n    }\n    insert(location, value) {\n        this._throwIfFinalized();\n        this._pushEdit(( new Range(location, location)), value, true);\n    }\n    delete(location) {\n        this._throwIfFinalized();\n        let range = null;\n        if (location instanceof Range) {\n            range = location;\n        }\n        else {\n            throw ( new Error('Unrecognized location'));\n        }\n        this._pushEdit(range, null, true);\n    }\n    _pushEdit(range, text, forceMoveMarkers) {\n        const validRange = this._document.validateRange(range);\n        this._collectedEdits.push({\n            range: validRange,\n            text: text,\n            forceMoveMarkers: forceMoveMarkers\n        });\n    }\n    setEndOfLine(endOfLine) {\n        this._throwIfFinalized();\n        if (endOfLine !== EndOfLine$1.LF && endOfLine !== EndOfLine$1.CRLF) {\n            throw illegalArgument('endOfLine');\n        }\n        this._setEndOfLine = endOfLine;\n    }\n}\nclass ExtHostTextEditorOptions {\n    constructor(proxy, id, source, logService) {\n        this._proxy = proxy;\n        this._id = id;\n        this._accept(source);\n        this._logService = logService;\n        const that = this;\n        this.value = {\n            get tabSize() {\n                return that._tabSize;\n            },\n            set tabSize(value) {\n                that._setTabSize(value);\n            },\n            get indentSize() {\n                return that._indentSize;\n            },\n            set indentSize(value) {\n                that._setIndentSize(value);\n            },\n            get insertSpaces() {\n                return that._insertSpaces;\n            },\n            set insertSpaces(value) {\n                that._setInsertSpaces(value);\n            },\n            get cursorStyle() {\n                return that._cursorStyle;\n            },\n            set cursorStyle(value) {\n                that._setCursorStyle(value);\n            },\n            get lineNumbers() {\n                return that._lineNumbers;\n            },\n            set lineNumbers(value) {\n                that._setLineNumbers(value);\n            }\n        };\n    }\n    _accept(source) {\n        this._tabSize = source.tabSize;\n        this._indentSize = source.indentSize;\n        this._originalIndentSize = source.originalIndentSize;\n        this._insertSpaces = source.insertSpaces;\n        this._cursorStyle = source.cursorStyle;\n        this._lineNumbers = TextEditorLineNumbersStyle.to(source.lineNumbers);\n    }\n    _validateTabSize(value) {\n        if (value === 'auto') {\n            return 'auto';\n        }\n        if (typeof value === 'number') {\n            const r = Math.floor(value);\n            return (r > 0 ? r : null);\n        }\n        if (typeof value === 'string') {\n            const r = parseInt(value, 10);\n            if (isNaN(r)) {\n                return null;\n            }\n            return (r > 0 ? r : null);\n        }\n        return null;\n    }\n    _setTabSize(value) {\n        const tabSize = this._validateTabSize(value);\n        if (tabSize === null) {\n            return;\n        }\n        if (typeof tabSize === 'number') {\n            if (this._tabSize === tabSize) {\n                return;\n            }\n            this._tabSize = tabSize;\n        }\n        this._warnOnError('setTabSize', this._proxy.$trySetOptions(this._id, {\n            tabSize: tabSize\n        }));\n    }\n    _validateIndentSize(value) {\n        if (value === 'tabSize') {\n            return 'tabSize';\n        }\n        if (typeof value === 'number') {\n            const r = Math.floor(value);\n            return (r > 0 ? r : null);\n        }\n        if (typeof value === 'string') {\n            const r = parseInt(value, 10);\n            if (isNaN(r)) {\n                return null;\n            }\n            return (r > 0 ? r : null);\n        }\n        return null;\n    }\n    _setIndentSize(value) {\n        const indentSize = this._validateIndentSize(value);\n        if (indentSize === null) {\n            return;\n        }\n        if (typeof indentSize === 'number') {\n            if (this._originalIndentSize === indentSize) {\n                return;\n            }\n            this._indentSize = indentSize;\n            this._originalIndentSize = indentSize;\n        }\n        this._warnOnError('setIndentSize', this._proxy.$trySetOptions(this._id, {\n            indentSize: indentSize\n        }));\n    }\n    _validateInsertSpaces(value) {\n        if (value === 'auto') {\n            return 'auto';\n        }\n        return (value === 'false' ? false : Boolean(value));\n    }\n    _setInsertSpaces(value) {\n        const insertSpaces = this._validateInsertSpaces(value);\n        if (typeof insertSpaces === 'boolean') {\n            if (this._insertSpaces === insertSpaces) {\n                return;\n            }\n            this._insertSpaces = insertSpaces;\n        }\n        this._warnOnError('setInsertSpaces', this._proxy.$trySetOptions(this._id, {\n            insertSpaces: insertSpaces\n        }));\n    }\n    _setCursorStyle(value) {\n        if (this._cursorStyle === value) {\n            return;\n        }\n        this._cursorStyle = value;\n        this._warnOnError('setCursorStyle', this._proxy.$trySetOptions(this._id, {\n            cursorStyle: value\n        }));\n    }\n    _setLineNumbers(value) {\n        if (this._lineNumbers === value) {\n            return;\n        }\n        this._lineNumbers = value;\n        this._warnOnError('setLineNumbers', this._proxy.$trySetOptions(this._id, {\n            lineNumbers: TextEditorLineNumbersStyle.from(value)\n        }));\n    }\n    assign(newOptions) {\n        const bulkConfigurationUpdate = {};\n        let hasUpdate = false;\n        if (typeof newOptions.tabSize !== 'undefined') {\n            const tabSize = this._validateTabSize(newOptions.tabSize);\n            if (tabSize === 'auto') {\n                hasUpdate = true;\n                bulkConfigurationUpdate.tabSize = tabSize;\n            }\n            else if (typeof tabSize === 'number' && this._tabSize !== tabSize) {\n                this._tabSize = tabSize;\n                hasUpdate = true;\n                bulkConfigurationUpdate.tabSize = tabSize;\n            }\n        }\n        if (typeof newOptions.indentSize !== 'undefined') {\n            const indentSize = this._validateIndentSize(newOptions.indentSize);\n            if (indentSize === 'tabSize') {\n                hasUpdate = true;\n                bulkConfigurationUpdate.indentSize = indentSize;\n            }\n            else if (typeof indentSize === 'number' && this._originalIndentSize !== indentSize) {\n                this._indentSize = indentSize;\n                this._originalIndentSize = indentSize;\n                hasUpdate = true;\n                bulkConfigurationUpdate.indentSize = indentSize;\n            }\n        }\n        if (typeof newOptions.insertSpaces !== 'undefined') {\n            const insertSpaces = this._validateInsertSpaces(newOptions.insertSpaces);\n            if (insertSpaces === 'auto') {\n                hasUpdate = true;\n                bulkConfigurationUpdate.insertSpaces = insertSpaces;\n            }\n            else if (this._insertSpaces !== insertSpaces) {\n                this._insertSpaces = insertSpaces;\n                hasUpdate = true;\n                bulkConfigurationUpdate.insertSpaces = insertSpaces;\n            }\n        }\n        if (typeof newOptions.cursorStyle !== 'undefined') {\n            if (this._cursorStyle !== newOptions.cursorStyle) {\n                this._cursorStyle = newOptions.cursorStyle;\n                hasUpdate = true;\n                bulkConfigurationUpdate.cursorStyle = newOptions.cursorStyle;\n            }\n        }\n        if (typeof newOptions.lineNumbers !== 'undefined') {\n            if (this._lineNumbers !== newOptions.lineNumbers) {\n                this._lineNumbers = newOptions.lineNumbers;\n                hasUpdate = true;\n                bulkConfigurationUpdate.lineNumbers = TextEditorLineNumbersStyle.from(newOptions.lineNumbers);\n            }\n        }\n        if (hasUpdate) {\n            this._warnOnError('setOptions', this._proxy.$trySetOptions(this._id, bulkConfigurationUpdate));\n        }\n    }\n    _warnOnError(action, promise) {\n        promise.catch(err => {\n            this._logService.warn(`ExtHostTextEditorOptions '${action}' failed:'`);\n            this._logService.warn(err);\n        });\n    }\n}\nclass ExtHostTextEditor {\n    constructor(id, _proxy, _logService, document, selections, options, visibleRanges, viewColumn) {\n        this.id = id;\n        this._proxy = _proxy;\n        this._logService = _logService;\n        this._disposed = false;\n        this._hasDecorationsForKey = ( new Set());\n        this._selections = selections;\n        this._options = ( new ExtHostTextEditorOptions(this._proxy, this.id, options, _logService));\n        this._visibleRanges = visibleRanges;\n        this._viewColumn = viewColumn;\n        const that = this;\n        this.value = ( Object.freeze({\n            get document() {\n                return document.value;\n            },\n            set document(_value) {\n                throw ( new ReadonlyError('document'));\n            },\n            get selection() {\n                return that._selections && that._selections[0];\n            },\n            set selection(value) {\n                if (!(value instanceof Selection)) {\n                    throw illegalArgument('selection');\n                }\n                that._selections = [value];\n                that._trySetSelection();\n            },\n            get selections() {\n                return that._selections;\n            },\n            set selections(value) {\n                if (!Array.isArray(value) || ( value.some(a => !(a instanceof Selection)))) {\n                    throw illegalArgument('selections');\n                }\n                that._selections = value;\n                that._trySetSelection();\n            },\n            get visibleRanges() {\n                return that._visibleRanges;\n            },\n            set visibleRanges(_value) {\n                throw ( new ReadonlyError('visibleRanges'));\n            },\n            get options() {\n                return that._options.value;\n            },\n            set options(value) {\n                if (!that._disposed) {\n                    that._options.assign(value);\n                }\n            },\n            get viewColumn() {\n                return that._viewColumn;\n            },\n            set viewColumn(_value) {\n                throw ( new ReadonlyError('viewColumn'));\n            },\n            edit(callback, options = { undoStopBefore: true, undoStopAfter: true }) {\n                if (that._disposed) {\n                    return Promise.reject(( new Error('TextEditor#edit not possible on closed editors')));\n                }\n                const edit = ( new TextEditorEdit(document.value, options));\n                callback(edit);\n                return that._applyEdit(edit);\n            },\n            insertSnippet(snippet, where, options = { undoStopBefore: true, undoStopAfter: true }) {\n                if (that._disposed) {\n                    return Promise.reject(( new Error('TextEditor#insertSnippet not possible on closed editors')));\n                }\n                let ranges;\n                if (!where || (Array.isArray(where) && where.length === 0)) {\n                    ranges = ( that._selections.map(range => Range$1.from(range)));\n                }\n                else if (where instanceof Position) {\n                    const { lineNumber, column } = Position$1.from(where);\n                    ranges = [{ startLineNumber: lineNumber, startColumn: column, endLineNumber: lineNumber, endColumn: column }];\n                }\n                else if (where instanceof Range) {\n                    ranges = [Range$1.from(where)];\n                }\n                else {\n                    ranges = [];\n                    for (const posOrRange of where) {\n                        if (posOrRange instanceof Range) {\n                            ranges.push(Range$1.from(posOrRange));\n                        }\n                        else {\n                            const { lineNumber, column } = Position$1.from(posOrRange);\n                            ranges.push({ startLineNumber: lineNumber, startColumn: column, endLineNumber: lineNumber, endColumn: column });\n                        }\n                    }\n                }\n                return _proxy.$tryInsertSnippet(id, document.value.version, snippet.value, ranges, options);\n            },\n            setDecorations(decorationType, ranges) {\n                const willBeEmpty = (ranges.length === 0);\n                if (willBeEmpty && !( that._hasDecorationsForKey.has(decorationType.key))) {\n                    return;\n                }\n                if (willBeEmpty) {\n                    that._hasDecorationsForKey.delete(decorationType.key);\n                }\n                else {\n                    that._hasDecorationsForKey.add(decorationType.key);\n                }\n                that._runOnProxy(() => {\n                    if (isDecorationOptionsArr(ranges)) {\n                        return _proxy.$trySetDecorations(id, decorationType.key, fromRangeOrRangeWithMessage(ranges));\n                    }\n                    else {\n                        const _ranges = ( new Array(4 * ranges.length));\n                        for (let i = 0, len = ranges.length; i < len; i++) {\n                            const range = ranges[i];\n                            _ranges[4 * i] = range.start.line + 1;\n                            _ranges[4 * i + 1] = range.start.character + 1;\n                            _ranges[4 * i + 2] = range.end.line + 1;\n                            _ranges[4 * i + 3] = range.end.character + 1;\n                        }\n                        return _proxy.$trySetDecorationsFast(id, decorationType.key, _ranges);\n                    }\n                });\n            },\n            revealRange(range, revealType) {\n                that._runOnProxy(() => _proxy.$tryRevealRange(id, Range$1.from(range), (revealType || TextEditorRevealType.Default)));\n            },\n            show(column) {\n                _proxy.$tryShowEditor(id, ViewColumn.from(column));\n            },\n            hide() {\n                _proxy.$tryHideEditor(id);\n            },\n            [Symbol.for('debug.description')]() {\n                return `TextEditor(${( this.document.uri.toString())})`;\n            }\n        }));\n    }\n    dispose() {\n        ok(!this._disposed);\n        this._disposed = true;\n    }\n    _acceptOptions(options) {\n        ok(!this._disposed);\n        this._options._accept(options);\n    }\n    _acceptVisibleRanges(value) {\n        ok(!this._disposed);\n        this._visibleRanges = value;\n    }\n    _acceptViewColumn(value) {\n        ok(!this._disposed);\n        this._viewColumn = value;\n    }\n    _acceptSelections(selections) {\n        ok(!this._disposed);\n        this._selections = selections;\n    }\n    async _trySetSelection() {\n        const selection = ( this._selections.map(Selection$1.from));\n        await this._runOnProxy(() => this._proxy.$trySetSelections(this.id, selection));\n        return this.value;\n    }\n    _applyEdit(editBuilder) {\n        const editData = editBuilder.finalize();\n        if (editData.edits.length === 0 && !editData.setEndOfLine) {\n            return Promise.resolve(true);\n        }\n        const editRanges = ( editData.edits.map(edit => edit.range));\n        editRanges.sort((a, b) => {\n            if (a.end.line === b.end.line) {\n                if (a.end.character === b.end.character) {\n                    if (a.start.line === b.start.line) {\n                        return a.start.character - b.start.character;\n                    }\n                    return a.start.line - b.start.line;\n                }\n                return a.end.character - b.end.character;\n            }\n            return a.end.line - b.end.line;\n        });\n        for (let i = 0, count = editRanges.length - 1; i < count; i++) {\n            const rangeEnd = editRanges[i].end;\n            const nextRangeStart = editRanges[i + 1].start;\n            if (nextRangeStart.isBefore(rangeEnd)) {\n                return Promise.reject(( new Error('Overlapping ranges are not allowed!')));\n            }\n        }\n        const edits = ( editData.edits.map((edit) => {\n            return {\n                range: Range$1.from(edit.range),\n                text: edit.text,\n                forceMoveMarkers: edit.forceMoveMarkers\n            };\n        }));\n        return this._proxy.$tryApplyEdits(this.id, editData.documentVersionId, edits, {\n            setEndOfLine: typeof editData.setEndOfLine === 'number' ? EndOfLine.from(editData.setEndOfLine) : undefined,\n            undoStopBefore: editData.undoStopBefore,\n            undoStopAfter: editData.undoStopAfter\n        });\n    }\n    _runOnProxy(callback) {\n        if (this._disposed) {\n            this._logService.warn('TextEditor is closed/disposed');\n            return Promise.resolve(undefined);\n        }\n        return callback().then(() => this, err => {\n            if (!(err instanceof Error && err.name === 'DISPOSED')) {\n                this._logService.warn(err);\n            }\n            return null;\n        });\n    }\n}\nexport { ExtHostTextEditor, ExtHostTextEditorOptions, TextEditorDecorationType };\n","import { coalesce } from '../../../base/common/arrays.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { TextEditorDecorationType } from './extHostTextEditor.js';\nimport { ViewColumn, Range, TextEditorLineNumbersStyle, Selection } from './extHostTypeConverters.js';\nimport { TextEditorSelectionChangeKind } from './extHostTypes.js';\nclass ExtHostEditors extends Disposable {\n    constructor(mainContext, _extHostDocumentsAndEditors) {\n        super();\n        this._extHostDocumentsAndEditors = _extHostDocumentsAndEditors;\n        this._onDidChangeTextEditorSelection = ( new Emitter());\n        this._onDidChangeTextEditorOptions = ( new Emitter());\n        this._onDidChangeTextEditorVisibleRanges = ( new Emitter());\n        this._onDidChangeTextEditorViewColumn = ( new Emitter());\n        this._onDidChangeActiveTextEditor = ( new Emitter());\n        this._onDidChangeVisibleTextEditors = ( new Emitter());\n        this.onDidChangeTextEditorSelection = this._onDidChangeTextEditorSelection.event;\n        this.onDidChangeTextEditorOptions = this._onDidChangeTextEditorOptions.event;\n        this.onDidChangeTextEditorVisibleRanges = this._onDidChangeTextEditorVisibleRanges.event;\n        this.onDidChangeTextEditorViewColumn = this._onDidChangeTextEditorViewColumn.event;\n        this.onDidChangeActiveTextEditor = this._onDidChangeActiveTextEditor.event;\n        this.onDidChangeVisibleTextEditors = this._onDidChangeVisibleTextEditors.event;\n        this._proxy = ( mainContext.getProxy(MainContext.MainThreadTextEditors));\n        this._register(this._extHostDocumentsAndEditors.onDidChangeVisibleTextEditors(e => this._onDidChangeVisibleTextEditors.fire(e)));\n        this._register(this._extHostDocumentsAndEditors.onDidChangeActiveTextEditor(e => this._onDidChangeActiveTextEditor.fire(e)));\n    }\n    getActiveTextEditor() {\n        return this._extHostDocumentsAndEditors.activeEditor();\n    }\n    getVisibleTextEditors(internal) {\n        const editors = this._extHostDocumentsAndEditors.allEditors();\n        return internal\n            ? editors\n            : ( editors.map(editor => editor.value));\n    }\n    async showTextDocument(document, columnOrOptions, preserveFocus) {\n        let options;\n        if (typeof columnOrOptions === 'number') {\n            options = {\n                position: ViewColumn.from(columnOrOptions),\n                preserveFocus\n            };\n        }\n        else if (typeof columnOrOptions === 'object') {\n            options = {\n                position: ViewColumn.from(columnOrOptions.viewColumn),\n                preserveFocus: columnOrOptions.preserveFocus,\n                selection: typeof columnOrOptions.selection === 'object' ? Range.from(columnOrOptions.selection) : undefined,\n                pinned: typeof columnOrOptions.preview === 'boolean' ? !columnOrOptions.preview : undefined\n            };\n        }\n        else {\n            options = {\n                preserveFocus: false\n            };\n        }\n        const editorId = await this._proxy.$tryShowTextDocument(document.uri, options);\n        const editor = editorId && this._extHostDocumentsAndEditors.getEditor(editorId);\n        if (editor) {\n            return editor.value;\n        }\n        if (editorId) {\n            throw ( new Error(`Could NOT open editor for \"${( document.uri.toString())}\" because another editor opened in the meantime.`));\n        }\n        else {\n            throw ( new Error(`Could NOT open editor for \"${( document.uri.toString())}\".`));\n        }\n    }\n    createTextEditorDecorationType(extension, options) {\n        return ( new TextEditorDecorationType(this._proxy, extension, options)).value;\n    }\n    $acceptEditorPropertiesChanged(id, data) {\n        const textEditor = this._extHostDocumentsAndEditors.getEditor(id);\n        if (!textEditor) {\n            throw ( new Error('unknown text editor'));\n        }\n        if (data.options) {\n            textEditor._acceptOptions(data.options);\n        }\n        if (data.selections) {\n            const selections = ( data.selections.selections.map(Selection.to));\n            textEditor._acceptSelections(selections);\n        }\n        if (data.visibleRanges) {\n            const visibleRanges = coalesce(( data.visibleRanges.map(Range.to)));\n            textEditor._acceptVisibleRanges(visibleRanges);\n        }\n        if (data.options) {\n            this._onDidChangeTextEditorOptions.fire({\n                textEditor: textEditor.value,\n                options: { ...data.options, lineNumbers: TextEditorLineNumbersStyle.to(data.options.lineNumbers) }\n            });\n        }\n        if (data.selections) {\n            const kind = TextEditorSelectionChangeKind.fromValue(data.selections.source);\n            const selections = ( data.selections.selections.map(Selection.to));\n            this._onDidChangeTextEditorSelection.fire({\n                textEditor: textEditor.value,\n                selections,\n                kind\n            });\n        }\n        if (data.visibleRanges) {\n            const visibleRanges = coalesce(( data.visibleRanges.map(Range.to)));\n            this._onDidChangeTextEditorVisibleRanges.fire({\n                textEditor: textEditor.value,\n                visibleRanges\n            });\n        }\n    }\n    $acceptEditorPositionData(data) {\n        for (const id in data) {\n            const textEditor = this._extHostDocumentsAndEditors.getEditor(id);\n            if (!textEditor) {\n                throw ( new Error('Unknown text editor'));\n            }\n            const viewColumn = ViewColumn.to(data[id]);\n            if (textEditor.value.viewColumn !== viewColumn) {\n                textEditor._acceptViewColumn(viewColumn);\n                this._onDidChangeTextEditorViewColumn.fire({ textEditor: textEditor.value, viewColumn });\n            }\n        }\n    }\n    getDiffInformation(id) {\n        return Promise.resolve(this._proxy.$getDiffInformation(id));\n    }\n}\nexport { ExtHostEditors };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { ColorTheme, ColorThemeKind } from './extHostTypes.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\nimport { Emitter } from '../../../base/common/event.js';\nlet ExtHostTheming = class ExtHostTheming {\n    constructor(_extHostRpc) {\n        this._actual = ( new ColorTheme(ColorThemeKind.Dark));\n        this._onDidChangeActiveColorTheme = ( new Emitter());\n    }\n    get activeColorTheme() {\n        return this._actual;\n    }\n    $onColorThemeChange(type) {\n        let kind;\n        switch (type) {\n            case 'light':\n                kind = ColorThemeKind.Light;\n                break;\n            case 'hcDark':\n                kind = ColorThemeKind.HighContrast;\n                break;\n            case 'hcLight':\n                kind = ColorThemeKind.HighContrastLight;\n                break;\n            default:\n                kind = ColorThemeKind.Dark;\n        }\n        this._actual = ( new ColorTheme(kind));\n        this._onDidChangeActiveColorTheme.fire(this._actual);\n    }\n    get onDidChangeActiveColorTheme() {\n        return this._onDidChangeActiveColorTheme.event;\n    }\n};\nExtHostTheming = ( __decorate([\n    ( __param(0, IExtHostRpcService))\n], ExtHostTheming));\nexport { ExtHostTheming };\n","import { URI } from '../../../base/common/uri.js';\nimport '../../../platform/instantiation/common/instantiation.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { toDisposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport { ThemeIcon, MarkdownString } from './extHostTypes.js';\nimport { MarkdownString as MarkdownString$1 } from './extHostTypeConverters.js';\nimport { ExtensionIdentifier } from '../../../platform/extensions/common/extensions.js';\nimport { isString } from '../../../base/common/types.js';\nclass ExtHostTimeline {\n    constructor(mainContext, commands) {\n        this._providers = ( new Map());\n        this._itemsBySourceAndUriMap = ( new Map());\n        this._proxy = ( mainContext.getProxy(MainContext.MainThreadTimeline));\n        commands.registerArgumentProcessor({\n            processArgument: (arg, extension) => {\n                if (arg && arg.$mid === 12 ) {\n                    if (this._providers.get(arg.source) && ExtensionIdentifier.equals(extension, this._providers.get(arg.source)?.extension)) {\n                        const uri = arg.uri === undefined ? undefined : URI.revive(arg.uri);\n                        return this._itemsBySourceAndUriMap.get(arg.source)?.get(getUriKey(uri))?.get(arg.handle);\n                    }\n                    else {\n                        return undefined;\n                    }\n                }\n                return arg;\n            }\n        });\n    }\n    async $getTimeline(id, uri, options, token) {\n        const item = this._providers.get(id);\n        return item?.provider.provideTimeline(URI.revive(uri), options, token);\n    }\n    registerTimelineProvider(scheme, provider, extensionId, commandConverter) {\n        const timelineDisposables = ( new DisposableStore());\n        const convertTimelineItem = this.convertTimelineItem(provider.id, commandConverter, timelineDisposables).bind(this);\n        let disposable;\n        if (provider.onDidChange) {\n            disposable = provider.onDidChange(e => this._proxy.$emitTimelineChangeEvent({ uri: undefined, reset: true, ...e, id: provider.id }), this);\n        }\n        const itemsBySourceAndUriMap = this._itemsBySourceAndUriMap;\n        return this.registerTimelineProviderCore({\n            ...provider,\n            scheme: scheme,\n            onDidChange: undefined,\n            async provideTimeline(uri, options, token) {\n                if (options?.resetCache) {\n                    timelineDisposables.clear();\n                    itemsBySourceAndUriMap.get(provider.id)?.clear();\n                }\n                const result = await provider.provideTimeline(uri, options, token);\n                if (result === undefined || result === null) {\n                    return undefined;\n                }\n                const convertItem = convertTimelineItem(uri, options);\n                return {\n                    ...result,\n                    source: provider.id,\n                    items: ( result.items.map(convertItem))\n                };\n            },\n            dispose() {\n                for (const sourceMap of ( itemsBySourceAndUriMap.values())) {\n                    sourceMap.get(provider.id)?.clear();\n                }\n                disposable?.dispose();\n                timelineDisposables.dispose();\n            }\n        }, extensionId);\n    }\n    convertTimelineItem(source, commandConverter, disposables) {\n        return (uri, options) => {\n            let items;\n            if (options?.cacheResults) {\n                let itemsByUri = this._itemsBySourceAndUriMap.get(source);\n                if (itemsByUri === undefined) {\n                    itemsByUri = ( new Map());\n                    this._itemsBySourceAndUriMap.set(source, itemsByUri);\n                }\n                const uriKey = getUriKey(uri);\n                items = itemsByUri.get(uriKey);\n                if (items === undefined) {\n                    items = ( new Map());\n                    itemsByUri.set(uriKey, items);\n                }\n            }\n            return (item) => {\n                const { iconPath, ...props } = item;\n                const handle = `${source}|${item.id ?? item.timestamp}`;\n                items?.set(handle, item);\n                let icon;\n                let iconDark;\n                let themeIcon;\n                if (item.iconPath) {\n                    if (iconPath instanceof ThemeIcon) {\n                        themeIcon = { id: iconPath.id, color: iconPath.color };\n                    }\n                    else if (URI.isUri(iconPath)) {\n                        icon = iconPath;\n                        iconDark = iconPath;\n                    }\n                    else {\n                        ({ light: icon, dark: iconDark } = iconPath);\n                    }\n                }\n                let tooltip;\n                if (MarkdownString.isMarkdownString(props.tooltip)) {\n                    tooltip = MarkdownString$1.from(props.tooltip);\n                }\n                else if (isString(props.tooltip)) {\n                    tooltip = props.tooltip;\n                }\n                else if (MarkdownString.isMarkdownString(props.detail)) {\n                    console.warn('Using deprecated TimelineItem.detail, migrate to TimelineItem.tooltip');\n                    tooltip = MarkdownString$1.from(props.detail);\n                }\n                else if (isString(props.detail)) {\n                    console.warn('Using deprecated TimelineItem.detail, migrate to TimelineItem.tooltip');\n                    tooltip = props.detail;\n                }\n                return {\n                    ...props,\n                    id: props.id ?? undefined,\n                    handle: handle,\n                    source: source,\n                    command: item.command ? commandConverter.toInternal(item.command, disposables) : undefined,\n                    icon: icon,\n                    iconDark: iconDark,\n                    themeIcon: themeIcon,\n                    tooltip,\n                    accessibilityInformation: item.accessibilityInformation\n                };\n            };\n        };\n    }\n    registerTimelineProviderCore(provider, extension) {\n        const existing = this._providers.get(provider.id);\n        if (existing) {\n            throw ( new Error(`Timeline Provider ${provider.id} already exists.`));\n        }\n        this._proxy.$registerTimelineProvider({\n            id: provider.id,\n            label: provider.label,\n            scheme: provider.scheme\n        });\n        this._providers.set(provider.id, { provider, extension });\n        return toDisposable(() => {\n            for (const sourceMap of ( this._itemsBySourceAndUriMap.values())) {\n                sourceMap.get(provider.id)?.clear();\n            }\n            this._providers.delete(provider.id);\n            this._proxy.$unregisterTimelineProvider(provider.id);\n            provider.dispose();\n        });\n    }\n}\nfunction getUriKey(uri) {\n    return uri?.toString();\n}\nexport { ExtHostTimeline };\n","import { localize } from '../../../nls.js';\nimport { basename } from '../../../base/common/resources.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { Disposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport { NoTreeViewError } from '../../common/views.js';\nimport { asPromise } from '../../../base/common/async.js';\nimport { TreeItemCheckboxState, MarkdownString as MarkdownString$1, TreeItem, TreeItemCollapsibleState, ThemeIcon, DataTransfer as DataTransfer$1, ViewBadge as ViewBadge$1 } from './extHostTypes.js';\nimport { isUndefinedOrNull, isString } from '../../../base/common/types.js';\nimport { equals, coalesce } from '../../../base/common/arrays.js';\nimport { MarkdownString, ViewBadge, DataTransfer } from './extHostTypeConverters.js';\nimport { isMarkdownString } from '../../../base/common/htmlContent.js';\nimport { CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { TreeViewsDnDService } from '../../../editor/common/services/treeViewsDnd.js';\nimport { checkProposedApiEnabled } from '../../services/extensions/common/extensions.js';\nfunction toTreeItemLabel(label, extension) {\n    if (isString(label)) {\n        return { label };\n    }\n    if (label\n        && typeof label === 'object'\n        && typeof label.label === 'string') {\n        let highlights = undefined;\n        if (Array.isArray(label.highlights)) {\n            highlights = label.highlights.filter((highlight => highlight.length === 2 && typeof highlight[0] === 'number' && typeof highlight[1] === 'number'));\n            highlights = highlights.length ? highlights : undefined;\n        }\n        return { label: label.label, highlights };\n    }\n    return undefined;\n}\nclass ExtHostTreeViews extends Disposable {\n    constructor(_proxy, commands, logService) {\n        super();\n        this._proxy = _proxy;\n        this.commands = commands;\n        this.logService = logService;\n        this.treeViews = ( new Map());\n        this.treeDragAndDropService = ( new TreeViewsDnDService());\n        function isTreeViewConvertableItem(arg) {\n            return arg && arg.$treeViewId && (arg.$treeItemHandle || arg.$selectedTreeItems || arg.$focusedTreeItem);\n        }\n        commands.registerArgumentProcessor({\n            processArgument: arg => {\n                if (isTreeViewConvertableItem(arg)) {\n                    return this.convertArgument(arg);\n                }\n                else if (Array.isArray(arg) && (arg.length > 0)) {\n                    return ( arg.map(item => {\n                        if (isTreeViewConvertableItem(item)) {\n                            return this.convertArgument(item);\n                        }\n                        return item;\n                    }));\n                }\n                return arg;\n            }\n        });\n    }\n    registerTreeDataProvider(id, treeDataProvider, extension) {\n        const treeView = this.createTreeView(id, { treeDataProvider }, extension);\n        return { dispose: () => treeView.dispose() };\n    }\n    createTreeView(viewId, options, extension) {\n        if (!options || !options.treeDataProvider) {\n            throw ( new Error('Options with treeDataProvider is mandatory'));\n        }\n        const dropMimeTypes = options.dragAndDropController?.dropMimeTypes ?? [];\n        const dragMimeTypes = options.dragAndDropController?.dragMimeTypes ?? [];\n        const hasHandleDrag = !!options.dragAndDropController?.handleDrag;\n        const hasHandleDrop = !!options.dragAndDropController?.handleDrop;\n        const treeView = this.createExtHostTreeView(viewId, options, extension);\n        const proxyOptions = { showCollapseAll: !!options.showCollapseAll, canSelectMany: !!options.canSelectMany, dropMimeTypes, dragMimeTypes, hasHandleDrag, hasHandleDrop, manuallyManageCheckboxes: !!options.manageCheckboxStateManually };\n        const registerPromise = this._proxy.$registerTreeViewDataProvider(viewId, proxyOptions);\n        const view = {\n            get onDidCollapseElement() { return treeView.onDidCollapseElement; },\n            get onDidExpandElement() { return treeView.onDidExpandElement; },\n            get selection() { return treeView.selectedElements; },\n            get onDidChangeSelection() { return treeView.onDidChangeSelection; },\n            get activeItem() {\n                checkProposedApiEnabled(extension, 'treeViewActiveItem');\n                return treeView.focusedElement;\n            },\n            get onDidChangeActiveItem() {\n                checkProposedApiEnabled(extension, 'treeViewActiveItem');\n                return treeView.onDidChangeActiveItem;\n            },\n            get visible() { return treeView.visible; },\n            get onDidChangeVisibility() { return treeView.onDidChangeVisibility; },\n            get onDidChangeCheckboxState() {\n                return treeView.onDidChangeCheckboxState;\n            },\n            get message() { return treeView.message; },\n            set message(message) {\n                if (isMarkdownString(message)) {\n                    checkProposedApiEnabled(extension, 'treeViewMarkdownMessage');\n                }\n                treeView.message = message;\n            },\n            get title() { return treeView.title; },\n            set title(title) {\n                treeView.title = title;\n            },\n            get description() {\n                return treeView.description;\n            },\n            set description(description) {\n                treeView.description = description;\n            },\n            get badge() {\n                return treeView.badge;\n            },\n            set badge(badge) {\n                if ((badge !== undefined) && ViewBadge$1.isViewBadge(badge)) {\n                    treeView.badge = {\n                        value: Math.floor(Math.abs(badge.value)),\n                        tooltip: badge.tooltip\n                    };\n                }\n                else if (badge === undefined) {\n                    treeView.badge = undefined;\n                }\n            },\n            reveal: (element, options) => {\n                return treeView.reveal(element, options);\n            },\n            dispose: async () => {\n                await registerPromise;\n                this.treeViews.delete(viewId);\n                treeView.dispose();\n            }\n        };\n        this._register(view);\n        return view;\n    }\n    $getChildren(treeViewId, treeItemHandle) {\n        const treeView = this.treeViews.get(treeViewId);\n        if (!treeView) {\n            return Promise.reject(( new NoTreeViewError(treeViewId)));\n        }\n        return treeView.getChildren(treeItemHandle);\n    }\n    async $handleDrop(destinationViewId, requestId, treeDataTransferDTO, targetItemHandle, token, operationUuid, sourceViewId, sourceTreeItemHandles) {\n        const treeView = this.treeViews.get(destinationViewId);\n        if (!treeView) {\n            return Promise.reject(( new NoTreeViewError(destinationViewId)));\n        }\n        const treeDataTransfer = DataTransfer.toDataTransfer(treeDataTransferDTO, async (dataItemIndex) => {\n            return (await this._proxy.$resolveDropFileData(destinationViewId, requestId, dataItemIndex)).buffer;\n        });\n        if ((sourceViewId === destinationViewId) && sourceTreeItemHandles) {\n            await this.addAdditionalTransferItems(treeDataTransfer, treeView, sourceTreeItemHandles, token, operationUuid);\n        }\n        return treeView.onDrop(treeDataTransfer, targetItemHandle, token);\n    }\n    async addAdditionalTransferItems(treeDataTransfer, treeView, sourceTreeItemHandles, token, operationUuid) {\n        const existingTransferOperation = this.treeDragAndDropService.removeDragOperationTransfer(operationUuid);\n        if (existingTransferOperation) {\n            (await existingTransferOperation)?.forEach((value, key) => {\n                if (value) {\n                    treeDataTransfer.set(key, value);\n                }\n            });\n        }\n        else if (operationUuid && treeView.handleDrag) {\n            const willDropPromise = treeView.handleDrag(sourceTreeItemHandles, treeDataTransfer, token);\n            this.treeDragAndDropService.addDragOperationTransfer(operationUuid, willDropPromise);\n            await willDropPromise;\n        }\n        return treeDataTransfer;\n    }\n    async $handleDrag(sourceViewId, sourceTreeItemHandles, operationUuid, token) {\n        const treeView = this.treeViews.get(sourceViewId);\n        if (!treeView) {\n            return Promise.reject(( new NoTreeViewError(sourceViewId)));\n        }\n        const treeDataTransfer = await this.addAdditionalTransferItems(new DataTransfer$1(), treeView, sourceTreeItemHandles, token, operationUuid);\n        if (!treeDataTransfer || token.isCancellationRequested) {\n            return;\n        }\n        return DataTransfer.from(treeDataTransfer);\n    }\n    async $hasResolve(treeViewId) {\n        const treeView = this.treeViews.get(treeViewId);\n        if (!treeView) {\n            throw ( new NoTreeViewError(treeViewId));\n        }\n        return treeView.hasResolve;\n    }\n    $resolve(treeViewId, treeItemHandle, token) {\n        const treeView = this.treeViews.get(treeViewId);\n        if (!treeView) {\n            throw ( new NoTreeViewError(treeViewId));\n        }\n        return treeView.resolveTreeItem(treeItemHandle, token);\n    }\n    $setExpanded(treeViewId, treeItemHandle, expanded) {\n        const treeView = this.treeViews.get(treeViewId);\n        if (!treeView) {\n            throw ( new NoTreeViewError(treeViewId));\n        }\n        treeView.setExpanded(treeItemHandle, expanded);\n    }\n    $setSelectionAndFocus(treeViewId, selectedHandles, focusedHandle) {\n        const treeView = this.treeViews.get(treeViewId);\n        if (!treeView) {\n            throw ( new NoTreeViewError(treeViewId));\n        }\n        treeView.setSelectionAndFocus(selectedHandles, focusedHandle);\n    }\n    $setVisible(treeViewId, isVisible) {\n        const treeView = this.treeViews.get(treeViewId);\n        if (!treeView) {\n            if (!isVisible) {\n                return;\n            }\n            throw ( new NoTreeViewError(treeViewId));\n        }\n        treeView.setVisible(isVisible);\n    }\n    $changeCheckboxState(treeViewId, checkboxUpdate) {\n        const treeView = this.treeViews.get(treeViewId);\n        if (!treeView) {\n            throw ( new NoTreeViewError(treeViewId));\n        }\n        treeView.setCheckboxState(checkboxUpdate);\n    }\n    createExtHostTreeView(id, options, extension) {\n        const treeView = this._register(( new ExtHostTreeView(\n            id,\n            options,\n            this._proxy,\n            this.commands.converter,\n            this.logService,\n            extension\n        )));\n        this.treeViews.set(id, treeView);\n        return treeView;\n    }\n    convertArgument(arg) {\n        const treeView = this.treeViews.get(arg.$treeViewId);\n        if (treeView && '$treeItemHandle' in arg) {\n            return treeView.getExtensionElement(arg.$treeItemHandle);\n        }\n        if (treeView && '$focusedTreeItem' in arg && arg.$focusedTreeItem) {\n            return treeView.focusedElement;\n        }\n        return null;\n    }\n}\nclass ExtHostTreeView extends Disposable {\n    static { this.LABEL_HANDLE_PREFIX = '0'; }\n    static { this.ID_HANDLE_PREFIX = '1'; }\n    get visible() { return this._visible; }\n    get selectedElements() { return ( this._selectedHandles.map(handle => this.getExtensionElement(handle))).filter(element => !isUndefinedOrNull(element)); }\n    get focusedElement() { return (this._focusedHandle ? this.getExtensionElement(this._focusedHandle) : undefined); }\n    constructor(viewId, options, proxy, commands, logService, extension) {\n        super();\n        this.viewId = viewId;\n        this.proxy = proxy;\n        this.commands = commands;\n        this.logService = logService;\n        this.extension = extension;\n        this.roots = undefined;\n        this.elements = ( new Map());\n        this.nodes = ( new Map());\n        this._visible = false;\n        this._selectedHandles = [];\n        this._focusedHandle = undefined;\n        this._onDidExpandElement = this._register(( new Emitter()));\n        this.onDidExpandElement = this._onDidExpandElement.event;\n        this._onDidCollapseElement = this._register(( new Emitter()));\n        this.onDidCollapseElement = this._onDidCollapseElement.event;\n        this._onDidChangeSelection = this._register(( new Emitter()));\n        this.onDidChangeSelection = this._onDidChangeSelection.event;\n        this._onDidChangeActiveItem = this._register(( new Emitter()));\n        this.onDidChangeActiveItem = this._onDidChangeActiveItem.event;\n        this._onDidChangeVisibility = this._register(( new Emitter()));\n        this.onDidChangeVisibility = this._onDidChangeVisibility.event;\n        this._onDidChangeCheckboxState = this._register(( new Emitter()));\n        this.onDidChangeCheckboxState = this._onDidChangeCheckboxState.event;\n        this._onDidChangeData = this._register(( new Emitter()));\n        this.refreshPromise = Promise.resolve();\n        this.refreshQueue = Promise.resolve();\n        this._message = '';\n        this._title = '';\n        this._refreshCancellationSource = ( new CancellationTokenSource());\n        if (extension.contributes && extension.contributes.views) {\n            for (const location in extension.contributes.views) {\n                for (const view of extension.contributes.views[location]) {\n                    if (view.id === viewId) {\n                        this._title = view.name;\n                    }\n                }\n            }\n        }\n        this.dataProvider = options.treeDataProvider;\n        this.dndController = options.dragAndDropController;\n        if (this.dataProvider.onDidChangeTreeData) {\n            this._register(this.dataProvider.onDidChangeTreeData(elementOrElements => {\n                if (Array.isArray(elementOrElements) && elementOrElements.length === 0) {\n                    return;\n                }\n                this._onDidChangeData.fire({ message: false, element: elementOrElements });\n            }));\n        }\n        let refreshingPromise;\n        let promiseCallback;\n        const onDidChangeData = Event.debounce(this._onDidChangeData.event, (result, current) => {\n            if (!result) {\n                result = { message: false, elements: [] };\n            }\n            if (current.element !== false) {\n                if (!refreshingPromise) {\n                    refreshingPromise = ( new Promise(c => promiseCallback = c));\n                    this.refreshPromise = this.refreshPromise.then(() => refreshingPromise);\n                }\n                if (Array.isArray(current.element)) {\n                    result.elements.push(...current.element);\n                }\n                else {\n                    result.elements.push(current.element);\n                }\n            }\n            if (current.message) {\n                result.message = true;\n            }\n            return result;\n        }, 200, true);\n        this._register(onDidChangeData(({ message, elements }) => {\n            if (elements.length) {\n                this.refreshQueue = this.refreshQueue.then(() => {\n                    const _promiseCallback = promiseCallback;\n                    refreshingPromise = null;\n                    return this.refresh(elements).then(() => _promiseCallback());\n                });\n            }\n            if (message) {\n                this.proxy.$setMessage(this.viewId, MarkdownString.fromStrict(this._message) ?? '');\n            }\n        }));\n    }\n    async getChildren(parentHandle) {\n        const parentElement = parentHandle ? this.getExtensionElement(parentHandle) : undefined;\n        if (parentHandle && !parentElement) {\n            this.logService.error(`No tree item with id \\'${parentHandle}\\' found.`);\n            return Promise.resolve([]);\n        }\n        let childrenNodes = this.getChildrenNodes(parentHandle);\n        if (!childrenNodes) {\n            childrenNodes = await this.fetchChildrenNodes(parentElement);\n        }\n        return childrenNodes ? ( childrenNodes.map(n => n.item)) : undefined;\n    }\n    getExtensionElement(treeItemHandle) {\n        return this.elements.get(treeItemHandle);\n    }\n    reveal(element, options) {\n        options = options ? options : { select: true, focus: false };\n        const select = isUndefinedOrNull(options.select) ? true : options.select;\n        const focus = isUndefinedOrNull(options.focus) ? false : options.focus;\n        const expand = isUndefinedOrNull(options.expand) ? false : options.expand;\n        if (typeof this.dataProvider.getParent !== 'function') {\n            return Promise.reject(( new Error(\n                `Required registered TreeDataProvider to implement 'getParent' method to access 'reveal' method`\n            )));\n        }\n        if (element) {\n            return this.refreshPromise\n                .then(() => this.resolveUnknownParentChain(element))\n                .then(parentChain => this.resolveTreeNode(element, parentChain[parentChain.length - 1])\n                .then(treeNode => this.proxy.$reveal(this.viewId, { item: treeNode.item, parentChain: ( parentChain.map(p => p.item)) }, { select, focus, expand })), error => this.logService.error(error));\n        }\n        else {\n            return this.proxy.$reveal(this.viewId, undefined, { select, focus, expand });\n        }\n    }\n    get message() {\n        return this._message;\n    }\n    set message(message) {\n        this._message = message;\n        this._onDidChangeData.fire({ message: true, element: false });\n    }\n    get title() {\n        return this._title;\n    }\n    set title(title) {\n        this._title = title;\n        this.proxy.$setTitle(this.viewId, title, this._description);\n    }\n    get description() {\n        return this._description;\n    }\n    set description(description) {\n        this._description = description;\n        this.proxy.$setTitle(this.viewId, this._title, description);\n    }\n    get badge() {\n        return this._badge;\n    }\n    set badge(badge) {\n        if (this._badge?.value === badge?.value &&\n            this._badge?.tooltip === badge?.tooltip) {\n            return;\n        }\n        this._badge = ViewBadge.from(badge);\n        this.proxy.$setBadge(this.viewId, badge);\n    }\n    setExpanded(treeItemHandle, expanded) {\n        const element = this.getExtensionElement(treeItemHandle);\n        if (element) {\n            if (expanded) {\n                this._onDidExpandElement.fire(( Object.freeze({ element })));\n            }\n            else {\n                this._onDidCollapseElement.fire(( Object.freeze({ element })));\n            }\n        }\n    }\n    setSelectionAndFocus(selectedHandles, focusedHandle) {\n        const changedSelection = !equals(this._selectedHandles, selectedHandles);\n        this._selectedHandles = selectedHandles;\n        const changedFocus = this._focusedHandle !== focusedHandle;\n        this._focusedHandle = focusedHandle;\n        if (changedSelection) {\n            this._onDidChangeSelection.fire(( Object.freeze({ selection: this.selectedElements })));\n        }\n        if (changedFocus) {\n            this._onDidChangeActiveItem.fire(( Object.freeze({ activeItem: this.focusedElement })));\n        }\n    }\n    setVisible(visible) {\n        if (visible !== this._visible) {\n            this._visible = visible;\n            this._onDidChangeVisibility.fire(( Object.freeze({ visible: this._visible })));\n        }\n    }\n    async setCheckboxState(checkboxUpdates) {\n        const items = (await Promise.all(( checkboxUpdates.map(async (checkboxUpdate) => {\n            const extensionItem = this.getExtensionElement(checkboxUpdate.treeItemHandle);\n            if (extensionItem) {\n                return {\n                    extensionItem: extensionItem,\n                    treeItem: await this.dataProvider.getTreeItem(extensionItem),\n                    newState: checkboxUpdate.newState ? TreeItemCheckboxState.Checked : TreeItemCheckboxState.Unchecked\n                };\n            }\n            return Promise.resolve(undefined);\n        })))).filter((item) => item !== undefined);\n        items.forEach(item => {\n            item.treeItem.checkboxState = item.newState ? TreeItemCheckboxState.Checked : TreeItemCheckboxState.Unchecked;\n        });\n        this._onDidChangeCheckboxState.fire({ items: ( items.map(item => [item.extensionItem, item.newState])) });\n    }\n    async handleDrag(sourceTreeItemHandles, treeDataTransfer, token) {\n        const extensionTreeItems = [];\n        for (const sourceHandle of sourceTreeItemHandles) {\n            const extensionItem = this.getExtensionElement(sourceHandle);\n            if (extensionItem) {\n                extensionTreeItems.push(extensionItem);\n            }\n        }\n        if (!this.dndController?.handleDrag || (extensionTreeItems.length === 0)) {\n            return;\n        }\n        await this.dndController.handleDrag(extensionTreeItems, treeDataTransfer, token);\n        return treeDataTransfer;\n    }\n    get hasHandleDrag() {\n        return !!this.dndController?.handleDrag;\n    }\n    async onDrop(treeDataTransfer, targetHandleOrNode, token) {\n        const target = targetHandleOrNode ? this.getExtensionElement(targetHandleOrNode) : undefined;\n        if ((!target && targetHandleOrNode) || !this.dndController?.handleDrop) {\n            return;\n        }\n        return asPromise(() => this.dndController?.handleDrop\n            ? this.dndController.handleDrop(target, treeDataTransfer, token)\n            : undefined);\n    }\n    get hasResolve() {\n        return !!this.dataProvider.resolveTreeItem;\n    }\n    async resolveTreeItem(treeItemHandle, token) {\n        if (!this.dataProvider.resolveTreeItem) {\n            return;\n        }\n        const element = this.elements.get(treeItemHandle);\n        if (element) {\n            const node = this.nodes.get(element);\n            if (node) {\n                const resolve = (await this.dataProvider.resolveTreeItem(node.extensionItem, element, token)) ?? node.extensionItem;\n                this.validateTreeItem(resolve);\n                node.item.tooltip = this.getTooltip(resolve.tooltip);\n                node.item.command = this.getCommand(node.disposableStore, resolve.command);\n                return node.item;\n            }\n        }\n        return;\n    }\n    resolveUnknownParentChain(element) {\n        return this.resolveParent(element)\n            .then((parent) => {\n            if (!parent) {\n                return Promise.resolve([]);\n            }\n            return this.resolveUnknownParentChain(parent)\n                .then(result => this.resolveTreeNode(parent, result[result.length - 1])\n                .then(parentNode => {\n                result.push(parentNode);\n                return result;\n            }));\n        });\n    }\n    resolveParent(element) {\n        const node = this.nodes.get(element);\n        if (node) {\n            return Promise.resolve(node.parent ? this.elements.get(node.parent.item.handle) : undefined);\n        }\n        return asPromise(() => this.dataProvider.getParent(element));\n    }\n    resolveTreeNode(element, parent) {\n        const node = this.nodes.get(element);\n        if (node) {\n            return Promise.resolve(node);\n        }\n        return asPromise(() => this.dataProvider.getTreeItem(element))\n            .then(extTreeItem => this.createHandle(element, extTreeItem, parent, true))\n            .then(handle => this.getChildren(parent ? parent.item.handle : undefined)\n            .then(() => {\n            const cachedElement = this.getExtensionElement(handle);\n            if (cachedElement) {\n                const node = this.nodes.get(cachedElement);\n                if (node) {\n                    return Promise.resolve(node);\n                }\n            }\n            throw ( new Error(\n                `Cannot resolve tree item for element ${handle} from extension ${this.extension.identifier.value}`\n            ));\n        }));\n    }\n    getChildrenNodes(parentNodeOrHandle) {\n        if (parentNodeOrHandle) {\n            let parentNode;\n            if (typeof parentNodeOrHandle === 'string') {\n                const parentElement = this.getExtensionElement(parentNodeOrHandle);\n                parentNode = parentElement ? this.nodes.get(parentElement) : undefined;\n            }\n            else {\n                parentNode = parentNodeOrHandle;\n            }\n            return parentNode ? parentNode.children || undefined : undefined;\n        }\n        return this.roots;\n    }\n    async fetchChildrenNodes(parentElement) {\n        this.clearChildren(parentElement);\n        const cts = ( new CancellationTokenSource(this._refreshCancellationSource.token));\n        try {\n            const parentNode = parentElement ? this.nodes.get(parentElement) : undefined;\n            const elements = await this.dataProvider.getChildren(parentElement);\n            if (cts.token.isCancellationRequested) {\n                return undefined;\n            }\n            const coalescedElements = coalesce(elements || []);\n            const treeItems = await Promise.all(( coalesce(coalescedElements).map(element => {\n                return this.dataProvider.getTreeItem(element);\n            })));\n            if (cts.token.isCancellationRequested) {\n                return undefined;\n            }\n            const items = ( treeItems.map(\n                (item, index) => item ? this.createAndRegisterTreeNode(coalescedElements[index], item, parentNode) : null\n            ));\n            return coalesce(items);\n        }\n        finally {\n            cts.dispose();\n        }\n    }\n    refresh(elements) {\n        const hasRoot = ( elements.some(element => !element));\n        if (hasRoot) {\n            this._refreshCancellationSource.dispose(true);\n            this._refreshCancellationSource = ( new CancellationTokenSource());\n            this.clearAll();\n            return this.proxy.$refresh(this.viewId);\n        }\n        else {\n            const handlesToRefresh = this.getHandlesToRefresh(elements);\n            if (handlesToRefresh.length) {\n                return this.refreshHandles(handlesToRefresh);\n            }\n        }\n        return Promise.resolve(undefined);\n    }\n    getHandlesToRefresh(elements) {\n        const elementsToUpdate = ( new Set());\n        const elementNodes = ( elements.map(element => this.nodes.get(element)));\n        for (const elementNode of elementNodes) {\n            if (elementNode && !( elementsToUpdate.has(elementNode.item.handle))) {\n                let currentNode = elementNode;\n                while (currentNode && currentNode.parent && elementNodes.findIndex(node => currentNode && currentNode.parent && node && node.item.handle === currentNode.parent.item.handle) === -1) {\n                    const parentElement = this.elements.get(currentNode.parent.item.handle);\n                    currentNode = parentElement ? this.nodes.get(parentElement) : undefined;\n                }\n                if (currentNode && !currentNode.parent) {\n                    elementsToUpdate.add(elementNode.item.handle);\n                }\n            }\n        }\n        const handlesToUpdate = [];\n        elementsToUpdate.forEach((handle) => {\n            const element = this.elements.get(handle);\n            if (element) {\n                const node = this.nodes.get(element);\n                if (node && (!node.parent || !( elementsToUpdate.has(node.parent.item.handle)))) {\n                    handlesToUpdate.push(handle);\n                }\n            }\n        });\n        return handlesToUpdate;\n    }\n    refreshHandles(itemHandles) {\n        const itemsToRefresh = {};\n        return Promise.all(( itemHandles.map(treeItemHandle => this.refreshNode(treeItemHandle)\n            .then(node => {\n            if (node) {\n                itemsToRefresh[treeItemHandle] = node.item;\n            }\n        }))))\n            .then(() => ( Object.keys(itemsToRefresh)).length ? this.proxy.$refresh(this.viewId, itemsToRefresh) : undefined);\n    }\n    refreshNode(treeItemHandle) {\n        const extElement = this.getExtensionElement(treeItemHandle);\n        if (extElement) {\n            const existing = this.nodes.get(extElement);\n            if (existing) {\n                this.clearChildren(extElement);\n                return asPromise(() => this.dataProvider.getTreeItem(extElement))\n                    .then(extTreeItem => {\n                    if (extTreeItem) {\n                        const newNode = this.createTreeNode(extElement, extTreeItem, existing.parent);\n                        this.updateNodeCache(extElement, newNode, existing, existing.parent);\n                        existing.dispose();\n                        return newNode;\n                    }\n                    return null;\n                });\n            }\n        }\n        return Promise.resolve(null);\n    }\n    createAndRegisterTreeNode(element, extTreeItem, parentNode) {\n        const node = this.createTreeNode(element, extTreeItem, parentNode);\n        if (extTreeItem.id && ( this.elements.has(node.item.handle))) {\n            throw ( new Error(\n                localize(4804, 'Element with id {0} is already registered', extTreeItem.id)\n            ));\n        }\n        this.addNodeToCache(element, node);\n        this.addNodeToParentCache(node, parentNode);\n        return node;\n    }\n    getTooltip(tooltip) {\n        if (MarkdownString$1.isMarkdownString(tooltip)) {\n            return MarkdownString.from(tooltip);\n        }\n        return tooltip;\n    }\n    getCommand(disposable, command) {\n        return command ? { ...this.commands.toInternal(command, disposable), originalId: command.command } : undefined;\n    }\n    getCheckbox(extensionTreeItem) {\n        if (extensionTreeItem.checkboxState === undefined) {\n            return undefined;\n        }\n        let checkboxState;\n        let tooltip = undefined;\n        let accessibilityInformation = undefined;\n        if (typeof extensionTreeItem.checkboxState === 'number') {\n            checkboxState = extensionTreeItem.checkboxState;\n        }\n        else {\n            checkboxState = extensionTreeItem.checkboxState.state;\n            tooltip = extensionTreeItem.checkboxState.tooltip;\n            accessibilityInformation = extensionTreeItem.checkboxState.accessibilityInformation;\n        }\n        return { isChecked: checkboxState === TreeItemCheckboxState.Checked, tooltip, accessibilityInformation };\n    }\n    validateTreeItem(extensionTreeItem) {\n        if (!TreeItem.isTreeItem(extensionTreeItem, this.extension)) {\n            throw ( new Error(\n                `Extension ${this.extension.identifier.value} has provided an invalid tree item.`\n            ));\n        }\n    }\n    createTreeNode(element, extensionTreeItem, parent) {\n        this.validateTreeItem(extensionTreeItem);\n        const disposableStore = this._register(( new DisposableStore()));\n        const handle = this.createHandle(element, extensionTreeItem, parent);\n        const icon = this.getLightIconPath(extensionTreeItem);\n        const item = {\n            handle,\n            parentHandle: parent ? parent.item.handle : undefined,\n            label: toTreeItemLabel(extensionTreeItem.label),\n            description: extensionTreeItem.description,\n            resourceUri: extensionTreeItem.resourceUri,\n            tooltip: this.getTooltip(extensionTreeItem.tooltip),\n            command: this.getCommand(disposableStore, extensionTreeItem.command),\n            contextValue: extensionTreeItem.contextValue,\n            icon,\n            iconDark: this.getDarkIconPath(extensionTreeItem) || icon,\n            themeIcon: this.getThemeIcon(extensionTreeItem),\n            collapsibleState: isUndefinedOrNull(extensionTreeItem.collapsibleState) ? TreeItemCollapsibleState.None : extensionTreeItem.collapsibleState,\n            accessibilityInformation: extensionTreeItem.accessibilityInformation,\n            checkbox: this.getCheckbox(extensionTreeItem),\n        };\n        return {\n            item,\n            extensionItem: extensionTreeItem,\n            parent,\n            children: undefined,\n            disposableStore,\n            dispose() { disposableStore.dispose(); }\n        };\n    }\n    getThemeIcon(extensionTreeItem) {\n        return extensionTreeItem.iconPath instanceof ThemeIcon ? extensionTreeItem.iconPath : undefined;\n    }\n    createHandle(element, { id, label, resourceUri }, parent, returnFirst) {\n        if (id) {\n            return `${ExtHostTreeView.ID_HANDLE_PREFIX}/${id}`;\n        }\n        const treeItemLabel = toTreeItemLabel(label);\n        const prefix = parent ? parent.item.handle : ExtHostTreeView.LABEL_HANDLE_PREFIX;\n        let elementId = treeItemLabel ? treeItemLabel.label : resourceUri ? basename(resourceUri) : '';\n        elementId = elementId.indexOf('/') !== -1 ? elementId.replace('/', '//') : elementId;\n        const existingHandle = ( this.nodes.has(element)) ? this.nodes.get(element).item.handle : undefined;\n        const childrenNodes = (this.getChildrenNodes(parent) || []);\n        let handle;\n        let counter = 0;\n        do {\n            handle = `${prefix}/${counter}:${elementId}`;\n            if (returnFirst || !( this.elements.has(handle)) || existingHandle === handle) {\n                break;\n            }\n            counter++;\n        } while (counter <= childrenNodes.length);\n        return handle;\n    }\n    getLightIconPath(extensionTreeItem) {\n        if (extensionTreeItem.iconPath && !(extensionTreeItem.iconPath instanceof ThemeIcon)) {\n            if (typeof extensionTreeItem.iconPath === 'string'\n                || URI.isUri(extensionTreeItem.iconPath)) {\n                return this.getIconPath(extensionTreeItem.iconPath);\n            }\n            return this.getIconPath(extensionTreeItem.iconPath.light);\n        }\n        return undefined;\n    }\n    getDarkIconPath(extensionTreeItem) {\n        if (extensionTreeItem.iconPath && !(extensionTreeItem.iconPath instanceof ThemeIcon) && extensionTreeItem.iconPath.dark) {\n            return this.getIconPath(extensionTreeItem.iconPath.dark);\n        }\n        return undefined;\n    }\n    getIconPath(iconPath) {\n        if (URI.isUri(iconPath)) {\n            return iconPath;\n        }\n        return URI.file(iconPath);\n    }\n    addNodeToCache(element, node) {\n        this.elements.set(node.item.handle, element);\n        this.nodes.set(element, node);\n    }\n    updateNodeCache(element, newNode, existing, parentNode) {\n        this.elements.delete(newNode.item.handle);\n        this.nodes.delete(element);\n        if (newNode.item.handle !== existing.item.handle) {\n            this.elements.delete(existing.item.handle);\n        }\n        this.addNodeToCache(element, newNode);\n        const childrenNodes = (this.getChildrenNodes(parentNode) || []);\n        const childNode = childrenNodes.filter(c => c.item.handle === existing.item.handle)[0];\n        if (childNode) {\n            childrenNodes.splice(childrenNodes.indexOf(childNode), 1, newNode);\n        }\n    }\n    addNodeToParentCache(node, parentNode) {\n        if (parentNode) {\n            if (!parentNode.children) {\n                parentNode.children = [];\n            }\n            parentNode.children.push(node);\n        }\n        else {\n            if (!this.roots) {\n                this.roots = [];\n            }\n            this.roots.push(node);\n        }\n    }\n    clearChildren(parentElement) {\n        if (parentElement) {\n            const node = this.nodes.get(parentElement);\n            if (node) {\n                if (node.children) {\n                    for (const child of node.children) {\n                        const childElement = this.elements.get(child.item.handle);\n                        if (childElement) {\n                            this.clear(childElement);\n                        }\n                    }\n                }\n                node.children = undefined;\n            }\n        }\n        else {\n            this.clearAll();\n        }\n    }\n    clear(element) {\n        const node = this.nodes.get(element);\n        if (node) {\n            if (node.children) {\n                for (const child of node.children) {\n                    const childElement = this.elements.get(child.item.handle);\n                    if (childElement) {\n                        this.clear(childElement);\n                    }\n                }\n            }\n            this.nodes.delete(element);\n            this.elements.delete(node.item.handle);\n            node.dispose();\n        }\n    }\n    clearAll() {\n        this.roots = undefined;\n        this.elements.clear();\n        this.nodes.forEach(node => node.dispose());\n        this.nodes.clear();\n    }\n    dispose() {\n        super.dispose();\n        this._refreshCancellationSource.dispose();\n        this.clearAll();\n        this.proxy.$disposeTree(this.viewId);\n    }\n}\nexport { ExtHostTreeViews };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { localize } from '../../../nls.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { ILogService } from '../../../platform/log/common/log.service.js';\nimport { TunnelPrivacyId, DisposableTunnel } from '../../../platform/tunnel/common/tunnel.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { IExtHostInitDataService } from './extHostInitDataService.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\nimport { Disposable as Disposable$1 } from './extHostTypes.js';\nclass ExtensionTunnel extends DisposableTunnel {\n}\nvar TunnelDtoConverter;\n( ((function(TunnelDtoConverter) {\n    function fromApiTunnel(tunnel) {\n        return {\n            remoteAddress: tunnel.remoteAddress,\n            localAddress: tunnel.localAddress,\n            public: !!tunnel.public,\n            privacy: tunnel.privacy ?? (tunnel.public ? TunnelPrivacyId.Public : TunnelPrivacyId.Private),\n            protocol: tunnel.protocol\n        };\n    }\n    TunnelDtoConverter.fromApiTunnel = fromApiTunnel;\n    function fromServiceTunnel(tunnel) {\n        return {\n            remoteAddress: {\n                host: tunnel.tunnelRemoteHost,\n                port: tunnel.tunnelRemotePort\n            },\n            localAddress: tunnel.localAddress,\n            public: tunnel.privacy !== TunnelPrivacyId.ConstantPrivate && tunnel.privacy !== TunnelPrivacyId.ConstantPrivate,\n            privacy: tunnel.privacy,\n            protocol: tunnel.protocol\n        };\n    }\n    TunnelDtoConverter.fromServiceTunnel = fromServiceTunnel;\n})(TunnelDtoConverter || (TunnelDtoConverter = {}))));\nconst IExtHostTunnelService = ( (createDecorator('IExtHostTunnelService')));\nlet ExtHostTunnelService = class ExtHostTunnelService extends Disposable {\n    constructor(extHostRpc, initData, logService) {\n        super();\n        this.logService = logService;\n        this._showCandidatePort = () => { return Promise.resolve(true); };\n        this._extensionTunnels = ( (new Map()));\n        this._onDidChangeTunnels = ( (new Emitter()));\n        this.onDidChangeTunnels = this._onDidChangeTunnels.event;\n        this._providerHandleCounter = 0;\n        this._portAttributesProviders = ( (new Map()));\n        this._proxy = ( (extHostRpc.getProxy(MainContext.MainThreadTunnelService)));\n    }\n    async openTunnel(extension, forward) {\n        this.logService.trace(`ForwardedPorts: (ExtHostTunnelService) ${extension.identifier.value} called openTunnel API for ${forward.remoteAddress.host}:${forward.remoteAddress.port}.`);\n        const tunnel = await this._proxy.$openTunnel(forward, extension.displayName);\n        if (tunnel) {\n            const disposableTunnel = ( (new ExtensionTunnel(tunnel.remoteAddress, tunnel.localAddress, () => {\n                return this._proxy.$closeTunnel(tunnel.remoteAddress);\n            })));\n            this._register(disposableTunnel);\n            return disposableTunnel;\n        }\n        return undefined;\n    }\n    async getTunnels() {\n        return this._proxy.$getTunnels();\n    }\n    nextPortAttributesProviderHandle() {\n        return this._providerHandleCounter++;\n    }\n    registerPortsAttributesProvider(portSelector, provider) {\n        if (portSelector.portRange === undefined && portSelector.commandPattern === undefined) {\n            this.logService.error('PortAttributesProvider must specify either a portRange or a commandPattern');\n        }\n        const providerHandle = this.nextPortAttributesProviderHandle();\n        this._portAttributesProviders.set(providerHandle, { selector: portSelector, provider });\n        this._proxy.$registerPortsAttributesProvider(portSelector, providerHandle);\n        return new Disposable$1(() => {\n            this._portAttributesProviders.delete(providerHandle);\n            this._proxy.$unregisterPortsAttributesProvider(providerHandle);\n        });\n    }\n    async $providePortAttributes(handles, ports, pid, commandLine, cancellationToken) {\n        const providedAttributes = [];\n        for (const handle of handles) {\n            const provider = this._portAttributesProviders.get(handle);\n            if (!provider) {\n                return [];\n            }\n            providedAttributes.push(...(await Promise.all(( (ports.map(async (port) => {\n                let providedAttributes;\n                try {\n                    providedAttributes = await provider.provider.providePortAttributes({ port, pid, commandLine }, cancellationToken);\n                }\n                catch (e) {\n                    providedAttributes = await provider.provider.providePortAttributes(port, pid, commandLine, cancellationToken);\n                }\n                return { providedAttributes, port };\n            }))))));\n        }\n        const allAttributes = providedAttributes.filter(attribute => !!attribute.providedAttributes);\n        return (allAttributes.length > 0) ? ( (allAttributes.map(attributes => {\n            return {\n                autoForwardAction: attributes.providedAttributes.autoForwardAction,\n                port: attributes.port\n            };\n        }))) : [];\n    }\n    async $registerCandidateFinder(_enable) { }\n    registerTunnelProvider(provider, information) {\n        if (this._forwardPortProvider) {\n            throw ( (new Error(\n                'A tunnel provider has already been registered. Only the first tunnel provider to be registered will be used.'\n            )));\n        }\n        this._forwardPortProvider = async (tunnelOptions, tunnelCreationOptions) => {\n            const result = await provider.provideTunnel(tunnelOptions, tunnelCreationOptions, CancellationToken.None);\n            return result ?? undefined;\n        };\n        const tunnelFeatures = information.tunnelFeatures ? {\n            elevation: !!information.tunnelFeatures?.elevation,\n            privacyOptions: information.tunnelFeatures?.privacyOptions,\n            protocol: information.tunnelFeatures.protocol === undefined ? true : information.tunnelFeatures.protocol,\n        } : undefined;\n        this._proxy.$setTunnelProvider(tunnelFeatures, true);\n        return Promise.resolve(toDisposable(() => {\n            this._forwardPortProvider = undefined;\n            this._proxy.$setTunnelProvider(undefined, false);\n        }));\n    }\n    async setTunnelFactory(provider, managedRemoteAuthority) {\n        if (provider) {\n            if (provider.candidatePortSource !== undefined) {\n                this._proxy.$setCandidatePortSource(provider.candidatePortSource);\n            }\n            if (provider.showCandidatePort) {\n                this._showCandidatePort = provider.showCandidatePort;\n                this._proxy.$setCandidateFilter();\n            }\n            const tunnelFactory = provider.tunnelFactory ?? (managedRemoteAuthority ? this.makeManagedTunnelFactory(managedRemoteAuthority) : undefined);\n            if (tunnelFactory) {\n                this._forwardPortProvider = tunnelFactory;\n                let privacyOptions = provider.tunnelFeatures?.privacyOptions ?? [];\n                if (provider.tunnelFeatures?.public && (privacyOptions.length === 0)) {\n                    privacyOptions = [\n                        {\n                            id: 'private',\n                            label: ( localize(586, \"Private\")),\n                            themeIcon: 'lock'\n                        },\n                        {\n                            id: 'public',\n                            label: ( localize(587, \"Public\")),\n                            themeIcon: 'eye'\n                        }\n                    ];\n                }\n                const tunnelFeatures = provider.tunnelFeatures ? {\n                    elevation: !!provider.tunnelFeatures?.elevation,\n                    public: !!provider.tunnelFeatures?.public,\n                    privacyOptions,\n                    protocol: true\n                } : undefined;\n                this._proxy.$setTunnelProvider(tunnelFeatures, !!provider.tunnelFactory);\n            }\n        }\n        else {\n            this._forwardPortProvider = undefined;\n        }\n        return toDisposable(() => {\n            this._forwardPortProvider = undefined;\n        });\n    }\n    makeManagedTunnelFactory(_authority) {\n        return undefined;\n    }\n    async $closeTunnel(remote, silent) {\n        if (( (this._extensionTunnels.has(remote.host)))) {\n            const hostMap = this._extensionTunnels.get(remote.host);\n            if (( (hostMap.has(remote.port)))) {\n                if (silent) {\n                    hostMap.get(remote.port).disposeListener.dispose();\n                }\n                await hostMap.get(remote.port).tunnel.dispose();\n                hostMap.delete(remote.port);\n            }\n        }\n    }\n    async $onDidTunnelsChange() {\n        this._onDidChangeTunnels.fire();\n    }\n    async $forwardPort(tunnelOptions, tunnelCreationOptions) {\n        if (this._forwardPortProvider) {\n            try {\n                this.logService.trace('ForwardedPorts: (ExtHostTunnelService) Getting tunnel from provider.');\n                const providedPort = this._forwardPortProvider(tunnelOptions, tunnelCreationOptions);\n                this.logService.trace('ForwardedPorts: (ExtHostTunnelService) Got tunnel promise from provider.');\n                if (providedPort !== undefined) {\n                    const tunnel = await providedPort;\n                    this.logService.trace('ForwardedPorts: (ExtHostTunnelService) Successfully awaited tunnel from provider.');\n                    if (tunnel === undefined) {\n                        this.logService.error('ForwardedPorts: (ExtHostTunnelService) Resolved tunnel is undefined');\n                        return undefined;\n                    }\n                    if (!( (this._extensionTunnels.has(tunnelOptions.remoteAddress.host)))) {\n                        this._extensionTunnels.set(tunnelOptions.remoteAddress.host, ( (new Map())));\n                    }\n                    const disposeListener = this._register(tunnel.onDidDispose(() => {\n                        this.logService.trace('ForwardedPorts: (ExtHostTunnelService) Extension fired tunnel\\'s onDidDispose.');\n                        return this._proxy.$closeTunnel(tunnel.remoteAddress);\n                    }));\n                    this._extensionTunnels.get(tunnelOptions.remoteAddress.host).set(tunnelOptions.remoteAddress.port, { tunnel, disposeListener });\n                    return TunnelDtoConverter.fromApiTunnel(tunnel);\n                }\n                else {\n                    this.logService.trace('ForwardedPorts: (ExtHostTunnelService) Tunnel is undefined');\n                }\n            }\n            catch (e) {\n                this.logService.trace('ForwardedPorts: (ExtHostTunnelService) tunnel provider error');\n                if (e instanceof Error) {\n                    return e.message;\n                }\n            }\n        }\n        return undefined;\n    }\n    async $applyCandidateFilter(candidates) {\n        const filter = await Promise.all(( (candidates.map(\n            candidate => this._showCandidatePort(candidate.host, candidate.port, candidate.detail ?? '')\n        ))));\n        const result = candidates.filter((candidate, index) => filter[index]);\n        this.logService.trace(`ForwardedPorts: (ExtHostTunnelService) filtered from ${( (candidates.map(port => port.port))).join(', ')} to ${( (result.map(port => port.port))).join(', ')}`);\n        return result;\n    }\n};\nExtHostTunnelService = ( (__decorate([\n    ( (__param(0, IExtHostRpcService))),\n    ( (__param(1, IExtHostInitDataService))),\n    ( (__param(2, ILogService)))\n], ExtHostTunnelService)));\nexport { ExtHostTunnelService, IExtHostTunnelService, TunnelDtoConverter };\n","import { coalesce, asArray, isNonEmptyArray } from '../../../base/common/arrays.js';\nimport { encodeBase64, VSBuffer } from '../../../base/common/buffer.js';\nimport { UriList } from '../../../base/common/dataTransfer.js';\nimport { createSingleCallFunction } from '../../../base/common/functional.js';\nimport { parseHrefAndDimensions, isMarkdownString } from '../../../base/common/htmlContent.js';\nimport { ResourceSet, ResourceMap } from '../../../base/common/map.js';\nimport { marked } from 'marked';\nimport { revive, parse } from '../../../base/common/marshalling.js';\nimport { Mimes } from '../../../base/common/mime.js';\nimport { cloneAndChange } from '../../../base/common/objects.js';\nimport { WellDefinedPrefixTree } from '../../../base/common/prefixTree.js';\nimport { basename } from '../../../base/common/resources.js';\nimport { ThemeIcon } from '../../../base/common/themables.js';\nimport { isString, isEmptyObject, isUndefinedOrNull, isNumber, isDefined } from '../../../base/common/types.js';\nimport { URI, isUriComponents } from '../../../base/common/uri.js';\nimport { Range as Range$2 } from '../../../editor/common/core/range.js';\nimport { Command, FoldingRangeKind as FoldingRangeKind$2 } from '../../../editor/common/languages.js';\nimport { MarkerSeverity } from '../../../platform/markers/common/markers.js';\nimport { DEFAULT_EDITOR_ASSOCIATION } from '../../common/editor.js';\nimport { ChatAgentLocation } from '../../contrib/chat/common/chatAgents.js';\nimport { CellKind, NotebookCellExecutionState as NotebookCellExecutionState$1 } from '../../contrib/notebook/common/notebookCommon.js';\nimport { TestId } from '../../contrib/testing/common/testId.js';\nimport { namespaceTestTag, denamespaceTestTag } from '../../contrib/testing/common/testTypes.js';\nimport { SIDE_GROUP, ACTIVE_GROUP } from '../../services/editor/common/editorService.js';\nimport { getPrivateApiFor } from './extHostTestingPrivateApi.js';\nimport { Position as Position$1, Selection as Selection$1, Range as Range$1, Diagnostic as Diagnostic$1, ViewColumn as ViewColumn$1, MarkdownString as MarkdownString$1, WorkspaceEdit as WorkspaceEdit$1, SnippetTextEdit, SnippetString, TextEdit as TextEdit$1, SymbolKind as SymbolKind$1, SymbolInformation, CallHierarchyItem as CallHierarchyItem$1, CallHierarchyIncomingCall as CallHierarchyIncomingCall$1, CallHierarchyOutgoingCall as CallHierarchyOutgoingCall$1, Location as Location$1, InlineValueText, InlineValueVariableLookup, InlineValueEvaluatableExpression, InlineValueContext as InlineValueContext$1, CompletionItem as CompletionItem$1, InlayHint as InlayHint$1, DocumentLink as DocumentLink$1, ColorPresentation as ColorPresentation$1, Color as Color$1, NotebookRange as NotebookRange$1, NotebookCellData as NotebookCellData$1, NotebookCellOutputItem as NotebookCellOutputItem$1, NotebookCellOutput as NotebookCellOutput$1, TestTag as TestTag$1, CodeActionTriggerKind as CodeActionTriggerKind$1, TypeHierarchyItem as TypeHierarchyItem$1, ChatResponseProgressPart as ChatResponseProgressPart$1, ChatResponseReferencePart as ChatResponseReferencePart$1, ChatLocation as ChatLocation$1, DiagnosticRelatedInformation as DiagnosticRelatedInformation$1, DiagnosticSeverity as DiagnosticSeverity$1, VerboseHover, DocumentHighlight as DocumentHighlight$1, InlayHintLabelPart as InlayHintLabelPart$1, FoldingRangeKind as FoldingRangeKind$1, NotebookData as NotebookData$1, NotebookCellStatusBarAlignment, LanguageModelToolResultPart, LanguageModelToolCallPart, LanguageModelChatMessage as LanguageModelChatMessage$1, ChatResponseMarkdownPart as ChatResponseMarkdownPart$1, ChatResponseCodeblockUriPart as ChatResponseCodeblockUriPart$1, ChatResponseMarkdownWithVulnerabilitiesPart as ChatResponseMarkdownWithVulnerabilitiesPart$1, ChatResponseDetectedParticipantPart as ChatResponseDetectedParticipantPart$1, ChatResponseFileTreePart, ChatResponseAnchorPart as ChatResponseAnchorPart$1, ChatResponseWarningPart as ChatResponseWarningPart$1, ChatResponseCommandButtonPart as ChatResponseCommandButtonPart$1, ChatResponseTextEditPart as ChatResponseTextEditPart$1, ChatResponseConfirmationPart as ChatResponseConfirmationPart$1, ChatResponseCodeCitationPart as ChatResponseCodeCitationPart$1, ChatResponseMovePart as ChatResponseMovePart$1, DiagnosticTag as DiagnosticTag$1, DecorationRangeBehavior as DecorationRangeBehavior$1, SymbolTag as SymbolTag$1, CompletionItemTag as CompletionItemTag$1, CompletionItemKind as CompletionItemKind$1, EndOfLine as EndOfLine$1, RelativePattern, NotebookCellKind as NotebookCellKind$1, LanguageModelChatMessageRole as LanguageModelChatMessageRole$1, TestMessage as TestMessage$1, StatementCoverage, BranchCoverage, DeclarationCoverage, validateTestCoverageCount, FileCoverage, DataTransfer as DataTransfer$1, StandardTokenType, TextDocumentSaveReason as TextDocumentSaveReason$1, TextEditorLineNumbersStyle as TextEditorLineNumbersStyle$1, ProgressLocation as ProgressLocation$1, NotebookCellExecutionState as NotebookCellExecutionState$2, InternalFileDataTransferItem, DataTransferFile, InternalDataTransferItem, DocumentSymbol as DocumentSymbol$1, EvaluatableExpression as EvaluatableExpression$1, MultiDocumentHighlight as MultiDocumentHighlight$1, SelectionRange as SelectionRange$1, NotebookRendererScript as NotebookRendererScript$1, CompletionTriggerKind as CompletionTriggerKind$1, PartialAcceptTriggerKind as PartialAcceptTriggerKind$1 } from './extHostTypes.js';\nvar Selection;\n( (function(Selection) {\n    function to(selection) {\n        const { selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn } = selection;\n        const start = new Position$1(selectionStartLineNumber - 1, selectionStartColumn - 1);\n        const end = new Position$1(positionLineNumber - 1, positionColumn - 1);\n        return new Selection$1(start, end);\n    }\n    Selection.to = to;\n    function from(selection) {\n        const { anchor, active } = selection;\n        return {\n            selectionStartLineNumber: anchor.line + 1,\n            selectionStartColumn: anchor.character + 1,\n            positionLineNumber: active.line + 1,\n            positionColumn: active.character + 1\n        };\n    }\n    Selection.from = from;\n})(Selection || (Selection = {})));\nvar Range;\n( (function(Range) {\n    function from(range) {\n        if (!range) {\n            return undefined;\n        }\n        const { start, end } = range;\n        return {\n            startLineNumber: start.line + 1,\n            startColumn: start.character + 1,\n            endLineNumber: end.line + 1,\n            endColumn: end.character + 1\n        };\n    }\n    Range.from = from;\n    function to(range) {\n        if (!range) {\n            return undefined;\n        }\n        const { startLineNumber, startColumn, endLineNumber, endColumn } = range;\n        return new Range$1(startLineNumber - 1, startColumn - 1, endLineNumber - 1, endColumn - 1);\n    }\n    Range.to = to;\n})(Range || (Range = {})));\nvar Location;\n( (function(Location) {\n    function from(location) {\n        return {\n            uri: location.uri,\n            range: Range.from(location.range)\n        };\n    }\n    Location.from = from;\n    function to(location) {\n        return new Location$1(URI.revive(location.uri), Range.to(location.range));\n    }\n    Location.to = to;\n})(Location || (Location = {})));\nvar TokenType;\n( (function(TokenType) {\n    function to(type) {\n        switch (type) {\n            case 1 : return StandardTokenType.Comment;\n            case 0 : return StandardTokenType.Other;\n            case 3 : return StandardTokenType.RegEx;\n            case 2 : return StandardTokenType.String;\n        }\n    }\n    TokenType.to = to;\n})(TokenType || (TokenType = {})));\nvar Position;\n( (function(Position) {\n    function to(position) {\n        return new Position$1(position.lineNumber - 1, position.column - 1);\n    }\n    Position.to = to;\n    function from(position) {\n        return { lineNumber: position.line + 1, column: position.character + 1 };\n    }\n    Position.from = from;\n})(Position || (Position = {})));\nvar DocumentSelector;\n( (function(DocumentSelector) {\n    function from(value, uriTransformer, extension) {\n        return coalesce(( asArray(value).map(sel => _doTransformDocumentSelector(sel, uriTransformer, extension))));\n    }\n    DocumentSelector.from = from;\n    function _doTransformDocumentSelector(selector, uriTransformer, extension) {\n        if (typeof selector === 'string') {\n            return {\n                $serialized: true,\n                language: selector,\n                isBuiltin: extension?.isBuiltin,\n            };\n        }\n        if (selector) {\n            return {\n                $serialized: true,\n                language: selector.language,\n                scheme: _transformScheme(selector.scheme, uriTransformer),\n                pattern: GlobPattern.from(selector.pattern) ?? undefined,\n                exclusive: selector.exclusive,\n                notebookType: selector.notebookType,\n                isBuiltin: extension?.isBuiltin\n            };\n        }\n        return undefined;\n    }\n    function _transformScheme(scheme, uriTransformer) {\n        if (uriTransformer && typeof scheme === 'string') {\n            return uriTransformer.transformOutgoingScheme(scheme);\n        }\n        return scheme;\n    }\n})(DocumentSelector || (DocumentSelector = {})));\nvar DiagnosticTag;\n( (function(DiagnosticTag) {\n    function from(value) {\n        switch (value) {\n            case DiagnosticTag$1.Unnecessary:\n                return 1 ;\n            case DiagnosticTag$1.Deprecated:\n                return 2 ;\n        }\n        return undefined;\n    }\n    DiagnosticTag.from = from;\n    function to(value) {\n        switch (value) {\n            case 1 :\n                return DiagnosticTag$1.Unnecessary;\n            case 2 :\n                return DiagnosticTag$1.Deprecated;\n            default:\n                return undefined;\n        }\n    }\n    DiagnosticTag.to = to;\n})(DiagnosticTag || (DiagnosticTag = {})));\nvar Diagnostic;\n( (function(Diagnostic) {\n    function from(value) {\n        let code;\n        if (value.code) {\n            if (isString(value.code) || isNumber(value.code)) {\n                code = String(value.code);\n            }\n            else {\n                code = {\n                    value: String(value.code.value),\n                    target: value.code.target,\n                };\n            }\n        }\n        return {\n            ...Range.from(value.range),\n            message: value.message,\n            source: value.source,\n            code,\n            severity: DiagnosticSeverity.from(value.severity),\n            relatedInformation: value.relatedInformation && ( value.relatedInformation.map(DiagnosticRelatedInformation.from)),\n            tags: Array.isArray(value.tags) ? coalesce(( value.tags.map(DiagnosticTag.from))) : undefined,\n        };\n    }\n    Diagnostic.from = from;\n    function to(value) {\n        const res = new Diagnostic$1(Range.to(value), value.message, DiagnosticSeverity.to(value.severity));\n        res.source = value.source;\n        res.code = isString(value.code) ? value.code : value.code?.value;\n        res.relatedInformation = value.relatedInformation && ( value.relatedInformation.map(DiagnosticRelatedInformation.to));\n        res.tags = value.tags && coalesce(( value.tags.map(DiagnosticTag.to)));\n        return res;\n    }\n    Diagnostic.to = to;\n})(Diagnostic || (Diagnostic = {})));\nvar DiagnosticRelatedInformation;\n( (function(DiagnosticRelatedInformation) {\n    function from(value) {\n        return {\n            ...Range.from(value.location.range),\n            message: value.message,\n            resource: value.location.uri\n        };\n    }\n    DiagnosticRelatedInformation.from = from;\n    function to(value) {\n        return new DiagnosticRelatedInformation$1(new Location$1(value.resource, Range.to(value)), value.message);\n    }\n    DiagnosticRelatedInformation.to = to;\n})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {})));\nvar DiagnosticSeverity;\n( (function(DiagnosticSeverity) {\n    function from(value) {\n        switch (value) {\n            case DiagnosticSeverity$1.Error:\n                return MarkerSeverity.Error;\n            case DiagnosticSeverity$1.Warning:\n                return MarkerSeverity.Warning;\n            case DiagnosticSeverity$1.Information:\n                return MarkerSeverity.Info;\n            case DiagnosticSeverity$1.Hint:\n                return MarkerSeverity.Hint;\n        }\n        return MarkerSeverity.Error;\n    }\n    DiagnosticSeverity.from = from;\n    function to(value) {\n        switch (value) {\n            case MarkerSeverity.Info:\n                return DiagnosticSeverity$1.Information;\n            case MarkerSeverity.Warning:\n                return DiagnosticSeverity$1.Warning;\n            case MarkerSeverity.Error:\n                return DiagnosticSeverity$1.Error;\n            case MarkerSeverity.Hint:\n                return DiagnosticSeverity$1.Hint;\n            default:\n                return DiagnosticSeverity$1.Error;\n        }\n    }\n    DiagnosticSeverity.to = to;\n})(DiagnosticSeverity || (DiagnosticSeverity = {})));\nvar ViewColumn;\n( (function(ViewColumn) {\n    function from(column) {\n        if (typeof column === 'number' && column >= ViewColumn$1.One) {\n            return column - 1;\n        }\n        if (column === ViewColumn$1.Beside) {\n            return SIDE_GROUP;\n        }\n        return ACTIVE_GROUP;\n    }\n    ViewColumn.from = from;\n    function to(position) {\n        if (typeof position === 'number' && position >= 0) {\n            return position + 1;\n        }\n        throw ( new Error(`invalid 'EditorGroupColumn'`));\n    }\n    ViewColumn.to = to;\n})(ViewColumn || (ViewColumn = {})));\nfunction isDecorationOptions(something) {\n    return (typeof something.range !== 'undefined');\n}\nfunction isDecorationOptionsArr(something) {\n    if (something.length === 0) {\n        return true;\n    }\n    return isDecorationOptions(something[0]) ? true : false;\n}\nvar MarkdownString;\n( (function(MarkdownString) {\n    function fromMany(markup) {\n        return ( markup.map(MarkdownString.from));\n    }\n    MarkdownString.fromMany = fromMany;\n    function isCodeblock(thing) {\n        return thing && typeof thing === 'object'\n            && typeof thing.language === 'string'\n            && typeof thing.value === 'string';\n    }\n    function from(markup) {\n        let res;\n        if (isCodeblock(markup)) {\n            const { language, value } = markup;\n            res = { value: '```' + language + '\\n' + value + '\\n```\\n' };\n        }\n        else if (MarkdownString$1.isMarkdownString(markup)) {\n            res = { value: markup.value, isTrusted: markup.isTrusted, supportThemeIcons: markup.supportThemeIcons, supportHtml: markup.supportHtml, baseUri: markup.baseUri };\n        }\n        else if (typeof markup === 'string') {\n            res = { value: markup };\n        }\n        else {\n            res = { value: '' };\n        }\n        const resUris = Object.create(null);\n        res.uris = resUris;\n        const collectUri = ({ href }) => {\n            try {\n                let uri = ( URI.parse(href, true));\n                uri = uri.with({ query: _uriMassage(uri.query, resUris) });\n                resUris[href] = uri;\n            }\n            catch (e) {\n            }\n            return '';\n        };\n        marked.walkTokens(marked.lexer(res.value), token => {\n            if (token.type === 'link') {\n                collectUri({ href: token.href });\n            }\n            else if (token.type === 'image') {\n                if (typeof token.href === 'string') {\n                    collectUri(parseHrefAndDimensions(token.href));\n                }\n            }\n        });\n        return res;\n    }\n    MarkdownString.from = from;\n    function _uriMassage(part, bucket) {\n        if (!part) {\n            return part;\n        }\n        let data;\n        try {\n            data = parse(part);\n        }\n        catch (e) {\n        }\n        if (!data) {\n            return part;\n        }\n        let changed = false;\n        data = cloneAndChange(data, value => {\n            if (URI.isUri(value)) {\n                const key = `__uri_${( Math.random().toString(16)).slice(2, 8)}`;\n                bucket[key] = value;\n                changed = true;\n                return key;\n            }\n            else {\n                return undefined;\n            }\n        });\n        if (!changed) {\n            return part;\n        }\n        return JSON.stringify(data);\n    }\n    function to(value) {\n        const result = new MarkdownString$1(value.value, value.supportThemeIcons);\n        result.isTrusted = value.isTrusted;\n        result.supportHtml = value.supportHtml;\n        result.baseUri = value.baseUri ? ( URI.from(value.baseUri)) : undefined;\n        return result;\n    }\n    MarkdownString.to = to;\n    function fromStrict(value) {\n        if (!value) {\n            return undefined;\n        }\n        return typeof value === 'string' ? value : MarkdownString.from(value);\n    }\n    MarkdownString.fromStrict = fromStrict;\n})(MarkdownString || (MarkdownString = {})));\nfunction fromRangeOrRangeWithMessage(ranges) {\n    if (isDecorationOptionsArr(ranges)) {\n        return ( ranges.map((r) => {\n            return {\n                range: Range.from(r.range),\n                hoverMessage: Array.isArray(r.hoverMessage)\n                    ? MarkdownString.fromMany(r.hoverMessage)\n                    : (r.hoverMessage ? MarkdownString.from(r.hoverMessage) : undefined),\n                renderOptions:  r.renderOptions\n            };\n        }));\n    }\n    else {\n        return ( ranges.map((r) => {\n            return {\n                range: Range.from(r)\n            };\n        }));\n    }\n}\nfunction pathOrURIToURI(value) {\n    if (typeof value === 'undefined') {\n        return value;\n    }\n    if (typeof value === 'string') {\n        return URI.file(value);\n    }\n    else {\n        return value;\n    }\n}\nvar ThemableDecorationAttachmentRenderOptions;\n( (function(ThemableDecorationAttachmentRenderOptions) {\n    function from(options) {\n        if (typeof options === 'undefined') {\n            return options;\n        }\n        return {\n            contentText: options.contentText,\n            contentIconPath: options.contentIconPath ? pathOrURIToURI(options.contentIconPath) : undefined,\n            border: options.border,\n            borderColor: options.borderColor,\n            fontStyle: options.fontStyle,\n            fontWeight: options.fontWeight,\n            textDecoration: options.textDecoration,\n            color: options.color,\n            backgroundColor: options.backgroundColor,\n            margin: options.margin,\n            width: options.width,\n            height: options.height,\n        };\n    }\n    ThemableDecorationAttachmentRenderOptions.from = from;\n})(\n    ThemableDecorationAttachmentRenderOptions || (ThemableDecorationAttachmentRenderOptions = {})\n));\nvar ThemableDecorationRenderOptions;\n( (function(ThemableDecorationRenderOptions) {\n    function from(options) {\n        if (typeof options === 'undefined') {\n            return options;\n        }\n        return {\n            backgroundColor: options.backgroundColor,\n            outline: options.outline,\n            outlineColor: options.outlineColor,\n            outlineStyle: options.outlineStyle,\n            outlineWidth: options.outlineWidth,\n            border: options.border,\n            borderColor: options.borderColor,\n            borderRadius: options.borderRadius,\n            borderSpacing: options.borderSpacing,\n            borderStyle: options.borderStyle,\n            borderWidth: options.borderWidth,\n            fontStyle: options.fontStyle,\n            fontWeight: options.fontWeight,\n            textDecoration: options.textDecoration,\n            cursor: options.cursor,\n            color: options.color,\n            opacity: options.opacity,\n            letterSpacing: options.letterSpacing,\n            gutterIconPath: options.gutterIconPath ? pathOrURIToURI(options.gutterIconPath) : undefined,\n            gutterIconSize: options.gutterIconSize,\n            overviewRulerColor: options.overviewRulerColor,\n            before: options.before ? ThemableDecorationAttachmentRenderOptions.from(options.before) : undefined,\n            after: options.after ? ThemableDecorationAttachmentRenderOptions.from(options.after) : undefined,\n        };\n    }\n    ThemableDecorationRenderOptions.from = from;\n})(ThemableDecorationRenderOptions || (ThemableDecorationRenderOptions = {})));\nvar DecorationRangeBehavior;\n( (function(DecorationRangeBehavior) {\n    function from(value) {\n        if (typeof value === 'undefined') {\n            return value;\n        }\n        switch (value) {\n            case DecorationRangeBehavior$1.OpenOpen:\n                return 0 ;\n            case DecorationRangeBehavior$1.ClosedClosed:\n                return 1 ;\n            case DecorationRangeBehavior$1.OpenClosed:\n                return 2 ;\n            case DecorationRangeBehavior$1.ClosedOpen:\n                return 3 ;\n        }\n    }\n    DecorationRangeBehavior.from = from;\n})(DecorationRangeBehavior || (DecorationRangeBehavior = {})));\nvar DecorationRenderOptions;\n( (function(DecorationRenderOptions) {\n    function from(options) {\n        return {\n            isWholeLine: options.isWholeLine,\n            rangeBehavior: options.rangeBehavior ? DecorationRangeBehavior.from(options.rangeBehavior) : undefined,\n            overviewRulerLane: options.overviewRulerLane,\n            light: options.light ? ThemableDecorationRenderOptions.from(options.light) : undefined,\n            dark: options.dark ? ThemableDecorationRenderOptions.from(options.dark) : undefined,\n            backgroundColor: options.backgroundColor,\n            outline: options.outline,\n            outlineColor: options.outlineColor,\n            outlineStyle: options.outlineStyle,\n            outlineWidth: options.outlineWidth,\n            border: options.border,\n            borderColor: options.borderColor,\n            borderRadius: options.borderRadius,\n            borderSpacing: options.borderSpacing,\n            borderStyle: options.borderStyle,\n            borderWidth: options.borderWidth,\n            fontStyle: options.fontStyle,\n            fontWeight: options.fontWeight,\n            textDecoration: options.textDecoration,\n            cursor: options.cursor,\n            color: options.color,\n            opacity: options.opacity,\n            letterSpacing: options.letterSpacing,\n            gutterIconPath: options.gutterIconPath ? pathOrURIToURI(options.gutterIconPath) : undefined,\n            gutterIconSize: options.gutterIconSize,\n            overviewRulerColor: options.overviewRulerColor,\n            before: options.before ? ThemableDecorationAttachmentRenderOptions.from(options.before) : undefined,\n            after: options.after ? ThemableDecorationAttachmentRenderOptions.from(options.after) : undefined,\n        };\n    }\n    DecorationRenderOptions.from = from;\n})(DecorationRenderOptions || (DecorationRenderOptions = {})));\nvar TextEdit;\n( (function(TextEdit) {\n    function from(edit) {\n        return {\n            text: edit.newText,\n            eol: edit.newEol && EndOfLine.from(edit.newEol),\n            range: Range.from(edit.range)\n        };\n    }\n    TextEdit.from = from;\n    function to(edit) {\n        const result = new TextEdit$1(Range.to(edit.range), edit.text);\n        result.newEol = (typeof edit.eol === 'undefined' ? undefined : EndOfLine.to(edit.eol));\n        return result;\n    }\n    TextEdit.to = to;\n})(TextEdit || (TextEdit = {})));\nvar WorkspaceEdit;\n( (function(WorkspaceEdit) {\n    function from(value, versionInfo) {\n        const result = {\n            edits: []\n        };\n        if (value instanceof WorkspaceEdit$1) {\n            const toCreate = ( new ResourceSet());\n            for (const entry of value._allEntries()) {\n                if (entry._type === 1  && URI.isUri(entry.to) && entry.from === undefined) {\n                    toCreate.add(entry.to);\n                }\n            }\n            for (const entry of value._allEntries()) {\n                if (entry._type === 1 ) {\n                    let contents;\n                    if (entry.options?.contents) {\n                        if (ArrayBuffer.isView(entry.options.contents)) {\n                            contents = { type: 'base64', value: encodeBase64(VSBuffer.wrap(entry.options.contents)) };\n                        }\n                        else {\n                            contents = { type: 'dataTransferItem', id: entry.options.contents._itemId };\n                        }\n                    }\n                    result.edits.push({\n                        oldResource: entry.from,\n                        newResource: entry.to,\n                        options: { ...entry.options, contents },\n                        metadata: entry.metadata\n                    });\n                }\n                else if (entry._type === 2 ) {\n                    result.edits.push({\n                        resource: entry.uri,\n                        textEdit: TextEdit.from(entry.edit),\n                        versionId: !( toCreate.has(entry.uri)) ? versionInfo?.getTextDocumentVersion(entry.uri) : undefined,\n                        metadata: entry.metadata\n                    });\n                }\n                else if (entry._type === 6 ) {\n                    result.edits.push({\n                        resource: entry.uri,\n                        textEdit: {\n                            range: Range.from(entry.range),\n                            text: entry.edit.value,\n                            insertAsSnippet: true\n                        },\n                        versionId: !( toCreate.has(entry.uri)) ? versionInfo?.getTextDocumentVersion(entry.uri) : undefined,\n                        metadata: entry.metadata\n                    });\n                }\n                else if (entry._type === 3 ) {\n                    result.edits.push({\n                        metadata: entry.metadata,\n                        resource: entry.uri,\n                        cellEdit: entry.edit,\n                        notebookMetadata: entry.notebookMetadata,\n                        notebookVersionId: versionInfo?.getNotebookDocumentVersion(entry.uri)\n                    });\n                }\n                else if (entry._type === 5 ) {\n                    result.edits.push({\n                        metadata: entry.metadata,\n                        resource: entry.uri,\n                        notebookVersionId: versionInfo?.getNotebookDocumentVersion(entry.uri),\n                        cellEdit: {\n                            editType: 1 ,\n                            index: entry.index,\n                            count: entry.count,\n                            cells: ( entry.cells.map(NotebookCellData.from))\n                        }\n                    });\n                }\n            }\n        }\n        return result;\n    }\n    WorkspaceEdit.from = from;\n    function to(value) {\n        const result = new WorkspaceEdit$1();\n        const edits = ( new ResourceMap());\n        for (const edit of value.edits) {\n            if (edit.textEdit) {\n                const item = edit;\n                const uri = URI.revive(item.resource);\n                const range = Range.to(item.textEdit.range);\n                const text = item.textEdit.text;\n                const isSnippet = item.textEdit.insertAsSnippet;\n                let editOrSnippetTest;\n                if (isSnippet) {\n                    editOrSnippetTest = SnippetTextEdit.replace(range, new SnippetString(text));\n                }\n                else {\n                    editOrSnippetTest = TextEdit$1.replace(range, text);\n                }\n                const array = edits.get(uri);\n                if (!array) {\n                    edits.set(uri, [editOrSnippetTest]);\n                }\n                else {\n                    array.push(editOrSnippetTest);\n                }\n            }\n            else {\n                result.renameFile(URI.revive(edit.oldResource), URI.revive(edit.newResource), edit.options);\n            }\n        }\n        for (const [uri, array] of edits) {\n            result.set(uri, array);\n        }\n        return result;\n    }\n    WorkspaceEdit.to = to;\n})(WorkspaceEdit || (WorkspaceEdit = {})));\nvar SymbolKind;\n( (function(SymbolKind) {\n    const _fromMapping = Object.create(null);\n    _fromMapping[SymbolKind$1.File] = 0 ;\n    _fromMapping[SymbolKind$1.Module] = 1 ;\n    _fromMapping[SymbolKind$1.Namespace] = 2 ;\n    _fromMapping[SymbolKind$1.Package] = 3 ;\n    _fromMapping[SymbolKind$1.Class] = 4 ;\n    _fromMapping[SymbolKind$1.Method] = 5 ;\n    _fromMapping[SymbolKind$1.Property] = 6 ;\n    _fromMapping[SymbolKind$1.Field] = 7 ;\n    _fromMapping[SymbolKind$1.Constructor] = 8 ;\n    _fromMapping[SymbolKind$1.Enum] = 9 ;\n    _fromMapping[SymbolKind$1.Interface] = 10 ;\n    _fromMapping[SymbolKind$1.Function] = 11 ;\n    _fromMapping[SymbolKind$1.Variable] = 12 ;\n    _fromMapping[SymbolKind$1.Constant] = 13 ;\n    _fromMapping[SymbolKind$1.String] = 14 ;\n    _fromMapping[SymbolKind$1.Number] = 15 ;\n    _fromMapping[SymbolKind$1.Boolean] = 16 ;\n    _fromMapping[SymbolKind$1.Array] = 17 ;\n    _fromMapping[SymbolKind$1.Object] = 18 ;\n    _fromMapping[SymbolKind$1.Key] = 19 ;\n    _fromMapping[SymbolKind$1.Null] = 20 ;\n    _fromMapping[SymbolKind$1.EnumMember] = 21 ;\n    _fromMapping[SymbolKind$1.Struct] = 22 ;\n    _fromMapping[SymbolKind$1.Event] = 23 ;\n    _fromMapping[SymbolKind$1.Operator] = 24 ;\n    _fromMapping[SymbolKind$1.TypeParameter] = 25 ;\n    function from(kind) {\n        return typeof _fromMapping[kind] === 'number' ? _fromMapping[kind] : 6 ;\n    }\n    SymbolKind.from = from;\n    function to(kind) {\n        for (const k in _fromMapping) {\n            if (_fromMapping[k] === kind) {\n                return Number(k);\n            }\n        }\n        return SymbolKind$1.Property;\n    }\n    SymbolKind.to = to;\n})(SymbolKind || (SymbolKind = {})));\nvar SymbolTag;\n( (function(SymbolTag) {\n    function from(kind) {\n        switch (kind) {\n            case SymbolTag$1.Deprecated: return 1 ;\n        }\n    }\n    SymbolTag.from = from;\n    function to(kind) {\n        switch (kind) {\n            case 1 : return SymbolTag$1.Deprecated;\n        }\n    }\n    SymbolTag.to = to;\n})(SymbolTag || (SymbolTag = {})));\nvar WorkspaceSymbol;\n( (function(WorkspaceSymbol) {\n    function from(info) {\n        return {\n            name: info.name,\n            kind: SymbolKind.from(info.kind),\n            tags: info.tags && ( info.tags.map(SymbolTag.from)),\n            containerName: info.containerName,\n            location: location.from(info.location)\n        };\n    }\n    WorkspaceSymbol.from = from;\n    function to(info) {\n        const result = new SymbolInformation(info.name, SymbolKind.to(info.kind), info.containerName, location.to(info.location));\n        result.tags = info.tags && ( info.tags.map(SymbolTag.to));\n        return result;\n    }\n    WorkspaceSymbol.to = to;\n})(WorkspaceSymbol || (WorkspaceSymbol = {})));\nvar DocumentSymbol;\n( (function(DocumentSymbol) {\n    function from(info) {\n        const result = {\n            name: info.name || '!!MISSING: name!!',\n            detail: info.detail,\n            range: Range.from(info.range),\n            selectionRange: Range.from(info.selectionRange),\n            kind: SymbolKind.from(info.kind),\n            tags: info.tags?.map(SymbolTag.from) ?? []\n        };\n        if (info.children) {\n            result.children = ( info.children.map(from));\n        }\n        return result;\n    }\n    DocumentSymbol.from = from;\n    function to(info) {\n        const result = new DocumentSymbol$1(info.name, info.detail, SymbolKind.to(info.kind), Range.to(info.range), Range.to(info.selectionRange));\n        if (isNonEmptyArray(info.tags)) {\n            result.tags = ( info.tags.map(SymbolTag.to));\n        }\n        if (info.children) {\n            result.children = ( info.children.map(to));\n        }\n        return result;\n    }\n    DocumentSymbol.to = to;\n})(DocumentSymbol || (DocumentSymbol = {})));\nvar CallHierarchyItem;\n( (function(CallHierarchyItem) {\n    function to(item) {\n        const result = new CallHierarchyItem$1(SymbolKind.to(item.kind), item.name, item.detail || '', URI.revive(item.uri), Range.to(item.range), Range.to(item.selectionRange));\n        result._sessionId = item._sessionId;\n        result._itemId = item._itemId;\n        return result;\n    }\n    CallHierarchyItem.to = to;\n    function from(item, sessionId, itemId) {\n        sessionId = sessionId ?? item._sessionId;\n        itemId = itemId ?? item._itemId;\n        if (sessionId === undefined || itemId === undefined) {\n            throw ( new Error('invalid item'));\n        }\n        return {\n            _sessionId: sessionId,\n            _itemId: itemId,\n            name: item.name,\n            detail: item.detail,\n            kind: SymbolKind.from(item.kind),\n            uri: item.uri,\n            range: Range.from(item.range),\n            selectionRange: Range.from(item.selectionRange),\n            tags: item.tags?.map(SymbolTag.from)\n        };\n    }\n    CallHierarchyItem.from = from;\n})(CallHierarchyItem || (CallHierarchyItem = {})));\nvar CallHierarchyIncomingCall;\n( (function(CallHierarchyIncomingCall) {\n    function to(item) {\n        return new CallHierarchyIncomingCall$1(CallHierarchyItem.to(item.from), ( item.fromRanges.map(r => Range.to(r))));\n    }\n    CallHierarchyIncomingCall.to = to;\n})(CallHierarchyIncomingCall || (CallHierarchyIncomingCall = {})));\nvar CallHierarchyOutgoingCall;\n( (function(CallHierarchyOutgoingCall) {\n    function to(item) {\n        return new CallHierarchyOutgoingCall$1(CallHierarchyItem.to(item.to), ( item.fromRanges.map(r => Range.to(r))));\n    }\n    CallHierarchyOutgoingCall.to = to;\n})(CallHierarchyOutgoingCall || (CallHierarchyOutgoingCall = {})));\nvar location;\n( (function(location) {\n    function from(value) {\n        return {\n            range: value.range && Range.from(value.range),\n            uri: value.uri\n        };\n    }\n    location.from = from;\n    function to(value) {\n        return new Location$1(URI.revive(value.uri), Range.to(value.range));\n    }\n    location.to = to;\n})(location || (location = {})));\nvar DefinitionLink;\n( (function(DefinitionLink) {\n    function from(value) {\n        const definitionLink = value;\n        const location = value;\n        return {\n            originSelectionRange: definitionLink.originSelectionRange\n                ? Range.from(definitionLink.originSelectionRange)\n                : undefined,\n            uri: definitionLink.targetUri ? definitionLink.targetUri : location.uri,\n            range: Range.from(definitionLink.targetRange ? definitionLink.targetRange : location.range),\n            targetSelectionRange: definitionLink.targetSelectionRange\n                ? Range.from(definitionLink.targetSelectionRange)\n                : undefined,\n        };\n    }\n    DefinitionLink.from = from;\n    function to(value) {\n        return {\n            targetUri: URI.revive(value.uri),\n            targetRange: Range.to(value.range),\n            targetSelectionRange: value.targetSelectionRange\n                ? Range.to(value.targetSelectionRange)\n                : undefined,\n            originSelectionRange: value.originSelectionRange\n                ? Range.to(value.originSelectionRange)\n                : undefined\n        };\n    }\n    DefinitionLink.to = to;\n})(DefinitionLink || (DefinitionLink = {})));\nvar Hover;\n( (function(Hover) {\n    function from(hover) {\n        const convertedHover = {\n            range: Range.from(hover.range),\n            contents: MarkdownString.fromMany(hover.contents),\n            canIncreaseVerbosity: hover.canIncreaseVerbosity,\n            canDecreaseVerbosity: hover.canDecreaseVerbosity,\n        };\n        return convertedHover;\n    }\n    Hover.from = from;\n    function to(info) {\n        const contents = ( info.contents.map(MarkdownString.to));\n        const range = Range.to(info.range);\n        const canIncreaseVerbosity = info.canIncreaseVerbosity;\n        const canDecreaseVerbosity = info.canDecreaseVerbosity;\n        return new VerboseHover(contents, range, canIncreaseVerbosity, canDecreaseVerbosity);\n    }\n    Hover.to = to;\n})(Hover || (Hover = {})));\nvar EvaluatableExpression;\n( (function(EvaluatableExpression) {\n    function from(expression) {\n        return {\n            range: Range.from(expression.range),\n            expression: expression.expression\n        };\n    }\n    EvaluatableExpression.from = from;\n    function to(info) {\n        return new EvaluatableExpression$1(Range.to(info.range), info.expression);\n    }\n    EvaluatableExpression.to = to;\n})(EvaluatableExpression || (EvaluatableExpression = {})));\nvar InlineValue;\n( (function(InlineValue) {\n    function from(inlineValue) {\n        if (inlineValue instanceof InlineValueText) {\n            return {\n                type: 'text',\n                range: Range.from(inlineValue.range),\n                text: inlineValue.text\n            };\n        }\n        else if (inlineValue instanceof InlineValueVariableLookup) {\n            return {\n                type: 'variable',\n                range: Range.from(inlineValue.range),\n                variableName: inlineValue.variableName,\n                caseSensitiveLookup: inlineValue.caseSensitiveLookup\n            };\n        }\n        else if (inlineValue instanceof InlineValueEvaluatableExpression) {\n            return {\n                type: 'expression',\n                range: Range.from(inlineValue.range),\n                expression: inlineValue.expression\n            };\n        }\n        else {\n            throw ( new Error(`Unknown 'InlineValue' type`));\n        }\n    }\n    InlineValue.from = from;\n    function to(inlineValue) {\n        switch (inlineValue.type) {\n            case 'text':\n                return {\n                    range: Range.to(inlineValue.range),\n                    text: inlineValue.text\n                };\n            case 'variable':\n                return {\n                    range: Range.to(inlineValue.range),\n                    variableName: inlineValue.variableName,\n                    caseSensitiveLookup: inlineValue.caseSensitiveLookup\n                };\n            case 'expression':\n                return {\n                    range: Range.to(inlineValue.range),\n                    expression: inlineValue.expression\n                };\n        }\n    }\n    InlineValue.to = to;\n})(InlineValue || (InlineValue = {})));\nvar InlineValueContext;\n( (function(InlineValueContext) {\n    function from(inlineValueContext) {\n        return {\n            frameId: inlineValueContext.frameId,\n            stoppedLocation: Range.from(inlineValueContext.stoppedLocation)\n        };\n    }\n    InlineValueContext.from = from;\n    function to(inlineValueContext) {\n        return new InlineValueContext$1(inlineValueContext.frameId, Range.to(inlineValueContext.stoppedLocation));\n    }\n    InlineValueContext.to = to;\n})(InlineValueContext || (InlineValueContext = {})));\nvar DocumentHighlight;\n( (function(DocumentHighlight) {\n    function from(documentHighlight) {\n        return {\n            range: Range.from(documentHighlight.range),\n            kind: documentHighlight.kind\n        };\n    }\n    DocumentHighlight.from = from;\n    function to(occurrence) {\n        return new DocumentHighlight$1(Range.to(occurrence.range), occurrence.kind);\n    }\n    DocumentHighlight.to = to;\n})(DocumentHighlight || (DocumentHighlight = {})));\nvar MultiDocumentHighlight;\n( (function(MultiDocumentHighlight) {\n    function from(multiDocumentHighlight) {\n        return {\n            uri: multiDocumentHighlight.uri,\n            highlights: ( multiDocumentHighlight.highlights.map(DocumentHighlight.from))\n        };\n    }\n    MultiDocumentHighlight.from = from;\n    function to(multiDocumentHighlight) {\n        return new MultiDocumentHighlight$1(URI.revive(multiDocumentHighlight.uri), ( multiDocumentHighlight.highlights.map(DocumentHighlight.to)));\n    }\n    MultiDocumentHighlight.to = to;\n})(MultiDocumentHighlight || (MultiDocumentHighlight = {})));\nvar CompletionTriggerKind;\n( (function(CompletionTriggerKind) {\n    function to(kind) {\n        switch (kind) {\n            case 1 :\n                return CompletionTriggerKind$1.TriggerCharacter;\n            case 2 :\n                return CompletionTriggerKind$1.TriggerForIncompleteCompletions;\n            case 0 :\n            default:\n                return CompletionTriggerKind$1.Invoke;\n        }\n    }\n    CompletionTriggerKind.to = to;\n})(CompletionTriggerKind || (CompletionTriggerKind = {})));\nvar CompletionContext;\n( (function(CompletionContext) {\n    function to(context) {\n        return {\n            triggerKind: CompletionTriggerKind.to(context.triggerKind),\n            triggerCharacter: context.triggerCharacter\n        };\n    }\n    CompletionContext.to = to;\n})(CompletionContext || (CompletionContext = {})));\nvar CompletionItemTag;\n( (function(CompletionItemTag) {\n    function from(kind) {\n        switch (kind) {\n            case CompletionItemTag$1.Deprecated: return 1 ;\n        }\n    }\n    CompletionItemTag.from = from;\n    function to(kind) {\n        switch (kind) {\n            case 1 : return CompletionItemTag$1.Deprecated;\n        }\n    }\n    CompletionItemTag.to = to;\n})(CompletionItemTag || (CompletionItemTag = {})));\nvar CompletionItemKind;\n( (function(CompletionItemKind) {\n    const _from = ( new Map([\n        [CompletionItemKind$1.Method, 0 ],\n        [CompletionItemKind$1.Function, 1 ],\n        [CompletionItemKind$1.Constructor, 2 ],\n        [CompletionItemKind$1.Field, 3 ],\n        [CompletionItemKind$1.Variable, 4 ],\n        [CompletionItemKind$1.Class, 5 ],\n        [CompletionItemKind$1.Interface, 7 ],\n        [CompletionItemKind$1.Struct, 6 ],\n        [CompletionItemKind$1.Module, 8 ],\n        [CompletionItemKind$1.Property, 9 ],\n        [CompletionItemKind$1.Unit, 12 ],\n        [CompletionItemKind$1.Value, 13 ],\n        [CompletionItemKind$1.Constant, 14 ],\n        [CompletionItemKind$1.Enum, 15 ],\n        [CompletionItemKind$1.EnumMember, 16 ],\n        [CompletionItemKind$1.Keyword, 17 ],\n        [CompletionItemKind$1.Snippet, 27 ],\n        [CompletionItemKind$1.Text, 18 ],\n        [CompletionItemKind$1.Color, 19 ],\n        [CompletionItemKind$1.File, 20 ],\n        [CompletionItemKind$1.Reference, 21 ],\n        [CompletionItemKind$1.Folder, 23 ],\n        [CompletionItemKind$1.Event, 10 ],\n        [CompletionItemKind$1.Operator, 11 ],\n        [CompletionItemKind$1.TypeParameter, 24 ],\n        [CompletionItemKind$1.Issue, 26 ],\n        [CompletionItemKind$1.User, 25 ],\n    ]));\n    function from(kind) {\n        return _from.get(kind) ?? 9 ;\n    }\n    CompletionItemKind.from = from;\n    const _to = ( new Map([\n        [0 , CompletionItemKind$1.Method],\n        [1 , CompletionItemKind$1.Function],\n        [2 , CompletionItemKind$1.Constructor],\n        [3 , CompletionItemKind$1.Field],\n        [4 , CompletionItemKind$1.Variable],\n        [5 , CompletionItemKind$1.Class],\n        [7 , CompletionItemKind$1.Interface],\n        [6 , CompletionItemKind$1.Struct],\n        [8 , CompletionItemKind$1.Module],\n        [9 , CompletionItemKind$1.Property],\n        [12 , CompletionItemKind$1.Unit],\n        [13 , CompletionItemKind$1.Value],\n        [14 , CompletionItemKind$1.Constant],\n        [15 , CompletionItemKind$1.Enum],\n        [16 , CompletionItemKind$1.EnumMember],\n        [17 , CompletionItemKind$1.Keyword],\n        [27 , CompletionItemKind$1.Snippet],\n        [18 , CompletionItemKind$1.Text],\n        [19 , CompletionItemKind$1.Color],\n        [20 , CompletionItemKind$1.File],\n        [21 , CompletionItemKind$1.Reference],\n        [23 , CompletionItemKind$1.Folder],\n        [10 , CompletionItemKind$1.Event],\n        [11 , CompletionItemKind$1.Operator],\n        [24 , CompletionItemKind$1.TypeParameter],\n        [25 , CompletionItemKind$1.User],\n        [26 , CompletionItemKind$1.Issue],\n    ]));\n    function to(kind) {\n        return _to.get(kind) ?? CompletionItemKind$1.Property;\n    }\n    CompletionItemKind.to = to;\n})(CompletionItemKind || (CompletionItemKind = {})));\nvar CompletionItem;\n( (function(CompletionItem) {\n    function to(suggestion, converter) {\n        const result = new CompletionItem$1(suggestion.label);\n        result.insertText = suggestion.insertText;\n        result.kind = CompletionItemKind.to(suggestion.kind);\n        result.tags = suggestion.tags?.map(CompletionItemTag.to);\n        result.detail = suggestion.detail;\n        result.documentation = isMarkdownString(suggestion.documentation) ? MarkdownString.to(suggestion.documentation) : suggestion.documentation;\n        result.sortText = suggestion.sortText;\n        result.filterText = suggestion.filterText;\n        result.preselect = suggestion.preselect;\n        result.commitCharacters = suggestion.commitCharacters;\n        if (Range$2.isIRange(suggestion.range)) {\n            result.range = Range.to(suggestion.range);\n        }\n        else if (typeof suggestion.range === 'object') {\n            result.range = { inserting: Range.to(suggestion.range.insert), replacing: Range.to(suggestion.range.replace) };\n        }\n        result.keepWhitespace = typeof suggestion.insertTextRules === 'undefined' ? false : Boolean(suggestion.insertTextRules & 1 );\n        if (typeof suggestion.insertTextRules !== 'undefined' && suggestion.insertTextRules & 4 ) {\n            result.insertText = new SnippetString(suggestion.insertText);\n        }\n        else {\n            result.insertText = suggestion.insertText;\n            result.textEdit = result.range instanceof Range$1 ? new TextEdit$1(result.range, result.insertText) : undefined;\n        }\n        if (suggestion.additionalTextEdits && suggestion.additionalTextEdits.length > 0) {\n            result.additionalTextEdits = ( suggestion.additionalTextEdits.map(e => TextEdit.to(e)));\n        }\n        result.command = converter && suggestion.command ? converter.fromInternal(suggestion.command) : undefined;\n        return result;\n    }\n    CompletionItem.to = to;\n})(CompletionItem || (CompletionItem = {})));\nvar ParameterInformation;\n( (function(ParameterInformation) {\n    function from(info) {\n        if (typeof info.label !== 'string' && !Array.isArray(info.label)) {\n            throw ( new TypeError('Invalid label'));\n        }\n        return {\n            label: info.label,\n            documentation: MarkdownString.fromStrict(info.documentation)\n        };\n    }\n    ParameterInformation.from = from;\n    function to(info) {\n        return {\n            label: info.label,\n            documentation: isMarkdownString(info.documentation) ? MarkdownString.to(info.documentation) : info.documentation\n        };\n    }\n    ParameterInformation.to = to;\n})(ParameterInformation || (ParameterInformation = {})));\nvar SignatureInformation;\n( (function(SignatureInformation) {\n    function from(info) {\n        return {\n            label: info.label,\n            documentation: MarkdownString.fromStrict(info.documentation),\n            parameters: Array.isArray(info.parameters) ? ( info.parameters.map(ParameterInformation.from)) : [],\n            activeParameter: info.activeParameter,\n        };\n    }\n    SignatureInformation.from = from;\n    function to(info) {\n        return {\n            label: info.label,\n            documentation: isMarkdownString(info.documentation) ? MarkdownString.to(info.documentation) : info.documentation,\n            parameters: Array.isArray(info.parameters) ? ( info.parameters.map(ParameterInformation.to)) : [],\n            activeParameter: info.activeParameter,\n        };\n    }\n    SignatureInformation.to = to;\n})(SignatureInformation || (SignatureInformation = {})));\nvar SignatureHelp;\n( (function(SignatureHelp) {\n    function from(help) {\n        return {\n            activeSignature: help.activeSignature,\n            activeParameter: help.activeParameter,\n            signatures: Array.isArray(help.signatures) ? ( help.signatures.map(SignatureInformation.from)) : [],\n        };\n    }\n    SignatureHelp.from = from;\n    function to(help) {\n        return {\n            activeSignature: help.activeSignature,\n            activeParameter: help.activeParameter,\n            signatures: Array.isArray(help.signatures) ? ( help.signatures.map(SignatureInformation.to)) : [],\n        };\n    }\n    SignatureHelp.to = to;\n})(SignatureHelp || (SignatureHelp = {})));\nvar InlayHint;\n( (function(InlayHint) {\n    function to(converter, hint) {\n        const res = new InlayHint$1(Position.to(hint.position), typeof hint.label === 'string' ? hint.label : ( hint.label.map(InlayHintLabelPart.to.bind(undefined, converter))), hint.kind && InlayHintKind.to(hint.kind));\n        res.textEdits = hint.textEdits && ( hint.textEdits.map(TextEdit.to));\n        res.tooltip = isMarkdownString(hint.tooltip) ? MarkdownString.to(hint.tooltip) : hint.tooltip;\n        res.paddingLeft = hint.paddingLeft;\n        res.paddingRight = hint.paddingRight;\n        return res;\n    }\n    InlayHint.to = to;\n})(InlayHint || (InlayHint = {})));\nvar InlayHintLabelPart;\n( (function(InlayHintLabelPart) {\n    function to(converter, part) {\n        const result = new InlayHintLabelPart$1(part.label);\n        result.tooltip = isMarkdownString(part.tooltip)\n            ? MarkdownString.to(part.tooltip)\n            : part.tooltip;\n        if (Command.is(part.command)) {\n            result.command = converter.fromInternal(part.command);\n        }\n        if (part.location) {\n            result.location = location.to(part.location);\n        }\n        return result;\n    }\n    InlayHintLabelPart.to = to;\n})(InlayHintLabelPart || (InlayHintLabelPart = {})));\nvar InlayHintKind;\n( (function(InlayHintKind) {\n    function from(kind) {\n        return kind;\n    }\n    InlayHintKind.from = from;\n    function to(kind) {\n        return kind;\n    }\n    InlayHintKind.to = to;\n})(InlayHintKind || (InlayHintKind = {})));\nvar DocumentLink;\n( (function(DocumentLink) {\n    function from(link) {\n        return {\n            range: Range.from(link.range),\n            url: link.target,\n            tooltip: link.tooltip\n        };\n    }\n    DocumentLink.from = from;\n    function to(link) {\n        let target = undefined;\n        if (link.url) {\n            try {\n                target = typeof link.url === 'string' ? ( URI.parse(link.url, true)) : URI.revive(link.url);\n            }\n            catch (err) {\n            }\n        }\n        const result = new DocumentLink$1(Range.to(link.range), target);\n        result.tooltip = link.tooltip;\n        return result;\n    }\n    DocumentLink.to = to;\n})(DocumentLink || (DocumentLink = {})));\nvar ColorPresentation;\n( (function(ColorPresentation) {\n    function to(colorPresentation) {\n        const cp = new ColorPresentation$1(colorPresentation.label);\n        if (colorPresentation.textEdit) {\n            cp.textEdit = TextEdit.to(colorPresentation.textEdit);\n        }\n        if (colorPresentation.additionalTextEdits) {\n            cp.additionalTextEdits = ( colorPresentation.additionalTextEdits.map(value => TextEdit.to(value)));\n        }\n        return cp;\n    }\n    ColorPresentation.to = to;\n    function from(colorPresentation) {\n        return {\n            label: colorPresentation.label,\n            textEdit: colorPresentation.textEdit ? TextEdit.from(colorPresentation.textEdit) : undefined,\n            additionalTextEdits: colorPresentation.additionalTextEdits ? ( colorPresentation.additionalTextEdits.map(value => TextEdit.from(value))) : undefined\n        };\n    }\n    ColorPresentation.from = from;\n})(ColorPresentation || (ColorPresentation = {})));\nvar Color;\n( (function(Color) {\n    function to(c) {\n        return new Color$1(c[0], c[1], c[2], c[3]);\n    }\n    Color.to = to;\n    function from(color) {\n        return [color.red, color.green, color.blue, color.alpha];\n    }\n    Color.from = from;\n})(Color || (Color = {})));\nvar SelectionRange;\n( (function(SelectionRange) {\n    function from(obj) {\n        return { range: Range.from(obj.range) };\n    }\n    SelectionRange.from = from;\n    function to(obj) {\n        return new SelectionRange$1(Range.to(obj.range));\n    }\n    SelectionRange.to = to;\n})(SelectionRange || (SelectionRange = {})));\nvar TextDocumentSaveReason;\n( (function(TextDocumentSaveReason) {\n    function to(reason) {\n        switch (reason) {\n            case 2 :\n                return TextDocumentSaveReason$1.AfterDelay;\n            case 1 :\n                return TextDocumentSaveReason$1.Manual;\n            case 3 :\n            case 4 :\n                return TextDocumentSaveReason$1.FocusOut;\n        }\n    }\n    TextDocumentSaveReason.to = to;\n})(TextDocumentSaveReason || (TextDocumentSaveReason = {})));\nvar TextEditorLineNumbersStyle;\n( (function(TextEditorLineNumbersStyle) {\n    function from(style) {\n        switch (style) {\n            case TextEditorLineNumbersStyle$1.Off:\n                return 0 ;\n            case TextEditorLineNumbersStyle$1.Relative:\n                return 2 ;\n            case TextEditorLineNumbersStyle$1.Interval:\n                return 3 ;\n            case TextEditorLineNumbersStyle$1.On:\n            default:\n                return 1 ;\n        }\n    }\n    TextEditorLineNumbersStyle.from = from;\n    function to(style) {\n        switch (style) {\n            case 0 :\n                return TextEditorLineNumbersStyle$1.Off;\n            case 2 :\n                return TextEditorLineNumbersStyle$1.Relative;\n            case 3 :\n                return TextEditorLineNumbersStyle$1.Interval;\n            case 1 :\n            default:\n                return TextEditorLineNumbersStyle$1.On;\n        }\n    }\n    TextEditorLineNumbersStyle.to = to;\n})(TextEditorLineNumbersStyle || (TextEditorLineNumbersStyle = {})));\nvar EndOfLine;\n( (function(EndOfLine) {\n    function from(eol) {\n        if (eol === EndOfLine$1.CRLF) {\n            return 1 ;\n        }\n        else if (eol === EndOfLine$1.LF) {\n            return 0 ;\n        }\n        return undefined;\n    }\n    EndOfLine.from = from;\n    function to(eol) {\n        if (eol === 1 ) {\n            return EndOfLine$1.CRLF;\n        }\n        else if (eol === 0 ) {\n            return EndOfLine$1.LF;\n        }\n        return undefined;\n    }\n    EndOfLine.to = to;\n})(EndOfLine || (EndOfLine = {})));\nvar ProgressLocation;\n( (function(ProgressLocation) {\n    function from(loc) {\n        if (typeof loc === 'object') {\n            return loc.viewId;\n        }\n        switch (loc) {\n            case ProgressLocation$1.SourceControl: return 3 ;\n            case ProgressLocation$1.Window: return 10 ;\n            case ProgressLocation$1.Notification: return 15 ;\n        }\n        throw ( new Error(`Unknown 'ProgressLocation'`));\n    }\n    ProgressLocation.from = from;\n})(ProgressLocation || (ProgressLocation = {})));\nvar FoldingRange;\n( (function(FoldingRange) {\n    function from(r) {\n        const range = { start: r.start + 1, end: r.end + 1 };\n        if (r.kind) {\n            range.kind = FoldingRangeKind.from(r.kind);\n        }\n        return range;\n    }\n    FoldingRange.from = from;\n    function to(r) {\n        const range = { start: r.start - 1, end: r.end - 1 };\n        if (r.kind) {\n            range.kind = FoldingRangeKind.to(r.kind);\n        }\n        return range;\n    }\n    FoldingRange.to = to;\n})(FoldingRange || (FoldingRange = {})));\nvar FoldingRangeKind;\n( (function(FoldingRangeKind) {\n    function from(kind) {\n        if (kind) {\n            switch (kind) {\n                case FoldingRangeKind$1.Comment:\n                    return FoldingRangeKind$2.Comment;\n                case FoldingRangeKind$1.Imports:\n                    return FoldingRangeKind$2.Imports;\n                case FoldingRangeKind$1.Region:\n                    return FoldingRangeKind$2.Region;\n            }\n        }\n        return undefined;\n    }\n    FoldingRangeKind.from = from;\n    function to(kind) {\n        if (kind) {\n            switch (kind.value) {\n                case FoldingRangeKind$2.Comment.value:\n                    return FoldingRangeKind$1.Comment;\n                case FoldingRangeKind$2.Imports.value:\n                    return FoldingRangeKind$1.Imports;\n                case FoldingRangeKind$2.Region.value:\n                    return FoldingRangeKind$1.Region;\n            }\n        }\n        return undefined;\n    }\n    FoldingRangeKind.to = to;\n})(FoldingRangeKind || (FoldingRangeKind = {})));\nvar TextEditorOpenOptions;\n( (function(TextEditorOpenOptions) {\n    function from(options) {\n        if (options) {\n            return {\n                pinned: typeof options.preview === 'boolean' ? !options.preview : undefined,\n                inactive: options.background,\n                preserveFocus: options.preserveFocus,\n                selection: typeof options.selection === 'object' ? Range.from(options.selection) : undefined,\n                override: typeof options.override === 'boolean' ? DEFAULT_EDITOR_ASSOCIATION.id : undefined\n            };\n        }\n        return undefined;\n    }\n    TextEditorOpenOptions.from = from;\n})(TextEditorOpenOptions || (TextEditorOpenOptions = {})));\nvar GlobPattern;\n( (function(GlobPattern) {\n    function from(pattern) {\n        if (pattern instanceof RelativePattern) {\n            return pattern.toJSON();\n        }\n        if (typeof pattern === 'string') {\n            return pattern;\n        }\n        if (isRelativePatternShape(pattern) || isLegacyRelativePatternShape(pattern)) {\n            return new RelativePattern(pattern.baseUri ?? pattern.base, pattern.pattern).toJSON();\n        }\n        return pattern;\n    }\n    GlobPattern.from = from;\n    function isRelativePatternShape(obj) {\n        const rp = obj;\n        if (!rp) {\n            return false;\n        }\n        return URI.isUri(rp.baseUri) && typeof rp.pattern === 'string';\n    }\n    function isLegacyRelativePatternShape(obj) {\n        const rp = obj;\n        if (!rp) {\n            return false;\n        }\n        return typeof rp.base === 'string' && typeof rp.pattern === 'string';\n    }\n    function to(pattern) {\n        if (typeof pattern === 'string') {\n            return pattern;\n        }\n        return new RelativePattern(URI.revive(pattern.baseUri), pattern.pattern);\n    }\n    GlobPattern.to = to;\n})(GlobPattern || (GlobPattern = {})));\nvar LanguageSelector;\n( (function(LanguageSelector) {\n    function from(selector) {\n        if (!selector) {\n            return undefined;\n        }\n        else if (Array.isArray(selector)) {\n            return ( selector.map(from));\n        }\n        else if (typeof selector === 'string') {\n            return selector;\n        }\n        else {\n            const filter = selector;\n            return {\n                language: filter.language,\n                scheme: filter.scheme,\n                pattern: GlobPattern.from(filter.pattern),\n                exclusive: filter.exclusive,\n                notebookType: filter.notebookType\n            };\n        }\n    }\n    LanguageSelector.from = from;\n})(LanguageSelector || (LanguageSelector = {})));\nvar MappedEditsContext;\n( (function(MappedEditsContext) {\n    function is(v) {\n        return (!!v && typeof v === 'object' &&\n            'documents' in v &&\n            Array.isArray(v.documents) &&\n            v.documents.every(subArr => Array.isArray(subArr) &&\n                subArr.every(DocumentContextItem.is)));\n    }\n    MappedEditsContext.is = is;\n    function from(extContext) {\n        return {\n            documents: ( extContext.documents.map((subArray) => ( subArray.map(DocumentContextItem.from)))),\n            conversation: extContext.conversation?.map(item => ((item.type === 'request') ?\n                {\n                    type: 'request',\n                    message: item.message,\n                } :\n                {\n                    type: 'response',\n                    message: item.message,\n                    references: item.references?.map(DocumentContextItem.from)\n                }))\n        };\n    }\n    MappedEditsContext.from = from;\n})(MappedEditsContext || (MappedEditsContext = {})));\nvar DocumentContextItem;\n( (function(DocumentContextItem) {\n    function is(item) {\n        return (typeof item === 'object' &&\n            item !== null &&\n            'uri' in item && URI.isUri(item.uri) &&\n            'version' in item && typeof item.version === 'number' &&\n            'ranges' in item && Array.isArray(item.ranges) && item.ranges.every((r) => r instanceof Range$1));\n    }\n    DocumentContextItem.is = is;\n    function from(item) {\n        return {\n            uri: ( URI.from(item.uri)),\n            version: item.version,\n            ranges: ( item.ranges.map(r => Range.from(r))),\n        };\n    }\n    DocumentContextItem.from = from;\n})(DocumentContextItem || (DocumentContextItem = {})));\nvar NotebookRange;\n( (function(NotebookRange) {\n    function from(range) {\n        return { start: range.start, end: range.end };\n    }\n    NotebookRange.from = from;\n    function to(range) {\n        return new NotebookRange$1(range.start, range.end);\n    }\n    NotebookRange.to = to;\n})(NotebookRange || (NotebookRange = {})));\nvar NotebookCellExecutionSummary;\n( (function(NotebookCellExecutionSummary) {\n    function to(data) {\n        return {\n            timing: typeof data.runStartTime === 'number' && typeof data.runEndTime === 'number' ? { startTime: data.runStartTime, endTime: data.runEndTime } : undefined,\n            executionOrder: data.executionOrder,\n            success: data.lastRunSuccess\n        };\n    }\n    NotebookCellExecutionSummary.to = to;\n    function from(data) {\n        return {\n            lastRunSuccess: data.success,\n            runStartTime: data.timing?.startTime,\n            runEndTime: data.timing?.endTime,\n            executionOrder: data.executionOrder\n        };\n    }\n    NotebookCellExecutionSummary.from = from;\n})(NotebookCellExecutionSummary || (NotebookCellExecutionSummary = {})));\nvar NotebookCellExecutionState;\n( (function(NotebookCellExecutionState) {\n    function to(state) {\n        if (state === NotebookCellExecutionState$1.Unconfirmed) {\n            return NotebookCellExecutionState$2.Pending;\n        }\n        else if (state === NotebookCellExecutionState$1.Pending) {\n            return undefined;\n        }\n        else if (state === NotebookCellExecutionState$1.Executing) {\n            return NotebookCellExecutionState$2.Executing;\n        }\n        else {\n            throw ( new Error(`Unknown state: ${state}`));\n        }\n    }\n    NotebookCellExecutionState.to = to;\n})(NotebookCellExecutionState || (NotebookCellExecutionState = {})));\nvar NotebookCellKind;\n( (function(NotebookCellKind) {\n    function from(data) {\n        switch (data) {\n            case NotebookCellKind$1.Markup:\n                return CellKind.Markup;\n            case NotebookCellKind$1.Code:\n            default:\n                return CellKind.Code;\n        }\n    }\n    NotebookCellKind.from = from;\n    function to(data) {\n        switch (data) {\n            case CellKind.Markup:\n                return NotebookCellKind$1.Markup;\n            case CellKind.Code:\n            default:\n                return NotebookCellKind$1.Code;\n        }\n    }\n    NotebookCellKind.to = to;\n})(NotebookCellKind || (NotebookCellKind = {})));\nvar NotebookData;\n( (function(NotebookData) {\n    function from(data) {\n        const res = {\n            metadata: data.metadata ?? Object.create(null),\n            cells: [],\n        };\n        for (const cell of data.cells) {\n            NotebookCellData$1.validate(cell);\n            res.cells.push(NotebookCellData.from(cell));\n        }\n        return res;\n    }\n    NotebookData.from = from;\n    function to(data) {\n        const res = new NotebookData$1(( data.cells.map(NotebookCellData.to)));\n        if (!isEmptyObject(data.metadata)) {\n            res.metadata = data.metadata;\n        }\n        return res;\n    }\n    NotebookData.to = to;\n})(NotebookData || (NotebookData = {})));\nvar NotebookCellData;\n( (function(NotebookCellData) {\n    function from(data) {\n        return {\n            cellKind: NotebookCellKind.from(data.kind),\n            language: data.languageId,\n            mime: data.mime,\n            source: data.value,\n            metadata: data.metadata,\n            internalMetadata: NotebookCellExecutionSummary.from(data.executionSummary ?? {}),\n            outputs: data.outputs ? ( data.outputs.map(NotebookCellOutput.from)) : []\n        };\n    }\n    NotebookCellData.from = from;\n    function to(data) {\n        return new NotebookCellData$1(NotebookCellKind.to(data.cellKind), data.source, data.language, data.mime, data.outputs ? ( data.outputs.map(NotebookCellOutput.to)) : undefined, data.metadata, data.internalMetadata ? NotebookCellExecutionSummary.to(data.internalMetadata) : undefined);\n    }\n    NotebookCellData.to = to;\n})(NotebookCellData || (NotebookCellData = {})));\nvar NotebookCellOutputItem;\n( (function(NotebookCellOutputItem) {\n    function from(item) {\n        return {\n            mime: item.mime,\n            valueBytes: VSBuffer.wrap(item.data),\n        };\n    }\n    NotebookCellOutputItem.from = from;\n    function to(item) {\n        return new NotebookCellOutputItem$1(item.valueBytes.buffer, item.mime);\n    }\n    NotebookCellOutputItem.to = to;\n})(NotebookCellOutputItem || (NotebookCellOutputItem = {})));\nvar NotebookCellOutput;\n( (function(NotebookCellOutput) {\n    function from(output) {\n        return {\n            outputId: output.id,\n            items: ( output.items.map(NotebookCellOutputItem.from)),\n            metadata: output.metadata\n        };\n    }\n    NotebookCellOutput.from = from;\n    function to(output) {\n        const items = ( output.items.map(NotebookCellOutputItem.to));\n        return new NotebookCellOutput$1(items, output.outputId, output.metadata);\n    }\n    NotebookCellOutput.to = to;\n})(NotebookCellOutput || (NotebookCellOutput = {})));\nvar NotebookExclusiveDocumentPattern;\n( (function(NotebookExclusiveDocumentPattern) {\n    function from(pattern) {\n        if (isExclusivePattern(pattern)) {\n            return {\n                include: GlobPattern.from(pattern.include) ?? undefined,\n                exclude: GlobPattern.from(pattern.exclude) ?? undefined,\n            };\n        }\n        return GlobPattern.from(pattern) ?? undefined;\n    }\n    NotebookExclusiveDocumentPattern.from = from;\n    function to(pattern) {\n        if (isExclusivePattern(pattern)) {\n            return {\n                include: GlobPattern.to(pattern.include),\n                exclude: GlobPattern.to(pattern.exclude)\n            };\n        }\n        return GlobPattern.to(pattern);\n    }\n    NotebookExclusiveDocumentPattern.to = to;\n    function isExclusivePattern(obj) {\n        const ep = obj;\n        if (!ep) {\n            return false;\n        }\n        return !isUndefinedOrNull(ep.include) && !isUndefinedOrNull(ep.exclude);\n    }\n})(\n    NotebookExclusiveDocumentPattern || (NotebookExclusiveDocumentPattern = {})\n));\nvar NotebookStatusBarItem;\n( (function(NotebookStatusBarItem) {\n    function from(item, commandsConverter, disposables) {\n        const command = typeof item.command === 'string' ? { title: '', command: item.command } : item.command;\n        return {\n            alignment: item.alignment === NotebookCellStatusBarAlignment.Left ? 1  : 2 ,\n            command: commandsConverter.toInternal(command, disposables),\n            text: item.text,\n            tooltip: item.tooltip,\n            accessibilityInformation: item.accessibilityInformation,\n            priority: item.priority\n        };\n    }\n    NotebookStatusBarItem.from = from;\n})(NotebookStatusBarItem || (NotebookStatusBarItem = {})));\nvar NotebookKernelSourceAction;\n( (function(NotebookKernelSourceAction) {\n    function from(item, commandsConverter, disposables) {\n        const command = typeof item.command === 'string' ? { title: '', command: item.command } : item.command;\n        return {\n            command: commandsConverter.toInternal(command, disposables),\n            label: item.label,\n            description: item.description,\n            detail: item.detail,\n            documentation: item.documentation\n        };\n    }\n    NotebookKernelSourceAction.from = from;\n})(NotebookKernelSourceAction || (NotebookKernelSourceAction = {})));\nvar NotebookDocumentContentOptions;\n( (function(NotebookDocumentContentOptions) {\n    function from(options) {\n        return {\n            transientOutputs: options?.transientOutputs ?? false,\n            transientCellMetadata: options?.transientCellMetadata ?? {},\n            transientDocumentMetadata: options?.transientDocumentMetadata ?? {},\n            cellContentMetadata: options?.cellContentMetadata ?? {}\n        };\n    }\n    NotebookDocumentContentOptions.from = from;\n})(NotebookDocumentContentOptions || (NotebookDocumentContentOptions = {})));\nvar NotebookRendererScript;\n( (function(NotebookRendererScript) {\n    function from(preload) {\n        return {\n            uri: preload.uri,\n            provides: preload.provides\n        };\n    }\n    NotebookRendererScript.from = from;\n    function to(preload) {\n        return new NotebookRendererScript$1(URI.revive(preload.uri), preload.provides);\n    }\n    NotebookRendererScript.to = to;\n})(NotebookRendererScript || (NotebookRendererScript = {})));\nvar TestMessage;\n( (function(TestMessage) {\n    function from(message) {\n        return {\n            message: MarkdownString.fromStrict(message.message) || '',\n            type: 0 ,\n            expected: message.expectedOutput,\n            actual: message.actualOutput,\n            contextValue: message.contextValue,\n            location: message.location && ({ range: Range.from(message.location.range), uri: message.location.uri }),\n            stackTrace: message.stackTrace?.map(s => ({\n                label: s.label,\n                position: s.position && Position.from(s.position),\n                uri: s.uri && URI.revive(s.uri).toJSON(),\n            })),\n        };\n    }\n    TestMessage.from = from;\n    function to(item) {\n        const message = new TestMessage$1(typeof item.message === 'string' ? item.message : MarkdownString.to(item.message));\n        message.actualOutput = item.actual;\n        message.expectedOutput = item.expected;\n        message.contextValue = item.contextValue;\n        message.location = item.location ? location.to(item.location) : undefined;\n        return message;\n    }\n    TestMessage.to = to;\n})(TestMessage || (TestMessage = {})));\nvar TestTag;\n( (function(TestTag) {\n    TestTag.namespace = namespaceTestTag;\n    TestTag.denamespace = denamespaceTestTag;\n})(TestTag || (TestTag = {})));\nvar TestItem;\n( (function(TestItem) {\n    function from(item) {\n        const ctrlId = getPrivateApiFor(item).controllerId;\n        return {\n            extId: ( TestId.fromExtHostTestItem(item, ctrlId).toString()),\n            label: item.label,\n            uri: URI.revive(item.uri),\n            busy: item.busy,\n            tags: ( item.tags.map(t => TestTag.namespace(ctrlId, t.id))),\n            range: Range$2.lift(Range.from(item.range)),\n            description: item.description || null,\n            sortText: item.sortText || null,\n            error: item.error ? (MarkdownString.fromStrict(item.error) || null) : null,\n        };\n    }\n    TestItem.from = from;\n    function toPlain(item) {\n        return {\n            parent: undefined,\n            error: undefined,\n            id: TestId.fromString(item.extId).localId,\n            label: item.label,\n            uri: URI.revive(item.uri),\n            tags: ( (item.tags || []).map(t => {\n                const { tagId } = TestTag.denamespace(t);\n                return new TestTag$1(tagId);\n            })),\n            children: {\n                add: () => { },\n                delete: () => { },\n                forEach: () => { },\n                *[Symbol.iterator]() { },\n                get: () => undefined,\n                replace: () => { },\n                size: 0,\n            },\n            range: Range.to(item.range || undefined),\n            canResolveChildren: false,\n            busy: item.busy,\n            description: item.description || undefined,\n            sortText: item.sortText || undefined,\n        };\n    }\n    TestItem.toPlain = toPlain;\n})(TestItem || (TestItem = {})));\n( (function(TestTag) {\n    function from(tag) {\n        return { id: tag.id };\n    }\n    TestTag.from = from;\n    function to(tag) {\n        return new TestTag$1(tag.id);\n    }\n    TestTag.to = to;\n})(TestTag || (TestTag = {})));\nvar TestResults;\n( (function(TestResults) {\n    const convertTestResultItem = (node, parent) => {\n        const item = node.value;\n        if (!item) {\n            return undefined;\n        }\n        const snapshot = ({\n            ...TestItem.toPlain(item.item),\n            parent,\n            taskStates: ( item.tasks.map(t => ({\n                state: t.state,\n                duration: t.duration,\n                messages: ( t.messages\n                    .filter((m) => m.type === 0 )\n                    .map(TestMessage.to)),\n            }))),\n            children: [],\n        });\n        if (node.children) {\n            for (const child of ( node.children.values())) {\n                const c = convertTestResultItem(child, snapshot);\n                if (c) {\n                    snapshot.children.push(c);\n                }\n            }\n        }\n        return snapshot;\n    };\n    function to(serialized) {\n        const tree = ( new WellDefinedPrefixTree());\n        for (const item of serialized.items) {\n            tree.insert(TestId.fromString(item.item.extId).path, item);\n        }\n        const queue = [tree.nodes];\n        const roots = [];\n        while (queue.length) {\n            for (const node of queue.pop()) {\n                if (node.value) {\n                    roots.push(node);\n                }\n                else if (node.children) {\n                    queue.push(( node.children.values()));\n                }\n            }\n        }\n        return {\n            completedAt: serialized.completedAt,\n            results: ( roots.map(r => convertTestResultItem(r))).filter(isDefined),\n        };\n    }\n    TestResults.to = to;\n})(TestResults || (TestResults = {})));\nvar TestCoverage;\n( (function(TestCoverage) {\n    function fromCoverageCount(count) {\n        return { covered: count.covered, total: count.total };\n    }\n    function fromLocation(location) {\n        return 'line' in location ? Position.from(location) : Range.from(location);\n    }\n    function toLocation(location) {\n        if (!location) {\n            return undefined;\n        }\n        return 'endLineNumber' in location ? Range.to(location) : Position.to(location);\n    }\n    function to(serialized) {\n        if (serialized.type === 1 ) {\n            const branches = [];\n            if (serialized.branches) {\n                for (const branch of serialized.branches) {\n                    branches.push({\n                        executed: branch.count,\n                        location: toLocation(branch.location),\n                        label: branch.label\n                    });\n                }\n            }\n            return new StatementCoverage(serialized.count, toLocation(serialized.location), serialized.branches?.map(b => new BranchCoverage(b.count, toLocation(b.location), b.label)));\n        }\n        else {\n            return new DeclarationCoverage(serialized.name, serialized.count, toLocation(serialized.location));\n        }\n    }\n    TestCoverage.to = to;\n    function fromDetails(coverage) {\n        if (typeof coverage.executed === 'number' && coverage.executed < 0) {\n            throw ( new Error(`Invalid coverage count ${coverage.executed}`));\n        }\n        if ('branches' in coverage) {\n            return {\n                count: coverage.executed,\n                location: fromLocation(coverage.location),\n                type: 1 ,\n                branches: coverage.branches.length\n                    ? ( coverage.branches.map(\n                    b => ({ count: b.executed, location: b.location && fromLocation(b.location), label: b.label })\n                ))\n                    : undefined,\n            };\n        }\n        else {\n            return {\n                type: 0 ,\n                name: coverage.name,\n                count: coverage.executed,\n                location: fromLocation(coverage.location),\n            };\n        }\n    }\n    TestCoverage.fromDetails = fromDetails;\n    function fromFile(controllerId, id, coverage) {\n        validateTestCoverageCount(coverage.statementCoverage);\n        validateTestCoverageCount(coverage.branchCoverage);\n        validateTestCoverageCount(coverage.declarationCoverage);\n        return {\n            id,\n            uri: coverage.uri,\n            statement: fromCoverageCount(coverage.statementCoverage),\n            branch: coverage.branchCoverage && fromCoverageCount(coverage.branchCoverage),\n            declaration: coverage.declarationCoverage && fromCoverageCount(coverage.declarationCoverage),\n            testIds: coverage instanceof FileCoverage && coverage.fromTests.length ?\n                ( coverage.fromTests.map(t => ( TestId.fromExtHostTestItem(t, controllerId).toString()))) : undefined,\n        };\n    }\n    TestCoverage.fromFile = fromFile;\n})(TestCoverage || (TestCoverage = {})));\nvar CodeActionTriggerKind;\n( (function(CodeActionTriggerKind) {\n    function to(value) {\n        switch (value) {\n            case 1 :\n                return CodeActionTriggerKind$1.Invoke;\n            case 2 :\n                return CodeActionTriggerKind$1.Automatic;\n        }\n    }\n    CodeActionTriggerKind.to = to;\n})(CodeActionTriggerKind || (CodeActionTriggerKind = {})));\nvar TypeHierarchyItem;\n( (function(TypeHierarchyItem) {\n    function to(item) {\n        const result = new TypeHierarchyItem$1(SymbolKind.to(item.kind), item.name, item.detail || '', URI.revive(item.uri), Range.to(item.range), Range.to(item.selectionRange));\n        result._sessionId = item._sessionId;\n        result._itemId = item._itemId;\n        return result;\n    }\n    TypeHierarchyItem.to = to;\n    function from(item, sessionId, itemId) {\n        sessionId = sessionId ?? item._sessionId;\n        itemId = itemId ?? item._itemId;\n        if (sessionId === undefined || itemId === undefined) {\n            throw ( new Error('invalid item'));\n        }\n        return {\n            _sessionId: sessionId,\n            _itemId: itemId,\n            kind: SymbolKind.from(item.kind),\n            name: item.name,\n            detail: item.detail ?? '',\n            uri: item.uri,\n            range: Range.from(item.range),\n            selectionRange: Range.from(item.selectionRange),\n            tags: item.tags?.map(SymbolTag.from)\n        };\n    }\n    TypeHierarchyItem.from = from;\n})(TypeHierarchyItem || (TypeHierarchyItem = {})));\nvar ViewBadge;\n( (function(ViewBadge) {\n    function from(badge) {\n        if (!badge) {\n            return undefined;\n        }\n        return {\n            value: badge.value,\n            tooltip: badge.tooltip\n        };\n    }\n    ViewBadge.from = from;\n})(ViewBadge || (ViewBadge = {})));\nvar DataTransferItem;\n( (function(DataTransferItem) {\n    function to(mime, item, resolveFileData) {\n        const file = item.fileData;\n        if (file) {\n            return new InternalFileDataTransferItem(new DataTransferFile(file.name, URI.revive(file.uri), file.id, createSingleCallFunction(() => resolveFileData(file.id))));\n        }\n        if (mime === Mimes.uriList && item.uriListData) {\n            return new InternalDataTransferItem(reviveUriList(item.uriListData));\n        }\n        return new InternalDataTransferItem(item.asString);\n    }\n    DataTransferItem.to = to;\n    async function from(mime, item) {\n        const stringValue = await item.asString();\n        if (mime === Mimes.uriList) {\n            return {\n                asString: stringValue,\n                fileData: undefined,\n                uriListData: serializeUriList(stringValue),\n            };\n        }\n        const fileValue = item.asFile();\n        return {\n            asString: stringValue,\n            fileData: fileValue ? {\n                name: fileValue.name,\n                uri: fileValue.uri,\n                id: fileValue._itemId ?? fileValue.id,\n            } : undefined,\n        };\n    }\n    DataTransferItem.from = from;\n    function serializeUriList(stringValue) {\n        return ( UriList.split(stringValue).map(part => {\n            if (part.startsWith('#')) {\n                return part;\n            }\n            try {\n                return ( URI.parse(part));\n            }\n            catch {\n            }\n            return part;\n        }));\n    }\n    function reviveUriList(parts) {\n        return UriList.create(( parts.map(part => {\n            return typeof part === 'string' ? part : URI.revive(part);\n        })));\n    }\n})(DataTransferItem || (DataTransferItem = {})));\nvar DataTransfer;\n( (function(DataTransfer) {\n    function toDataTransfer(value, resolveFileData) {\n        const init = ( value.items.map(([type, item]) => {\n            return [type, DataTransferItem.to(type, item, resolveFileData)];\n        }));\n        return new DataTransfer$1(init);\n    }\n    DataTransfer.toDataTransfer = toDataTransfer;\n    async function from(dataTransfer) {\n        const newDTO = { items: [] };\n        const promises = [];\n        for (const [mime, value] of dataTransfer) {\n            promises.push((async () => {\n                newDTO.items.push([mime, await DataTransferItem.from(mime, value)]);\n            })());\n        }\n        await Promise.all(promises);\n        return newDTO;\n    }\n    DataTransfer.from = from;\n})(DataTransfer || (DataTransfer = {})));\nvar ChatFollowup;\n( (function(ChatFollowup) {\n    function from(followup, request) {\n        return {\n            kind: 'reply',\n            agentId: followup.participant ?? request?.agentId ?? '',\n            subCommand: followup.command ?? request?.command,\n            message: followup.prompt,\n            title: followup.label\n        };\n    }\n    ChatFollowup.from = from;\n    function to(followup) {\n        return {\n            prompt: followup.message,\n            label: followup.title,\n            participant: followup.agentId,\n            command: followup.subCommand,\n        };\n    }\n    ChatFollowup.to = to;\n})(ChatFollowup || (ChatFollowup = {})));\nvar LanguageModelChatMessageRole;\n( (function(LanguageModelChatMessageRole) {\n    function to(role) {\n        switch (role) {\n            case 0 : return LanguageModelChatMessageRole$1.System;\n            case 1 : return LanguageModelChatMessageRole$1.User;\n            case 2 : return LanguageModelChatMessageRole$1.Assistant;\n        }\n    }\n    LanguageModelChatMessageRole.to = to;\n    function from(role) {\n        switch (role) {\n            case LanguageModelChatMessageRole$1.System: return 0 ;\n            case LanguageModelChatMessageRole$1.User: return 1 ;\n            case LanguageModelChatMessageRole$1.Assistant: return 2 ;\n        }\n        return 1 ;\n    }\n    LanguageModelChatMessageRole.from = from;\n})(LanguageModelChatMessageRole || (LanguageModelChatMessageRole = {})));\nvar LanguageModelChatMessage;\n( (function(LanguageModelChatMessage) {\n    function to(message) {\n        const content2 = ( message.content.map(c => {\n            if (c.type === 'text') {\n                return c.value;\n            }\n            else if (c.type === 'tool_result') {\n                return new LanguageModelToolResultPart(c.toolCallId, c.value, c.isError);\n            }\n            else {\n                return new LanguageModelToolCallPart(c.name, c.toolCallId, c.parameters);\n            }\n        }));\n        const content = content2.find(c => typeof c === 'string') ?? '';\n        const role = LanguageModelChatMessageRole.to(message.role);\n        const result = new LanguageModelChatMessage$1(role, content, message.name);\n        result.content2 = content2;\n        return result;\n    }\n    LanguageModelChatMessage.to = to;\n    function from(message) {\n        const role = LanguageModelChatMessageRole.from(message.role);\n        const name = message.name;\n        const content = ( message.content2.map((c) => {\n            if (c instanceof LanguageModelToolResultPart) {\n                return {\n                    type: 'tool_result',\n                    toolCallId: c.toolCallId,\n                    value: c.content,\n                    isError: c.isError\n                };\n            }\n            else if (c instanceof LanguageModelToolCallPart) {\n                return {\n                    type: 'tool_use',\n                    toolCallId: c.toolCallId,\n                    name: c.name,\n                    parameters: c.parameters\n                };\n            }\n            else {\n                if (typeof c !== 'string') {\n                    throw ( new Error('Unexpected chat message content type'));\n                }\n                return {\n                    type: 'text',\n                    value: c\n                };\n            }\n        }));\n        return {\n            role,\n            name,\n            content\n        };\n    }\n    LanguageModelChatMessage.from = from;\n})(LanguageModelChatMessage || (LanguageModelChatMessage = {})));\nvar ChatResponseMarkdownPart;\n( (function(ChatResponseMarkdownPart) {\n    function from(part) {\n        return {\n            kind: 'markdownContent',\n            content: MarkdownString.from(part.value)\n        };\n    }\n    ChatResponseMarkdownPart.from = from;\n    function to(part) {\n        return new ChatResponseMarkdownPart$1(MarkdownString.to(part.content));\n    }\n    ChatResponseMarkdownPart.to = to;\n})(ChatResponseMarkdownPart || (ChatResponseMarkdownPart = {})));\nvar ChatResponseCodeblockUriPart;\n( (function(ChatResponseCodeblockUriPart) {\n    function from(part) {\n        return {\n            kind: 'codeblockUri',\n            uri: part.value,\n        };\n    }\n    ChatResponseCodeblockUriPart.from = from;\n    function to(part) {\n        return new ChatResponseCodeblockUriPart$1(URI.revive(part.uri));\n    }\n    ChatResponseCodeblockUriPart.to = to;\n})(ChatResponseCodeblockUriPart || (ChatResponseCodeblockUriPart = {})));\nvar ChatResponseMarkdownWithVulnerabilitiesPart;\n( (function(ChatResponseMarkdownWithVulnerabilitiesPart) {\n    function from(part) {\n        return {\n            kind: 'markdownVuln',\n            content: MarkdownString.from(part.value),\n            vulnerabilities: part.vulnerabilities,\n        };\n    }\n    ChatResponseMarkdownWithVulnerabilitiesPart.from = from;\n    function to(part) {\n        return new ChatResponseMarkdownWithVulnerabilitiesPart$1(MarkdownString.to(part.content), part.vulnerabilities);\n    }\n    ChatResponseMarkdownWithVulnerabilitiesPart.to = to;\n})(\n    ChatResponseMarkdownWithVulnerabilitiesPart || (ChatResponseMarkdownWithVulnerabilitiesPart = {})\n));\nvar ChatResponseDetectedParticipantPart;\n( (function(ChatResponseDetectedParticipantPart) {\n    function from(part) {\n        return {\n            kind: 'agentDetection',\n            agentId: part.participant,\n            command: part.command,\n        };\n    }\n    ChatResponseDetectedParticipantPart.from = from;\n    function to(part) {\n        return new ChatResponseDetectedParticipantPart$1(part.agentId, part.command);\n    }\n    ChatResponseDetectedParticipantPart.to = to;\n})(\n    ChatResponseDetectedParticipantPart || (ChatResponseDetectedParticipantPart = {})\n));\nvar ChatResponseConfirmationPart;\n( (function(ChatResponseConfirmationPart) {\n    function from(part) {\n        return {\n            kind: 'confirmation',\n            title: part.title,\n            message: part.message,\n            data: part.data,\n            buttons: part.buttons\n        };\n    }\n    ChatResponseConfirmationPart.from = from;\n})(ChatResponseConfirmationPart || (ChatResponseConfirmationPart = {})));\nvar ChatResponseFilesPart;\n( (function(ChatResponseFilesPart) {\n    function from(part) {\n        const { value, baseUri } = part;\n        function convert(items, baseUri) {\n            return ( items.map(item => {\n                const myUri = URI.joinPath(baseUri, item.name);\n                return {\n                    label: item.name,\n                    uri: myUri,\n                    children: item.children && convert(item.children, myUri)\n                };\n            }));\n        }\n        return {\n            kind: 'treeData',\n            treeData: {\n                label: basename(baseUri),\n                uri: baseUri,\n                children: convert(value, baseUri)\n            }\n        };\n    }\n    ChatResponseFilesPart.from = from;\n    function to(part) {\n        const treeData = revive(part.treeData);\n        function convert(items) {\n            return ( items.map(item => {\n                return {\n                    name: item.label,\n                    children: item.children && convert(item.children)\n                };\n            }));\n        }\n        const baseUri = treeData.uri;\n        const items = treeData.children ? convert(treeData.children) : [];\n        return new ChatResponseFileTreePart(items, baseUri);\n    }\n    ChatResponseFilesPart.to = to;\n})(ChatResponseFilesPart || (ChatResponseFilesPart = {})));\nvar ChatResponseAnchorPart;\n( (function(ChatResponseAnchorPart) {\n    function from(part) {\n        const isUri = (thing) => URI.isUri(thing);\n        const isSymbolInformation = (x) => x instanceof SymbolInformation;\n        return {\n            kind: 'inlineReference',\n            name: part.title,\n            inlineReference: isUri(part.value)\n                ? part.value\n                : isSymbolInformation(part.value)\n                    ? WorkspaceSymbol.from(part.value)\n                    : Location.from(part.value)\n        };\n    }\n    ChatResponseAnchorPart.from = from;\n    function to(part) {\n        const value = revive(part);\n        return new ChatResponseAnchorPart$1(URI.isUri(value.inlineReference)\n            ? value.inlineReference\n            : 'location' in value.inlineReference\n                ? WorkspaceSymbol.to(value.inlineReference)\n                : Location.to(value.inlineReference), part.name);\n    }\n    ChatResponseAnchorPart.to = to;\n})(ChatResponseAnchorPart || (ChatResponseAnchorPart = {})));\nvar ChatResponseProgressPart;\n( (function(ChatResponseProgressPart) {\n    function from(part) {\n        return {\n            kind: 'progressMessage',\n            content: MarkdownString.from(part.value)\n        };\n    }\n    ChatResponseProgressPart.from = from;\n    function to(part) {\n        return new ChatResponseProgressPart$1(part.content.value);\n    }\n    ChatResponseProgressPart.to = to;\n})(ChatResponseProgressPart || (ChatResponseProgressPart = {})));\nvar ChatResponseWarningPart;\n( (function(ChatResponseWarningPart) {\n    function from(part) {\n        return {\n            kind: 'warning',\n            content: MarkdownString.from(part.value)\n        };\n    }\n    ChatResponseWarningPart.from = from;\n    function to(part) {\n        return new ChatResponseWarningPart$1(part.content.value);\n    }\n    ChatResponseWarningPart.to = to;\n})(ChatResponseWarningPart || (ChatResponseWarningPart = {})));\nvar ChatResponseMovePart;\n( (function(ChatResponseMovePart) {\n    function from(part) {\n        return {\n            kind: 'move',\n            uri: part.uri,\n            range: Range.from(part.range),\n        };\n    }\n    ChatResponseMovePart.from = from;\n    function to(part) {\n        return new ChatResponseMovePart$1(URI.revive(part.uri), Range.to(part.range));\n    }\n    ChatResponseMovePart.to = to;\n})(ChatResponseMovePart || (ChatResponseMovePart = {})));\nvar ChatTask;\n( (function(ChatTask) {\n    function from(part) {\n        return {\n            kind: 'progressTask',\n            content: MarkdownString.from(part.value),\n        };\n    }\n    ChatTask.from = from;\n})(ChatTask || (ChatTask = {})));\nvar ChatTaskResult;\n( (function(ChatTaskResult) {\n    function from(part) {\n        return {\n            kind: 'progressTaskResult',\n            content: typeof part === 'string' ? MarkdownString.from(part) : undefined\n        };\n    }\n    ChatTaskResult.from = from;\n})(ChatTaskResult || (ChatTaskResult = {})));\nvar ChatResponseCommandButtonPart;\n( (function(ChatResponseCommandButtonPart) {\n    function from(part, commandsConverter, commandDisposables) {\n        const command = commandsConverter.toInternal(part.value, commandDisposables) ?? { command: part.value.command, title: part.value.title };\n        return {\n            kind: 'command',\n            command\n        };\n    }\n    ChatResponseCommandButtonPart.from = from;\n    function to(part, commandsConverter) {\n        return new ChatResponseCommandButtonPart$1(commandsConverter.fromInternal(part.command) ?? { command: part.command.id, title: part.command.title });\n    }\n    ChatResponseCommandButtonPart.to = to;\n})(ChatResponseCommandButtonPart || (ChatResponseCommandButtonPart = {})));\nvar ChatResponseTextEditPart;\n( (function(ChatResponseTextEditPart) {\n    function from(part) {\n        return {\n            kind: 'textEdit',\n            uri: part.uri,\n            edits: ( part.edits.map(e => TextEdit.from(e)))\n        };\n    }\n    ChatResponseTextEditPart.from = from;\n    function to(part) {\n        return new ChatResponseTextEditPart$1(URI.revive(part.uri), ( part.edits.map(e => TextEdit.to(e))));\n    }\n    ChatResponseTextEditPart.to = to;\n})(ChatResponseTextEditPart || (ChatResponseTextEditPart = {})));\nvar ChatResponseReferencePart;\n( (function(ChatResponseReferencePart) {\n    function from(part) {\n        const iconPath = ThemeIcon.isThemeIcon(part.iconPath) ? part.iconPath\n            : URI.isUri(part.iconPath) ? { light: URI.revive(part.iconPath) }\n                : (part.iconPath && 'light' in part.iconPath && 'dark' in part.iconPath && URI.isUri(part.iconPath.light) && URI.isUri(part.iconPath.dark) ? { light: URI.revive(part.iconPath.light), dark: URI.revive(part.iconPath.dark) }\n                    : undefined);\n        if (typeof part.value === 'object' && 'variableName' in part.value) {\n            return {\n                kind: 'reference',\n                reference: {\n                    variableName: part.value.variableName,\n                    value: URI.isUri(part.value.value) || !part.value.value ?\n                        part.value.value :\n                        Location.from(part.value.value)\n                },\n                iconPath,\n                options: part.options\n            };\n        }\n        return {\n            kind: 'reference',\n            reference: URI.isUri(part.value) || typeof part.value === 'string' ?\n                part.value :\n                Location.from(part.value),\n            iconPath,\n            options: part.options\n        };\n    }\n    ChatResponseReferencePart.from = from;\n    function to(part) {\n        const value = revive(part);\n        const mapValue = (value) => URI.isUri(value) ?\n            value :\n            Location.to(value);\n        return new ChatResponseReferencePart$1(typeof value.reference === 'string' ? value.reference : 'variableName' in value.reference ? {\n            variableName: value.reference.variableName,\n            value: value.reference.value && mapValue(value.reference.value)\n        } :\n            mapValue(value.reference));\n    }\n    ChatResponseReferencePart.to = to;\n})(ChatResponseReferencePart || (ChatResponseReferencePart = {})));\nvar ChatResponseCodeCitationPart;\n( (function(ChatResponseCodeCitationPart) {\n    function from(part) {\n        return {\n            kind: 'codeCitation',\n            value: part.value,\n            license: part.license,\n            snippet: part.snippet\n        };\n    }\n    ChatResponseCodeCitationPart.from = from;\n})(ChatResponseCodeCitationPart || (ChatResponseCodeCitationPart = {})));\nvar ChatResponsePart;\n( (function(ChatResponsePart) {\n    function from(part, commandsConverter, commandDisposables) {\n        if (part instanceof ChatResponseMarkdownPart$1) {\n            return ChatResponseMarkdownPart.from(part);\n        }\n        else if (part instanceof ChatResponseAnchorPart$1) {\n            return ChatResponseAnchorPart.from(part);\n        }\n        else if (part instanceof ChatResponseReferencePart$1) {\n            return ChatResponseReferencePart.from(part);\n        }\n        else if (part instanceof ChatResponseProgressPart$1) {\n            return ChatResponseProgressPart.from(part);\n        }\n        else if (part instanceof ChatResponseFileTreePart) {\n            return ChatResponseFilesPart.from(part);\n        }\n        else if (part instanceof ChatResponseCommandButtonPart$1) {\n            return ChatResponseCommandButtonPart.from(part, commandsConverter, commandDisposables);\n        }\n        else if (part instanceof ChatResponseTextEditPart$1) {\n            return ChatResponseTextEditPart.from(part);\n        }\n        else if (part instanceof ChatResponseMarkdownWithVulnerabilitiesPart$1) {\n            return ChatResponseMarkdownWithVulnerabilitiesPart.from(part);\n        }\n        else if (part instanceof ChatResponseCodeblockUriPart$1) {\n            return ChatResponseCodeblockUriPart.from(part);\n        }\n        else if (part instanceof ChatResponseDetectedParticipantPart$1) {\n            return ChatResponseDetectedParticipantPart.from(part);\n        }\n        else if (part instanceof ChatResponseWarningPart$1) {\n            return ChatResponseWarningPart.from(part);\n        }\n        else if (part instanceof ChatResponseConfirmationPart$1) {\n            return ChatResponseConfirmationPart.from(part);\n        }\n        else if (part instanceof ChatResponseCodeCitationPart$1) {\n            return ChatResponseCodeCitationPart.from(part);\n        }\n        else if (part instanceof ChatResponseMovePart$1) {\n            return ChatResponseMovePart.from(part);\n        }\n        return {\n            kind: 'markdownContent',\n            content: MarkdownString.from('')\n        };\n    }\n    ChatResponsePart.from = from;\n    function to(part, commandsConverter) {\n        switch (part.kind) {\n            case 'reference': return ChatResponseReferencePart.to(part);\n            case 'markdownContent':\n            case 'inlineReference':\n            case 'progressMessage':\n            case 'treeData':\n            case 'command':\n                return toContent(part, commandsConverter);\n        }\n        return undefined;\n    }\n    ChatResponsePart.to = to;\n    function toContent(part, commandsConverter) {\n        switch (part.kind) {\n            case 'markdownContent': return ChatResponseMarkdownPart.to(part);\n            case 'inlineReference': return ChatResponseAnchorPart.to(part);\n            case 'progressMessage': return undefined;\n            case 'treeData': return ChatResponseFilesPart.to(part);\n            case 'command': return ChatResponseCommandButtonPart.to(part, commandsConverter);\n        }\n        return undefined;\n    }\n    ChatResponsePart.toContent = toContent;\n})(ChatResponsePart || (ChatResponsePart = {})));\nvar ChatAgentRequest;\n( (function(ChatAgentRequest) {\n    function to(request, location2) {\n        const toolReferences = request.variables.variables.filter(v => v.isTool);\n        const variableReferences = request.variables.variables.filter(v => !v.isTool);\n        return {\n            prompt: request.message,\n            command: request.command,\n            attempt: request.attempt ?? 0,\n            enableCommandDetection: request.enableCommandDetection ?? true,\n            isParticipantDetected: request.isParticipantDetected ?? false,\n            references: ( variableReferences.map(ChatPromptReference.to)),\n            toolReferences: ( toolReferences.map(ChatLanguageModelToolReference.to)),\n            location: ChatLocation.to(request.location),\n            acceptedConfirmationData: request.acceptedConfirmationData,\n            rejectedConfirmationData: request.rejectedConfirmationData,\n            location2,\n            toolInvocationToken: ( Object.freeze({ sessionId: request.sessionId }))\n        };\n    }\n    ChatAgentRequest.to = to;\n})(ChatAgentRequest || (ChatAgentRequest = {})));\nvar ChatLocation;\n( (function(ChatLocation) {\n    function to(loc) {\n        switch (loc) {\n            case ChatAgentLocation.Notebook: return ChatLocation$1.Notebook;\n            case ChatAgentLocation.Terminal: return ChatLocation$1.Terminal;\n            case ChatAgentLocation.Panel: return ChatLocation$1.Panel;\n            case ChatAgentLocation.Editor: return ChatLocation$1.Editor;\n        }\n    }\n    ChatLocation.to = to;\n    function from(loc) {\n        switch (loc) {\n            case ChatLocation$1.Notebook: return ChatAgentLocation.Notebook;\n            case ChatLocation$1.Terminal: return ChatAgentLocation.Terminal;\n            case ChatLocation$1.Panel: return ChatAgentLocation.Panel;\n            case ChatLocation$1.Editor: return ChatAgentLocation.Editor;\n        }\n    }\n    ChatLocation.from = from;\n})(ChatLocation || (ChatLocation = {})));\nvar ChatPromptReference;\n( (function(ChatPromptReference) {\n    function to(variable) {\n        const value = variable.value;\n        if (!value) {\n            throw ( new Error('Invalid value reference'));\n        }\n        return {\n            id: variable.id,\n            name: variable.name,\n            range: variable.range && [variable.range.start, variable.range.endExclusive],\n            value: isUriComponents(value) ? URI.revive(value) :\n                value && typeof value === 'object' && 'uri' in value && 'range' in value && isUriComponents(value.uri) ?\n                    Location.to(revive(value)) : value,\n            modelDescription: variable.modelDescription\n        };\n    }\n    ChatPromptReference.to = to;\n})(ChatPromptReference || (ChatPromptReference = {})));\nvar ChatLanguageModelToolReference;\n( (function(ChatLanguageModelToolReference) {\n    function to(variable) {\n        const value = variable.value;\n        if (value) {\n            throw ( new Error('Invalid tool reference'));\n        }\n        return {\n            id: variable.id,\n            range: variable.range && [variable.range.start, variable.range.endExclusive],\n        };\n    }\n    ChatLanguageModelToolReference.to = to;\n})(ChatLanguageModelToolReference || (ChatLanguageModelToolReference = {})));\nvar ChatAgentCompletionItem;\n( (function(ChatAgentCompletionItem) {\n    function from(item, commandsConverter, disposables) {\n        return {\n            id: item.id,\n            label: item.label,\n            fullName: item.fullName,\n            icon: item.icon?.id,\n            value: item.values[0].value,\n            insertText: item.insertText,\n            detail: item.detail,\n            documentation: item.documentation,\n            command: commandsConverter.toInternal(item.command, disposables),\n        };\n    }\n    ChatAgentCompletionItem.from = from;\n})(ChatAgentCompletionItem || (ChatAgentCompletionItem = {})));\nvar ChatAgentResult;\n( (function(ChatAgentResult) {\n    function to(result) {\n        return {\n            errorDetails: result.errorDetails,\n            metadata: result.metadata,\n            nextQuestion: result.nextQuestion,\n        };\n    }\n    ChatAgentResult.to = to;\n})(ChatAgentResult || (ChatAgentResult = {})));\nvar ChatAgentUserActionEvent;\n( (function(ChatAgentUserActionEvent) {\n    function to(result, event, commandsConverter) {\n        if (event.action.kind === 'vote') {\n            return;\n        }\n        const ehResult = ChatAgentResult.to(result);\n        if (event.action.kind === 'command') {\n            const command = event.action.commandButton.command;\n            const commandButton = {\n                command: commandsConverter.fromInternal(command) ?? { command: command.id, title: command.title },\n            };\n            const commandAction = { kind: 'command', commandButton };\n            return { action: commandAction, result: ehResult };\n        }\n        else if (event.action.kind === 'followUp') {\n            const followupAction = { kind: 'followUp', followup: ChatFollowup.to(event.action.followup) };\n            return { action: followupAction, result: ehResult };\n        }\n        else if (event.action.kind === 'inlineChat') {\n            return { action: { kind: 'editor', accepted: event.action.action === 'accepted' }, result: ehResult };\n        }\n        else {\n            return { action: event.action, result: ehResult };\n        }\n    }\n    ChatAgentUserActionEvent.to = to;\n})(ChatAgentUserActionEvent || (ChatAgentUserActionEvent = {})));\nvar TerminalQuickFix;\n( (function(TerminalQuickFix) {\n    function from(quickFix, converter, disposables) {\n        if ('terminalCommand' in quickFix) {\n            return { terminalCommand: quickFix.terminalCommand, shouldExecute: quickFix.shouldExecute };\n        }\n        if ('uri' in quickFix) {\n            return { uri: quickFix.uri };\n        }\n        return converter.toInternal(quickFix, disposables);\n    }\n    TerminalQuickFix.from = from;\n})(TerminalQuickFix || (TerminalQuickFix = {})));\nvar PartialAcceptInfo;\n( (function(PartialAcceptInfo) {\n    function to(info) {\n        return {\n            kind: PartialAcceptTriggerKind.to(info.kind),\n        };\n    }\n    PartialAcceptInfo.to = to;\n})(PartialAcceptInfo || (PartialAcceptInfo = {})));\nvar PartialAcceptTriggerKind;\n( (function(PartialAcceptTriggerKind) {\n    function to(kind) {\n        switch (kind) {\n            case 0 :\n                return PartialAcceptTriggerKind$1.Word;\n            case 1 :\n                return PartialAcceptTriggerKind$1.Line;\n            case 2 :\n                return PartialAcceptTriggerKind$1.Suggest;\n            default:\n                return PartialAcceptTriggerKind$1.Unknown;\n        }\n    }\n    PartialAcceptTriggerKind.to = to;\n})(PartialAcceptTriggerKind || (PartialAcceptTriggerKind = {})));\nvar DebugTreeItem;\n( (function(DebugTreeItem) {\n    function from(item, id) {\n        return {\n            id,\n            label: item.label,\n            description: item.description,\n            canEdit: item.canEdit,\n            collapsibleState: ((item.collapsibleState || 0) ),\n            contextValue: item.contextValue,\n        };\n    }\n    DebugTreeItem.from = from;\n})(DebugTreeItem || (DebugTreeItem = {})));\nvar LanguageModelToolDescription;\n( (function(LanguageModelToolDescription) {\n    function to(item) {\n        return {\n            id: item.id,\n            modelDescription: item.modelDescription,\n            parametersSchema: item.parametersSchema,\n            displayName: item.displayName,\n            supportedContentTypes: item.supportedContentTypes,\n        };\n    }\n    LanguageModelToolDescription.to = to;\n})(LanguageModelToolDescription || (LanguageModelToolDescription = {})));\nexport { CallHierarchyIncomingCall, CallHierarchyItem, CallHierarchyOutgoingCall, ChatAgentCompletionItem, ChatAgentRequest, ChatAgentResult, ChatAgentUserActionEvent, ChatFollowup, ChatLanguageModelToolReference, ChatLocation, ChatPromptReference, ChatResponseAnchorPart, ChatResponseCodeCitationPart, ChatResponseCodeblockUriPart, ChatResponseCommandButtonPart, ChatResponseConfirmationPart, ChatResponseDetectedParticipantPart, ChatResponseFilesPart, ChatResponseMarkdownPart, ChatResponseMarkdownWithVulnerabilitiesPart, ChatResponseMovePart, ChatResponsePart, ChatResponseProgressPart, ChatResponseReferencePart, ChatResponseTextEditPart, ChatResponseWarningPart, ChatTask, ChatTaskResult, CodeActionTriggerKind, Color, ColorPresentation, CompletionContext, CompletionItem, CompletionItemKind, CompletionItemTag, CompletionTriggerKind, DataTransfer, DataTransferItem, DebugTreeItem, DecorationRangeBehavior, DecorationRenderOptions, DefinitionLink, Diagnostic, DiagnosticRelatedInformation, DiagnosticSeverity, DiagnosticTag, DocumentContextItem, DocumentHighlight, DocumentLink, DocumentSelector, DocumentSymbol, EndOfLine, EvaluatableExpression, FoldingRange, FoldingRangeKind, GlobPattern, Hover, InlayHint, InlayHintKind, InlayHintLabelPart, InlineValue, InlineValueContext, LanguageModelChatMessage, LanguageModelChatMessageRole, LanguageModelToolDescription, LanguageSelector, Location, MappedEditsContext, MarkdownString, MultiDocumentHighlight, NotebookCellData, NotebookCellExecutionState, NotebookCellExecutionSummary, NotebookCellKind, NotebookCellOutput, NotebookCellOutputItem, NotebookData, NotebookDocumentContentOptions, NotebookExclusiveDocumentPattern, NotebookKernelSourceAction, NotebookRange, NotebookRendererScript, NotebookStatusBarItem, ParameterInformation, PartialAcceptInfo, PartialAcceptTriggerKind, Position, ProgressLocation, Range, Selection, SelectionRange, SignatureHelp, SignatureInformation, SymbolKind, SymbolTag, TerminalQuickFix, TestCoverage, TestItem, TestMessage, TestResults, TestTag, TextDocumentSaveReason, TextEdit, TextEditorLineNumbersStyle, TextEditorOpenOptions, ThemableDecorationAttachmentRenderOptions, ThemableDecorationRenderOptions, TokenType, TypeHierarchyItem, ViewBadge, ViewColumn, WorkspaceEdit, WorkspaceSymbol, fromRangeOrRangeWithMessage, isDecorationOptionsArr, location, pathOrURIToURI };\n","import { __decorate } from '../../../../../../external/tslib/tslib.es6.js';\nimport { coalesceInPlace, equals, asArray } from '../../../base/common/arrays.js';\nimport { illegalArgument } from '../../../base/common/errors.js';\nimport { MarkdownString as MarkdownString$1 } from '../../../base/common/htmlContent.js';\nimport { ResourceMap } from '../../../base/common/map.js';\nimport { Mimes, normalizeMimeType } from '../../../base/common/mime.js';\nimport { nextCharLength } from '../../../base/common/strings.js';\nimport { isString, isNumber, isObject, isStringArray } from '../../../base/common/types.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { generateUuid } from '../../../base/common/uuid.js';\nimport { ExtensionIdentifier } from '../../../platform/extensions/common/extensions.js';\nimport { FileSystemProviderErrorCode, markAsFileSystemProviderError } from '../../../platform/files/common/files.js';\nimport { RemoteAuthorityResolverErrorCode } from '../../../platform/remote/common/remoteAuthorityResolver.js';\nimport { isTextStreamMime } from '../../contrib/notebook/common/notebookCommon.js';\nvar Disposable_1, Position_1, Range_1, Selection_1, TextEdit_1, NotebookEdit_1, SnippetString_1, Location_1, SymbolInformation_1, DocumentSymbol_1, CodeActionKind_1, MarkdownString_1, TaskGroup_1, Task_1, TreeItem_1, FileSystemError_1, TestMessage_1;\nfunction es5ClassCompat(target) {\n    const interceptFunctions = {\n        apply: function (...args) {\n            if (args.length === 0) {\n                return Reflect.construct(target, []);\n            }\n            else {\n                const argsList = args.length === 1 ? [] : args[1];\n                return Reflect.construct(target, argsList, args[0].constructor);\n            }\n        },\n        call: function (...args) {\n            if (args.length === 0) {\n                return Reflect.construct(target, []);\n            }\n            else {\n                const [thisArg, ...restArgs] = args;\n                return Reflect.construct(target, restArgs, thisArg.constructor);\n            }\n        }\n    };\n    return Object.assign(target, interceptFunctions);\n}\nvar TerminalOutputAnchor;\n( (function(TerminalOutputAnchor) {\n    TerminalOutputAnchor[TerminalOutputAnchor[\"Top\"] = 0] = \"Top\";\n    TerminalOutputAnchor[TerminalOutputAnchor[\"Bottom\"] = 1] = \"Bottom\";\n})(TerminalOutputAnchor || (TerminalOutputAnchor = {})));\nlet Disposable = Disposable_1 = class Disposable {\n    static from(...inDisposables) {\n        let disposables = inDisposables;\n        return ( new Disposable_1(function () {\n            if (disposables) {\n                for (const disposable of disposables) {\n                    if (disposable && typeof disposable.dispose === 'function') {\n                        disposable.dispose();\n                    }\n                }\n                disposables = undefined;\n            }\n        }));\n    }\n    #callOnDispose;\n    constructor(callOnDispose) {\n        this.#callOnDispose = callOnDispose;\n    }\n    dispose() {\n        if (typeof this.#callOnDispose === 'function') {\n            this.#callOnDispose();\n            this.#callOnDispose = undefined;\n        }\n    }\n};\nDisposable = Disposable_1 = ( __decorate([\n    es5ClassCompat\n], Disposable));\nlet Position = Position_1 = class Position {\n    static Min(...positions) {\n        if (positions.length === 0) {\n            throw ( new TypeError());\n        }\n        let result = positions[0];\n        for (let i = 1; i < positions.length; i++) {\n            const p = positions[i];\n            if (p.isBefore(result)) {\n                result = p;\n            }\n        }\n        return result;\n    }\n    static Max(...positions) {\n        if (positions.length === 0) {\n            throw ( new TypeError());\n        }\n        let result = positions[0];\n        for (let i = 1; i < positions.length; i++) {\n            const p = positions[i];\n            if (p.isAfter(result)) {\n                result = p;\n            }\n        }\n        return result;\n    }\n    static isPosition(other) {\n        if (!other) {\n            return false;\n        }\n        if (other instanceof Position_1) {\n            return true;\n        }\n        const { line, character } = other;\n        if (typeof line === 'number' && typeof character === 'number') {\n            return true;\n        }\n        return false;\n    }\n    static of(obj) {\n        if (obj instanceof Position_1) {\n            return obj;\n        }\n        else if (this.isPosition(obj)) {\n            return ( new Position_1(obj.line, obj.character));\n        }\n        throw ( new Error('Invalid argument, is NOT a position-like object'));\n    }\n    get line() {\n        return this._line;\n    }\n    get character() {\n        return this._character;\n    }\n    constructor(line, character) {\n        if (line < 0) {\n            throw illegalArgument('line must be non-negative');\n        }\n        if (character < 0) {\n            throw illegalArgument('character must be non-negative');\n        }\n        this._line = line;\n        this._character = character;\n    }\n    isBefore(other) {\n        if (this._line < other._line) {\n            return true;\n        }\n        if (other._line < this._line) {\n            return false;\n        }\n        return this._character < other._character;\n    }\n    isBeforeOrEqual(other) {\n        if (this._line < other._line) {\n            return true;\n        }\n        if (other._line < this._line) {\n            return false;\n        }\n        return this._character <= other._character;\n    }\n    isAfter(other) {\n        return !this.isBeforeOrEqual(other);\n    }\n    isAfterOrEqual(other) {\n        return !this.isBefore(other);\n    }\n    isEqual(other) {\n        return this._line === other._line && this._character === other._character;\n    }\n    compareTo(other) {\n        if (this._line < other._line) {\n            return -1;\n        }\n        else if (this._line > other.line) {\n            return 1;\n        }\n        else {\n            if (this._character < other._character) {\n                return -1;\n            }\n            else if (this._character > other._character) {\n                return 1;\n            }\n            else {\n                return 0;\n            }\n        }\n    }\n    translate(lineDeltaOrChange, characterDelta = 0) {\n        if (lineDeltaOrChange === null || characterDelta === null) {\n            throw illegalArgument();\n        }\n        let lineDelta;\n        if (typeof lineDeltaOrChange === 'undefined') {\n            lineDelta = 0;\n        }\n        else if (typeof lineDeltaOrChange === 'number') {\n            lineDelta = lineDeltaOrChange;\n        }\n        else {\n            lineDelta = typeof lineDeltaOrChange.lineDelta === 'number' ? lineDeltaOrChange.lineDelta : 0;\n            characterDelta = typeof lineDeltaOrChange.characterDelta === 'number' ? lineDeltaOrChange.characterDelta : 0;\n        }\n        if (lineDelta === 0 && characterDelta === 0) {\n            return this;\n        }\n        return ( new Position_1(this.line + lineDelta, this.character + characterDelta));\n    }\n    with(lineOrChange, character = this.character) {\n        if (lineOrChange === null || character === null) {\n            throw illegalArgument();\n        }\n        let line;\n        if (typeof lineOrChange === 'undefined') {\n            line = this.line;\n        }\n        else if (typeof lineOrChange === 'number') {\n            line = lineOrChange;\n        }\n        else {\n            line = typeof lineOrChange.line === 'number' ? lineOrChange.line : this.line;\n            character = typeof lineOrChange.character === 'number' ? lineOrChange.character : this.character;\n        }\n        if (line === this.line && character === this.character) {\n            return this;\n        }\n        return ( new Position_1(line, character));\n    }\n    toJSON() {\n        return { line: this.line, character: this.character };\n    }\n    [Symbol.for('debug.description')]() {\n        return `(${this.line}:${this.character})`;\n    }\n};\nPosition = Position_1 = ( __decorate([\n    es5ClassCompat\n], Position));\nlet Range = Range_1 = class Range {\n    static isRange(thing) {\n        if (thing instanceof Range_1) {\n            return true;\n        }\n        if (!thing) {\n            return false;\n        }\n        return Position.isPosition(thing.start)\n            && Position.isPosition(thing.end);\n    }\n    static of(obj) {\n        if (obj instanceof Range_1) {\n            return obj;\n        }\n        if (this.isRange(obj)) {\n            return ( new Range_1(obj.start, obj.end));\n        }\n        throw ( new Error('Invalid argument, is NOT a range-like object'));\n    }\n    get start() {\n        return this._start;\n    }\n    get end() {\n        return this._end;\n    }\n    constructor(startLineOrStart, startColumnOrEnd, endLine, endColumn) {\n        let start;\n        let end;\n        if (typeof startLineOrStart === 'number' && typeof startColumnOrEnd === 'number' && typeof endLine === 'number' && typeof endColumn === 'number') {\n            start = ( new Position(startLineOrStart, startColumnOrEnd));\n            end = ( new Position(endLine, endColumn));\n        }\n        else if (Position.isPosition(startLineOrStart) && Position.isPosition(startColumnOrEnd)) {\n            start = Position.of(startLineOrStart);\n            end = Position.of(startColumnOrEnd);\n        }\n        if (!start || !end) {\n            throw ( new Error('Invalid arguments'));\n        }\n        if (start.isBefore(end)) {\n            this._start = start;\n            this._end = end;\n        }\n        else {\n            this._start = end;\n            this._end = start;\n        }\n    }\n    contains(positionOrRange) {\n        if (Range_1.isRange(positionOrRange)) {\n            return this.contains(positionOrRange.start)\n                && this.contains(positionOrRange.end);\n        }\n        else if (Position.isPosition(positionOrRange)) {\n            if (Position.of(positionOrRange).isBefore(this._start)) {\n                return false;\n            }\n            if (this._end.isBefore(positionOrRange)) {\n                return false;\n            }\n            return true;\n        }\n        return false;\n    }\n    isEqual(other) {\n        return this._start.isEqual(other._start) && this._end.isEqual(other._end);\n    }\n    intersection(other) {\n        const start = Position.Max(other.start, this._start);\n        const end = Position.Min(other.end, this._end);\n        if (start.isAfter(end)) {\n            return undefined;\n        }\n        return ( new Range_1(start, end));\n    }\n    union(other) {\n        if (this.contains(other)) {\n            return this;\n        }\n        else if (other.contains(this)) {\n            return other;\n        }\n        const start = Position.Min(other.start, this._start);\n        const end = Position.Max(other.end, this.end);\n        return ( new Range_1(start, end));\n    }\n    get isEmpty() {\n        return this._start.isEqual(this._end);\n    }\n    get isSingleLine() {\n        return this._start.line === this._end.line;\n    }\n    with(startOrChange, end = this.end) {\n        if (startOrChange === null || end === null) {\n            throw illegalArgument();\n        }\n        let start;\n        if (!startOrChange) {\n            start = this.start;\n        }\n        else if (Position.isPosition(startOrChange)) {\n            start = startOrChange;\n        }\n        else {\n            start = startOrChange.start || this.start;\n            end = startOrChange.end || this.end;\n        }\n        if (start.isEqual(this._start) && end.isEqual(this.end)) {\n            return this;\n        }\n        return ( new Range_1(start, end));\n    }\n    toJSON() {\n        return [this.start, this.end];\n    }\n    [Symbol.for('debug.description')]() {\n        return getDebugDescriptionOfRange(this);\n    }\n};\nRange = Range_1 = ( __decorate([\n    es5ClassCompat\n], Range));\nlet Selection = Selection_1 = class Selection extends Range {\n    static isSelection(thing) {\n        if (thing instanceof Selection_1) {\n            return true;\n        }\n        if (!thing) {\n            return false;\n        }\n        return Range.isRange(thing)\n            && Position.isPosition(thing.anchor)\n            && Position.isPosition(thing.active)\n            && typeof thing.isReversed === 'boolean';\n    }\n    get anchor() {\n        return this._anchor;\n    }\n    get active() {\n        return this._active;\n    }\n    constructor(anchorLineOrAnchor, anchorColumnOrActive, activeLine, activeColumn) {\n        let anchor;\n        let active;\n        if (typeof anchorLineOrAnchor === 'number' && typeof anchorColumnOrActive === 'number' && typeof activeLine === 'number' && typeof activeColumn === 'number') {\n            anchor = ( new Position(anchorLineOrAnchor, anchorColumnOrActive));\n            active = ( new Position(activeLine, activeColumn));\n        }\n        else if (Position.isPosition(anchorLineOrAnchor) && Position.isPosition(anchorColumnOrActive)) {\n            anchor = Position.of(anchorLineOrAnchor);\n            active = Position.of(anchorColumnOrActive);\n        }\n        if (!anchor || !active) {\n            throw ( new Error('Invalid arguments'));\n        }\n        super(anchor, active);\n        this._anchor = anchor;\n        this._active = active;\n    }\n    get isReversed() {\n        return this._anchor === this._end;\n    }\n    toJSON() {\n        return {\n            start: this.start,\n            end: this.end,\n            active: this.active,\n            anchor: this.anchor\n        };\n    }\n    [Symbol.for('debug.description')]() {\n        return getDebugDescriptionOfSelection(this);\n    }\n};\nSelection = Selection_1 = ( __decorate([\n    es5ClassCompat\n], Selection));\nfunction getDebugDescriptionOfRange(range) {\n    return range.isEmpty\n        ? `[${range.start.line}:${range.start.character})`\n        : `[${range.start.line}:${range.start.character} -> ${range.end.line}:${range.end.character})`;\n}\nfunction getDebugDescriptionOfSelection(selection) {\n    let rangeStr = getDebugDescriptionOfRange(selection);\n    if (!selection.isEmpty) {\n        if (selection.active.isEqual(selection.start)) {\n            rangeStr = `|${rangeStr}`;\n        }\n        else {\n            rangeStr = `${rangeStr}|`;\n        }\n    }\n    return rangeStr;\n}\nconst validateConnectionToken = (connectionToken) => {\n    if (typeof connectionToken !== 'string' || connectionToken.length === 0 || !/^[0-9A-Za-z_\\-]+$/.test(connectionToken)) {\n        throw illegalArgument('connectionToken');\n    }\n};\nclass ResolvedAuthority {\n    static isResolvedAuthority(resolvedAuthority) {\n        return resolvedAuthority\n            && typeof resolvedAuthority === 'object'\n            && typeof resolvedAuthority.host === 'string'\n            && typeof resolvedAuthority.port === 'number'\n            && (resolvedAuthority.connectionToken === undefined || typeof resolvedAuthority.connectionToken === 'string');\n    }\n    constructor(host, port, connectionToken) {\n        if (typeof host !== 'string' || host.length === 0) {\n            throw illegalArgument('host');\n        }\n        if (typeof port !== 'number' || port === 0 || Math.round(port) !== port) {\n            throw illegalArgument('port');\n        }\n        if (typeof connectionToken !== 'undefined') {\n            validateConnectionToken(connectionToken);\n        }\n        this.host = host;\n        this.port = Math.round(port);\n        this.connectionToken = connectionToken;\n    }\n}\nclass ManagedResolvedAuthority {\n    static isManagedResolvedAuthority(resolvedAuthority) {\n        return resolvedAuthority\n            && typeof resolvedAuthority === 'object'\n            && typeof resolvedAuthority.makeConnection === 'function'\n            && (resolvedAuthority.connectionToken === undefined || typeof resolvedAuthority.connectionToken === 'string');\n    }\n    constructor(makeConnection, connectionToken) {\n        this.makeConnection = makeConnection;\n        this.connectionToken = connectionToken;\n        if (typeof connectionToken !== 'undefined') {\n            validateConnectionToken(connectionToken);\n        }\n    }\n}\nclass RemoteAuthorityResolverError extends Error {\n    static NotAvailable(message, handled) {\n        return ( new RemoteAuthorityResolverError(message, RemoteAuthorityResolverErrorCode.NotAvailable, handled));\n    }\n    static TemporarilyNotAvailable(message) {\n        return ( new RemoteAuthorityResolverError(message, RemoteAuthorityResolverErrorCode.TemporarilyNotAvailable));\n    }\n    constructor(message, code = RemoteAuthorityResolverErrorCode.Unknown, detail) {\n        super(message);\n        this._message = message;\n        this._code = code;\n        this._detail = detail;\n        Object.setPrototypeOf(this, RemoteAuthorityResolverError.prototype);\n    }\n}\nvar EndOfLine;\n( (function(EndOfLine) {\n    EndOfLine[EndOfLine[\"LF\"] = 1] = \"LF\";\n    EndOfLine[EndOfLine[\"CRLF\"] = 2] = \"CRLF\";\n})(EndOfLine || (EndOfLine = {})));\nvar EnvironmentVariableMutatorType;\n( (function(EnvironmentVariableMutatorType) {\n    EnvironmentVariableMutatorType[EnvironmentVariableMutatorType[\"Replace\"] = 1] = \"Replace\";\n    EnvironmentVariableMutatorType[EnvironmentVariableMutatorType[\"Append\"] = 2] = \"Append\";\n    EnvironmentVariableMutatorType[EnvironmentVariableMutatorType[\"Prepend\"] = 3] = \"Prepend\";\n})(EnvironmentVariableMutatorType || (EnvironmentVariableMutatorType = {})));\nlet TextEdit = TextEdit_1 = class TextEdit {\n    static isTextEdit(thing) {\n        if (thing instanceof TextEdit_1) {\n            return true;\n        }\n        if (!thing) {\n            return false;\n        }\n        return Range.isRange(thing)\n            && typeof thing.newText === 'string';\n    }\n    static replace(range, newText) {\n        return ( new TextEdit_1(range, newText));\n    }\n    static insert(position, newText) {\n        return TextEdit_1.replace(( new Range(position, position)), newText);\n    }\n    static delete(range) {\n        return TextEdit_1.replace(range, '');\n    }\n    static setEndOfLine(eol) {\n        const ret = ( new TextEdit_1(( new Range(( new Position(0, 0)), ( new Position(0, 0)))), ''));\n        ret.newEol = eol;\n        return ret;\n    }\n    get range() {\n        return this._range;\n    }\n    set range(value) {\n        if (value && !Range.isRange(value)) {\n            throw illegalArgument('range');\n        }\n        this._range = value;\n    }\n    get newText() {\n        return this._newText || '';\n    }\n    set newText(value) {\n        if (value && typeof value !== 'string') {\n            throw illegalArgument('newText');\n        }\n        this._newText = value;\n    }\n    get newEol() {\n        return this._newEol;\n    }\n    set newEol(value) {\n        if (value && typeof value !== 'number') {\n            throw illegalArgument('newEol');\n        }\n        this._newEol = value;\n    }\n    constructor(range, newText) {\n        this._range = range;\n        this._newText = newText;\n    }\n    toJSON() {\n        return {\n            range: this.range,\n            newText: this.newText,\n            newEol: this._newEol\n        };\n    }\n};\nTextEdit = TextEdit_1 = ( __decorate([\n    es5ClassCompat\n], TextEdit));\nlet NotebookEdit = NotebookEdit_1 = class NotebookEdit {\n    static isNotebookCellEdit(thing) {\n        if (thing instanceof NotebookEdit_1) {\n            return true;\n        }\n        if (!thing) {\n            return false;\n        }\n        return NotebookRange.isNotebookRange(thing)\n            && Array.isArray(thing.newCells);\n    }\n    static replaceCells(range, newCells) {\n        return ( new NotebookEdit_1(range, newCells));\n    }\n    static insertCells(index, newCells) {\n        return ( new NotebookEdit_1(( new NotebookRange(index, index)), newCells));\n    }\n    static deleteCells(range) {\n        return ( new NotebookEdit_1(range, []));\n    }\n    static updateCellMetadata(index, newMetadata) {\n        const edit = ( new NotebookEdit_1(( new NotebookRange(index, index)), []));\n        edit.newCellMetadata = newMetadata;\n        return edit;\n    }\n    static updateNotebookMetadata(newMetadata) {\n        const edit = ( new NotebookEdit_1(( new NotebookRange(0, 0)), []));\n        edit.newNotebookMetadata = newMetadata;\n        return edit;\n    }\n    constructor(range, newCells) {\n        this.range = range;\n        this.newCells = newCells;\n    }\n};\nNotebookEdit = NotebookEdit_1 = ( __decorate([\n    es5ClassCompat\n], NotebookEdit));\nclass SnippetTextEdit {\n    static isSnippetTextEdit(thing) {\n        if (thing instanceof SnippetTextEdit) {\n            return true;\n        }\n        if (!thing) {\n            return false;\n        }\n        return Range.isRange(thing.range)\n            && SnippetString.isSnippetString(thing.snippet);\n    }\n    static replace(range, snippet) {\n        return ( new SnippetTextEdit(range, snippet));\n    }\n    static insert(position, snippet) {\n        return SnippetTextEdit.replace(( new Range(position, position)), snippet);\n    }\n    constructor(range, snippet) {\n        this.range = range;\n        this.snippet = snippet;\n    }\n}\nlet WorkspaceEdit = class WorkspaceEdit {\n    constructor() {\n        this._edits = [];\n    }\n    _allEntries() {\n        return this._edits;\n    }\n    renameFile(from, to, options, metadata) {\n        this._edits.push({ _type: 1 , from, to, options, metadata });\n    }\n    createFile(uri, options, metadata) {\n        this._edits.push({ _type: 1 , from: undefined, to: uri, options, metadata });\n    }\n    deleteFile(uri, options, metadata) {\n        this._edits.push({ _type: 1 , from: uri, to: undefined, options, metadata });\n    }\n    replaceNotebookMetadata(uri, value, metadata) {\n        this._edits.push({ _type: 3 , metadata, uri, edit: { editType: 5 , metadata: value }, notebookMetadata: value });\n    }\n    replaceNotebookCells(uri, startOrRange, cellData, metadata) {\n        const start = startOrRange.start;\n        const end = startOrRange.end;\n        if (start !== end || cellData.length > 0) {\n            this._edits.push({ _type: 5 , uri, index: start, count: end - start, cells: cellData, metadata });\n        }\n    }\n    replaceNotebookCellMetadata(uri, index, cellMetadata, metadata) {\n        this._edits.push({ _type: 3 , metadata, uri, edit: { editType: 3 , index, metadata: cellMetadata } });\n    }\n    replace(uri, range, newText, metadata) {\n        this._edits.push({ _type: 2 , uri, edit: ( new TextEdit(range, newText)), metadata });\n    }\n    insert(resource, position, newText, metadata) {\n        this.replace(resource, ( new Range(position, position)), newText, metadata);\n    }\n    delete(resource, range, metadata) {\n        this.replace(resource, range, '', metadata);\n    }\n    has(uri) {\n        return ( this._edits.some(edit => edit._type === 2  && ( edit.uri.toString()) === ( uri.toString())));\n    }\n    set(uri, edits) {\n        if (!edits) {\n            for (let i = 0; i < this._edits.length; i++) {\n                const element = this._edits[i];\n                switch (element._type) {\n                    case 2 :\n                    case 6 :\n                    case 3 :\n                    case 5 :\n                        if (( element.uri.toString()) === ( uri.toString())) {\n                            this._edits[i] = undefined;\n                        }\n                        break;\n                }\n            }\n            coalesceInPlace(this._edits);\n        }\n        else {\n            for (const editOrTuple of edits) {\n                if (!editOrTuple) {\n                    continue;\n                }\n                let edit;\n                let metadata;\n                if (Array.isArray(editOrTuple)) {\n                    edit = editOrTuple[0];\n                    metadata = editOrTuple[1];\n                }\n                else {\n                    edit = editOrTuple;\n                }\n                if (NotebookEdit.isNotebookCellEdit(edit)) {\n                    if (edit.newCellMetadata) {\n                        this.replaceNotebookCellMetadata(uri, edit.range.start, edit.newCellMetadata, metadata);\n                    }\n                    else if (edit.newNotebookMetadata) {\n                        this.replaceNotebookMetadata(uri, edit.newNotebookMetadata, metadata);\n                    }\n                    else {\n                        this.replaceNotebookCells(uri, edit.range, edit.newCells, metadata);\n                    }\n                }\n                else if (SnippetTextEdit.isSnippetTextEdit(edit)) {\n                    this._edits.push({ _type: 6 , uri, range: edit.range, edit: edit.snippet, metadata });\n                }\n                else {\n                    this._edits.push({ _type: 2 , uri, edit, metadata });\n                }\n            }\n        }\n    }\n    get(uri) {\n        const res = [];\n        for (const candidate of this._edits) {\n            if (candidate._type === 2  && ( candidate.uri.toString()) === ( uri.toString())) {\n                res.push(candidate.edit);\n            }\n        }\n        return res;\n    }\n    entries() {\n        const textEdits = ( new ResourceMap());\n        for (const candidate of this._edits) {\n            if (candidate._type === 2 ) {\n                let textEdit = textEdits.get(candidate.uri);\n                if (!textEdit) {\n                    textEdit = [candidate.uri, []];\n                    textEdits.set(candidate.uri, textEdit);\n                }\n                textEdit[1].push(candidate.edit);\n            }\n        }\n        return [...( textEdits.values())];\n    }\n    get size() {\n        return this.entries().length;\n    }\n    toJSON() {\n        return this.entries();\n    }\n};\nWorkspaceEdit = ( __decorate([\n    es5ClassCompat\n], WorkspaceEdit));\nlet SnippetString = SnippetString_1 = class SnippetString {\n    static isSnippetString(thing) {\n        if (thing instanceof SnippetString_1) {\n            return true;\n        }\n        if (!thing) {\n            return false;\n        }\n        return typeof thing.value === 'string';\n    }\n    static _escape(value) {\n        return value.replace(/\\$|}|\\\\/g, '\\\\$&');\n    }\n    constructor(value) {\n        this._tabstop = 1;\n        this.value = value || '';\n    }\n    appendText(string) {\n        this.value += SnippetString_1._escape(string);\n        return this;\n    }\n    appendTabstop(number = this._tabstop++) {\n        this.value += '$';\n        this.value += number;\n        return this;\n    }\n    appendPlaceholder(value, number = this._tabstop++) {\n        if (typeof value === 'function') {\n            const nested = ( new SnippetString_1());\n            nested._tabstop = this._tabstop;\n            value(nested);\n            this._tabstop = nested._tabstop;\n            value = nested.value;\n        }\n        else {\n            value = SnippetString_1._escape(value);\n        }\n        this.value += '${';\n        this.value += number;\n        this.value += ':';\n        this.value += value;\n        this.value += '}';\n        return this;\n    }\n    appendChoice(values, number = this._tabstop++) {\n        const value = ( values.map(s => s.replaceAll(/[|\\\\,]/g, '\\\\$&'))).join(',');\n        this.value += '${';\n        this.value += number;\n        this.value += '|';\n        this.value += value;\n        this.value += '|}';\n        return this;\n    }\n    appendVariable(name, defaultValue) {\n        if (typeof defaultValue === 'function') {\n            const nested = ( new SnippetString_1());\n            nested._tabstop = this._tabstop;\n            defaultValue(nested);\n            this._tabstop = nested._tabstop;\n            defaultValue = nested.value;\n        }\n        else if (typeof defaultValue === 'string') {\n            defaultValue = defaultValue.replace(/\\$|}/g, '\\\\$&');\n        }\n        this.value += '${';\n        this.value += name;\n        if (defaultValue) {\n            this.value += ':';\n            this.value += defaultValue;\n        }\n        this.value += '}';\n        return this;\n    }\n};\nSnippetString = SnippetString_1 = ( __decorate([\n    es5ClassCompat\n], SnippetString));\nvar DiagnosticTag;\n( (function(DiagnosticTag) {\n    DiagnosticTag[DiagnosticTag[\"Unnecessary\"] = 1] = \"Unnecessary\";\n    DiagnosticTag[DiagnosticTag[\"Deprecated\"] = 2] = \"Deprecated\";\n})(DiagnosticTag || (DiagnosticTag = {})));\nvar DiagnosticSeverity;\n( (function(DiagnosticSeverity) {\n    DiagnosticSeverity[DiagnosticSeverity[\"Hint\"] = 3] = \"Hint\";\n    DiagnosticSeverity[DiagnosticSeverity[\"Information\"] = 2] = \"Information\";\n    DiagnosticSeverity[DiagnosticSeverity[\"Warning\"] = 1] = \"Warning\";\n    DiagnosticSeverity[DiagnosticSeverity[\"Error\"] = 0] = \"Error\";\n})(DiagnosticSeverity || (DiagnosticSeverity = {})));\nlet Location = Location_1 = class Location {\n    static isLocation(thing) {\n        if (thing instanceof Location_1) {\n            return true;\n        }\n        if (!thing) {\n            return false;\n        }\n        return Range.isRange(thing.range)\n            && URI.isUri(thing.uri);\n    }\n    constructor(uri, rangeOrPosition) {\n        this.uri = uri;\n        if (!rangeOrPosition) ;\n        else if (Range.isRange(rangeOrPosition)) {\n            this.range = Range.of(rangeOrPosition);\n        }\n        else if (Position.isPosition(rangeOrPosition)) {\n            this.range = ( new Range(rangeOrPosition, rangeOrPosition));\n        }\n        else {\n            throw ( new Error('Illegal argument'));\n        }\n    }\n    toJSON() {\n        return {\n            uri: this.uri,\n            range: this.range\n        };\n    }\n};\nLocation = Location_1 = ( __decorate([\n    es5ClassCompat\n], Location));\nlet DiagnosticRelatedInformation = class DiagnosticRelatedInformation {\n    static is(thing) {\n        if (!thing) {\n            return false;\n        }\n        return typeof thing.message === 'string'\n            && thing.location\n            && Range.isRange(thing.location.range)\n            && URI.isUri(thing.location.uri);\n    }\n    constructor(location, message) {\n        this.location = location;\n        this.message = message;\n    }\n    static isEqual(a, b) {\n        if (a === b) {\n            return true;\n        }\n        if (!a || !b) {\n            return false;\n        }\n        return a.message === b.message\n            && a.location.range.isEqual(b.location.range)\n            && ( a.location.uri.toString()) === ( b.location.uri.toString());\n    }\n};\nDiagnosticRelatedInformation = ( __decorate([\n    es5ClassCompat\n], DiagnosticRelatedInformation));\nlet Diagnostic = class Diagnostic {\n    constructor(range, message, severity = DiagnosticSeverity.Error) {\n        if (!Range.isRange(range)) {\n            throw ( new TypeError('range must be set'));\n        }\n        if (!message) {\n            throw ( new TypeError('message must be set'));\n        }\n        this.range = range;\n        this.message = message;\n        this.severity = severity;\n    }\n    toJSON() {\n        return {\n            severity: DiagnosticSeverity[this.severity],\n            message: this.message,\n            range: this.range,\n            source: this.source,\n            code: this.code,\n        };\n    }\n    static isEqual(a, b) {\n        if (a === b) {\n            return true;\n        }\n        if (!a || !b) {\n            return false;\n        }\n        return a.message === b.message\n            && a.severity === b.severity\n            && a.code === b.code\n            && a.severity === b.severity\n            && a.source === b.source\n            && a.range.isEqual(b.range)\n            && equals(a.tags, b.tags)\n            && equals(a.relatedInformation, b.relatedInformation, DiagnosticRelatedInformation.isEqual);\n    }\n};\nDiagnostic = ( __decorate([\n    es5ClassCompat\n], Diagnostic));\nlet Hover = class Hover {\n    constructor(contents, range) {\n        if (!contents) {\n            throw ( new Error('Illegal argument, contents must be defined'));\n        }\n        if (Array.isArray(contents)) {\n            this.contents = contents;\n        }\n        else {\n            this.contents = [contents];\n        }\n        this.range = range;\n    }\n};\nHover = ( __decorate([\n    es5ClassCompat\n], Hover));\nlet VerboseHover = class VerboseHover extends Hover {\n    constructor(contents, range, canIncreaseVerbosity, canDecreaseVerbosity) {\n        super(contents, range);\n        this.canIncreaseVerbosity = canIncreaseVerbosity;\n        this.canDecreaseVerbosity = canDecreaseVerbosity;\n    }\n};\nVerboseHover = ( __decorate([\n    es5ClassCompat\n], VerboseHover));\nvar HoverVerbosityAction;\n( (function(HoverVerbosityAction) {\n    HoverVerbosityAction[HoverVerbosityAction[\"Increase\"] = 0] = \"Increase\";\n    HoverVerbosityAction[HoverVerbosityAction[\"Decrease\"] = 1] = \"Decrease\";\n})(HoverVerbosityAction || (HoverVerbosityAction = {})));\nvar DocumentHighlightKind;\n( (function(DocumentHighlightKind) {\n    DocumentHighlightKind[DocumentHighlightKind[\"Text\"] = 0] = \"Text\";\n    DocumentHighlightKind[DocumentHighlightKind[\"Read\"] = 1] = \"Read\";\n    DocumentHighlightKind[DocumentHighlightKind[\"Write\"] = 2] = \"Write\";\n})(DocumentHighlightKind || (DocumentHighlightKind = {})));\nlet DocumentHighlight = class DocumentHighlight {\n    constructor(range, kind = DocumentHighlightKind.Text) {\n        this.range = range;\n        this.kind = kind;\n    }\n    toJSON() {\n        return {\n            range: this.range,\n            kind: DocumentHighlightKind[this.kind]\n        };\n    }\n};\nDocumentHighlight = ( __decorate([\n    es5ClassCompat\n], DocumentHighlight));\nlet MultiDocumentHighlight = class MultiDocumentHighlight {\n    constructor(uri, highlights) {\n        this.uri = uri;\n        this.highlights = highlights;\n    }\n    toJSON() {\n        return {\n            uri: this.uri,\n            highlights: ( this.highlights.map(h => h.toJSON()))\n        };\n    }\n};\nMultiDocumentHighlight = ( __decorate([\n    es5ClassCompat\n], MultiDocumentHighlight));\nvar SymbolKind;\n( (function(SymbolKind) {\n    SymbolKind[SymbolKind[\"File\"] = 0] = \"File\";\n    SymbolKind[SymbolKind[\"Module\"] = 1] = \"Module\";\n    SymbolKind[SymbolKind[\"Namespace\"] = 2] = \"Namespace\";\n    SymbolKind[SymbolKind[\"Package\"] = 3] = \"Package\";\n    SymbolKind[SymbolKind[\"Class\"] = 4] = \"Class\";\n    SymbolKind[SymbolKind[\"Method\"] = 5] = \"Method\";\n    SymbolKind[SymbolKind[\"Property\"] = 6] = \"Property\";\n    SymbolKind[SymbolKind[\"Field\"] = 7] = \"Field\";\n    SymbolKind[SymbolKind[\"Constructor\"] = 8] = \"Constructor\";\n    SymbolKind[SymbolKind[\"Enum\"] = 9] = \"Enum\";\n    SymbolKind[SymbolKind[\"Interface\"] = 10] = \"Interface\";\n    SymbolKind[SymbolKind[\"Function\"] = 11] = \"Function\";\n    SymbolKind[SymbolKind[\"Variable\"] = 12] = \"Variable\";\n    SymbolKind[SymbolKind[\"Constant\"] = 13] = \"Constant\";\n    SymbolKind[SymbolKind[\"String\"] = 14] = \"String\";\n    SymbolKind[SymbolKind[\"Number\"] = 15] = \"Number\";\n    SymbolKind[SymbolKind[\"Boolean\"] = 16] = \"Boolean\";\n    SymbolKind[SymbolKind[\"Array\"] = 17] = \"Array\";\n    SymbolKind[SymbolKind[\"Object\"] = 18] = \"Object\";\n    SymbolKind[SymbolKind[\"Key\"] = 19] = \"Key\";\n    SymbolKind[SymbolKind[\"Null\"] = 20] = \"Null\";\n    SymbolKind[SymbolKind[\"EnumMember\"] = 21] = \"EnumMember\";\n    SymbolKind[SymbolKind[\"Struct\"] = 22] = \"Struct\";\n    SymbolKind[SymbolKind[\"Event\"] = 23] = \"Event\";\n    SymbolKind[SymbolKind[\"Operator\"] = 24] = \"Operator\";\n    SymbolKind[SymbolKind[\"TypeParameter\"] = 25] = \"TypeParameter\";\n})(SymbolKind || (SymbolKind = {})));\nvar SymbolTag;\n( (function(SymbolTag) {\n    SymbolTag[SymbolTag[\"Deprecated\"] = 1] = \"Deprecated\";\n})(SymbolTag || (SymbolTag = {})));\nlet SymbolInformation = SymbolInformation_1 = class SymbolInformation {\n    static validate(candidate) {\n        if (!candidate.name) {\n            throw ( new Error('name must not be falsy'));\n        }\n    }\n    constructor(name, kind, rangeOrContainer, locationOrUri, containerName) {\n        this.name = name;\n        this.kind = kind;\n        this.containerName = containerName;\n        if (typeof rangeOrContainer === 'string') {\n            this.containerName = rangeOrContainer;\n        }\n        if (locationOrUri instanceof Location) {\n            this.location = locationOrUri;\n        }\n        else if (rangeOrContainer instanceof Range) {\n            this.location = ( new Location(locationOrUri, rangeOrContainer));\n        }\n        SymbolInformation_1.validate(this);\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            kind: SymbolKind[this.kind],\n            location: this.location,\n            containerName: this.containerName\n        };\n    }\n};\nSymbolInformation = SymbolInformation_1 = ( __decorate([\n    es5ClassCompat\n], SymbolInformation));\nlet DocumentSymbol = DocumentSymbol_1 = class DocumentSymbol {\n    static validate(candidate) {\n        if (!candidate.name) {\n            throw ( new Error('name must not be falsy'));\n        }\n        if (!candidate.range.contains(candidate.selectionRange)) {\n            throw ( new Error('selectionRange must be contained in fullRange'));\n        }\n        candidate.children?.forEach(DocumentSymbol_1.validate);\n    }\n    constructor(name, detail, kind, range, selectionRange) {\n        this.name = name;\n        this.detail = detail;\n        this.kind = kind;\n        this.range = range;\n        this.selectionRange = selectionRange;\n        this.children = [];\n        DocumentSymbol_1.validate(this);\n    }\n};\nDocumentSymbol = DocumentSymbol_1 = ( __decorate([\n    es5ClassCompat\n], DocumentSymbol));\nvar CodeActionTriggerKind;\n( (function(CodeActionTriggerKind) {\n    CodeActionTriggerKind[CodeActionTriggerKind[\"Invoke\"] = 1] = \"Invoke\";\n    CodeActionTriggerKind[CodeActionTriggerKind[\"Automatic\"] = 2] = \"Automatic\";\n})(CodeActionTriggerKind || (CodeActionTriggerKind = {})));\nlet CodeAction = class CodeAction {\n    constructor(title, kind) {\n        this.title = title;\n        this.kind = kind;\n    }\n};\nCodeAction = ( __decorate([\n    es5ClassCompat\n], CodeAction));\nlet CodeActionKind = class CodeActionKind {\n    static { CodeActionKind_1 = this; }\n    static { this.sep = '.'; }\n    constructor(value) {\n        this.value = value;\n    }\n    append(parts) {\n        return ( new CodeActionKind_1(this.value ? this.value + CodeActionKind_1.sep + parts : parts));\n    }\n    intersects(other) {\n        return this.contains(other) || other.contains(this);\n    }\n    contains(other) {\n        return this.value === other.value || other.value.startsWith(this.value + CodeActionKind_1.sep);\n    }\n};\nCodeActionKind = CodeActionKind_1 = ( __decorate([\n    es5ClassCompat\n], CodeActionKind));\nCodeActionKind.Empty = ( new CodeActionKind(''));\nCodeActionKind.QuickFix = CodeActionKind.Empty.append('quickfix');\nCodeActionKind.Refactor = CodeActionKind.Empty.append('refactor');\nCodeActionKind.RefactorExtract = CodeActionKind.Refactor.append('extract');\nCodeActionKind.RefactorInline = CodeActionKind.Refactor.append('inline');\nCodeActionKind.RefactorMove = CodeActionKind.Refactor.append('move');\nCodeActionKind.RefactorRewrite = CodeActionKind.Refactor.append('rewrite');\nCodeActionKind.Source = CodeActionKind.Empty.append('source');\nCodeActionKind.SourceOrganizeImports = CodeActionKind.Source.append('organizeImports');\nCodeActionKind.SourceFixAll = CodeActionKind.Source.append('fixAll');\nCodeActionKind.Notebook = CodeActionKind.Empty.append('notebook');\nlet SelectionRange = class SelectionRange {\n    constructor(range, parent) {\n        this.range = range;\n        this.parent = parent;\n        if (parent && !parent.range.contains(this.range)) {\n            throw ( new Error('Invalid argument: parent must contain this range'));\n        }\n    }\n};\nSelectionRange = ( __decorate([\n    es5ClassCompat\n], SelectionRange));\nclass CallHierarchyItem {\n    constructor(kind, name, detail, uri, range, selectionRange) {\n        this.kind = kind;\n        this.name = name;\n        this.detail = detail;\n        this.uri = uri;\n        this.range = range;\n        this.selectionRange = selectionRange;\n    }\n}\nclass CallHierarchyIncomingCall {\n    constructor(item, fromRanges) {\n        this.fromRanges = fromRanges;\n        this.from = item;\n    }\n}\nclass CallHierarchyOutgoingCall {\n    constructor(item, fromRanges) {\n        this.fromRanges = fromRanges;\n        this.to = item;\n    }\n}\nvar LanguageStatusSeverity;\n( (function(LanguageStatusSeverity) {\n    LanguageStatusSeverity[LanguageStatusSeverity[\"Information\"] = 0] = \"Information\";\n    LanguageStatusSeverity[LanguageStatusSeverity[\"Warning\"] = 1] = \"Warning\";\n    LanguageStatusSeverity[LanguageStatusSeverity[\"Error\"] = 2] = \"Error\";\n})(LanguageStatusSeverity || (LanguageStatusSeverity = {})));\nlet CodeLens = class CodeLens {\n    constructor(range, command) {\n        this.range = range;\n        this.command = command;\n    }\n    get isResolved() {\n        return !!this.command;\n    }\n};\nCodeLens = ( __decorate([\n    es5ClassCompat\n], CodeLens));\nlet MarkdownString = MarkdownString_1 = class MarkdownString {\n    #delegate;\n    static isMarkdownString(thing) {\n        if (thing instanceof MarkdownString_1) {\n            return true;\n        }\n        return thing && thing.appendCodeblock && thing.appendMarkdown && thing.appendText && (thing.value !== undefined);\n    }\n    constructor(value, supportThemeIcons = false) {\n        this.#delegate = ( new MarkdownString$1(value, { supportThemeIcons }));\n    }\n    get value() {\n        return this.#delegate.value;\n    }\n    set value(value) {\n        this.#delegate.value = value;\n    }\n    get isTrusted() {\n        return this.#delegate.isTrusted;\n    }\n    set isTrusted(value) {\n        this.#delegate.isTrusted = value;\n    }\n    get supportThemeIcons() {\n        return this.#delegate.supportThemeIcons;\n    }\n    set supportThemeIcons(value) {\n        this.#delegate.supportThemeIcons = value;\n    }\n    get supportHtml() {\n        return this.#delegate.supportHtml;\n    }\n    set supportHtml(value) {\n        this.#delegate.supportHtml = value;\n    }\n    get baseUri() {\n        return this.#delegate.baseUri;\n    }\n    set baseUri(value) {\n        this.#delegate.baseUri = value;\n    }\n    appendText(value) {\n        this.#delegate.appendText(value);\n        return this;\n    }\n    appendMarkdown(value) {\n        this.#delegate.appendMarkdown(value);\n        return this;\n    }\n    appendCodeblock(value, language) {\n        this.#delegate.appendCodeblock(language ?? '', value);\n        return this;\n    }\n};\nMarkdownString = MarkdownString_1 = ( __decorate([\n    es5ClassCompat\n], MarkdownString));\nlet ParameterInformation = class ParameterInformation {\n    constructor(label, documentation) {\n        this.label = label;\n        this.documentation = documentation;\n    }\n};\nParameterInformation = ( __decorate([\n    es5ClassCompat\n], ParameterInformation));\nlet SignatureInformation = class SignatureInformation {\n    constructor(label, documentation) {\n        this.label = label;\n        this.documentation = documentation;\n        this.parameters = [];\n    }\n};\nSignatureInformation = ( __decorate([\n    es5ClassCompat\n], SignatureInformation));\nlet SignatureHelp = class SignatureHelp {\n    constructor() {\n        this.activeSignature = 0;\n        this.activeParameter = 0;\n        this.signatures = [];\n    }\n};\nSignatureHelp = ( __decorate([\n    es5ClassCompat\n], SignatureHelp));\nvar SignatureHelpTriggerKind;\n( (function(SignatureHelpTriggerKind) {\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"Invoke\"] = 1] = \"Invoke\";\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"TriggerCharacter\"] = 2] = \"TriggerCharacter\";\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"ContentChange\"] = 3] = \"ContentChange\";\n})(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {})));\nvar InlayHintKind;\n( (function(InlayHintKind) {\n    InlayHintKind[InlayHintKind[\"Type\"] = 1] = \"Type\";\n    InlayHintKind[InlayHintKind[\"Parameter\"] = 2] = \"Parameter\";\n})(InlayHintKind || (InlayHintKind = {})));\nlet InlayHintLabelPart = class InlayHintLabelPart {\n    constructor(value) {\n        this.value = value;\n    }\n};\nInlayHintLabelPart = ( __decorate([\n    es5ClassCompat\n], InlayHintLabelPart));\nlet InlayHint = class InlayHint {\n    constructor(position, label, kind) {\n        this.position = position;\n        this.label = label;\n        this.kind = kind;\n    }\n};\nInlayHint = ( __decorate([\n    es5ClassCompat\n], InlayHint));\nvar CompletionTriggerKind;\n( (function(CompletionTriggerKind) {\n    CompletionTriggerKind[CompletionTriggerKind[\"Invoke\"] = 0] = \"Invoke\";\n    CompletionTriggerKind[CompletionTriggerKind[\"TriggerCharacter\"] = 1] = \"TriggerCharacter\";\n    CompletionTriggerKind[CompletionTriggerKind[\"TriggerForIncompleteCompletions\"] = 2] = \"TriggerForIncompleteCompletions\";\n})(CompletionTriggerKind || (CompletionTriggerKind = {})));\nvar CompletionItemKind;\n( (function(CompletionItemKind) {\n    CompletionItemKind[CompletionItemKind[\"Text\"] = 0] = \"Text\";\n    CompletionItemKind[CompletionItemKind[\"Method\"] = 1] = \"Method\";\n    CompletionItemKind[CompletionItemKind[\"Function\"] = 2] = \"Function\";\n    CompletionItemKind[CompletionItemKind[\"Constructor\"] = 3] = \"Constructor\";\n    CompletionItemKind[CompletionItemKind[\"Field\"] = 4] = \"Field\";\n    CompletionItemKind[CompletionItemKind[\"Variable\"] = 5] = \"Variable\";\n    CompletionItemKind[CompletionItemKind[\"Class\"] = 6] = \"Class\";\n    CompletionItemKind[CompletionItemKind[\"Interface\"] = 7] = \"Interface\";\n    CompletionItemKind[CompletionItemKind[\"Module\"] = 8] = \"Module\";\n    CompletionItemKind[CompletionItemKind[\"Property\"] = 9] = \"Property\";\n    CompletionItemKind[CompletionItemKind[\"Unit\"] = 10] = \"Unit\";\n    CompletionItemKind[CompletionItemKind[\"Value\"] = 11] = \"Value\";\n    CompletionItemKind[CompletionItemKind[\"Enum\"] = 12] = \"Enum\";\n    CompletionItemKind[CompletionItemKind[\"Keyword\"] = 13] = \"Keyword\";\n    CompletionItemKind[CompletionItemKind[\"Snippet\"] = 14] = \"Snippet\";\n    CompletionItemKind[CompletionItemKind[\"Color\"] = 15] = \"Color\";\n    CompletionItemKind[CompletionItemKind[\"File\"] = 16] = \"File\";\n    CompletionItemKind[CompletionItemKind[\"Reference\"] = 17] = \"Reference\";\n    CompletionItemKind[CompletionItemKind[\"Folder\"] = 18] = \"Folder\";\n    CompletionItemKind[CompletionItemKind[\"EnumMember\"] = 19] = \"EnumMember\";\n    CompletionItemKind[CompletionItemKind[\"Constant\"] = 20] = \"Constant\";\n    CompletionItemKind[CompletionItemKind[\"Struct\"] = 21] = \"Struct\";\n    CompletionItemKind[CompletionItemKind[\"Event\"] = 22] = \"Event\";\n    CompletionItemKind[CompletionItemKind[\"Operator\"] = 23] = \"Operator\";\n    CompletionItemKind[CompletionItemKind[\"TypeParameter\"] = 24] = \"TypeParameter\";\n    CompletionItemKind[CompletionItemKind[\"User\"] = 25] = \"User\";\n    CompletionItemKind[CompletionItemKind[\"Issue\"] = 26] = \"Issue\";\n})(CompletionItemKind || (CompletionItemKind = {})));\nvar CompletionItemTag;\n( (function(CompletionItemTag) {\n    CompletionItemTag[CompletionItemTag[\"Deprecated\"] = 1] = \"Deprecated\";\n})(CompletionItemTag || (CompletionItemTag = {})));\nlet CompletionItem = class CompletionItem {\n    constructor(label, kind) {\n        this.label = label;\n        this.kind = kind;\n    }\n    toJSON() {\n        return {\n            label: this.label,\n            kind: this.kind && CompletionItemKind[this.kind],\n            detail: this.detail,\n            documentation: this.documentation,\n            sortText: this.sortText,\n            filterText: this.filterText,\n            preselect: this.preselect,\n            insertText: this.insertText,\n            textEdit: this.textEdit\n        };\n    }\n};\nCompletionItem = ( __decorate([\n    es5ClassCompat\n], CompletionItem));\nlet CompletionList = class CompletionList {\n    constructor(items = [], isIncomplete = false) {\n        this.items = items;\n        this.isIncomplete = isIncomplete;\n    }\n};\nCompletionList = ( __decorate([\n    es5ClassCompat\n], CompletionList));\nlet InlineSuggestion = class InlineSuggestion {\n    constructor(insertText, range, command) {\n        this.insertText = insertText;\n        this.range = range;\n        this.command = command;\n    }\n};\nInlineSuggestion = ( __decorate([\n    es5ClassCompat\n], InlineSuggestion));\nlet InlineSuggestionList = class InlineSuggestionList {\n    constructor(items) {\n        this.commands = undefined;\n        this.suppressSuggestions = undefined;\n        this.items = items;\n    }\n};\nInlineSuggestionList = ( __decorate([\n    es5ClassCompat\n], InlineSuggestionList));\nvar PartialAcceptTriggerKind;\n( (function(PartialAcceptTriggerKind) {\n    PartialAcceptTriggerKind[PartialAcceptTriggerKind[\"Unknown\"] = 0] = \"Unknown\";\n    PartialAcceptTriggerKind[PartialAcceptTriggerKind[\"Word\"] = 1] = \"Word\";\n    PartialAcceptTriggerKind[PartialAcceptTriggerKind[\"Line\"] = 2] = \"Line\";\n    PartialAcceptTriggerKind[PartialAcceptTriggerKind[\"Suggest\"] = 3] = \"Suggest\";\n})(PartialAcceptTriggerKind || (PartialAcceptTriggerKind = {})));\nvar ViewColumn;\n( (function(ViewColumn) {\n    ViewColumn[ViewColumn[\"Active\"] = -1] = \"Active\";\n    ViewColumn[ViewColumn[\"Beside\"] = -2] = \"Beside\";\n    ViewColumn[ViewColumn[\"One\"] = 1] = \"One\";\n    ViewColumn[ViewColumn[\"Two\"] = 2] = \"Two\";\n    ViewColumn[ViewColumn[\"Three\"] = 3] = \"Three\";\n    ViewColumn[ViewColumn[\"Four\"] = 4] = \"Four\";\n    ViewColumn[ViewColumn[\"Five\"] = 5] = \"Five\";\n    ViewColumn[ViewColumn[\"Six\"] = 6] = \"Six\";\n    ViewColumn[ViewColumn[\"Seven\"] = 7] = \"Seven\";\n    ViewColumn[ViewColumn[\"Eight\"] = 8] = \"Eight\";\n    ViewColumn[ViewColumn[\"Nine\"] = 9] = \"Nine\";\n})(ViewColumn || (ViewColumn = {})));\nvar StatusBarAlignment;\n( (function(StatusBarAlignment) {\n    StatusBarAlignment[StatusBarAlignment[\"Left\"] = 1] = \"Left\";\n    StatusBarAlignment[StatusBarAlignment[\"Right\"] = 2] = \"Right\";\n})(StatusBarAlignment || (StatusBarAlignment = {})));\nfunction asStatusBarItemIdentifier(extension, id) {\n    return `${ExtensionIdentifier.toKey(extension)}.${id}`;\n}\nvar TextEditorLineNumbersStyle;\n( (function(TextEditorLineNumbersStyle) {\n    TextEditorLineNumbersStyle[TextEditorLineNumbersStyle[\"Off\"] = 0] = \"Off\";\n    TextEditorLineNumbersStyle[TextEditorLineNumbersStyle[\"On\"] = 1] = \"On\";\n    TextEditorLineNumbersStyle[TextEditorLineNumbersStyle[\"Relative\"] = 2] = \"Relative\";\n    TextEditorLineNumbersStyle[TextEditorLineNumbersStyle[\"Interval\"] = 3] = \"Interval\";\n})(TextEditorLineNumbersStyle || (TextEditorLineNumbersStyle = {})));\nvar TextDocumentSaveReason;\n( (function(TextDocumentSaveReason) {\n    TextDocumentSaveReason[TextDocumentSaveReason[\"Manual\"] = 1] = \"Manual\";\n    TextDocumentSaveReason[TextDocumentSaveReason[\"AfterDelay\"] = 2] = \"AfterDelay\";\n    TextDocumentSaveReason[TextDocumentSaveReason[\"FocusOut\"] = 3] = \"FocusOut\";\n})(TextDocumentSaveReason || (TextDocumentSaveReason = {})));\nvar TextEditorRevealType;\n( (function(TextEditorRevealType) {\n    TextEditorRevealType[TextEditorRevealType[\"Default\"] = 0] = \"Default\";\n    TextEditorRevealType[TextEditorRevealType[\"InCenter\"] = 1] = \"InCenter\";\n    TextEditorRevealType[TextEditorRevealType[\"InCenterIfOutsideViewport\"] = 2] = \"InCenterIfOutsideViewport\";\n    TextEditorRevealType[TextEditorRevealType[\"AtTop\"] = 3] = \"AtTop\";\n})(TextEditorRevealType || (TextEditorRevealType = {})));\nvar TextEditorSelectionChangeKind;\n( (function(TextEditorSelectionChangeKind) {\n    TextEditorSelectionChangeKind[TextEditorSelectionChangeKind[\"Keyboard\"] = 1] = \"Keyboard\";\n    TextEditorSelectionChangeKind[TextEditorSelectionChangeKind[\"Mouse\"] = 2] = \"Mouse\";\n    TextEditorSelectionChangeKind[TextEditorSelectionChangeKind[\"Command\"] = 3] = \"Command\";\n})(TextEditorSelectionChangeKind || (TextEditorSelectionChangeKind = {})));\nvar TextDocumentChangeReason;\n( (function(TextDocumentChangeReason) {\n    TextDocumentChangeReason[TextDocumentChangeReason[\"Undo\"] = 1] = \"Undo\";\n    TextDocumentChangeReason[TextDocumentChangeReason[\"Redo\"] = 2] = \"Redo\";\n})(TextDocumentChangeReason || (TextDocumentChangeReason = {})));\nvar DecorationRangeBehavior;\n( (function(DecorationRangeBehavior) {\n    DecorationRangeBehavior[DecorationRangeBehavior[\"OpenOpen\"] = 0] = \"OpenOpen\";\n    DecorationRangeBehavior[DecorationRangeBehavior[\"ClosedClosed\"] = 1] = \"ClosedClosed\";\n    DecorationRangeBehavior[DecorationRangeBehavior[\"OpenClosed\"] = 2] = \"OpenClosed\";\n    DecorationRangeBehavior[DecorationRangeBehavior[\"ClosedOpen\"] = 3] = \"ClosedOpen\";\n})(DecorationRangeBehavior || (DecorationRangeBehavior = {})));\n( (function(TextEditorSelectionChangeKind) {\n    function fromValue(s) {\n        switch (s) {\n            case 'keyboard': return TextEditorSelectionChangeKind.Keyboard;\n            case 'mouse': return TextEditorSelectionChangeKind.Mouse;\n            case 'api': return TextEditorSelectionChangeKind.Command;\n        }\n        return undefined;\n    }\n    TextEditorSelectionChangeKind.fromValue = fromValue;\n})(TextEditorSelectionChangeKind || (TextEditorSelectionChangeKind = {})));\nvar SyntaxTokenType;\n( (function(SyntaxTokenType) {\n    SyntaxTokenType[SyntaxTokenType[\"Other\"] = 0] = \"Other\";\n    SyntaxTokenType[SyntaxTokenType[\"Comment\"] = 1] = \"Comment\";\n    SyntaxTokenType[SyntaxTokenType[\"String\"] = 2] = \"String\";\n    SyntaxTokenType[SyntaxTokenType[\"RegEx\"] = 3] = \"RegEx\";\n})(SyntaxTokenType || (SyntaxTokenType = {})));\n( (function(SyntaxTokenType) {\n    function toString(v) {\n        switch (v) {\n            case SyntaxTokenType.Other: return 'other';\n            case SyntaxTokenType.Comment: return 'comment';\n            case SyntaxTokenType.String: return 'string';\n            case SyntaxTokenType.RegEx: return 'regex';\n        }\n        return 'other';\n    }\n    SyntaxTokenType.toString = toString;\n})(SyntaxTokenType || (SyntaxTokenType = {})));\nlet DocumentLink = class DocumentLink {\n    constructor(range, target) {\n        if (target && !(URI.isUri(target))) {\n            throw illegalArgument('target');\n        }\n        if (!Range.isRange(range) || range.isEmpty) {\n            throw illegalArgument('range');\n        }\n        this.range = range;\n        this.target = target;\n    }\n};\nDocumentLink = ( __decorate([\n    es5ClassCompat\n], DocumentLink));\nlet Color = class Color {\n    constructor(red, green, blue, alpha) {\n        this.red = red;\n        this.green = green;\n        this.blue = blue;\n        this.alpha = alpha;\n    }\n};\nColor = ( __decorate([\n    es5ClassCompat\n], Color));\nlet ColorInformation = class ColorInformation {\n    constructor(range, color) {\n        if (color && !(color instanceof Color)) {\n            throw illegalArgument('color');\n        }\n        if (!Range.isRange(range) || range.isEmpty) {\n            throw illegalArgument('range');\n        }\n        this.range = range;\n        this.color = color;\n    }\n};\nColorInformation = ( __decorate([\n    es5ClassCompat\n], ColorInformation));\nlet ColorPresentation = class ColorPresentation {\n    constructor(label) {\n        if (!label || typeof label !== 'string') {\n            throw illegalArgument('label');\n        }\n        this.label = label;\n    }\n};\nColorPresentation = ( __decorate([\n    es5ClassCompat\n], ColorPresentation));\nvar SourceControlInputBoxValidationType;\n( (function(SourceControlInputBoxValidationType) {\n    SourceControlInputBoxValidationType[SourceControlInputBoxValidationType[\"Error\"] = 0] = \"Error\";\n    SourceControlInputBoxValidationType[SourceControlInputBoxValidationType[\"Warning\"] = 1] = \"Warning\";\n    SourceControlInputBoxValidationType[SourceControlInputBoxValidationType[\"Information\"] = 2] = \"Information\";\n})(\n    SourceControlInputBoxValidationType || (SourceControlInputBoxValidationType = {})\n));\nvar TerminalExitReason;\n( (function(TerminalExitReason) {\n    TerminalExitReason[TerminalExitReason[\"Unknown\"] = 0] = \"Unknown\";\n    TerminalExitReason[TerminalExitReason[\"Shutdown\"] = 1] = \"Shutdown\";\n    TerminalExitReason[TerminalExitReason[\"Process\"] = 2] = \"Process\";\n    TerminalExitReason[TerminalExitReason[\"User\"] = 3] = \"User\";\n    TerminalExitReason[TerminalExitReason[\"Extension\"] = 4] = \"Extension\";\n})(TerminalExitReason || (TerminalExitReason = {})));\nvar TerminalShellExecutionCommandLineConfidence;\n( (function(TerminalShellExecutionCommandLineConfidence) {\n    TerminalShellExecutionCommandLineConfidence[TerminalShellExecutionCommandLineConfidence[\"Low\"] = 0] = \"Low\";\n    TerminalShellExecutionCommandLineConfidence[TerminalShellExecutionCommandLineConfidence[\"Medium\"] = 1] = \"Medium\";\n    TerminalShellExecutionCommandLineConfidence[TerminalShellExecutionCommandLineConfidence[\"High\"] = 2] = \"High\";\n})(\n    TerminalShellExecutionCommandLineConfidence || (TerminalShellExecutionCommandLineConfidence = {})\n));\nclass TerminalLink {\n    constructor(startIndex, length, tooltip) {\n        this.startIndex = startIndex;\n        this.length = length;\n        this.tooltip = tooltip;\n        if (typeof startIndex !== 'number' || startIndex < 0) {\n            throw illegalArgument('startIndex');\n        }\n        if (typeof length !== 'number' || length < 1) {\n            throw illegalArgument('length');\n        }\n        if (tooltip !== undefined && typeof tooltip !== 'string') {\n            throw illegalArgument('tooltip');\n        }\n    }\n}\nclass TerminalQuickFixOpener {\n    constructor(uri) {\n        this.uri = uri;\n    }\n}\nclass TerminalQuickFixCommand {\n    constructor(terminalCommand) {\n        this.terminalCommand = terminalCommand;\n    }\n}\nvar TerminalLocation;\n( (function(TerminalLocation) {\n    TerminalLocation[TerminalLocation[\"Panel\"] = 1] = \"Panel\";\n    TerminalLocation[TerminalLocation[\"Editor\"] = 2] = \"Editor\";\n})(TerminalLocation || (TerminalLocation = {})));\nclass TerminalProfile {\n    constructor(options) {\n        this.options = options;\n        if (typeof options !== 'object') {\n            throw illegalArgument('options');\n        }\n    }\n}\nvar TaskRevealKind;\n( (function(TaskRevealKind) {\n    TaskRevealKind[TaskRevealKind[\"Always\"] = 1] = \"Always\";\n    TaskRevealKind[TaskRevealKind[\"Silent\"] = 2] = \"Silent\";\n    TaskRevealKind[TaskRevealKind[\"Never\"] = 3] = \"Never\";\n})(TaskRevealKind || (TaskRevealKind = {})));\nvar TaskPanelKind;\n( (function(TaskPanelKind) {\n    TaskPanelKind[TaskPanelKind[\"Shared\"] = 1] = \"Shared\";\n    TaskPanelKind[TaskPanelKind[\"Dedicated\"] = 2] = \"Dedicated\";\n    TaskPanelKind[TaskPanelKind[\"New\"] = 3] = \"New\";\n})(TaskPanelKind || (TaskPanelKind = {})));\nlet TaskGroup = class TaskGroup {\n    static { TaskGroup_1 = this; }\n    static { this.Clean = ( new TaskGroup_1('clean', 'Clean')); }\n    static { this.Build = ( new TaskGroup_1('build', 'Build')); }\n    static { this.Rebuild = ( new TaskGroup_1('rebuild', 'Rebuild')); }\n    static { this.Test = ( new TaskGroup_1('test', 'Test')); }\n    static from(value) {\n        switch (value) {\n            case 'clean':\n                return TaskGroup_1.Clean;\n            case 'build':\n                return TaskGroup_1.Build;\n            case 'rebuild':\n                return TaskGroup_1.Rebuild;\n            case 'test':\n                return TaskGroup_1.Test;\n            default:\n                return undefined;\n        }\n    }\n    constructor(id, label) {\n        this.label = label;\n        if (typeof id !== 'string') {\n            throw illegalArgument('name');\n        }\n        if (typeof label !== 'string') {\n            throw illegalArgument('name');\n        }\n        this._id = id;\n    }\n    get id() {\n        return this._id;\n    }\n};\nTaskGroup = TaskGroup_1 = ( __decorate([\n    es5ClassCompat\n], TaskGroup));\nfunction computeTaskExecutionId(values) {\n    let id = '';\n    for (let i = 0; i < values.length; i++) {\n        id += values[i].replace(/,/g, ',,') + ',';\n    }\n    return id;\n}\nlet ProcessExecution = class ProcessExecution {\n    constructor(process, varg1, varg2) {\n        if (typeof process !== 'string') {\n            throw illegalArgument('process');\n        }\n        this._args = [];\n        this._process = process;\n        if (varg1 !== undefined) {\n            if (Array.isArray(varg1)) {\n                this._args = varg1;\n                this._options = varg2;\n            }\n            else {\n                this._options = varg1;\n            }\n        }\n    }\n    get process() {\n        return this._process;\n    }\n    set process(value) {\n        if (typeof value !== 'string') {\n            throw illegalArgument('process');\n        }\n        this._process = value;\n    }\n    get args() {\n        return this._args;\n    }\n    set args(value) {\n        if (!Array.isArray(value)) {\n            value = [];\n        }\n        this._args = value;\n    }\n    get options() {\n        return this._options;\n    }\n    set options(value) {\n        this._options = value;\n    }\n    computeId() {\n        const props = [];\n        props.push('process');\n        if (this._process !== undefined) {\n            props.push(this._process);\n        }\n        if (this._args && this._args.length > 0) {\n            for (const arg of this._args) {\n                props.push(arg);\n            }\n        }\n        return computeTaskExecutionId(props);\n    }\n};\nProcessExecution = ( __decorate([\n    es5ClassCompat\n], ProcessExecution));\nlet ShellExecution = class ShellExecution {\n    constructor(arg0, arg1, arg2) {\n        this._args = [];\n        if (Array.isArray(arg1)) {\n            if (!arg0) {\n                throw illegalArgument('command can\\'t be undefined or null');\n            }\n            if (typeof arg0 !== 'string' && typeof arg0.value !== 'string') {\n                throw illegalArgument('command');\n            }\n            this._command = arg0;\n            this._args = arg1;\n            this._options = arg2;\n        }\n        else {\n            if (typeof arg0 !== 'string') {\n                throw illegalArgument('commandLine');\n            }\n            this._commandLine = arg0;\n            this._options = arg1;\n        }\n    }\n    get commandLine() {\n        return this._commandLine;\n    }\n    set commandLine(value) {\n        if (typeof value !== 'string') {\n            throw illegalArgument('commandLine');\n        }\n        this._commandLine = value;\n    }\n    get command() {\n        return this._command ? this._command : '';\n    }\n    set command(value) {\n        if (typeof value !== 'string' && typeof value.value !== 'string') {\n            throw illegalArgument('command');\n        }\n        this._command = value;\n    }\n    get args() {\n        return this._args;\n    }\n    set args(value) {\n        this._args = value || [];\n    }\n    get options() {\n        return this._options;\n    }\n    set options(value) {\n        this._options = value;\n    }\n    computeId() {\n        const props = [];\n        props.push('shell');\n        if (this._commandLine !== undefined) {\n            props.push(this._commandLine);\n        }\n        if (this._command !== undefined) {\n            props.push(typeof this._command === 'string' ? this._command : this._command.value);\n        }\n        if (this._args && this._args.length > 0) {\n            for (const arg of this._args) {\n                props.push(typeof arg === 'string' ? arg : arg.value);\n            }\n        }\n        return computeTaskExecutionId(props);\n    }\n};\nShellExecution = ( __decorate([\n    es5ClassCompat\n], ShellExecution));\nvar ShellQuoting;\n( (function(ShellQuoting) {\n    ShellQuoting[ShellQuoting[\"Escape\"] = 1] = \"Escape\";\n    ShellQuoting[ShellQuoting[\"Strong\"] = 2] = \"Strong\";\n    ShellQuoting[ShellQuoting[\"Weak\"] = 3] = \"Weak\";\n})(ShellQuoting || (ShellQuoting = {})));\nvar TaskScope;\n( (function(TaskScope) {\n    TaskScope[TaskScope[\"Global\"] = 1] = \"Global\";\n    TaskScope[TaskScope[\"Workspace\"] = 2] = \"Workspace\";\n})(TaskScope || (TaskScope = {})));\nclass CustomExecution {\n    constructor(callback) {\n        this._callback = callback;\n    }\n    computeId() {\n        return 'customExecution' + generateUuid();\n    }\n    set callback(value) {\n        this._callback = value;\n    }\n    get callback() {\n        return this._callback;\n    }\n}\nlet Task = class Task {\n    static { Task_1 = this; }\n    static { this.ExtensionCallbackType = 'customExecution'; }\n    static { this.ProcessType = 'process'; }\n    static { this.ShellType = 'shell'; }\n    static { this.EmptyType = '$empty'; }\n    constructor(definition, arg2, arg3, arg4, arg5, arg6) {\n        this.__deprecated = false;\n        this._definition = this.definition = definition;\n        let problemMatchers;\n        if (typeof arg2 === 'string') {\n            this._name = this.name = arg2;\n            this._source = this.source = arg3;\n            this.execution = arg4;\n            problemMatchers = arg5;\n            this.__deprecated = true;\n        }\n        else if (arg2 === TaskScope.Global || arg2 === TaskScope.Workspace) {\n            this.target = arg2;\n            this._name = this.name = arg3;\n            this._source = this.source = arg4;\n            this.execution = arg5;\n            problemMatchers = arg6;\n        }\n        else {\n            this.target = arg2;\n            this._name = this.name = arg3;\n            this._source = this.source = arg4;\n            this.execution = arg5;\n            problemMatchers = arg6;\n        }\n        if (typeof problemMatchers === 'string') {\n            this._problemMatchers = [problemMatchers];\n            this._hasDefinedMatchers = true;\n        }\n        else if (Array.isArray(problemMatchers)) {\n            this._problemMatchers = problemMatchers;\n            this._hasDefinedMatchers = true;\n        }\n        else {\n            this._problemMatchers = [];\n            this._hasDefinedMatchers = false;\n        }\n        this._isBackground = false;\n        this._presentationOptions = Object.create(null);\n        this._runOptions = Object.create(null);\n    }\n    get _id() {\n        return this.__id;\n    }\n    set _id(value) {\n        this.__id = value;\n    }\n    get _deprecated() {\n        return this.__deprecated;\n    }\n    clear() {\n        if (this.__id === undefined) {\n            return;\n        }\n        this.__id = undefined;\n        this._scope = undefined;\n        this.computeDefinitionBasedOnExecution();\n    }\n    computeDefinitionBasedOnExecution() {\n        if (this._execution instanceof ProcessExecution) {\n            this._definition = {\n                type: Task_1.ProcessType,\n                id: this._execution.computeId()\n            };\n        }\n        else if (this._execution instanceof ShellExecution) {\n            this._definition = {\n                type: Task_1.ShellType,\n                id: this._execution.computeId()\n            };\n        }\n        else if (this._execution instanceof CustomExecution) {\n            this._definition = {\n                type: Task_1.ExtensionCallbackType,\n                id: this._execution.computeId()\n            };\n        }\n        else {\n            this._definition = {\n                type: Task_1.EmptyType,\n                id: generateUuid()\n            };\n        }\n    }\n    get definition() {\n        return this._definition;\n    }\n    set definition(value) {\n        if (value === undefined || value === null) {\n            throw illegalArgument('Kind can\\'t be undefined or null');\n        }\n        this.clear();\n        this._definition = value;\n    }\n    get scope() {\n        return this._scope;\n    }\n    set target(value) {\n        this.clear();\n        this._scope = value;\n    }\n    get name() {\n        return this._name;\n    }\n    set name(value) {\n        if (typeof value !== 'string') {\n            throw illegalArgument('name');\n        }\n        this.clear();\n        this._name = value;\n    }\n    get execution() {\n        return this._execution;\n    }\n    set execution(value) {\n        if (value === null) {\n            value = undefined;\n        }\n        this.clear();\n        this._execution = value;\n        const type = this._definition.type;\n        if (Task_1.EmptyType === type || Task_1.ProcessType === type || Task_1.ShellType === type || Task_1.ExtensionCallbackType === type) {\n            this.computeDefinitionBasedOnExecution();\n        }\n    }\n    get problemMatchers() {\n        return this._problemMatchers;\n    }\n    set problemMatchers(value) {\n        if (!Array.isArray(value)) {\n            this.clear();\n            this._problemMatchers = [];\n            this._hasDefinedMatchers = false;\n            return;\n        }\n        else {\n            this.clear();\n            this._problemMatchers = value;\n            this._hasDefinedMatchers = true;\n        }\n    }\n    get hasDefinedMatchers() {\n        return this._hasDefinedMatchers;\n    }\n    get isBackground() {\n        return this._isBackground;\n    }\n    set isBackground(value) {\n        if (value !== true && value !== false) {\n            value = false;\n        }\n        this.clear();\n        this._isBackground = value;\n    }\n    get source() {\n        return this._source;\n    }\n    set source(value) {\n        if (typeof value !== 'string' || value.length === 0) {\n            throw illegalArgument('source must be a string of length > 0');\n        }\n        this.clear();\n        this._source = value;\n    }\n    get group() {\n        return this._group;\n    }\n    set group(value) {\n        if (value === null) {\n            value = undefined;\n        }\n        this.clear();\n        this._group = value;\n    }\n    get detail() {\n        return this._detail;\n    }\n    set detail(value) {\n        if (value === null) {\n            value = undefined;\n        }\n        this._detail = value;\n    }\n    get presentationOptions() {\n        return this._presentationOptions;\n    }\n    set presentationOptions(value) {\n        if (value === null || value === undefined) {\n            value = Object.create(null);\n        }\n        this.clear();\n        this._presentationOptions = value;\n    }\n    get runOptions() {\n        return this._runOptions;\n    }\n    set runOptions(value) {\n        if (value === null || value === undefined) {\n            value = Object.create(null);\n        }\n        this.clear();\n        this._runOptions = value;\n    }\n};\nTask = Task_1 = ( __decorate([\n    es5ClassCompat\n], Task));\nvar ProgressLocation;\n( (function(ProgressLocation) {\n    ProgressLocation[ProgressLocation[\"SourceControl\"] = 1] = \"SourceControl\";\n    ProgressLocation[ProgressLocation[\"Window\"] = 10] = \"Window\";\n    ProgressLocation[ProgressLocation[\"Notification\"] = 15] = \"Notification\";\n})(ProgressLocation || (ProgressLocation = {})));\nvar ViewBadge;\n( (function(ViewBadge) {\n    function isViewBadge(thing) {\n        const viewBadgeThing = thing;\n        if (!isNumber(viewBadgeThing.value)) {\n            console.log('INVALID view badge, invalid value', viewBadgeThing.value);\n            return false;\n        }\n        if (viewBadgeThing.tooltip && !isString(viewBadgeThing.tooltip)) {\n            console.log('INVALID view badge, invalid tooltip', viewBadgeThing.tooltip);\n            return false;\n        }\n        return true;\n    }\n    ViewBadge.isViewBadge = isViewBadge;\n})(ViewBadge || (ViewBadge = {})));\nlet TreeItem = TreeItem_1 = class TreeItem {\n    static isTreeItem(thing, extension) {\n        const treeItemThing = thing;\n        if (treeItemThing.checkboxState !== undefined) {\n            const checkbox = isNumber(treeItemThing.checkboxState) ? treeItemThing.checkboxState :\n                isObject(treeItemThing.checkboxState) && isNumber(treeItemThing.checkboxState.state) ? treeItemThing.checkboxState.state : undefined;\n            const tooltip = !isNumber(treeItemThing.checkboxState) && isObject(treeItemThing.checkboxState) ? treeItemThing.checkboxState.tooltip : undefined;\n            if (checkbox === undefined || (checkbox !== TreeItemCheckboxState.Checked && checkbox !== TreeItemCheckboxState.Unchecked) || (tooltip !== undefined && !isString(tooltip))) {\n                console.log('INVALID tree item, invalid checkboxState', treeItemThing.checkboxState);\n                return false;\n            }\n        }\n        if (thing instanceof TreeItem_1) {\n            return true;\n        }\n        if (treeItemThing.label !== undefined && !isString(treeItemThing.label) && !(treeItemThing.label?.label)) {\n            console.log('INVALID tree item, invalid label', treeItemThing.label);\n            return false;\n        }\n        if ((treeItemThing.id !== undefined) && !isString(treeItemThing.id)) {\n            console.log('INVALID tree item, invalid id', treeItemThing.id);\n            return false;\n        }\n        if ((treeItemThing.iconPath !== undefined) && !isString(treeItemThing.iconPath) && !URI.isUri(treeItemThing.iconPath) && (!treeItemThing.iconPath || !isString(treeItemThing.iconPath.id))) {\n            const asLightAndDarkThing = treeItemThing.iconPath;\n            if (!asLightAndDarkThing || (!isString(asLightAndDarkThing.light) && !URI.isUri(asLightAndDarkThing.light) && !isString(asLightAndDarkThing.dark) && !URI.isUri(asLightAndDarkThing.dark))) {\n                console.log('INVALID tree item, invalid iconPath', treeItemThing.iconPath);\n                return false;\n            }\n        }\n        if ((treeItemThing.description !== undefined) && !isString(treeItemThing.description) && (typeof treeItemThing.description !== 'boolean')) {\n            console.log('INVALID tree item, invalid description', treeItemThing.description);\n            return false;\n        }\n        if ((treeItemThing.resourceUri !== undefined) && !URI.isUri(treeItemThing.resourceUri)) {\n            console.log('INVALID tree item, invalid resourceUri', treeItemThing.resourceUri);\n            return false;\n        }\n        if ((treeItemThing.tooltip !== undefined) && !isString(treeItemThing.tooltip) && !(treeItemThing.tooltip instanceof MarkdownString)) {\n            console.log('INVALID tree item, invalid tooltip', treeItemThing.tooltip);\n            return false;\n        }\n        if ((treeItemThing.command !== undefined) && !treeItemThing.command.command) {\n            console.log('INVALID tree item, invalid command', treeItemThing.command);\n            return false;\n        }\n        if ((treeItemThing.collapsibleState !== undefined) && (treeItemThing.collapsibleState < TreeItemCollapsibleState.None) && (treeItemThing.collapsibleState > TreeItemCollapsibleState.Expanded)) {\n            console.log('INVALID tree item, invalid collapsibleState', treeItemThing.collapsibleState);\n            return false;\n        }\n        if ((treeItemThing.contextValue !== undefined) && !isString(treeItemThing.contextValue)) {\n            console.log('INVALID tree item, invalid contextValue', treeItemThing.contextValue);\n            return false;\n        }\n        if ((treeItemThing.accessibilityInformation !== undefined) && !treeItemThing.accessibilityInformation?.label) {\n            console.log('INVALID tree item, invalid accessibilityInformation', treeItemThing.accessibilityInformation);\n            return false;\n        }\n        return true;\n    }\n    constructor(arg1, collapsibleState = TreeItemCollapsibleState.None) {\n        this.collapsibleState = collapsibleState;\n        if (URI.isUri(arg1)) {\n            this.resourceUri = arg1;\n        }\n        else {\n            this.label = arg1;\n        }\n    }\n};\nTreeItem = TreeItem_1 = ( __decorate([\n    es5ClassCompat\n], TreeItem));\nvar TreeItemCollapsibleState;\n( (function(TreeItemCollapsibleState) {\n    TreeItemCollapsibleState[TreeItemCollapsibleState[\"None\"] = 0] = \"None\";\n    TreeItemCollapsibleState[TreeItemCollapsibleState[\"Collapsed\"] = 1] = \"Collapsed\";\n    TreeItemCollapsibleState[TreeItemCollapsibleState[\"Expanded\"] = 2] = \"Expanded\";\n})(TreeItemCollapsibleState || (TreeItemCollapsibleState = {})));\nvar TreeItemCheckboxState;\n( (function(TreeItemCheckboxState) {\n    TreeItemCheckboxState[TreeItemCheckboxState[\"Unchecked\"] = 0] = \"Unchecked\";\n    TreeItemCheckboxState[TreeItemCheckboxState[\"Checked\"] = 1] = \"Checked\";\n})(TreeItemCheckboxState || (TreeItemCheckboxState = {})));\nlet DataTransferItem = class DataTransferItem {\n    async asString() {\n        return typeof this.value === 'string' ? this.value : JSON.stringify(this.value);\n    }\n    asFile() {\n        return undefined;\n    }\n    constructor(value) {\n        this.value = value;\n    }\n};\nDataTransferItem = ( __decorate([\n    es5ClassCompat\n], DataTransferItem));\nclass InternalDataTransferItem extends DataTransferItem {\n}\nclass InternalFileDataTransferItem extends InternalDataTransferItem {\n    #file;\n    constructor(file) {\n        super('');\n        this.#file = file;\n    }\n    asFile() {\n        return this.#file;\n    }\n}\nclass DataTransferFile {\n    constructor(name, uri, itemId, getData) {\n        this.name = name;\n        this.uri = uri;\n        this._itemId = itemId;\n        this._getData = getData;\n    }\n    data() {\n        return this._getData();\n    }\n}\nlet DataTransfer = class DataTransfer {\n    #items = ( new Map());\n    constructor(init) {\n        for (const [mime, item] of init ?? []) {\n            const existing = this.#items.get(this.#normalizeMime(mime));\n            if (existing) {\n                existing.push(item);\n            }\n            else {\n                this.#items.set(this.#normalizeMime(mime), [item]);\n            }\n        }\n    }\n    get(mimeType) {\n        return this.#items.get(this.#normalizeMime(mimeType))?.[0];\n    }\n    set(mimeType, value) {\n        this.#items.set(this.#normalizeMime(mimeType), [value]);\n    }\n    forEach(callbackfn, thisArg) {\n        for (const [mime, items] of this.#items) {\n            for (const item of items) {\n                callbackfn.call(thisArg, item, mime, this);\n            }\n        }\n    }\n    *[Symbol.iterator]() {\n        for (const [mime, items] of this.#items) {\n            for (const item of items) {\n                yield [mime, item];\n            }\n        }\n    }\n    #normalizeMime(mimeType) {\n        return mimeType.toLowerCase();\n    }\n};\nDataTransfer = ( __decorate([\n    es5ClassCompat\n], DataTransfer));\nlet DocumentDropEdit = class DocumentDropEdit {\n    constructor(insertText, title, kind) {\n        this.insertText = insertText;\n        this.title = title;\n        this.kind = kind;\n    }\n};\nDocumentDropEdit = ( __decorate([\n    es5ClassCompat\n], DocumentDropEdit));\nvar DocumentPasteTriggerKind;\n( (function(DocumentPasteTriggerKind) {\n    DocumentPasteTriggerKind[DocumentPasteTriggerKind[\"Automatic\"] = 0] = \"Automatic\";\n    DocumentPasteTriggerKind[DocumentPasteTriggerKind[\"PasteAs\"] = 1] = \"PasteAs\";\n})(DocumentPasteTriggerKind || (DocumentPasteTriggerKind = {})));\nclass DocumentDropOrPasteEditKind {\n    static { this.sep = '.'; }\n    constructor(value) {\n        this.value = value;\n    }\n    append(...parts) {\n        return ( new DocumentDropOrPasteEditKind(\n            (this.value ? [this.value, ...parts] : parts).join(DocumentDropOrPasteEditKind.sep)\n        ));\n    }\n    intersects(other) {\n        return this.contains(other) || other.contains(this);\n    }\n    contains(other) {\n        return this.value === other.value || other.value.startsWith(this.value + DocumentDropOrPasteEditKind.sep);\n    }\n}\nDocumentDropOrPasteEditKind.Empty = ( new DocumentDropOrPasteEditKind(''));\nclass DocumentPasteEdit {\n    constructor(insertText, title, kind) {\n        this.title = title;\n        this.insertText = insertText;\n        this.kind = kind;\n    }\n}\nlet ThemeIcon = class ThemeIcon {\n    constructor(id, color) {\n        this.id = id;\n        this.color = color;\n    }\n    static isThemeIcon(thing) {\n        if (typeof thing.id !== 'string') {\n            console.log('INVALID ThemeIcon, invalid id', thing.id);\n            return false;\n        }\n        return true;\n    }\n};\nThemeIcon = ( __decorate([\n    es5ClassCompat\n], ThemeIcon));\nThemeIcon.File = ( new ThemeIcon('file'));\nThemeIcon.Folder = ( new ThemeIcon('folder'));\nlet ThemeColor = class ThemeColor {\n    constructor(id) {\n        this.id = id;\n    }\n};\nThemeColor = ( __decorate([\n    es5ClassCompat\n], ThemeColor));\nvar ConfigurationTarget;\n( (function(ConfigurationTarget) {\n    ConfigurationTarget[ConfigurationTarget[\"Global\"] = 1] = \"Global\";\n    ConfigurationTarget[ConfigurationTarget[\"Workspace\"] = 2] = \"Workspace\";\n    ConfigurationTarget[ConfigurationTarget[\"WorkspaceFolder\"] = 3] = \"WorkspaceFolder\";\n})(ConfigurationTarget || (ConfigurationTarget = {})));\nlet RelativePattern = class RelativePattern {\n    get base() {\n        return this._base;\n    }\n    set base(base) {\n        this._base = base;\n        this._baseUri = URI.file(base);\n    }\n    get baseUri() {\n        return this._baseUri;\n    }\n    set baseUri(baseUri) {\n        this._baseUri = baseUri;\n        this._base = baseUri.fsPath;\n    }\n    constructor(base, pattern) {\n        if (typeof base !== 'string') {\n            if (!base || !URI.isUri(base) && !URI.isUri(base.uri)) {\n                throw illegalArgument('base');\n            }\n        }\n        if (typeof pattern !== 'string') {\n            throw illegalArgument('pattern');\n        }\n        if (typeof base === 'string') {\n            this.baseUri = URI.file(base);\n        }\n        else if (URI.isUri(base)) {\n            this.baseUri = base;\n        }\n        else {\n            this.baseUri = base.uri;\n        }\n        this.pattern = pattern;\n    }\n    toJSON() {\n        return {\n            pattern: this.pattern,\n            base: this.base,\n            baseUri: this.baseUri.toJSON()\n        };\n    }\n};\nRelativePattern = ( __decorate([\n    es5ClassCompat\n], RelativePattern));\nconst breakpointIds = ( new WeakMap());\nfunction setBreakpointId(bp, id) {\n    breakpointIds.set(bp, id);\n}\nlet Breakpoint = class Breakpoint {\n    constructor(enabled, condition, hitCondition, logMessage, mode) {\n        this.enabled = typeof enabled === 'boolean' ? enabled : true;\n        if (typeof condition === 'string') {\n            this.condition = condition;\n        }\n        if (typeof hitCondition === 'string') {\n            this.hitCondition = hitCondition;\n        }\n        if (typeof logMessage === 'string') {\n            this.logMessage = logMessage;\n        }\n        if (typeof mode === 'string') {\n            this.mode = mode;\n        }\n    }\n    get id() {\n        if (!this._id) {\n            this._id = breakpointIds.get(this) ?? generateUuid();\n        }\n        return this._id;\n    }\n};\nBreakpoint = ( __decorate([\n    es5ClassCompat\n], Breakpoint));\nlet SourceBreakpoint = class SourceBreakpoint extends Breakpoint {\n    constructor(location, enabled, condition, hitCondition, logMessage, mode) {\n        super(enabled, condition, hitCondition, logMessage, mode);\n        if (location === null) {\n            throw illegalArgument('location');\n        }\n        this.location = location;\n    }\n};\nSourceBreakpoint = ( __decorate([\n    es5ClassCompat\n], SourceBreakpoint));\nlet FunctionBreakpoint = class FunctionBreakpoint extends Breakpoint {\n    constructor(functionName, enabled, condition, hitCondition, logMessage, mode) {\n        super(enabled, condition, hitCondition, logMessage, mode);\n        this.functionName = functionName;\n    }\n};\nFunctionBreakpoint = ( __decorate([\n    es5ClassCompat\n], FunctionBreakpoint));\nlet DataBreakpoint = class DataBreakpoint extends Breakpoint {\n    constructor(label, dataId, canPersist, enabled, condition, hitCondition, logMessage, mode) {\n        super(enabled, condition, hitCondition, logMessage, mode);\n        if (!dataId) {\n            throw illegalArgument('dataId');\n        }\n        this.label = label;\n        this.dataId = dataId;\n        this.canPersist = canPersist;\n    }\n};\nDataBreakpoint = ( __decorate([\n    es5ClassCompat\n], DataBreakpoint));\nlet DebugAdapterExecutable = class DebugAdapterExecutable {\n    constructor(command, args, options) {\n        this.command = command;\n        this.args = args || [];\n        this.options = options;\n    }\n};\nDebugAdapterExecutable = ( __decorate([\n    es5ClassCompat\n], DebugAdapterExecutable));\nlet DebugAdapterServer = class DebugAdapterServer {\n    constructor(port, host) {\n        this.port = port;\n        this.host = host;\n    }\n};\nDebugAdapterServer = ( __decorate([\n    es5ClassCompat\n], DebugAdapterServer));\nlet DebugAdapterNamedPipeServer = class DebugAdapterNamedPipeServer {\n    constructor(path) {\n        this.path = path;\n    }\n};\nDebugAdapterNamedPipeServer = ( __decorate([\n    es5ClassCompat\n], DebugAdapterNamedPipeServer));\nlet DebugAdapterInlineImplementation = class DebugAdapterInlineImplementation {\n    constructor(impl) {\n        this.implementation = impl;\n    }\n};\nDebugAdapterInlineImplementation = ( __decorate([\n    es5ClassCompat\n], DebugAdapterInlineImplementation));\nclass DebugStackFrame {\n    constructor(session, threadId, frameId) {\n        this.session = session;\n        this.threadId = threadId;\n        this.frameId = frameId;\n    }\n}\nclass DebugThread {\n    constructor(session, threadId) {\n        this.session = session;\n        this.threadId = threadId;\n    }\n}\nlet EvaluatableExpression = class EvaluatableExpression {\n    constructor(range, expression) {\n        this.range = range;\n        this.expression = expression;\n    }\n};\nEvaluatableExpression = ( __decorate([\n    es5ClassCompat\n], EvaluatableExpression));\nvar InlineCompletionTriggerKind;\n( (function(InlineCompletionTriggerKind) {\n    InlineCompletionTriggerKind[InlineCompletionTriggerKind[\"Invoke\"] = 0] = \"Invoke\";\n    InlineCompletionTriggerKind[InlineCompletionTriggerKind[\"Automatic\"] = 1] = \"Automatic\";\n})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {})));\nlet InlineValueText = class InlineValueText {\n    constructor(range, text) {\n        this.range = range;\n        this.text = text;\n    }\n};\nInlineValueText = ( __decorate([\n    es5ClassCompat\n], InlineValueText));\nlet InlineValueVariableLookup = class InlineValueVariableLookup {\n    constructor(range, variableName, caseSensitiveLookup = true) {\n        this.range = range;\n        this.variableName = variableName;\n        this.caseSensitiveLookup = caseSensitiveLookup;\n    }\n};\nInlineValueVariableLookup = ( __decorate([\n    es5ClassCompat\n], InlineValueVariableLookup));\nlet InlineValueEvaluatableExpression = class InlineValueEvaluatableExpression {\n    constructor(range, expression) {\n        this.range = range;\n        this.expression = expression;\n    }\n};\nInlineValueEvaluatableExpression = ( __decorate([\n    es5ClassCompat\n], InlineValueEvaluatableExpression));\nlet InlineValueContext = class InlineValueContext {\n    constructor(frameId, range) {\n        this.frameId = frameId;\n        this.stoppedLocation = range;\n    }\n};\nInlineValueContext = ( __decorate([\n    es5ClassCompat\n], InlineValueContext));\nvar NewSymbolNameTag;\n( (function(NewSymbolNameTag) {\n    NewSymbolNameTag[NewSymbolNameTag[\"AIGenerated\"] = 1] = \"AIGenerated\";\n})(NewSymbolNameTag || (NewSymbolNameTag = {})));\nvar NewSymbolNameTriggerKind;\n( (function(NewSymbolNameTriggerKind) {\n    NewSymbolNameTriggerKind[NewSymbolNameTriggerKind[\"Invoke\"] = 0] = \"Invoke\";\n    NewSymbolNameTriggerKind[NewSymbolNameTriggerKind[\"Automatic\"] = 1] = \"Automatic\";\n})(NewSymbolNameTriggerKind || (NewSymbolNameTriggerKind = {})));\nclass NewSymbolName {\n    constructor(newSymbolName, tags) {\n        this.newSymbolName = newSymbolName;\n        this.tags = tags;\n    }\n}\nvar FileChangeType;\n( (function(FileChangeType) {\n    FileChangeType[FileChangeType[\"Changed\"] = 1] = \"Changed\";\n    FileChangeType[FileChangeType[\"Created\"] = 2] = \"Created\";\n    FileChangeType[FileChangeType[\"Deleted\"] = 3] = \"Deleted\";\n})(FileChangeType || (FileChangeType = {})));\nlet FileSystemError = FileSystemError_1 = class FileSystemError extends Error {\n    static FileExists(messageOrUri) {\n        return ( new FileSystemError_1(\n            messageOrUri,\n            FileSystemProviderErrorCode.FileExists,\n            FileSystemError_1.FileExists\n        ));\n    }\n    static FileNotFound(messageOrUri) {\n        return ( new FileSystemError_1(\n            messageOrUri,\n            FileSystemProviderErrorCode.FileNotFound,\n            FileSystemError_1.FileNotFound\n        ));\n    }\n    static FileNotADirectory(messageOrUri) {\n        return ( new FileSystemError_1(\n            messageOrUri,\n            FileSystemProviderErrorCode.FileNotADirectory,\n            FileSystemError_1.FileNotADirectory\n        ));\n    }\n    static FileIsADirectory(messageOrUri) {\n        return ( new FileSystemError_1(\n            messageOrUri,\n            FileSystemProviderErrorCode.FileIsADirectory,\n            FileSystemError_1.FileIsADirectory\n        ));\n    }\n    static NoPermissions(messageOrUri) {\n        return ( new FileSystemError_1(\n            messageOrUri,\n            FileSystemProviderErrorCode.NoPermissions,\n            FileSystemError_1.NoPermissions\n        ));\n    }\n    static Unavailable(messageOrUri) {\n        return ( new FileSystemError_1(\n            messageOrUri,\n            FileSystemProviderErrorCode.Unavailable,\n            FileSystemError_1.Unavailable\n        ));\n    }\n    constructor(uriOrMessage, code = FileSystemProviderErrorCode.Unknown, terminator) {\n        super(URI.isUri(uriOrMessage) ? ( uriOrMessage.toString(true)) : uriOrMessage);\n        this.code = terminator?.name ?? 'Unknown';\n        markAsFileSystemProviderError(this, code);\n        Object.setPrototypeOf(this, FileSystemError_1.prototype);\n        if (typeof Error.captureStackTrace === 'function' && typeof terminator === 'function') {\n            Error.captureStackTrace(this, terminator);\n        }\n    }\n};\nFileSystemError = FileSystemError_1 = ( __decorate([\n    es5ClassCompat\n], FileSystemError));\nlet FoldingRange = class FoldingRange {\n    constructor(start, end, kind) {\n        this.start = start;\n        this.end = end;\n        this.kind = kind;\n    }\n};\nFoldingRange = ( __decorate([\n    es5ClassCompat\n], FoldingRange));\nvar FoldingRangeKind;\n( (function(FoldingRangeKind) {\n    FoldingRangeKind[FoldingRangeKind[\"Comment\"] = 1] = \"Comment\";\n    FoldingRangeKind[FoldingRangeKind[\"Imports\"] = 2] = \"Imports\";\n    FoldingRangeKind[FoldingRangeKind[\"Region\"] = 3] = \"Region\";\n})(FoldingRangeKind || (FoldingRangeKind = {})));\nvar CommentThreadCollapsibleState;\n( (function(CommentThreadCollapsibleState) {\n    CommentThreadCollapsibleState[CommentThreadCollapsibleState[\"Collapsed\"] = 0] = \"Collapsed\";\n    CommentThreadCollapsibleState[CommentThreadCollapsibleState[\"Expanded\"] = 1] = \"Expanded\";\n})(CommentThreadCollapsibleState || (CommentThreadCollapsibleState = {})));\nvar CommentMode;\n( (function(CommentMode) {\n    CommentMode[CommentMode[\"Editing\"] = 0] = \"Editing\";\n    CommentMode[CommentMode[\"Preview\"] = 1] = \"Preview\";\n})(CommentMode || (CommentMode = {})));\nvar CommentState;\n( (function(CommentState) {\n    CommentState[CommentState[\"Published\"] = 0] = \"Published\";\n    CommentState[CommentState[\"Draft\"] = 1] = \"Draft\";\n})(CommentState || (CommentState = {})));\nvar CommentThreadState;\n( (function(CommentThreadState) {\n    CommentThreadState[CommentThreadState[\"Unresolved\"] = 0] = \"Unresolved\";\n    CommentThreadState[CommentThreadState[\"Resolved\"] = 1] = \"Resolved\";\n})(CommentThreadState || (CommentThreadState = {})));\nvar CommentThreadApplicability;\n( (function(CommentThreadApplicability) {\n    CommentThreadApplicability[CommentThreadApplicability[\"Current\"] = 0] = \"Current\";\n    CommentThreadApplicability[CommentThreadApplicability[\"Outdated\"] = 1] = \"Outdated\";\n})(CommentThreadApplicability || (CommentThreadApplicability = {})));\nvar CommentThreadFocus;\n( (function(CommentThreadFocus) {\n    CommentThreadFocus[CommentThreadFocus[\"Reply\"] = 1] = \"Reply\";\n    CommentThreadFocus[CommentThreadFocus[\"Comment\"] = 2] = \"Comment\";\n})(CommentThreadFocus || (CommentThreadFocus = {})));\nclass SemanticTokensLegend {\n    constructor(tokenTypes, tokenModifiers = []) {\n        this.tokenTypes = tokenTypes;\n        this.tokenModifiers = tokenModifiers;\n    }\n}\nfunction isStrArrayOrUndefined(arg) {\n    return ((typeof arg === 'undefined') || isStringArray(arg));\n}\nclass SemanticTokensBuilder {\n    constructor(legend) {\n        this._prevLine = 0;\n        this._prevChar = 0;\n        this._dataIsSortedAndDeltaEncoded = true;\n        this._data = [];\n        this._dataLen = 0;\n        this._tokenTypeStrToInt = ( new Map());\n        this._tokenModifierStrToInt = ( new Map());\n        this._hasLegend = false;\n        if (legend) {\n            this._hasLegend = true;\n            for (let i = 0, len = legend.tokenTypes.length; i < len; i++) {\n                this._tokenTypeStrToInt.set(legend.tokenTypes[i], i);\n            }\n            for (let i = 0, len = legend.tokenModifiers.length; i < len; i++) {\n                this._tokenModifierStrToInt.set(legend.tokenModifiers[i], i);\n            }\n        }\n    }\n    push(arg0, arg1, arg2, arg3, arg4) {\n        if (typeof arg0 === 'number' && typeof arg1 === 'number' && typeof arg2 === 'number' && typeof arg3 === 'number' && (typeof arg4 === 'number' || typeof arg4 === 'undefined')) {\n            if (typeof arg4 === 'undefined') {\n                arg4 = 0;\n            }\n            return this._pushEncoded(arg0, arg1, arg2, arg3, arg4);\n        }\n        if (Range.isRange(arg0) && typeof arg1 === 'string' && isStrArrayOrUndefined(arg2)) {\n            return this._push(arg0, arg1, arg2);\n        }\n        throw illegalArgument();\n    }\n    _push(range, tokenType, tokenModifiers) {\n        if (!this._hasLegend) {\n            throw ( new Error('Legend must be provided in constructor'));\n        }\n        if (range.start.line !== range.end.line) {\n            throw ( new Error('`range` cannot span multiple lines'));\n        }\n        if (!( this._tokenTypeStrToInt.has(tokenType))) {\n            throw ( new Error('`tokenType` is not in the provided legend'));\n        }\n        const line = range.start.line;\n        const char = range.start.character;\n        const length = range.end.character - range.start.character;\n        const nTokenType = this._tokenTypeStrToInt.get(tokenType);\n        let nTokenModifiers = 0;\n        if (tokenModifiers) {\n            for (const tokenModifier of tokenModifiers) {\n                if (!( this._tokenModifierStrToInt.has(tokenModifier))) {\n                    throw ( new Error('`tokenModifier` is not in the provided legend'));\n                }\n                const nTokenModifier = this._tokenModifierStrToInt.get(tokenModifier);\n                nTokenModifiers |= (1 << nTokenModifier) >>> 0;\n            }\n        }\n        this._pushEncoded(line, char, length, nTokenType, nTokenModifiers);\n    }\n    _pushEncoded(line, char, length, tokenType, tokenModifiers) {\n        if (this._dataIsSortedAndDeltaEncoded && (line < this._prevLine || (line === this._prevLine && char < this._prevChar))) {\n            this._dataIsSortedAndDeltaEncoded = false;\n            const tokenCount = (this._data.length / 5) | 0;\n            let prevLine = 0;\n            let prevChar = 0;\n            for (let i = 0; i < tokenCount; i++) {\n                let line = this._data[5 * i];\n                let char = this._data[5 * i + 1];\n                if (line === 0) {\n                    line = prevLine;\n                    char += prevChar;\n                }\n                else {\n                    line += prevLine;\n                }\n                this._data[5 * i] = line;\n                this._data[5 * i + 1] = char;\n                prevLine = line;\n                prevChar = char;\n            }\n        }\n        let pushLine = line;\n        let pushChar = char;\n        if (this._dataIsSortedAndDeltaEncoded && this._dataLen > 0) {\n            pushLine -= this._prevLine;\n            if (pushLine === 0) {\n                pushChar -= this._prevChar;\n            }\n        }\n        this._data[this._dataLen++] = pushLine;\n        this._data[this._dataLen++] = pushChar;\n        this._data[this._dataLen++] = length;\n        this._data[this._dataLen++] = tokenType;\n        this._data[this._dataLen++] = tokenModifiers;\n        this._prevLine = line;\n        this._prevChar = char;\n    }\n    static _sortAndDeltaEncode(data) {\n        const pos = [];\n        const tokenCount = (data.length / 5) | 0;\n        for (let i = 0; i < tokenCount; i++) {\n            pos[i] = i;\n        }\n        pos.sort((a, b) => {\n            const aLine = data[5 * a];\n            const bLine = data[5 * b];\n            if (aLine === bLine) {\n                const aChar = data[5 * a + 1];\n                const bChar = data[5 * b + 1];\n                return aChar - bChar;\n            }\n            return aLine - bLine;\n        });\n        const result = ( new Uint32Array(data.length));\n        let prevLine = 0;\n        let prevChar = 0;\n        for (let i = 0; i < tokenCount; i++) {\n            const srcOffset = 5 * pos[i];\n            const line = data[srcOffset + 0];\n            const char = data[srcOffset + 1];\n            const length = data[srcOffset + 2];\n            const tokenType = data[srcOffset + 3];\n            const tokenModifiers = data[srcOffset + 4];\n            const pushLine = line - prevLine;\n            const pushChar = (pushLine === 0 ? char - prevChar : char);\n            const dstOffset = 5 * i;\n            result[dstOffset + 0] = pushLine;\n            result[dstOffset + 1] = pushChar;\n            result[dstOffset + 2] = length;\n            result[dstOffset + 3] = tokenType;\n            result[dstOffset + 4] = tokenModifiers;\n            prevLine = line;\n            prevChar = char;\n        }\n        return result;\n    }\n    build(resultId) {\n        if (!this._dataIsSortedAndDeltaEncoded) {\n            return ( new SemanticTokens(SemanticTokensBuilder._sortAndDeltaEncode(this._data), resultId));\n        }\n        return ( new SemanticTokens(( new Uint32Array(this._data)), resultId));\n    }\n}\nclass SemanticTokens {\n    constructor(data, resultId) {\n        this.resultId = resultId;\n        this.data = data;\n    }\n}\nclass SemanticTokensEdit {\n    constructor(start, deleteCount, data) {\n        this.start = start;\n        this.deleteCount = deleteCount;\n        this.data = data;\n    }\n}\nclass SemanticTokensEdits {\n    constructor(edits, resultId) {\n        this.resultId = resultId;\n        this.edits = edits;\n    }\n}\nvar DebugConsoleMode;\n( (function(DebugConsoleMode) {\n    DebugConsoleMode[DebugConsoleMode[\"Separate\"] = 0] = \"Separate\";\n    DebugConsoleMode[DebugConsoleMode[\"MergeWithParent\"] = 1] = \"MergeWithParent\";\n})(DebugConsoleMode || (DebugConsoleMode = {})));\nclass DebugVisualization {\n    constructor(name) {\n        this.name = name;\n    }\n}\nvar QuickInputButtonLocation;\n( (function(QuickInputButtonLocation) {\n    QuickInputButtonLocation[QuickInputButtonLocation[\"Title\"] = 1] = \"Title\";\n    QuickInputButtonLocation[QuickInputButtonLocation[\"Inline\"] = 2] = \"Inline\";\n})(QuickInputButtonLocation || (QuickInputButtonLocation = {})));\nlet QuickInputButtons = class QuickInputButtons {\n    static { this.Back = { iconPath: ( new ThemeIcon('arrow-left')) }; }\n    constructor() { }\n};\nQuickInputButtons = ( __decorate([\n    es5ClassCompat\n], QuickInputButtons));\nvar QuickPickItemKind;\n( (function(QuickPickItemKind) {\n    QuickPickItemKind[QuickPickItemKind[\"Separator\"] = -1] = \"Separator\";\n    QuickPickItemKind[QuickPickItemKind[\"Default\"] = 0] = \"Default\";\n})(QuickPickItemKind || (QuickPickItemKind = {})));\nvar InputBoxValidationSeverity;\n( (function(InputBoxValidationSeverity) {\n    InputBoxValidationSeverity[InputBoxValidationSeverity[\"Info\"] = 1] = \"Info\";\n    InputBoxValidationSeverity[InputBoxValidationSeverity[\"Warning\"] = 2] = \"Warning\";\n    InputBoxValidationSeverity[InputBoxValidationSeverity[\"Error\"] = 3] = \"Error\";\n})(InputBoxValidationSeverity || (InputBoxValidationSeverity = {})));\nvar ExtensionKind;\n( (function(ExtensionKind) {\n    ExtensionKind[ExtensionKind[\"UI\"] = 1] = \"UI\";\n    ExtensionKind[ExtensionKind[\"Workspace\"] = 2] = \"Workspace\";\n})(ExtensionKind || (ExtensionKind = {})));\nclass FileDecoration {\n    static validate(d) {\n        if (typeof d.badge === 'string') {\n            let len = nextCharLength(d.badge, 0);\n            if (len < d.badge.length) {\n                len += nextCharLength(d.badge, len);\n            }\n            if (d.badge.length > len) {\n                throw ( new Error(`The 'badge'-property must be undefined or a short character`));\n            }\n        }\n        else if (d.badge) {\n            if (!ThemeIcon.isThemeIcon(d.badge)) {\n                throw ( new Error(`The 'badge'-property is not a valid ThemeIcon`));\n            }\n        }\n        if (!d.color && !d.badge && !d.tooltip) {\n            throw ( new Error(`The decoration is empty`));\n        }\n        return true;\n    }\n    constructor(badge, tooltip, color) {\n        this.badge = badge;\n        this.tooltip = tooltip;\n        this.color = color;\n    }\n}\nlet ColorTheme = class ColorTheme {\n    constructor(kind) {\n        this.kind = kind;\n    }\n};\nColorTheme = ( __decorate([\n    es5ClassCompat\n], ColorTheme));\nvar ColorThemeKind;\n( (function(ColorThemeKind) {\n    ColorThemeKind[ColorThemeKind[\"Light\"] = 1] = \"Light\";\n    ColorThemeKind[ColorThemeKind[\"Dark\"] = 2] = \"Dark\";\n    ColorThemeKind[ColorThemeKind[\"HighContrast\"] = 3] = \"HighContrast\";\n    ColorThemeKind[ColorThemeKind[\"HighContrastLight\"] = 4] = \"HighContrastLight\";\n})(ColorThemeKind || (ColorThemeKind = {})));\nclass NotebookRange {\n    static isNotebookRange(thing) {\n        if (thing instanceof NotebookRange) {\n            return true;\n        }\n        if (!thing) {\n            return false;\n        }\n        return typeof thing.start === 'number'\n            && typeof thing.end === 'number';\n    }\n    get start() {\n        return this._start;\n    }\n    get end() {\n        return this._end;\n    }\n    get isEmpty() {\n        return this._start === this._end;\n    }\n    constructor(start, end) {\n        if (start < 0) {\n            throw illegalArgument('start must be positive');\n        }\n        if (end < 0) {\n            throw illegalArgument('end must be positive');\n        }\n        if (start <= end) {\n            this._start = start;\n            this._end = end;\n        }\n        else {\n            this._start = end;\n            this._end = start;\n        }\n    }\n    with(change) {\n        let start = this._start;\n        let end = this._end;\n        if (change.start !== undefined) {\n            start = change.start;\n        }\n        if (change.end !== undefined) {\n            end = change.end;\n        }\n        if (start === this._start && end === this._end) {\n            return this;\n        }\n        return ( new NotebookRange(start, end));\n    }\n}\nclass NotebookCellData {\n    static validate(data) {\n        if (typeof data.kind !== 'number') {\n            throw ( new Error('NotebookCellData MUST have \\'kind\\' property'));\n        }\n        if (typeof data.value !== 'string') {\n            throw ( new Error('NotebookCellData MUST have \\'value\\' property'));\n        }\n        if (typeof data.languageId !== 'string') {\n            throw ( new Error('NotebookCellData MUST have \\'languageId\\' property'));\n        }\n    }\n    static isNotebookCellDataArray(value) {\n        return Array.isArray(value) && value.every(elem => NotebookCellData.isNotebookCellData(elem));\n    }\n    static isNotebookCellData(value) {\n        return true;\n    }\n    constructor(kind, value, languageId, mime, outputs, metadata, executionSummary) {\n        this.kind = kind;\n        this.value = value;\n        this.languageId = languageId;\n        this.mime = mime;\n        this.outputs = outputs ?? [];\n        this.metadata = metadata;\n        this.executionSummary = executionSummary;\n        NotebookCellData.validate(this);\n    }\n}\nclass NotebookData {\n    constructor(cells) {\n        this.cells = cells;\n    }\n}\nclass NotebookCellOutputItem {\n    static isNotebookCellOutputItem(obj) {\n        if (obj instanceof NotebookCellOutputItem) {\n            return true;\n        }\n        if (!obj) {\n            return false;\n        }\n        return typeof obj.mime === 'string'\n            && obj.data instanceof Uint8Array;\n    }\n    static error(err) {\n        const obj = {\n            name: err.name,\n            message: err.message,\n            stack: err.stack\n        };\n        return NotebookCellOutputItem.json(obj, 'application/vnd.code.notebook.error');\n    }\n    static stdout(value) {\n        return NotebookCellOutputItem.text(value, 'application/vnd.code.notebook.stdout');\n    }\n    static stderr(value) {\n        return NotebookCellOutputItem.text(value, 'application/vnd.code.notebook.stderr');\n    }\n    static bytes(value, mime = 'application/octet-stream') {\n        return ( new NotebookCellOutputItem(value, mime));\n    }\n    static #encoder = ( new TextEncoder());\n    static text(value, mime = Mimes.text) {\n        const bytes = NotebookCellOutputItem.#encoder.encode(String(value));\n        return ( new NotebookCellOutputItem(bytes, mime));\n    }\n    static json(value, mime = 'text/x-json') {\n        const rawStr = JSON.stringify(value, undefined, '\\t');\n        return NotebookCellOutputItem.text(rawStr, mime);\n    }\n    constructor(data, mime) {\n        this.data = data;\n        this.mime = mime;\n        const mimeNormalized = normalizeMimeType(mime, true);\n        if (!mimeNormalized) {\n            throw ( new Error(\n                `INVALID mime type: ${mime}. Must be in the format \"type/subtype[;optionalparameter]\"`\n            ));\n        }\n        this.mime = mimeNormalized;\n    }\n}\nclass NotebookCellOutput {\n    static isNotebookCellOutput(candidate) {\n        if (candidate instanceof NotebookCellOutput) {\n            return true;\n        }\n        if (!candidate || typeof candidate !== 'object') {\n            return false;\n        }\n        return typeof candidate.id === 'string' && Array.isArray(candidate.items);\n    }\n    static ensureUniqueMimeTypes(items, warn = false) {\n        const seen = ( new Set());\n        const removeIdx = ( new Set());\n        for (let i = 0; i < items.length; i++) {\n            const item = items[i];\n            const normalMime = normalizeMimeType(item.mime);\n            if (!( seen.has(normalMime)) || isTextStreamMime(normalMime)) {\n                seen.add(normalMime);\n                continue;\n            }\n            removeIdx.add(i);\n            if (warn) {\n                console.warn(`DUPLICATED mime type '${item.mime}' will be dropped`);\n            }\n        }\n        if (removeIdx.size === 0) {\n            return items;\n        }\n        return items.filter((_item, index) => !( removeIdx.has(index)));\n    }\n    constructor(items, idOrMetadata, metadata) {\n        this.items = NotebookCellOutput.ensureUniqueMimeTypes(items, true);\n        if (typeof idOrMetadata === 'string') {\n            this.id = idOrMetadata;\n            this.metadata = metadata;\n        }\n        else {\n            this.id = generateUuid();\n            this.metadata = idOrMetadata ?? metadata;\n        }\n    }\n}\nvar NotebookCellKind;\n( (function(NotebookCellKind) {\n    NotebookCellKind[NotebookCellKind[\"Markup\"] = 1] = \"Markup\";\n    NotebookCellKind[NotebookCellKind[\"Code\"] = 2] = \"Code\";\n})(NotebookCellKind || (NotebookCellKind = {})));\nvar NotebookCellExecutionState;\n( (function(NotebookCellExecutionState) {\n    NotebookCellExecutionState[NotebookCellExecutionState[\"Idle\"] = 1] = \"Idle\";\n    NotebookCellExecutionState[NotebookCellExecutionState[\"Pending\"] = 2] = \"Pending\";\n    NotebookCellExecutionState[NotebookCellExecutionState[\"Executing\"] = 3] = \"Executing\";\n})(NotebookCellExecutionState || (NotebookCellExecutionState = {})));\nvar NotebookCellStatusBarAlignment;\n( (function(NotebookCellStatusBarAlignment) {\n    NotebookCellStatusBarAlignment[NotebookCellStatusBarAlignment[\"Left\"] = 1] = \"Left\";\n    NotebookCellStatusBarAlignment[NotebookCellStatusBarAlignment[\"Right\"] = 2] = \"Right\";\n})(NotebookCellStatusBarAlignment || (NotebookCellStatusBarAlignment = {})));\nvar NotebookEditorRevealType;\n( (function(NotebookEditorRevealType) {\n    NotebookEditorRevealType[NotebookEditorRevealType[\"Default\"] = 0] = \"Default\";\n    NotebookEditorRevealType[NotebookEditorRevealType[\"InCenter\"] = 1] = \"InCenter\";\n    NotebookEditorRevealType[NotebookEditorRevealType[\"InCenterIfOutsideViewport\"] = 2] = \"InCenterIfOutsideViewport\";\n    NotebookEditorRevealType[NotebookEditorRevealType[\"AtTop\"] = 3] = \"AtTop\";\n})(NotebookEditorRevealType || (NotebookEditorRevealType = {})));\nclass NotebookCellStatusBarItem {\n    constructor(text, alignment) {\n        this.text = text;\n        this.alignment = alignment;\n    }\n}\nvar NotebookControllerAffinity;\n( (function(NotebookControllerAffinity) {\n    NotebookControllerAffinity[NotebookControllerAffinity[\"Default\"] = 1] = \"Default\";\n    NotebookControllerAffinity[NotebookControllerAffinity[\"Preferred\"] = 2] = \"Preferred\";\n})(NotebookControllerAffinity || (NotebookControllerAffinity = {})));\nvar NotebookControllerAffinity2;\n( (function(NotebookControllerAffinity2) {\n    NotebookControllerAffinity2[NotebookControllerAffinity2[\"Default\"] = 1] = \"Default\";\n    NotebookControllerAffinity2[NotebookControllerAffinity2[\"Preferred\"] = 2] = \"Preferred\";\n    NotebookControllerAffinity2[NotebookControllerAffinity2[\"Hidden\"] = -1] = \"Hidden\";\n})(NotebookControllerAffinity2 || (NotebookControllerAffinity2 = {})));\nclass NotebookRendererScript {\n    constructor(uri, provides = []) {\n        this.uri = uri;\n        this.provides = asArray(provides);\n    }\n}\nclass NotebookKernelSourceAction {\n    constructor(label) {\n        this.label = label;\n    }\n}\nvar NotebookVariablesRequestKind;\n( (function(NotebookVariablesRequestKind) {\n    NotebookVariablesRequestKind[NotebookVariablesRequestKind[\"Named\"] = 1] = \"Named\";\n    NotebookVariablesRequestKind[NotebookVariablesRequestKind[\"Indexed\"] = 2] = \"Indexed\";\n})(NotebookVariablesRequestKind || (NotebookVariablesRequestKind = {})));\nlet TimelineItem = class TimelineItem {\n    constructor(label, timestamp) {\n        this.label = label;\n        this.timestamp = timestamp;\n    }\n};\nTimelineItem = ( __decorate([\n    es5ClassCompat\n], TimelineItem));\nvar ExtensionMode;\n( (function(ExtensionMode) {\n    ExtensionMode[ExtensionMode[\"Production\"] = 1] = \"Production\";\n    ExtensionMode[ExtensionMode[\"Development\"] = 2] = \"Development\";\n    ExtensionMode[ExtensionMode[\"Test\"] = 3] = \"Test\";\n})(ExtensionMode || (ExtensionMode = {})));\nvar ExtensionRuntime;\n( (function(ExtensionRuntime) {\n    ExtensionRuntime[ExtensionRuntime[\"Node\"] = 1] = \"Node\";\n    ExtensionRuntime[ExtensionRuntime[\"Webworker\"] = 2] = \"Webworker\";\n})(ExtensionRuntime || (ExtensionRuntime = {})));\nvar StandardTokenType;\n( (function(StandardTokenType) {\n    StandardTokenType[StandardTokenType[\"Other\"] = 0] = \"Other\";\n    StandardTokenType[StandardTokenType[\"Comment\"] = 1] = \"Comment\";\n    StandardTokenType[StandardTokenType[\"String\"] = 2] = \"String\";\n    StandardTokenType[StandardTokenType[\"RegEx\"] = 3] = \"RegEx\";\n})(StandardTokenType || (StandardTokenType = {})));\nclass LinkedEditingRanges {\n    constructor(ranges, wordPattern) {\n        this.ranges = ranges;\n        this.wordPattern = wordPattern;\n    }\n}\nclass PortAttributes {\n    constructor(autoForwardAction) {\n        this._autoForwardAction = autoForwardAction;\n    }\n    get autoForwardAction() {\n        return this._autoForwardAction;\n    }\n}\nvar TestResultState;\n( (function(TestResultState) {\n    TestResultState[TestResultState[\"Queued\"] = 1] = \"Queued\";\n    TestResultState[TestResultState[\"Running\"] = 2] = \"Running\";\n    TestResultState[TestResultState[\"Passed\"] = 3] = \"Passed\";\n    TestResultState[TestResultState[\"Failed\"] = 4] = \"Failed\";\n    TestResultState[TestResultState[\"Skipped\"] = 5] = \"Skipped\";\n    TestResultState[TestResultState[\"Errored\"] = 6] = \"Errored\";\n})(TestResultState || (TestResultState = {})));\nvar TestRunProfileKind;\n( (function(TestRunProfileKind) {\n    TestRunProfileKind[TestRunProfileKind[\"Run\"] = 1] = \"Run\";\n    TestRunProfileKind[TestRunProfileKind[\"Debug\"] = 2] = \"Debug\";\n    TestRunProfileKind[TestRunProfileKind[\"Coverage\"] = 3] = \"Coverage\";\n})(TestRunProfileKind || (TestRunProfileKind = {})));\nlet TestRunRequest = class TestRunRequest {\n    constructor(include = undefined, exclude = undefined, profile = undefined, continuous = false, preserveFocus = true) {\n        this.include = include;\n        this.exclude = exclude;\n        this.profile = profile;\n        this.continuous = continuous;\n        this.preserveFocus = preserveFocus;\n    }\n};\nTestRunRequest = ( __decorate([\n    es5ClassCompat\n], TestRunRequest));\nlet TestMessage = TestMessage_1 = class TestMessage {\n    static diff(message, expected, actual) {\n        const msg = ( new TestMessage_1(message));\n        msg.expectedOutput = expected;\n        msg.actualOutput = actual;\n        return msg;\n    }\n    constructor(message) {\n        this.message = message;\n    }\n};\nTestMessage = TestMessage_1 = ( __decorate([\n    es5ClassCompat\n], TestMessage));\nlet TestTag = class TestTag {\n    constructor(id) {\n        this.id = id;\n    }\n};\nTestTag = ( __decorate([\n    es5ClassCompat\n], TestTag));\nclass TestMessageStackFrame {\n    constructor(label, uri, position) {\n        this.label = label;\n        this.uri = uri;\n        this.position = position;\n    }\n}\nclass TestCoverageCount {\n    constructor(covered, total) {\n        this.covered = covered;\n        this.total = total;\n        validateTestCoverageCount(this);\n    }\n}\nfunction validateTestCoverageCount(cc) {\n    if (!cc) {\n        return;\n    }\n    if (cc.covered > cc.total) {\n        throw ( new Error(\n            `The total number of covered items (${cc.covered}) cannot be greater than the total (${cc.total})`\n        ));\n    }\n    if (cc.total < 0) {\n        throw ( new Error(`The number of covered items (${cc.total}) cannot be negative`));\n    }\n}\nclass FileCoverage {\n    static fromDetails(uri, details) {\n        const statements = ( new TestCoverageCount(0, 0));\n        const branches = ( new TestCoverageCount(0, 0));\n        const decl = ( new TestCoverageCount(0, 0));\n        for (const detail of details) {\n            if ('branches' in detail) {\n                statements.total += 1;\n                statements.covered += detail.executed ? 1 : 0;\n                for (const branch of detail.branches) {\n                    branches.total += 1;\n                    branches.covered += branch.executed ? 1 : 0;\n                }\n            }\n            else {\n                decl.total += 1;\n                decl.covered += detail.executed ? 1 : 0;\n            }\n        }\n        const coverage = ( new FileCoverage(\n            uri,\n            statements,\n            branches.total > 0 ? branches : undefined,\n            decl.total > 0 ? decl : undefined\n        ));\n        coverage.detailedCoverage = details;\n        return coverage;\n    }\n    constructor(uri, statementCoverage, branchCoverage, declarationCoverage, fromTests = []) {\n        this.uri = uri;\n        this.statementCoverage = statementCoverage;\n        this.branchCoverage = branchCoverage;\n        this.declarationCoverage = declarationCoverage;\n        this.fromTests = fromTests;\n    }\n}\nclass StatementCoverage {\n    get executionCount() { return +this.executed; }\n    set executionCount(n) { this.executed = n; }\n    constructor(executed, location, branches = []) {\n        this.executed = executed;\n        this.location = location;\n        this.branches = branches;\n    }\n}\nclass BranchCoverage {\n    get executionCount() { return +this.executed; }\n    set executionCount(n) { this.executed = n; }\n    constructor(executed, location, label) {\n        this.executed = executed;\n        this.location = location;\n        this.label = label;\n    }\n}\nclass DeclarationCoverage {\n    get executionCount() { return +this.executed; }\n    set executionCount(n) { this.executed = n; }\n    constructor(name, executed, location) {\n        this.name = name;\n        this.executed = executed;\n        this.location = location;\n    }\n}\nvar ExternalUriOpenerPriority;\n( (function(ExternalUriOpenerPriority) {\n    ExternalUriOpenerPriority[ExternalUriOpenerPriority[\"None\"] = 0] = \"None\";\n    ExternalUriOpenerPriority[ExternalUriOpenerPriority[\"Option\"] = 1] = \"Option\";\n    ExternalUriOpenerPriority[ExternalUriOpenerPriority[\"Default\"] = 2] = \"Default\";\n    ExternalUriOpenerPriority[ExternalUriOpenerPriority[\"Preferred\"] = 3] = \"Preferred\";\n})(ExternalUriOpenerPriority || (ExternalUriOpenerPriority = {})));\nvar WorkspaceTrustState;\n( (function(WorkspaceTrustState) {\n    WorkspaceTrustState[WorkspaceTrustState[\"Untrusted\"] = 0] = \"Untrusted\";\n    WorkspaceTrustState[WorkspaceTrustState[\"Trusted\"] = 1] = \"Trusted\";\n    WorkspaceTrustState[WorkspaceTrustState[\"Unspecified\"] = 2] = \"Unspecified\";\n})(WorkspaceTrustState || (WorkspaceTrustState = {})));\nvar PortAutoForwardAction;\n( (function(PortAutoForwardAction) {\n    PortAutoForwardAction[PortAutoForwardAction[\"Notify\"] = 1] = \"Notify\";\n    PortAutoForwardAction[PortAutoForwardAction[\"OpenBrowser\"] = 2] = \"OpenBrowser\";\n    PortAutoForwardAction[PortAutoForwardAction[\"OpenPreview\"] = 3] = \"OpenPreview\";\n    PortAutoForwardAction[PortAutoForwardAction[\"Silent\"] = 4] = \"Silent\";\n    PortAutoForwardAction[PortAutoForwardAction[\"Ignore\"] = 5] = \"Ignore\";\n    PortAutoForwardAction[PortAutoForwardAction[\"OpenBrowserOnce\"] = 6] = \"OpenBrowserOnce\";\n})(PortAutoForwardAction || (PortAutoForwardAction = {})));\nclass TypeHierarchyItem {\n    constructor(kind, name, detail, uri, range, selectionRange) {\n        this.kind = kind;\n        this.name = name;\n        this.detail = detail;\n        this.uri = uri;\n        this.range = range;\n        this.selectionRange = selectionRange;\n    }\n}\nclass TextTabInput {\n    constructor(uri) {\n        this.uri = uri;\n    }\n}\nclass TextDiffTabInput {\n    constructor(original, modified) {\n        this.original = original;\n        this.modified = modified;\n    }\n}\nclass TextMergeTabInput {\n    constructor(base, input1, input2, result) {\n        this.base = base;\n        this.input1 = input1;\n        this.input2 = input2;\n        this.result = result;\n    }\n}\nclass CustomEditorTabInput {\n    constructor(uri, viewType) {\n        this.uri = uri;\n        this.viewType = viewType;\n    }\n}\nclass WebviewEditorTabInput {\n    constructor(viewType) {\n        this.viewType = viewType;\n    }\n}\nclass NotebookEditorTabInput {\n    constructor(uri, notebookType) {\n        this.uri = uri;\n        this.notebookType = notebookType;\n    }\n}\nclass NotebookDiffEditorTabInput {\n    constructor(original, modified, notebookType) {\n        this.original = original;\n        this.modified = modified;\n        this.notebookType = notebookType;\n    }\n}\nclass TerminalEditorTabInput {\n    constructor() { }\n}\nclass InteractiveWindowInput {\n    constructor(uri, inputBoxUri) {\n        this.uri = uri;\n        this.inputBoxUri = inputBoxUri;\n    }\n}\nclass ChatEditorTabInput {\n    constructor() { }\n}\nclass TextMultiDiffTabInput {\n    constructor(textDiffs) {\n        this.textDiffs = textDiffs;\n    }\n}\nvar InteractiveSessionVoteDirection;\n( (function(InteractiveSessionVoteDirection) {\n    InteractiveSessionVoteDirection[InteractiveSessionVoteDirection[\"Down\"] = 0] = \"Down\";\n    InteractiveSessionVoteDirection[InteractiveSessionVoteDirection[\"Up\"] = 1] = \"Up\";\n})(InteractiveSessionVoteDirection || (InteractiveSessionVoteDirection = {})));\nvar ChatCopyKind;\n( (function(ChatCopyKind) {\n    ChatCopyKind[ChatCopyKind[\"Action\"] = 1] = \"Action\";\n    ChatCopyKind[ChatCopyKind[\"Toolbar\"] = 2] = \"Toolbar\";\n})(ChatCopyKind || (ChatCopyKind = {})));\nvar ChatVariableLevel;\n( (function(ChatVariableLevel) {\n    ChatVariableLevel[ChatVariableLevel[\"Short\"] = 1] = \"Short\";\n    ChatVariableLevel[ChatVariableLevel[\"Medium\"] = 2] = \"Medium\";\n    ChatVariableLevel[ChatVariableLevel[\"Full\"] = 3] = \"Full\";\n})(ChatVariableLevel || (ChatVariableLevel = {})));\nclass ChatCompletionItem {\n    constructor(id, label, values) {\n        this.id = id;\n        this.label = label;\n        this.values = values;\n    }\n}\nvar InteractiveEditorResponseFeedbackKind;\n( (function(InteractiveEditorResponseFeedbackKind) {\n    InteractiveEditorResponseFeedbackKind[InteractiveEditorResponseFeedbackKind[\"Unhelpful\"] = 0] = \"Unhelpful\";\n    InteractiveEditorResponseFeedbackKind[InteractiveEditorResponseFeedbackKind[\"Helpful\"] = 1] = \"Helpful\";\n    InteractiveEditorResponseFeedbackKind[InteractiveEditorResponseFeedbackKind[\"Undone\"] = 2] = \"Undone\";\n    InteractiveEditorResponseFeedbackKind[InteractiveEditorResponseFeedbackKind[\"Accepted\"] = 3] = \"Accepted\";\n    InteractiveEditorResponseFeedbackKind[InteractiveEditorResponseFeedbackKind[\"Bug\"] = 4] = \"Bug\";\n})(\n    InteractiveEditorResponseFeedbackKind || (InteractiveEditorResponseFeedbackKind = {})\n));\nvar ChatResultFeedbackKind;\n( (function(ChatResultFeedbackKind) {\n    ChatResultFeedbackKind[ChatResultFeedbackKind[\"Unhelpful\"] = 0] = \"Unhelpful\";\n    ChatResultFeedbackKind[ChatResultFeedbackKind[\"Helpful\"] = 1] = \"Helpful\";\n})(ChatResultFeedbackKind || (ChatResultFeedbackKind = {})));\nclass ChatResponseMarkdownPart {\n    constructor(value) {\n        if (typeof value !== 'string' && value.isTrusted === true) {\n            throw ( new Error(\n                'The boolean form of MarkdownString.isTrusted is NOT supported for chat participants.'\n            ));\n        }\n        this.value = typeof value === 'string' ? ( new MarkdownString(value)) : value;\n    }\n}\nclass ChatResponseMarkdownWithVulnerabilitiesPart {\n    constructor(value, vulnerabilities) {\n        if (typeof value !== 'string' && value.isTrusted === true) {\n            throw ( new Error(\n                'The boolean form of MarkdownString.isTrusted is NOT supported for chat participants.'\n            ));\n        }\n        this.value = typeof value === 'string' ? ( new MarkdownString(value)) : value;\n        this.vulnerabilities = vulnerabilities;\n    }\n}\nclass ChatResponseDetectedParticipantPart {\n    constructor(participant, command) {\n        this.participant = participant;\n        this.command = command;\n    }\n}\nclass ChatResponseConfirmationPart {\n    constructor(title, message, data, buttons) {\n        this.title = title;\n        this.message = message;\n        this.data = data;\n        this.buttons = buttons;\n    }\n}\nclass ChatResponseFileTreePart {\n    constructor(value, baseUri) {\n        this.value = value;\n        this.baseUri = baseUri;\n    }\n}\nclass ChatResponseAnchorPart {\n    constructor(value, title) {\n        this.value = value;\n        this.value2 = value;\n        this.title = title;\n    }\n}\nclass ChatResponseProgressPart {\n    constructor(value) {\n        this.value = value;\n    }\n}\nclass ChatResponseProgressPart2 {\n    constructor(value, task) {\n        this.value = value;\n        this.task = task;\n    }\n}\nclass ChatResponseWarningPart {\n    constructor(value) {\n        if (typeof value !== 'string' && value.isTrusted === true) {\n            throw ( new Error(\n                'The boolean form of MarkdownString.isTrusted is NOT supported for chat participants.'\n            ));\n        }\n        this.value = typeof value === 'string' ? ( new MarkdownString(value)) : value;\n    }\n}\nclass ChatResponseCommandButtonPart {\n    constructor(value) {\n        this.value = value;\n    }\n}\nclass ChatResponseReferencePart {\n    constructor(value, iconPath, options) {\n        this.value = value;\n        this.iconPath = iconPath;\n        this.options = options;\n    }\n}\nclass ChatResponseCodeblockUriPart {\n    constructor(value) {\n        this.value = value;\n    }\n}\nclass ChatResponseCodeCitationPart {\n    constructor(value, license, snippet) {\n        this.value = value;\n        this.license = license;\n        this.snippet = snippet;\n    }\n}\nclass ChatResponseMovePart {\n    constructor(uri, range) {\n        this.uri = uri;\n        this.range = range;\n    }\n}\nclass ChatResponseTextEditPart {\n    constructor(uri, edits) {\n        this.uri = uri;\n        this.edits = Array.isArray(edits) ? edits : [edits];\n    }\n}\nclass ChatRequestTurn {\n    constructor(prompt, command, references, participant) {\n        this.prompt = prompt;\n        this.command = command;\n        this.references = references;\n        this.participant = participant;\n    }\n}\nclass ChatResponseTurn {\n    constructor(response, result, participant, command) {\n        this.response = response;\n        this.result = result;\n        this.participant = participant;\n        this.command = command;\n    }\n}\nvar ChatLocation;\n( (function(ChatLocation) {\n    ChatLocation[ChatLocation[\"Panel\"] = 1] = \"Panel\";\n    ChatLocation[ChatLocation[\"Terminal\"] = 2] = \"Terminal\";\n    ChatLocation[ChatLocation[\"Notebook\"] = 3] = \"Notebook\";\n    ChatLocation[ChatLocation[\"Editor\"] = 4] = \"Editor\";\n})(ChatLocation || (ChatLocation = {})));\nvar ChatResponseReferencePartStatusKind;\n( (function(ChatResponseReferencePartStatusKind) {\n    ChatResponseReferencePartStatusKind[ChatResponseReferencePartStatusKind[\"Complete\"] = 1] = \"Complete\";\n    ChatResponseReferencePartStatusKind[ChatResponseReferencePartStatusKind[\"Partial\"] = 2] = \"Partial\";\n    ChatResponseReferencePartStatusKind[ChatResponseReferencePartStatusKind[\"Omitted\"] = 3] = \"Omitted\";\n})(\n    ChatResponseReferencePartStatusKind || (ChatResponseReferencePartStatusKind = {})\n));\nclass ChatRequestEditorData {\n    constructor(document, selection, wholeRange) {\n        this.document = document;\n        this.selection = selection;\n        this.wholeRange = wholeRange;\n    }\n}\nclass ChatRequestNotebookData {\n    constructor(cell) {\n        this.cell = cell;\n    }\n}\nvar LanguageModelChatMessageRole;\n( (function(LanguageModelChatMessageRole) {\n    LanguageModelChatMessageRole[LanguageModelChatMessageRole[\"User\"] = 1] = \"User\";\n    LanguageModelChatMessageRole[LanguageModelChatMessageRole[\"Assistant\"] = 2] = \"Assistant\";\n    LanguageModelChatMessageRole[LanguageModelChatMessageRole[\"System\"] = 3] = \"System\";\n})(LanguageModelChatMessageRole || (LanguageModelChatMessageRole = {})));\nclass LanguageModelToolResultPart {\n    constructor(toolCallId, content, isError) {\n        this.toolCallId = toolCallId;\n        this.content = content;\n        this.isError = isError ?? false;\n    }\n}\nclass LanguageModelChatMessage {\n    static User(content, name) {\n        const value = ( new LanguageModelChatMessage(\n            LanguageModelChatMessageRole.User,\n            typeof content === 'string' ? content : '',\n            name\n        ));\n        value.content2 = [content];\n        return value;\n    }\n    static Assistant(content, name) {\n        return ( new LanguageModelChatMessage(LanguageModelChatMessageRole.Assistant, content, name));\n    }\n    constructor(role, content, name) {\n        this.role = role;\n        this.content = content;\n        this.content2 = [content];\n        this.name = name;\n    }\n}\nclass LanguageModelToolCallPart {\n    constructor(name, toolCallId, parameters) {\n        this.name = name;\n        this.toolCallId = toolCallId;\n        this.parameters = parameters;\n    }\n}\nclass LanguageModelTextPart {\n    constructor(value) {\n        this.value = value;\n    }\n}\nclass LanguageModelError extends Error {\n    static NotFound(message) {\n        return ( new LanguageModelError(message, LanguageModelError.NotFound.name));\n    }\n    static NoPermissions(message) {\n        return ( new LanguageModelError(message, LanguageModelError.NoPermissions.name));\n    }\n    static Blocked(message) {\n        return ( new LanguageModelError(message, LanguageModelError.Blocked.name));\n    }\n    constructor(message, code, cause) {\n        super(message, { cause });\n        this.name = 'LanguageModelError';\n        this.code = code ?? '';\n    }\n}\nvar RelatedInformationType;\n( (function(RelatedInformationType) {\n    RelatedInformationType[RelatedInformationType[\"SymbolInformation\"] = 1] = \"SymbolInformation\";\n    RelatedInformationType[RelatedInformationType[\"CommandInformation\"] = 2] = \"CommandInformation\";\n    RelatedInformationType[RelatedInformationType[\"SearchInformation\"] = 3] = \"SearchInformation\";\n    RelatedInformationType[RelatedInformationType[\"SettingInformation\"] = 4] = \"SettingInformation\";\n})(RelatedInformationType || (RelatedInformationType = {})));\nvar SpeechToTextStatus;\n( (function(SpeechToTextStatus) {\n    SpeechToTextStatus[SpeechToTextStatus[\"Started\"] = 1] = \"Started\";\n    SpeechToTextStatus[SpeechToTextStatus[\"Recognizing\"] = 2] = \"Recognizing\";\n    SpeechToTextStatus[SpeechToTextStatus[\"Recognized\"] = 3] = \"Recognized\";\n    SpeechToTextStatus[SpeechToTextStatus[\"Stopped\"] = 4] = \"Stopped\";\n    SpeechToTextStatus[SpeechToTextStatus[\"Error\"] = 5] = \"Error\";\n})(SpeechToTextStatus || (SpeechToTextStatus = {})));\nvar TextToSpeechStatus;\n( (function(TextToSpeechStatus) {\n    TextToSpeechStatus[TextToSpeechStatus[\"Started\"] = 1] = \"Started\";\n    TextToSpeechStatus[TextToSpeechStatus[\"Stopped\"] = 2] = \"Stopped\";\n    TextToSpeechStatus[TextToSpeechStatus[\"Error\"] = 3] = \"Error\";\n})(TextToSpeechStatus || (TextToSpeechStatus = {})));\nvar KeywordRecognitionStatus;\n( (function(KeywordRecognitionStatus) {\n    KeywordRecognitionStatus[KeywordRecognitionStatus[\"Recognized\"] = 1] = \"Recognized\";\n    KeywordRecognitionStatus[KeywordRecognitionStatus[\"Stopped\"] = 2] = \"Stopped\";\n})(KeywordRecognitionStatus || (KeywordRecognitionStatus = {})));\nclass InlineEdit {\n    constructor(text, range) {\n        this.text = text;\n        this.range = range;\n    }\n}\nvar InlineEditTriggerKind;\n( (function(InlineEditTriggerKind) {\n    InlineEditTriggerKind[InlineEditTriggerKind[\"Invoke\"] = 0] = \"Invoke\";\n    InlineEditTriggerKind[InlineEditTriggerKind[\"Automatic\"] = 1] = \"Automatic\";\n})(InlineEditTriggerKind || (InlineEditTriggerKind = {})));\nexport { BranchCoverage, Breakpoint, CallHierarchyIncomingCall, CallHierarchyItem, CallHierarchyOutgoingCall, ChatCompletionItem, ChatCopyKind, ChatEditorTabInput, ChatLocation, ChatRequestEditorData, ChatRequestNotebookData, ChatRequestTurn, ChatResponseAnchorPart, ChatResponseCodeCitationPart, ChatResponseCodeblockUriPart, ChatResponseCommandButtonPart, ChatResponseConfirmationPart, ChatResponseDetectedParticipantPart, ChatResponseFileTreePart, ChatResponseMarkdownPart, ChatResponseMarkdownWithVulnerabilitiesPart, ChatResponseMovePart, ChatResponseProgressPart, ChatResponseProgressPart2, ChatResponseReferencePart, ChatResponseReferencePartStatusKind, ChatResponseTextEditPart, ChatResponseTurn, ChatResponseWarningPart, ChatResultFeedbackKind, ChatVariableLevel, CodeAction, CodeActionKind, CodeActionTriggerKind, CodeLens, Color, ColorInformation, ColorPresentation, ColorTheme, ColorThemeKind, CommentMode, CommentState, CommentThreadApplicability, CommentThreadCollapsibleState, CommentThreadFocus, CommentThreadState, CompletionItem, CompletionItemKind, CompletionItemTag, CompletionList, CompletionTriggerKind, ConfigurationTarget, CustomEditorTabInput, CustomExecution, DataBreakpoint, DataTransfer, DataTransferFile, DataTransferItem, DebugAdapterExecutable, DebugAdapterInlineImplementation, DebugAdapterNamedPipeServer, DebugAdapterServer, DebugConsoleMode, DebugStackFrame, DebugThread, DebugVisualization, DeclarationCoverage, DecorationRangeBehavior, Diagnostic, DiagnosticRelatedInformation, DiagnosticSeverity, DiagnosticTag, Disposable, DocumentDropEdit, DocumentDropOrPasteEditKind, DocumentHighlight, DocumentHighlightKind, DocumentLink, DocumentPasteEdit, DocumentPasteTriggerKind, DocumentSymbol, EndOfLine, EnvironmentVariableMutatorType, EvaluatableExpression, ExtensionKind, ExtensionMode, ExtensionRuntime, ExternalUriOpenerPriority, FileChangeType, FileCoverage, FileDecoration, FileSystemError, FoldingRange, FoldingRangeKind, FunctionBreakpoint, Hover, HoverVerbosityAction, InlayHint, InlayHintKind, InlayHintLabelPart, InlineCompletionTriggerKind, InlineEdit, InlineEditTriggerKind, InlineSuggestion, InlineSuggestionList, InlineValueContext, InlineValueEvaluatableExpression, InlineValueText, InlineValueVariableLookup, InputBoxValidationSeverity, InteractiveEditorResponseFeedbackKind, InteractiveSessionVoteDirection, InteractiveWindowInput, InternalDataTransferItem, InternalFileDataTransferItem, KeywordRecognitionStatus, LanguageModelChatMessage, LanguageModelChatMessageRole, LanguageModelError, LanguageModelTextPart, LanguageModelToolCallPart, LanguageModelToolResultPart, LanguageStatusSeverity, LinkedEditingRanges, Location, ManagedResolvedAuthority, MarkdownString, MultiDocumentHighlight, NewSymbolName, NewSymbolNameTag, NewSymbolNameTriggerKind, NotebookCellData, NotebookCellExecutionState, NotebookCellKind, NotebookCellOutput, NotebookCellOutputItem, NotebookCellStatusBarAlignment, NotebookCellStatusBarItem, NotebookControllerAffinity, NotebookControllerAffinity2, NotebookData, NotebookDiffEditorTabInput, NotebookEdit, NotebookEditorRevealType, NotebookEditorTabInput, NotebookKernelSourceAction, NotebookRange, NotebookRendererScript, NotebookVariablesRequestKind, ParameterInformation, PartialAcceptTriggerKind, PortAttributes, PortAutoForwardAction, Position, ProcessExecution, ProgressLocation, QuickInputButtonLocation, QuickInputButtons, QuickPickItemKind, Range, RelatedInformationType, RelativePattern, RemoteAuthorityResolverError, ResolvedAuthority, Selection, SelectionRange, SemanticTokens, SemanticTokensBuilder, SemanticTokensEdit, SemanticTokensEdits, SemanticTokensLegend, ShellExecution, ShellQuoting, SignatureHelp, SignatureHelpTriggerKind, SignatureInformation, SnippetString, SnippetTextEdit, SourceBreakpoint, SourceControlInputBoxValidationType, SpeechToTextStatus, StandardTokenType, StatementCoverage, StatusBarAlignment, SymbolInformation, SymbolKind, SymbolTag, SyntaxTokenType, Task, TaskGroup, TaskPanelKind, TaskRevealKind, TaskScope, TerminalEditorTabInput, TerminalExitReason, TerminalLink, TerminalLocation, TerminalOutputAnchor, TerminalProfile, TerminalQuickFixCommand, TerminalQuickFixOpener, TerminalShellExecutionCommandLineConfidence, TestCoverageCount, TestMessage, TestMessageStackFrame, TestResultState, TestRunProfileKind, TestRunRequest, TestTag, TextDiffTabInput, TextDocumentChangeReason, TextDocumentSaveReason, TextEdit, TextEditorLineNumbersStyle, TextEditorRevealType, TextEditorSelectionChangeKind, TextMergeTabInput, TextMultiDiffTabInput, TextTabInput, TextToSpeechStatus, ThemeColor, ThemeIcon, TimelineItem, TreeItem, TreeItemCheckboxState, TreeItemCollapsibleState, TypeHierarchyItem, VerboseHover, ViewBadge, ViewColumn, WebviewEditorTabInput, WorkspaceEdit, WorkspaceTrustState, asStatusBarItemIdentifier, getDebugDescriptionOfRange, getDebugDescriptionOfSelection, setBreakpointId, validateTestCoverageCount };\n","import { toDisposable } from '../../../base/common/lifecycle.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { MainContext } from './extHost.protocol.js';\nclass ExtHostUriOpeners {\n    static { this.supportedSchemes = ( new Set([Schemas.http, Schemas.https])); }\n    constructor(mainContext) {\n        this._openers = ( new Map());\n        this._proxy = ( mainContext.getProxy(MainContext.MainThreadUriOpeners));\n    }\n    registerExternalUriOpener(extensionId, id, opener, metadata) {\n        if (( this._openers.has(id))) {\n            throw ( new Error(`Opener with id '${id}' already registered`));\n        }\n        const invalidScheme = metadata.schemes.find(scheme => !( ExtHostUriOpeners.supportedSchemes.has(scheme)));\n        if (invalidScheme) {\n            throw ( new Error(\n                `Scheme '${invalidScheme}' is not supported. Only http and https are currently supported.`\n            ));\n        }\n        this._openers.set(id, opener);\n        this._proxy.$registerUriOpener(id, metadata.schemes, extensionId, metadata.label);\n        return toDisposable(() => {\n            this._openers.delete(id);\n            this._proxy.$unregisterUriOpener(id);\n        });\n    }\n    async $canOpenUri(id, uriComponents, token) {\n        const opener = this._openers.get(id);\n        if (!opener) {\n            throw ( new Error(`Unknown opener with id: ${id}`));\n        }\n        const uri = URI.revive(uriComponents);\n        return opener.canOpenExternalUri(uri, token);\n    }\n    async $openUri(id, context, token) {\n        const opener = this._openers.get(id);\n        if (!opener) {\n            throw ( new Error(`Unknown opener id: '${id}'`));\n        }\n        return opener.openExternalUri(URI.revive(context.resolvedUri), {\n            sourceUri: URI.revive(context.sourceUri)\n        }, token);\n    }\n}\nexport { ExtHostUriOpeners };\n","import { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nconst IURITransformerService = ( createDecorator('IURITransformerService'));\nclass URITransformerService {\n    constructor(delegate) {\n        if (!delegate) {\n            this.transformIncoming = arg => arg;\n            this.transformOutgoing = arg => arg;\n            this.transformOutgoingURI = arg => arg;\n            this.transformOutgoingScheme = arg => arg;\n        }\n        else {\n            this.transformIncoming = delegate.transformIncoming.bind(delegate);\n            this.transformOutgoing = delegate.transformOutgoing.bind(delegate);\n            this.transformOutgoingURI = delegate.transformOutgoingURI.bind(delegate);\n            this.transformOutgoingScheme = delegate.transformOutgoingScheme.bind(delegate);\n        }\n    }\n}\nexport { IURITransformerService, URITransformerService };\n","import { MainContext } from './extHost.protocol.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { toDisposable } from '../../../base/common/lifecycle.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { ExtensionIdentifierSet } from '../../../platform/extensions/common/extensions.js';\nclass ExtHostUrls {\n    static { this.HandlePool = 0; }\n    constructor(mainContext) {\n        this.handles = ( new ExtensionIdentifierSet());\n        this.handlers = ( new Map());\n        this._proxy = ( mainContext.getProxy(MainContext.MainThreadUrls));\n    }\n    registerUriHandler(extension, handler) {\n        const extensionId = extension.identifier;\n        if (( this.handles.has(extensionId))) {\n            throw ( new Error(`Protocol handler already registered for extension ${extensionId}`));\n        }\n        const handle = ExtHostUrls.HandlePool++;\n        this.handles.add(extensionId);\n        this.handlers.set(handle, handler);\n        this._proxy.$registerUriHandler(handle, extensionId, extension.displayName || extension.name);\n        return toDisposable(() => {\n            this.handles.delete(extensionId);\n            this.handlers.delete(handle);\n            this._proxy.$unregisterUriHandler(handle);\n        });\n    }\n    $handleExternalUri(handle, uri) {\n        const handler = this.handlers.get(handle);\n        if (!handler) {\n            return Promise.resolve(undefined);\n        }\n        try {\n            handler.handleUri(URI.revive(uri));\n        }\n        catch (err) {\n            onUnexpectedError(err);\n        }\n        return Promise.resolve(undefined);\n    }\n    async createAppUri(uri) {\n        return URI.revive(await this._proxy.$createAppUri(uri));\n    }\n}\nexport { ExtHostUrls };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { Lazy } from '../../../base/common/lazy.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { normalize } from '../../../base/common/path.js';\nimport { cwd, env } from '../../../base/common/process.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { IExtHostDocumentsAndEditors } from './extHostDocumentsAndEditors.js';\nimport { IExtHostEditorTabs } from './extHostEditorTabs.js';\nimport { IExtHostExtensionService } from './extHostExtensionService.js';\nimport { TextDiffTabInput, NotebookDiffEditorTabInput, TextTabInput, NotebookEditorTabInput, CustomEditorTabInput } from './extHostTypes.js';\nimport { IExtHostWorkspace } from './extHostWorkspace.js';\nimport { AbstractVariableResolverService } from '../../services/configurationResolver/common/variableResolver.js';\nimport { IExtHostConfiguration } from './extHostConfiguration.js';\nconst IExtHostVariableResolverProvider = ( createDecorator('IExtHostVariableResolverProvider'));\nclass ExtHostVariableResolverService extends AbstractVariableResolverService {\n    constructor(extensionService, workspaceService, editorService, editorTabs, configProvider, context, homeDir) {\n        function getActiveUri() {\n            if (editorService) {\n                const activeEditor = editorService.activeEditor();\n                if (activeEditor) {\n                    return activeEditor.document.uri;\n                }\n                const activeTab = editorTabs.tabGroups.all.find(group => group.isActive)?.activeTab;\n                if (activeTab !== undefined) {\n                    if (activeTab.input instanceof TextDiffTabInput || activeTab.input instanceof NotebookDiffEditorTabInput) {\n                        return activeTab.input.modified;\n                    }\n                    else if (activeTab.input instanceof TextTabInput || activeTab.input instanceof NotebookEditorTabInput || activeTab.input instanceof CustomEditorTabInput) {\n                        return activeTab.input.uri;\n                    }\n                }\n            }\n            return undefined;\n        }\n        super({\n            getFolderUri: (folderName) => {\n                const found = context.folders.filter(f => f.name === folderName);\n                if (found && found.length > 0) {\n                    return found[0].uri;\n                }\n                return undefined;\n            },\n            getWorkspaceFolderCount: () => {\n                return context.folders.length;\n            },\n            getConfigurationValue: (folderUri, section) => {\n                return configProvider.getConfiguration(undefined, folderUri).get(section);\n            },\n            getAppRoot: () => {\n                return cwd();\n            },\n            getExecPath: () => {\n                return env['VSCODE_EXEC_PATH'];\n            },\n            getFilePath: () => {\n                const activeUri = getActiveUri();\n                if (activeUri) {\n                    return normalize(activeUri.fsPath);\n                }\n                return undefined;\n            },\n            getWorkspaceFolderPathForFile: () => {\n                if (workspaceService) {\n                    const activeUri = getActiveUri();\n                    if (activeUri) {\n                        const ws = workspaceService.getWorkspaceFolder(activeUri);\n                        if (ws) {\n                            return normalize(ws.uri.fsPath);\n                        }\n                    }\n                }\n                return undefined;\n            },\n            getSelectedText: () => {\n                if (editorService) {\n                    const activeEditor = editorService.activeEditor();\n                    if (activeEditor && !activeEditor.selection.isEmpty) {\n                        return activeEditor.document.getText(activeEditor.selection);\n                    }\n                }\n                return undefined;\n            },\n            getLineNumber: () => {\n                if (editorService) {\n                    const activeEditor = editorService.activeEditor();\n                    if (activeEditor) {\n                        return String(activeEditor.selection.end.line + 1);\n                    }\n                }\n                return undefined;\n            },\n            getExtension: (id) => {\n                return extensionService.getExtension(id);\n            },\n        }, undefined, homeDir ? Promise.resolve(homeDir) : undefined, Promise.resolve(env));\n    }\n}\nlet ExtHostVariableResolverProviderService = class ExtHostVariableResolverProviderService extends Disposable {\n    constructor(extensionService, workspaceService, editorService, configurationService, editorTabs) {\n        super();\n        this.extensionService = extensionService;\n        this.workspaceService = workspaceService;\n        this.editorService = editorService;\n        this.configurationService = configurationService;\n        this.editorTabs = editorTabs;\n        this._resolver = ( new Lazy(async () => {\n            const configProvider = await this.configurationService.getConfigProvider();\n            const folders = (await this.workspaceService.getWorkspaceFolders2()) || [];\n            const dynamic = { folders };\n            this._register(this.workspaceService.onDidChangeWorkspace(async (e) => {\n                dynamic.folders = (await this.workspaceService.getWorkspaceFolders2()) || [];\n            }));\n            return ( new ExtHostVariableResolverService(\n                this.extensionService,\n                this.workspaceService,\n                this.editorService,\n                this.editorTabs,\n                configProvider,\n                dynamic,\n                this.homeDir()\n            ));\n        }));\n    }\n    getResolver() {\n        return this._resolver.value;\n    }\n    homeDir() {\n        return undefined;\n    }\n};\nExtHostVariableResolverProviderService = ( __decorate([\n    ( __param(0, IExtHostExtensionService)),\n    ( __param(1, IExtHostWorkspace)),\n    ( __param(2, IExtHostDocumentsAndEditors)),\n    ( __param(3, IExtHostConfiguration)),\n    ( __param(4, IExtHostEditorTabs))\n], ExtHostVariableResolverProviderService));\nexport { ExtHostVariableResolverProviderService, IExtHostVariableResolverProvider };\n","import { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { equals } from '../../../base/common/objects.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { normalizeVersion, parseVersion } from '../../../platform/extensions/common/extensionValidator.js';\nimport { deserializeWebviewMessage, serializeWebviewMessage } from './extHostWebviewMessaging.js';\nimport { asWebviewUri, webviewGenericCspSource } from '../../contrib/webview/common/webview.js';\nimport { MainContext } from './extHost.protocol.js';\nclass ExtHostWebview {\n    #handle;\n    #proxy;\n    #deprecationService;\n    #remoteInfo;\n    #workspace;\n    #extension;\n    #html;\n    #options;\n    #isDisposed;\n    #hasCalledAsWebviewUri;\n    #serializeBuffersForPostMessage;\n    #shouldRewriteOldResourceUris;\n    constructor(handle, proxy, options, remoteInfo, workspace, extension, deprecationService) {\n        this.#html = '';\n        this.#isDisposed = false;\n        this.#hasCalledAsWebviewUri = false;\n         this._onMessageEmitter = ( new Emitter());\n        this.onDidReceiveMessage = this._onMessageEmitter.event;\n        this.#onDidDisposeEmitter = ( new Emitter());\n         this._onDidDispose = this.#onDidDisposeEmitter.event;\n        this.#handle = handle;\n        this.#proxy = proxy;\n        this.#options = options;\n        this.#remoteInfo = remoteInfo;\n        this.#workspace = workspace;\n        this.#extension = extension;\n        this.#serializeBuffersForPostMessage = shouldSerializeBuffersForPostMessage(extension);\n        this.#shouldRewriteOldResourceUris = shouldTryRewritingOldResourceUris(extension);\n        this.#deprecationService = deprecationService;\n    }\n    #onDidDisposeEmitter;\n    dispose() {\n        this.#isDisposed = true;\n        this.#onDidDisposeEmitter.fire();\n        this.#onDidDisposeEmitter.dispose();\n        this._onMessageEmitter.dispose();\n    }\n    asWebviewUri(resource) {\n        this.#hasCalledAsWebviewUri = true;\n        return asWebviewUri(resource, this.#remoteInfo);\n    }\n    get cspSource() {\n        const extensionLocation = this.#extension.extensionLocation;\n        if (extensionLocation.scheme === Schemas.https || extensionLocation.scheme === Schemas.http) {\n            let extensionCspRule = ( extensionLocation.toString());\n            if (!extensionCspRule.endsWith('/')) {\n                extensionCspRule += '/';\n            }\n            return extensionCspRule + ' ' + webviewGenericCspSource;\n        }\n        return webviewGenericCspSource;\n    }\n    get html() {\n        this.assertNotDisposed();\n        return this.#html;\n    }\n    set html(value) {\n        this.assertNotDisposed();\n        if (this.#html !== value) {\n            this.#html = value;\n            if (this.#shouldRewriteOldResourceUris && !this.#hasCalledAsWebviewUri && /([\"'])vscode-resource:([^\\s'\"]+?)([\"'])/i.test(value)) {\n                this.#hasCalledAsWebviewUri = true;\n                this.#deprecationService.report('Webview vscode-resource: uris', this.#extension, `Please migrate to use the 'webview.asWebviewUri' api instead: https://aka.ms/vscode-webview-use-aswebviewuri`);\n            }\n            this.#proxy.$setHtml(this.#handle, this.rewriteOldResourceUrlsIfNeeded(value));\n        }\n    }\n    get options() {\n        this.assertNotDisposed();\n        return this.#options;\n    }\n    set options(newOptions) {\n        this.assertNotDisposed();\n        if (!equals(this.#options, newOptions)) {\n            this.#proxy.$setOptions(this.#handle, serializeWebviewOptions(this.#extension, this.#workspace, newOptions));\n        }\n        this.#options = newOptions;\n    }\n    async postMessage(message) {\n        if (this.#isDisposed) {\n            return false;\n        }\n        const serialized = serializeWebviewMessage(message, { serializeBuffersForPostMessage: this.#serializeBuffersForPostMessage });\n        return this.#proxy.$postMessage(this.#handle, serialized.message, ...serialized.buffers);\n    }\n    assertNotDisposed() {\n        if (this.#isDisposed) {\n            throw ( new Error('Webview is disposed'));\n        }\n    }\n    rewriteOldResourceUrlsIfNeeded(value) {\n        if (!this.#shouldRewriteOldResourceUris) {\n            return value;\n        }\n        const isRemote = this.#extension.extensionLocation?.scheme === Schemas.vscodeRemote;\n        const remoteAuthority = this.#extension.extensionLocation.scheme === Schemas.vscodeRemote ? this.#extension.extensionLocation.authority : undefined;\n        return value\n            .replace(/([\"'])(?:vscode-resource):(\\/\\/([^\\s\\/'\"]+?)(?=\\/))?([^\\s'\"]+?)([\"'])/gi, (_match, startQuote, _1, scheme, path, endQuote) => {\n            const uri = ( URI.from({\n                scheme: scheme || 'file',\n                path: decodeURIComponent(path),\n            }));\n            const webviewUri = ( asWebviewUri(uri, { isRemote, authority: remoteAuthority }).toString());\n            return `${startQuote}${webviewUri}${endQuote}`;\n        })\n            .replace(/([\"'])(?:vscode-webview-resource):(\\/\\/[^\\s\\/'\"]+\\/([^\\s\\/'\"]+?)(?=\\/))?([^\\s'\"]+?)([\"'])/gi, (_match, startQuote, _1, scheme, path, endQuote) => {\n            const uri = ( URI.from({\n                scheme: scheme || 'file',\n                path: decodeURIComponent(path),\n            }));\n            const webviewUri = ( asWebviewUri(uri, { isRemote, authority: remoteAuthority }).toString());\n            return `${startQuote}${webviewUri}${endQuote}`;\n        });\n    }\n}\nfunction shouldSerializeBuffersForPostMessage(extension) {\n    try {\n        const version = normalizeVersion(parseVersion(extension.engines.vscode));\n        return !!version && version.majorBase >= 1 && version.minorBase >= 57;\n    }\n    catch {\n        return false;\n    }\n}\nfunction shouldTryRewritingOldResourceUris(extension) {\n    try {\n        const version = normalizeVersion(parseVersion(extension.engines.vscode));\n        if (!version) {\n            return false;\n        }\n        return version.majorBase < 1 || (version.majorBase === 1 && version.minorBase < 60);\n    }\n    catch {\n        return false;\n    }\n}\nclass ExtHostWebviews extends Disposable {\n    constructor(mainContext, remoteInfo, workspace, _logService, _deprecationService) {\n        super();\n        this.remoteInfo = remoteInfo;\n        this.workspace = workspace;\n        this._logService = _logService;\n        this._deprecationService = _deprecationService;\n        this._webviews = ( new Map());\n        this._webviewProxy = ( mainContext.getProxy(MainContext.MainThreadWebviews));\n    }\n    dispose() {\n        super.dispose();\n        for (const webview of ( this._webviews.values())) {\n            webview.dispose();\n        }\n        this._webviews.clear();\n    }\n    $onMessage(handle, jsonMessage, buffers) {\n        const webview = this.getWebview(handle);\n        if (webview) {\n            const { message } = deserializeWebviewMessage(jsonMessage, buffers.value);\n            webview._onMessageEmitter.fire(message);\n        }\n    }\n    $onMissingCsp(_handle, extensionId) {\n        this._logService.warn(`${extensionId} created a webview without a content security policy: https://aka.ms/vscode-webview-missing-csp`);\n    }\n    createNewWebview(handle, options, extension) {\n        const webview = ( new ExtHostWebview(\n            handle,\n            this._webviewProxy,\n            reviveOptions(options),\n            this.remoteInfo,\n            this.workspace,\n            extension,\n            this._deprecationService\n        ));\n        this._webviews.set(handle, webview);\n        const sub = webview._onDidDispose(() => {\n            sub.dispose();\n            this.deleteWebview(handle);\n        });\n        return webview;\n    }\n    deleteWebview(handle) {\n        this._webviews.delete(handle);\n    }\n    getWebview(handle) {\n        return this._webviews.get(handle);\n    }\n}\nfunction toExtensionData(extension) {\n    return { id: extension.identifier, location: extension.extensionLocation };\n}\nfunction serializeWebviewOptions(extension, workspace, options) {\n    return {\n        enableCommandUris: options.enableCommandUris,\n        enableScripts: options.enableScripts,\n        enableForms: options.enableForms,\n        portMapping: options.portMapping,\n        localResourceRoots: options.localResourceRoots || getDefaultLocalResourceRoots(extension, workspace)\n    };\n}\nfunction reviveOptions(options) {\n    return {\n        enableCommandUris: options.enableCommandUris,\n        enableScripts: options.enableScripts,\n        enableForms: options.enableForms,\n        portMapping: options.portMapping,\n        localResourceRoots: options.localResourceRoots?.map(components => ( URI.from(components))),\n    };\n}\nfunction getDefaultLocalResourceRoots(extension, workspace) {\n    return [\n        ...( (workspace?.getWorkspaceFolders() || []).map(x => x.uri)),\n        extension.extensionLocation,\n    ];\n}\nexport { ExtHostWebview, ExtHostWebviews, serializeWebviewOptions, shouldSerializeBuffersForPostMessage, toExtensionData };\n","import { VSBuffer } from '../../../base/common/buffer.js';\nclass ArrayBufferSet {\n    constructor() {\n        this.buffers = [];\n    }\n    add(buffer) {\n        let index = this.buffers.indexOf(buffer);\n        if (index < 0) {\n            index = this.buffers.length;\n            this.buffers.push(buffer);\n        }\n        return index;\n    }\n}\nfunction serializeWebviewMessage(message, options) {\n    if (options.serializeBuffersForPostMessage) {\n        const arrayBuffers = ( new ArrayBufferSet());\n        const replacer = (_key, value) => {\n            if (value instanceof ArrayBuffer) {\n                const index = arrayBuffers.add(value);\n                return {\n                    $$vscode_array_buffer_reference$$: true,\n                    index,\n                };\n            }\n            else if (ArrayBuffer.isView(value)) {\n                const type = getTypedArrayType(value);\n                if (type) {\n                    const index = arrayBuffers.add(value.buffer);\n                    return {\n                        $$vscode_array_buffer_reference$$: true,\n                        index,\n                        view: {\n                            type: type,\n                            byteLength: value.byteLength,\n                            byteOffset: value.byteOffset,\n                        }\n                    };\n                }\n            }\n            return value;\n        };\n        const serializedMessage = JSON.stringify(message, replacer);\n        const buffers = ( arrayBuffers.buffers.map(arrayBuffer => {\n            const bytes = ( new Uint8Array(arrayBuffer));\n            return VSBuffer.wrap(bytes);\n        }));\n        return { message: serializedMessage, buffers };\n    }\n    else {\n        return { message: JSON.stringify(message), buffers: [] };\n    }\n}\nfunction getTypedArrayType(value) {\n    switch (value.constructor.name) {\n        case 'Int8Array': return 1 ;\n        case 'Uint8Array': return 2 ;\n        case 'Uint8ClampedArray': return 3 ;\n        case 'Int16Array': return 4 ;\n        case 'Uint16Array': return 5 ;\n        case 'Int32Array': return 6 ;\n        case 'Uint32Array': return 7 ;\n        case 'Float32Array': return 8 ;\n        case 'Float64Array': return 9 ;\n        case 'BigInt64Array': return 10 ;\n        case 'BigUint64Array': return 11 ;\n    }\n    return undefined;\n}\nfunction deserializeWebviewMessage(jsonMessage, buffers) {\n    const arrayBuffers = ( buffers.map(buffer => {\n        const arrayBuffer = ( new ArrayBuffer(buffer.byteLength));\n        const uint8Array = ( new Uint8Array(arrayBuffer));\n        uint8Array.set(buffer.buffer);\n        return arrayBuffer;\n    }));\n    const reviver = !buffers.length ? undefined : (_key, value) => {\n        if (value && typeof value === 'object' && value.$$vscode_array_buffer_reference$$) {\n            const ref = value;\n            const { index } = ref;\n            const arrayBuffer = arrayBuffers[index];\n            if (ref.view) {\n                switch (ref.view.type) {\n                    case 1 : return ( new Int8Array(\n                        arrayBuffer,\n                        ref.view.byteOffset,\n                        ref.view.byteLength / Int8Array.BYTES_PER_ELEMENT\n                    ));\n                    case 2 : return ( new Uint8Array(\n                        arrayBuffer,\n                        ref.view.byteOffset,\n                        ref.view.byteLength / Uint8Array.BYTES_PER_ELEMENT\n                    ));\n                    case 3 : return ( new Uint8ClampedArray(\n                        arrayBuffer,\n                        ref.view.byteOffset,\n                        ref.view.byteLength / Uint8ClampedArray.BYTES_PER_ELEMENT\n                    ));\n                    case 4 : return ( new Int16Array(\n                        arrayBuffer,\n                        ref.view.byteOffset,\n                        ref.view.byteLength / Int16Array.BYTES_PER_ELEMENT\n                    ));\n                    case 5 : return ( new Uint16Array(\n                        arrayBuffer,\n                        ref.view.byteOffset,\n                        ref.view.byteLength / Uint16Array.BYTES_PER_ELEMENT\n                    ));\n                    case 6 : return ( new Int32Array(\n                        arrayBuffer,\n                        ref.view.byteOffset,\n                        ref.view.byteLength / Int32Array.BYTES_PER_ELEMENT\n                    ));\n                    case 7 : return ( new Uint32Array(\n                        arrayBuffer,\n                        ref.view.byteOffset,\n                        ref.view.byteLength / Uint32Array.BYTES_PER_ELEMENT\n                    ));\n                    case 8 : return ( new Float32Array(\n                        arrayBuffer,\n                        ref.view.byteOffset,\n                        ref.view.byteLength / Float32Array.BYTES_PER_ELEMENT\n                    ));\n                    case 9 : return ( new Float64Array(\n                        arrayBuffer,\n                        ref.view.byteOffset,\n                        ref.view.byteLength / Float64Array.BYTES_PER_ELEMENT\n                    ));\n                    case 10 : return ( new BigInt64Array(\n                        arrayBuffer,\n                        ref.view.byteOffset,\n                        ref.view.byteLength / BigInt64Array.BYTES_PER_ELEMENT\n                    ));\n                    case 11 : return ( new BigUint64Array(\n                        arrayBuffer,\n                        ref.view.byteOffset,\n                        ref.view.byteLength / BigUint64Array.BYTES_PER_ELEMENT\n                    ));\n                    default: throw ( new Error('Unknown array buffer view type'));\n                }\n            }\n            return arrayBuffer;\n        }\n        return value;\n    };\n    const message = JSON.parse(jsonMessage, reviver);\n    return { message, arrayBuffers };\n}\nexport { deserializeWebviewMessage, serializeWebviewMessage };\n","import { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { generateUuid } from '../../../base/common/uuid.js';\nimport { ViewColumn } from './extHostTypeConverters.js';\nimport { shouldSerializeBuffersForPostMessage, toExtensionData, serializeWebviewOptions } from './extHostWebview.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { Disposable as Disposable$1 } from './extHostTypes.js';\nclass ExtHostWebviewPanel extends Disposable {\n    #handle;\n    #proxy;\n    #viewType;\n    #webview;\n    #options;\n    #title;\n    #iconPath;\n    #viewColumn;\n    #visible;\n    #active;\n    #isDisposed;\n    #onDidDispose;\n    #onDidChangeViewState;\n    constructor(handle, proxy, webview, params) {\n        super();\n        this.#viewColumn = undefined;\n        this.#visible = true;\n        this.#isDisposed = false;\n        this.#onDidDispose = this._register(( new Emitter()));\n        this.onDidDispose = this.#onDidDispose.event;\n        this.#onDidChangeViewState = this._register(( new Emitter()));\n        this.onDidChangeViewState = this.#onDidChangeViewState.event;\n        this.#handle = handle;\n        this.#proxy = proxy;\n        this.#webview = webview;\n        this.#viewType = params.viewType;\n        this.#options = params.panelOptions;\n        this.#viewColumn = params.viewColumn;\n        this.#title = params.title;\n        this.#active = params.active;\n    }\n    dispose() {\n        if (this.#isDisposed) {\n            return;\n        }\n        this.#isDisposed = true;\n        this.#onDidDispose.fire();\n        this.#proxy.$disposeWebview(this.#handle);\n        this.#webview.dispose();\n        super.dispose();\n    }\n    get webview() {\n        this.assertNotDisposed();\n        return this.#webview;\n    }\n    get viewType() {\n        this.assertNotDisposed();\n        return this.#viewType;\n    }\n    get title() {\n        this.assertNotDisposed();\n        return this.#title;\n    }\n    set title(value) {\n        this.assertNotDisposed();\n        if (this.#title !== value) {\n            this.#title = value;\n            this.#proxy.$setTitle(this.#handle, value);\n        }\n    }\n    get iconPath() {\n        this.assertNotDisposed();\n        return this.#iconPath;\n    }\n    set iconPath(value) {\n        this.assertNotDisposed();\n        if (this.#iconPath !== value) {\n            this.#iconPath = value;\n            this.#proxy.$setIconPath(this.#handle, URI.isUri(value) ? { light: value, dark: value } : value);\n        }\n    }\n    get options() {\n        return this.#options;\n    }\n    get viewColumn() {\n        this.assertNotDisposed();\n        if (typeof this.#viewColumn === 'number' && this.#viewColumn < 0) {\n            return undefined;\n        }\n        return this.#viewColumn;\n    }\n    get active() {\n        this.assertNotDisposed();\n        return this.#active;\n    }\n    get visible() {\n        this.assertNotDisposed();\n        return this.#visible;\n    }\n    _updateViewState(newState) {\n        if (this.#isDisposed) {\n            return;\n        }\n        if (this.active !== newState.active || this.visible !== newState.visible || this.viewColumn !== newState.viewColumn) {\n            this.#active = newState.active;\n            this.#visible = newState.visible;\n            this.#viewColumn = newState.viewColumn;\n            this.#onDidChangeViewState.fire({ webviewPanel: this });\n        }\n    }\n    reveal(viewColumn, preserveFocus) {\n        this.assertNotDisposed();\n        this.#proxy.$reveal(this.#handle, {\n            viewColumn: typeof viewColumn === 'undefined' ? undefined : ViewColumn.from(viewColumn),\n            preserveFocus: !!preserveFocus\n        });\n    }\n    assertNotDisposed() {\n        if (this.#isDisposed) {\n            throw ( new Error('Webview is disposed'));\n        }\n    }\n}\nclass ExtHostWebviewPanels extends Disposable {\n    static newHandle() {\n        return generateUuid();\n    }\n    constructor(mainContext, webviews, workspace) {\n        super();\n        this.webviews = webviews;\n        this.workspace = workspace;\n        this._webviewPanels = ( new Map());\n        this._serializers = ( new Map());\n        this._proxy = ( mainContext.getProxy(MainContext.MainThreadWebviewPanels));\n    }\n    dispose() {\n        super.dispose();\n        this._webviewPanels.forEach(value => value.dispose());\n        this._webviewPanels.clear();\n    }\n    createWebviewPanel(extension, viewType, title, showOptions, options = {}) {\n        const viewColumn = typeof showOptions === 'object' ? showOptions.viewColumn : showOptions;\n        const webviewShowOptions = {\n            viewColumn: ViewColumn.from(viewColumn),\n            preserveFocus: typeof showOptions === 'object' && !!showOptions.preserveFocus\n        };\n        const serializeBuffersForPostMessage = shouldSerializeBuffersForPostMessage(extension);\n        const handle = ExtHostWebviewPanels.newHandle();\n        this._proxy.$createWebviewPanel(toExtensionData(extension), handle, viewType, {\n            title,\n            panelOptions: serializeWebviewPanelOptions(options),\n            webviewOptions: serializeWebviewOptions(extension, this.workspace, options),\n            serializeBuffersForPostMessage,\n        }, webviewShowOptions);\n        const webview = this.webviews.createNewWebview(handle, options, extension);\n        const panel = this.createNewWebviewPanel(handle, viewType, title, viewColumn, options, webview, true);\n        return panel;\n    }\n    $onDidChangeWebviewPanelViewStates(newStates) {\n        const handles = ( Object.keys(newStates));\n        handles.sort((a, b) => {\n            const stateA = newStates[a];\n            const stateB = newStates[b];\n            if (stateA.active) {\n                return 1;\n            }\n            if (stateB.active) {\n                return -1;\n            }\n            return (+stateA.visible) - (+stateB.visible);\n        });\n        for (const handle of handles) {\n            const panel = this.getWebviewPanel(handle);\n            if (!panel) {\n                continue;\n            }\n            const newState = newStates[handle];\n            panel._updateViewState({\n                active: newState.active,\n                visible: newState.visible,\n                viewColumn: ViewColumn.to(newState.position),\n            });\n        }\n    }\n    async $onDidDisposeWebviewPanel(handle) {\n        const panel = this.getWebviewPanel(handle);\n        panel?.dispose();\n        this._webviewPanels.delete(handle);\n        this.webviews.deleteWebview(handle);\n    }\n    registerWebviewPanelSerializer(extension, viewType, serializer) {\n        if (( this._serializers.has(viewType))) {\n            throw ( new Error(`Serializer for '${viewType}' already registered`));\n        }\n        this._serializers.set(viewType, { serializer, extension });\n        this._proxy.$registerSerializer(viewType, {\n            serializeBuffersForPostMessage: shouldSerializeBuffersForPostMessage(extension)\n        });\n        return new Disposable$1(() => {\n            this._serializers.delete(viewType);\n            this._proxy.$unregisterSerializer(viewType);\n        });\n    }\n    async $deserializeWebviewPanel(webviewHandle, viewType, initData, position) {\n        const entry = this._serializers.get(viewType);\n        if (!entry) {\n            throw ( new Error(`No serializer found for '${viewType}'`));\n        }\n        const { serializer, extension } = entry;\n        const webview = this.webviews.createNewWebview(webviewHandle, initData.webviewOptions, extension);\n        const revivedPanel = this.createNewWebviewPanel(webviewHandle, viewType, initData.title, position, initData.panelOptions, webview, initData.active);\n        await serializer.deserializeWebviewPanel(revivedPanel, initData.state);\n    }\n    createNewWebviewPanel(webviewHandle, viewType, title, position, options, webview, active) {\n        const panel = ( new ExtHostWebviewPanel(\n            webviewHandle,\n            this._proxy,\n            webview,\n            { viewType, title, viewColumn: position, panelOptions: options, active }\n        ));\n        this._webviewPanels.set(webviewHandle, panel);\n        return panel;\n    }\n    getWebviewPanel(handle) {\n        return this._webviewPanels.get(handle);\n    }\n}\nfunction serializeWebviewPanelOptions(options) {\n    return {\n        enableFindWidget: options.enableFindWidget,\n        retainContextWhenHidden: options.retainContextWhenHidden,\n    };\n}\nexport { ExtHostWebviewPanels };\n","import { Emitter } from '../../../base/common/event.js';\nimport { Disposable as Disposable$1 } from '../../../base/common/lifecycle.js';\nimport { toExtensionData, shouldSerializeBuffersForPostMessage } from './extHostWebview.js';\nimport { ViewBadge } from './extHostTypeConverters.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { Disposable } from './extHostTypes.js';\nclass ExtHostWebviewView extends Disposable$1 {\n    #handle;\n    #proxy;\n    #viewType;\n    #webview;\n    #isDisposed;\n    #isVisible;\n    #title;\n    #description;\n    #badge;\n    constructor(handle, proxy, viewType, title, webview, isVisible) {\n        super();\n        this.#isDisposed = false;\n        this.#onDidChangeVisibility = this._register(( new Emitter()));\n        this.onDidChangeVisibility = this.#onDidChangeVisibility.event;\n        this.#onDidDispose = this._register(( new Emitter()));\n        this.onDidDispose = this.#onDidDispose.event;\n        this.#viewType = viewType;\n        this.#title = title;\n        this.#handle = handle;\n        this.#proxy = proxy;\n        this.#webview = webview;\n        this.#isVisible = isVisible;\n    }\n    dispose() {\n        if (this.#isDisposed) {\n            return;\n        }\n        this.#isDisposed = true;\n        this.#onDidDispose.fire();\n        this.#webview.dispose();\n        super.dispose();\n    }\n    #onDidChangeVisibility;\n    #onDidDispose;\n    get title() {\n        this.assertNotDisposed();\n        return this.#title;\n    }\n    set title(value) {\n        this.assertNotDisposed();\n        if (this.#title !== value) {\n            this.#title = value;\n            this.#proxy.$setWebviewViewTitle(this.#handle, value);\n        }\n    }\n    get description() {\n        this.assertNotDisposed();\n        return this.#description;\n    }\n    set description(value) {\n        this.assertNotDisposed();\n        if (this.#description !== value) {\n            this.#description = value;\n            this.#proxy.$setWebviewViewDescription(this.#handle, value);\n        }\n    }\n    get visible() { return this.#isVisible; }\n    get webview() { return this.#webview; }\n    get viewType() { return this.#viewType; }\n     _setVisible(visible) {\n        if (visible === this.#isVisible || this.#isDisposed) {\n            return;\n        }\n        this.#isVisible = visible;\n        this.#onDidChangeVisibility.fire();\n    }\n    get badge() {\n        this.assertNotDisposed();\n        return this.#badge;\n    }\n    set badge(badge) {\n        this.assertNotDisposed();\n        if (badge?.value === this.#badge?.value &&\n            badge?.tooltip === this.#badge?.tooltip) {\n            return;\n        }\n        this.#badge = ViewBadge.from(badge);\n        this.#proxy.$setWebviewViewBadge(this.#handle, badge);\n    }\n    show(preserveFocus) {\n        this.assertNotDisposed();\n        this.#proxy.$show(this.#handle, !!preserveFocus);\n    }\n    assertNotDisposed() {\n        if (this.#isDisposed) {\n            throw ( new Error('Webview is disposed'));\n        }\n    }\n}\nclass ExtHostWebviewViews {\n    constructor(mainContext, _extHostWebview) {\n        this._extHostWebview = _extHostWebview;\n        this._viewProviders = ( new Map());\n        this._webviewViews = ( new Map());\n        this._proxy = ( mainContext.getProxy(MainContext.MainThreadWebviewViews));\n    }\n    registerWebviewViewProvider(extension, viewType, provider, webviewOptions) {\n        if (( this._viewProviders.has(viewType))) {\n            throw ( new Error(`View provider for '${viewType}' already registered`));\n        }\n        this._viewProviders.set(viewType, { provider, extension });\n        this._proxy.$registerWebviewViewProvider(toExtensionData(extension), viewType, {\n            retainContextWhenHidden: webviewOptions?.retainContextWhenHidden,\n            serializeBuffersForPostMessage: shouldSerializeBuffersForPostMessage(extension),\n        });\n        return new Disposable(() => {\n            this._viewProviders.delete(viewType);\n            this._proxy.$unregisterWebviewViewProvider(viewType);\n        });\n    }\n    async $resolveWebviewView(webviewHandle, viewType, title, state, cancellation) {\n        const entry = this._viewProviders.get(viewType);\n        if (!entry) {\n            throw ( new Error(`No view provider found for '${viewType}'`));\n        }\n        const { provider, extension } = entry;\n        const webview = this._extHostWebview.createNewWebview(webviewHandle, { }, extension);\n        const revivedView = ( new ExtHostWebviewView(webviewHandle, this._proxy, viewType, title, webview, true));\n        this._webviewViews.set(webviewHandle, revivedView);\n        await provider.resolveWebviewView(revivedView, { state }, cancellation);\n    }\n    async $onDidChangeWebviewViewVisibility(webviewHandle, visible) {\n        const webviewView = this.getWebviewView(webviewHandle);\n        webviewView._setVisible(visible);\n    }\n    async $disposeWebviewView(webviewHandle) {\n        const webviewView = this.getWebviewView(webviewHandle);\n        this._webviewViews.delete(webviewHandle);\n        webviewView.dispose();\n        this._extHostWebview.deleteWebview(webviewHandle);\n    }\n    getWebviewView(handle) {\n        const entry = this._webviewViews.get(handle);\n        if (!entry) {\n            throw ( new Error('No webview found'));\n        }\n        return entry;\n    }\n}\nexport { ExtHostWebviewViews };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { isFalsyOrWhitespace } from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\nimport { MainContext } from './extHost.protocol.js';\nvar ExtHostWindow_1;\nlet ExtHostWindow = class ExtHostWindow {\n    static { ExtHostWindow_1 = this; }\n    static { this.InitialState = {\n        focused: true,\n        active: true,\n    }; }\n    getState() {\n        const state = this._state;\n        return {\n            get focused() {\n                return state.focused;\n            },\n            get active() {\n                return state.active;\n            },\n        };\n    }\n    constructor(extHostRpc) {\n        this._onDidChangeWindowState = ( new Emitter());\n        this.onDidChangeWindowState = this._onDidChangeWindowState.event;\n        this._state = ExtHostWindow_1.InitialState;\n        this._proxy = ( extHostRpc.getProxy(MainContext.MainThreadWindow));\n        this._proxy.$getInitialState().then(({ isFocused, isActive }) => {\n            this.onDidChangeWindowProperty('focused', isFocused);\n            this.onDidChangeWindowProperty('active', isActive);\n        });\n    }\n    $onDidChangeWindowFocus(value) {\n        this.onDidChangeWindowProperty('focused', value);\n    }\n    $onDidChangeWindowActive(value) {\n        this.onDidChangeWindowProperty('active', value);\n    }\n    onDidChangeWindowProperty(property, value) {\n        if (value === this._state[property]) {\n            return;\n        }\n        this._state = { ...this._state, [property]: value };\n        this._onDidChangeWindowState.fire(this._state);\n    }\n    openUri(stringOrUri, options) {\n        let uriAsString;\n        if (typeof stringOrUri === 'string') {\n            uriAsString = stringOrUri;\n            try {\n                stringOrUri = ( URI.parse(stringOrUri));\n            }\n            catch (e) {\n                return Promise.reject(`Invalid uri - '${stringOrUri}'`);\n            }\n        }\n        if (isFalsyOrWhitespace(stringOrUri.scheme)) {\n            return Promise.reject('Invalid scheme - cannot be empty');\n        }\n        else if (stringOrUri.scheme === Schemas.command) {\n            return Promise.reject(`Invalid scheme '${stringOrUri.scheme}'`);\n        }\n        return this._proxy.$openUri(stringOrUri, uriAsString, options);\n    }\n    async asExternalUri(uri, options) {\n        if (isFalsyOrWhitespace(uri.scheme)) {\n            return Promise.reject('Invalid scheme - cannot be empty');\n        }\n        const result = await this._proxy.$asExternalUri(uri, options);\n        return ( URI.from(result));\n    }\n};\nExtHostWindow = ExtHostWindow_1 = ( __decorate([\n    ( __param(0, IExtHostRpcService))\n], ExtHostWindow));\nconst IExtHostWindow = ( createDecorator('IExtHostWindow'));\nexport { ExtHostWindow, IExtHostWindow };\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { delta as delta$1, mapArrayOrNot } from '../../../base/common/arrays.js';\nimport { Barrier, AsyncIterableObject } from '../../../base/common/async.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { Emitter, AsyncEmitter } from '../../../base/common/event.js';\nimport { toDisposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport { TernarySearchTree } from '../../../base/common/ternarySearchTree.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { Counter } from '../../../base/common/numbers.js';\nimport { basename, dirname, basenameOrAuthority, relativePath, ExtUri } from '../../../base/common/resources.js';\nimport { compare } from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { localize } from '../../../nls.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { ILogService } from '../../../platform/log/common/log.service.js';\nimport '../../../platform/notification/common/notification.js';\nimport { Workspace as Workspace$1, WorkspaceFolder } from '../../../platform/workspace/common/workspace.js';\nimport { IExtHostFileSystemInfo } from './extHostFileSystemInfo.js';\nimport { IExtHostInitDataService } from './extHostInitDataService.js';\nimport { IExtHostRpcService } from './extHostRpcService.js';\nimport { GlobPattern } from './extHostTypeConverters.js';\nimport { Range } from './extHostTypes.js';\nimport { IURITransformerService } from './extHostUriTransformerService.js';\nimport { resultIsMatch } from '../../services/search/common/search.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { revive } from '../../../base/common/marshalling.js';\nimport { ExcludeSettingOptions, TextSearchMatchNew, TextSearchContextNew } from '../../services/search/common/searchExtTypes.js';\nimport Severity$1 from '../../../base/common/severity.js';\nfunction isFolderEqual(folderA, folderB, extHostFileSystemInfo) {\n    return ( (new ExtUri(uri => ignorePathCasing(uri, extHostFileSystemInfo)))).isEqual(folderA, folderB);\n}\nfunction compareWorkspaceFolderByUri(a, b, extHostFileSystemInfo) {\n    return isFolderEqual(a.uri, b.uri, extHostFileSystemInfo) ? 0 : compare(( (a.uri.toString())), ( (b.uri.toString())));\n}\nfunction compareWorkspaceFolderByUriAndNameAndIndex(a, b, extHostFileSystemInfo) {\n    if (a.index !== b.index) {\n        return a.index < b.index ? -1 : 1;\n    }\n    return isFolderEqual(a.uri, b.uri, extHostFileSystemInfo) ? compare(a.name, b.name) : compare(( (a.uri.toString())), ( (b.uri.toString())));\n}\nfunction delta(oldFolders, newFolders, compare, extHostFileSystemInfo) {\n    const oldSortedFolders = oldFolders.slice(0).sort((a, b) => compare(a, b, extHostFileSystemInfo));\n    const newSortedFolders = newFolders.slice(0).sort((a, b) => compare(a, b, extHostFileSystemInfo));\n    return delta$1(oldSortedFolders, newSortedFolders, (a, b) => compare(a, b, extHostFileSystemInfo));\n}\nfunction ignorePathCasing(uri, extHostFileSystemInfo) {\n    const capabilities = extHostFileSystemInfo.getCapabilities(uri.scheme);\n    return !(capabilities && ((capabilities & 1024) ));\n}\nclass ExtHostWorkspaceImpl extends Workspace$1 {\n    static toExtHostWorkspace(data, previousConfirmedWorkspace, previousUnconfirmedWorkspace, extHostFileSystemInfo) {\n        if (!data) {\n            return { workspace: null, added: [], removed: [] };\n        }\n        const { id, name, folders, configuration, transient, isUntitled } = data;\n        const newWorkspaceFolders = [];\n        const oldWorkspace = previousConfirmedWorkspace;\n        if (previousConfirmedWorkspace) {\n            folders.forEach((folderData, index) => {\n                const folderUri = URI.revive(folderData.uri);\n                const existingFolder = ExtHostWorkspaceImpl._findFolder(previousUnconfirmedWorkspace || previousConfirmedWorkspace, folderUri, extHostFileSystemInfo);\n                if (existingFolder) {\n                    existingFolder.name = folderData.name;\n                    existingFolder.index = folderData.index;\n                    newWorkspaceFolders.push(existingFolder);\n                }\n                else {\n                    newWorkspaceFolders.push({ uri: folderUri, name: folderData.name, index });\n                }\n            });\n        }\n        else {\n            newWorkspaceFolders.push(...( (folders.map(({ uri, name, index }) => ({ uri: URI.revive(uri), name, index })))));\n        }\n        newWorkspaceFolders.sort((f1, f2) => f1.index < f2.index ? -1 : 1);\n        const workspace = ( (new ExtHostWorkspaceImpl(\n            id,\n            name,\n            newWorkspaceFolders,\n            !!transient,\n            configuration ? URI.revive(configuration) : null,\n            !!isUntitled,\n            uri => ignorePathCasing(uri, extHostFileSystemInfo)\n        )));\n        const { added, removed } = delta(oldWorkspace ? oldWorkspace.workspaceFolders : [], workspace.workspaceFolders, compareWorkspaceFolderByUri, extHostFileSystemInfo);\n        return { workspace, added, removed };\n    }\n    static _findFolder(workspace, folderUriToFind, extHostFileSystemInfo) {\n        for (let i = 0; i < workspace.folders.length; i++) {\n            const folder = workspace.workspaceFolders[i];\n            if (isFolderEqual(folder.uri, folderUriToFind, extHostFileSystemInfo)) {\n                return folder;\n            }\n        }\n        return undefined;\n    }\n    constructor(id, _name, folders, transient, configuration, _isUntitled, ignorePathCasing) {\n        super(id, ( (folders.map(f => ( (new WorkspaceFolder(f)))))), transient, configuration, ignorePathCasing);\n        this._name = _name;\n        this._isUntitled = _isUntitled;\n        this._workspaceFolders = [];\n        this._structure = TernarySearchTree.forUris(ignorePathCasing, () => true);\n        folders.forEach(folder => {\n            this._workspaceFolders.push(folder);\n            this._structure.set(folder.uri, folder);\n        });\n    }\n    get name() {\n        return this._name;\n    }\n    get isUntitled() {\n        return this._isUntitled;\n    }\n    get workspaceFolders() {\n        return this._workspaceFolders.slice(0);\n    }\n    getWorkspaceFolder(uri, resolveParent) {\n        if (resolveParent && this._structure.get(uri)) {\n            uri = dirname(uri);\n        }\n        return this._structure.findSubstr(uri);\n    }\n    resolveWorkspaceFolder(uri) {\n        return this._structure.get(uri);\n    }\n}\nlet ExtHostWorkspace = class ExtHostWorkspace {\n    constructor(extHostRpc, initData, extHostFileSystemInfo, logService, uriTransformerService) {\n        this._onDidChangeWorkspace = ( (new Emitter()));\n        this.onDidChangeWorkspace = this._onDidChangeWorkspace.event;\n        this._onDidGrantWorkspaceTrust = ( (new Emitter()));\n        this.onDidGrantWorkspaceTrust = this._onDidGrantWorkspaceTrust.event;\n        this._activeSearchCallbacks = [];\n        this._trusted = false;\n        this._editSessionIdentityProviders = ( (new Map()));\n        this._providerHandlePool = 0;\n        this._onWillCreateEditSessionIdentityEvent = ( (new AsyncEmitter()));\n        this._canonicalUriProviders = ( (new Map()));\n        this._logService = logService;\n        this._extHostFileSystemInfo = extHostFileSystemInfo;\n        this._uriTransformerService = uriTransformerService;\n        this._requestIdProvider = ( (new Counter()));\n        this._barrier = ( (new Barrier()));\n        this._proxy = ( (extHostRpc.getProxy(MainContext.MainThreadWorkspace)));\n        this._messageService = ( (extHostRpc.getProxy(MainContext.MainThreadMessageService)));\n        const data = initData.workspace;\n        this._confirmedWorkspace = data ? ( (new ExtHostWorkspaceImpl(\n            data.id,\n            data.name,\n            [],\n            !!data.transient,\n            data.configuration ? URI.revive(data.configuration) : null,\n            !!data.isUntitled,\n            uri => ignorePathCasing(uri, extHostFileSystemInfo)\n        ))) : undefined;\n    }\n    $initializeWorkspace(data, trusted) {\n        this._trusted = trusted;\n        this.$acceptWorkspaceData(data);\n        this._barrier.open();\n    }\n    waitForInitializeCall() {\n        return this._barrier.wait();\n    }\n    get workspace() {\n        return this._actualWorkspace;\n    }\n    get name() {\n        return this._actualWorkspace ? this._actualWorkspace.name : undefined;\n    }\n    get workspaceFile() {\n        if (this._actualWorkspace) {\n            if (this._actualWorkspace.configuration) {\n                if (this._actualWorkspace.isUntitled) {\n                    return (\n                         (URI.from(\n                            { scheme: Schemas.untitled, path: basename(dirname(this._actualWorkspace.configuration)) }\n                        ))\n                    );\n                }\n                return this._actualWorkspace.configuration;\n            }\n        }\n        return undefined;\n    }\n    get _actualWorkspace() {\n        return this._unconfirmedWorkspace || this._confirmedWorkspace;\n    }\n    getWorkspaceFolders() {\n        if (!this._actualWorkspace) {\n            return undefined;\n        }\n        return this._actualWorkspace.workspaceFolders.slice(0);\n    }\n    async getWorkspaceFolders2() {\n        await this._barrier.wait();\n        if (!this._actualWorkspace) {\n            return undefined;\n        }\n        return this._actualWorkspace.workspaceFolders.slice(0);\n    }\n    updateWorkspaceFolders(extension, index, deleteCount, ...workspaceFoldersToAdd) {\n        const validatedDistinctWorkspaceFoldersToAdd = [];\n        if (Array.isArray(workspaceFoldersToAdd)) {\n            workspaceFoldersToAdd.forEach(folderToAdd => {\n                if (URI.isUri(folderToAdd.uri) && !( (validatedDistinctWorkspaceFoldersToAdd.some(f => isFolderEqual(f.uri, folderToAdd.uri, this._extHostFileSystemInfo))))) {\n                    validatedDistinctWorkspaceFoldersToAdd.push({ uri: folderToAdd.uri, name: folderToAdd.name || basenameOrAuthority(folderToAdd.uri) });\n                }\n            });\n        }\n        if (!!this._unconfirmedWorkspace) {\n            return false;\n        }\n        if (( ([index, deleteCount].some(i => typeof i !== 'number' || i < 0)))) {\n            return false;\n        }\n        if (deleteCount === 0 && validatedDistinctWorkspaceFoldersToAdd.length === 0) {\n            return false;\n        }\n        const currentWorkspaceFolders = this._actualWorkspace ? this._actualWorkspace.workspaceFolders : [];\n        if (index + deleteCount > currentWorkspaceFolders.length) {\n            return false;\n        }\n        const newWorkspaceFolders = currentWorkspaceFolders.slice(0);\n        newWorkspaceFolders.splice(index, deleteCount, ...( (validatedDistinctWorkspaceFoldersToAdd.map(\n            f => ({ uri: f.uri, name: f.name || basenameOrAuthority(f.uri), index: undefined  })\n        ))));\n        for (let i = 0; i < newWorkspaceFolders.length; i++) {\n            const folder = newWorkspaceFolders[i];\n            if (( (newWorkspaceFolders.some(\n                (otherFolder, index) => index !== i && isFolderEqual(folder.uri, otherFolder.uri, this._extHostFileSystemInfo)\n            )))) {\n                return false;\n            }\n        }\n        newWorkspaceFolders.forEach((f, index) => f.index = index);\n        const { added, removed } = delta(currentWorkspaceFolders, newWorkspaceFolders, compareWorkspaceFolderByUriAndNameAndIndex, this._extHostFileSystemInfo);\n        if (added.length === 0 && removed.length === 0) {\n            return false;\n        }\n        if (this._proxy) {\n            const extName = extension.displayName || extension.name;\n            this._proxy.$updateWorkspaceFolders(extName, index, deleteCount, validatedDistinctWorkspaceFoldersToAdd).then(undefined, error => {\n                this._unconfirmedWorkspace = undefined;\n                const options = { source: { identifier: extension.identifier, label: extension.displayName || extension.name } };\n                this._messageService.$showMessage(Severity$1.Error, ( localize(\n                    584,\n                    \"Extension '{0}' failed to update workspace folders: {1}\",\n                    extName,\n                     (error.toString())\n                )), options, []);\n            });\n        }\n        this.trySetWorkspaceFolders(newWorkspaceFolders);\n        return true;\n    }\n    getWorkspaceFolder(uri, resolveParent) {\n        if (!this._actualWorkspace) {\n            return undefined;\n        }\n        return this._actualWorkspace.getWorkspaceFolder(uri, resolveParent);\n    }\n    async getWorkspaceFolder2(uri, resolveParent) {\n        await this._barrier.wait();\n        if (!this._actualWorkspace) {\n            return undefined;\n        }\n        return this._actualWorkspace.getWorkspaceFolder(uri, resolveParent);\n    }\n    async resolveWorkspaceFolder(uri) {\n        await this._barrier.wait();\n        if (!this._actualWorkspace) {\n            return undefined;\n        }\n        return this._actualWorkspace.resolveWorkspaceFolder(uri);\n    }\n    getPath() {\n        if (!this._actualWorkspace) {\n            return undefined;\n        }\n        const { folders } = this._actualWorkspace;\n        if (folders.length === 0) {\n            return undefined;\n        }\n        return folders[0].uri.fsPath;\n    }\n    getRelativePath(pathOrUri, includeWorkspace) {\n        let resource;\n        let path = '';\n        if (typeof pathOrUri === 'string') {\n            resource = URI.file(pathOrUri);\n            path = pathOrUri;\n        }\n        else if (typeof pathOrUri !== 'undefined') {\n            resource = pathOrUri;\n            path = pathOrUri.fsPath;\n        }\n        if (!resource) {\n            return path;\n        }\n        const folder = this.getWorkspaceFolder(resource, true);\n        if (!folder) {\n            return path;\n        }\n        if (typeof includeWorkspace === 'undefined' && this._actualWorkspace) {\n            includeWorkspace = this._actualWorkspace.folders.length > 1;\n        }\n        let result = relativePath(folder.uri, resource);\n        if (includeWorkspace && folder.name) {\n            result = `${folder.name}/${result}`;\n        }\n        return result;\n    }\n    trySetWorkspaceFolders(folders) {\n        if (this._actualWorkspace) {\n            this._unconfirmedWorkspace = ExtHostWorkspaceImpl.toExtHostWorkspace({\n                id: this._actualWorkspace.id,\n                name: this._actualWorkspace.name,\n                configuration: this._actualWorkspace.configuration,\n                folders,\n                isUntitled: this._actualWorkspace.isUntitled\n            }, this._actualWorkspace, undefined, this._extHostFileSystemInfo).workspace || undefined;\n        }\n    }\n    $acceptWorkspaceData(data) {\n        const { workspace, added, removed } = ExtHostWorkspaceImpl.toExtHostWorkspace(data, this._confirmedWorkspace, this._unconfirmedWorkspace, this._extHostFileSystemInfo);\n        this._confirmedWorkspace = workspace || undefined;\n        this._unconfirmedWorkspace = undefined;\n        this._onDidChangeWorkspace.fire(( (Object.freeze({\n            added,\n            removed,\n        }))));\n    }\n    findFiles(include, exclude, maxResults, extensionId, token = CancellationToken.None) {\n        this._logService.trace(`extHostWorkspace#findFiles: fileSearch, extension: ${extensionId.value}, entryPoint: findFiles`);\n        let excludeString = '';\n        let useFileExcludes = true;\n        if (exclude === null) {\n            useFileExcludes = false;\n        }\n        else if (exclude !== undefined) {\n            if (typeof exclude === 'string') {\n                excludeString = exclude;\n            }\n            else {\n                excludeString = exclude.pattern;\n            }\n        }\n        return this._findFilesImpl(include, undefined, {\n            exclude: [excludeString],\n            maxResults,\n            useExcludeSettings: useFileExcludes ? ExcludeSettingOptions.FilesExclude : ExcludeSettingOptions.None,\n            useIgnoreFiles: {\n                local: false\n            }\n        }, token);\n    }\n    findFiles2(filePattern, options = {}, extensionId, token = CancellationToken.None) {\n        this._logService.trace(`extHostWorkspace#findFiles2: fileSearch, extension: ${extensionId.value}, entryPoint: findFiles2`);\n        const useDefaultExcludes = options.useDefaultExcludes ?? true;\n        const useDefaultSearchExcludes = options.useDefaultSearchExcludes ?? true;\n        const excludeSetting = useDefaultExcludes ?\n            (useDefaultSearchExcludes ? ExcludeSettingOptions.SearchAndFilesExclude : ExcludeSettingOptions.FilesExclude) :\n            ExcludeSettingOptions.None;\n        const newOptions = {\n            exclude: options.exclude ? [options.exclude] : undefined,\n            useIgnoreFiles: {\n                local: options.useIgnoreFiles,\n                global: options.useGlobalIgnoreFiles,\n                parent: options.useParentIgnoreFiles\n            },\n            useExcludeSettings: excludeSetting,\n            followSymlinks: options.followSymlinks,\n            maxResults: options.maxResults,\n        };\n        return this._findFilesImpl(undefined, filePattern !== undefined ? [filePattern] : [], newOptions, token);\n    }\n    findFiles2New(filePatterns, options = {}, extensionId, token = CancellationToken.None) {\n        this._logService.trace(`extHostWorkspace#findFiles2New: fileSearch, extension: ${extensionId.value}, entryPoint: findFiles2New`);\n        return this._findFilesImpl(undefined, filePatterns, options, token);\n    }\n    async _findFilesImpl(\n    include, filePatterns, options, token = CancellationToken.None) {\n        if (token && token.isCancellationRequested) {\n            return Promise.resolve([]);\n        }\n        const filePatternsToUse = include !== undefined ? [include] : filePatterns;\n        const queryOptions = filePatternsToUse?.map(filePattern => {\n            const excludePatterns = globsToISearchPatternBuilder(options.exclude);\n            const fileQueries = {\n                ignoreSymlinks: typeof options.followSymlinks === 'boolean' ? !options.followSymlinks : undefined,\n                disregardIgnoreFiles: typeof options.useIgnoreFiles?.local === 'boolean' ? !options.useIgnoreFiles.local : undefined,\n                disregardGlobalIgnoreFiles: typeof options.useIgnoreFiles?.global === 'boolean' ? !options.useIgnoreFiles.global : undefined,\n                disregardParentIgnoreFiles: typeof options.useIgnoreFiles?.parent === 'boolean' ? !options.useIgnoreFiles.parent : undefined,\n                disregardExcludeSettings: options.useExcludeSettings !== undefined && options.useExcludeSettings === ExcludeSettingOptions.None,\n                disregardSearchExcludeSettings: options.useExcludeSettings !== undefined && (options.useExcludeSettings !== ExcludeSettingOptions.SearchAndFilesExclude),\n                maxResults: options.maxResults,\n                excludePattern: excludePatterns.length > 0 ? excludePatterns : undefined,\n                _reason: 'startFileSearch',\n                shouldGlobSearch: include ? undefined : true,\n            };\n            const parseInclude = parseSearchExcludeInclude(GlobPattern.from(filePattern));\n            const folderToUse = parseInclude?.folder;\n            if (include) {\n                fileQueries.includePattern = parseInclude?.pattern;\n            }\n            else {\n                fileQueries.filePattern = parseInclude?.pattern;\n            }\n            return {\n                folder: folderToUse,\n                options: fileQueries\n            };\n        }) ?? [];\n        return this._findFilesBase(queryOptions, token);\n    }\n    async _findFilesBase(queryOptions, token) {\n        const result = await Promise.all(queryOptions?.map(option => this._proxy.$startFileSearch(option.folder ?? null, option.options, token).then(data => Array.isArray(data) ? ( (data.map(d => URI.revive(d)))) : [])) ?? []);\n        return result.flat();\n    }\n    findTextInFilesNew(query, options, extensionId, token = CancellationToken.None) {\n        this._logService.trace(`extHostWorkspace#findTextInFilesNew: textSearch, extension: ${extensionId.value}, entryPoint: findTextInFilesNew`);\n        const getOptions = (include) => {\n            if (!options) {\n                return {\n                    folder: undefined,\n                    options: {}\n                };\n            }\n            const parsedInclude = include ? parseSearchExcludeInclude(GlobPattern.from(include)) : undefined;\n            const excludePatterns = options.exclude ? globsToISearchPatternBuilder(options.exclude) : undefined;\n            return {\n                options: {\n                    ignoreSymlinks: typeof options.followSymlinks === 'boolean' ? !options.followSymlinks : undefined,\n                    disregardIgnoreFiles: typeof options.useIgnoreFiles === 'boolean' ? !options.useIgnoreFiles : undefined,\n                    disregardGlobalIgnoreFiles: typeof options.useIgnoreFiles?.global === 'boolean' ? !options.useIgnoreFiles?.global : undefined,\n                    disregardParentIgnoreFiles: typeof options.useIgnoreFiles?.parent === 'boolean' ? !options.useIgnoreFiles?.parent : undefined,\n                    disregardExcludeSettings: options.useExcludeSettings !== undefined && options.useExcludeSettings === ExcludeSettingOptions.None,\n                    disregardSearchExcludeSettings: options.useExcludeSettings !== undefined && (options.useExcludeSettings !== ExcludeSettingOptions.SearchAndFilesExclude),\n                    fileEncoding: options.encoding,\n                    maxResults: options.maxResults,\n                    previewOptions: options.previewOptions ? {\n                        matchLines: options.previewOptions?.numMatchLines ?? 100,\n                        charsPerLine: options.previewOptions?.charsPerLine ?? 10000,\n                    } : undefined,\n                    surroundingContext: options.surroundingContext,\n                    includePattern: parsedInclude?.pattern,\n                    excludePattern: excludePatterns\n                },\n                folder: parsedInclude?.folder\n            };\n        };\n        const queryOptionsRaw = ((options?.include?.map((include) => getOptions(include)))) ?? [getOptions(undefined)];\n        const queryOptions = queryOptionsRaw.filter((queryOps) => !!queryOps);\n        const disposables = ( (new DisposableStore()));\n        const progressEmitter = disposables.add(( (new Emitter())));\n        const complete = this.findTextInFilesBase(query, queryOptions, (result, uri) => progressEmitter.fire({ result, uri }), token);\n        const asyncIterable = ( (new AsyncIterableObject(async (emitter) => {\n            disposables.add(progressEmitter.event(e => {\n                const result = e.result;\n                const uri = e.uri;\n                if (resultIsMatch(result)) {\n                    emitter.emitOne(( (new TextSearchMatchNew(uri,  (result.rangeLocations.map((range) => ({\n                        previewRange: ( (new Range(\n                            range.preview.startLineNumber,\n                            range.preview.startColumn,\n                            range.preview.endLineNumber,\n                            range.preview.endColumn\n                        ))),\n                        sourceRange: ( (new Range(\n                            range.source.startLineNumber,\n                            range.source.startColumn,\n                            range.source.endLineNumber,\n                            range.source.endColumn\n                        )))\n                    }))), result.previewText))));\n                }\n                else {\n                    emitter.emitOne(( (new TextSearchContextNew(uri, result.text, result.lineNumber))));\n                }\n            }));\n            await complete;\n        })));\n        return {\n            results: asyncIterable,\n            complete: complete.then((e) => {\n                disposables.dispose();\n                return {\n                    limitHit: e?.limitHit ?? false\n                };\n            }),\n        };\n    }\n    async findTextInFilesBase(query, queryOptions, callback, token = CancellationToken.None) {\n        const requestId = this._requestIdProvider.getNext();\n        let isCanceled = false;\n        token.onCancellationRequested(_ => {\n            isCanceled = true;\n        });\n        this._activeSearchCallbacks[requestId] = p => {\n            if (isCanceled) {\n                return;\n            }\n            const uri = URI.revive(p.resource);\n            p.results.forEach(rawResult => {\n                const result = revive(rawResult);\n                callback(result, uri);\n            });\n        };\n        if (token.isCancellationRequested) {\n            return {};\n        }\n        try {\n            const result = await Promise.all(queryOptions?.map(option => this._proxy.$startTextSearch(query, option.folder ?? null, option.options, requestId, token) || {}) ?? []);\n            delete this._activeSearchCallbacks[requestId];\n            return result.reduce((acc, val) => {\n                return {\n                    limitHit: acc?.limitHit || (val?.limitHit ?? false),\n                    message: [acc?.message ?? [], val?.message ?? []].flat(),\n                };\n            }, {}) ?? { limitHit: false };\n        }\n        catch (err) {\n            delete this._activeSearchCallbacks[requestId];\n            throw err;\n        }\n    }\n    async findTextInFiles(query, options, callback, extensionId, token = CancellationToken.None) {\n        this._logService.trace(`extHostWorkspace#findTextInFiles: textSearch, extension: ${extensionId.value}, entryPoint: findTextInFiles`);\n        const previewOptions = typeof options.previewOptions === 'undefined' ?\n            {\n                matchLines: 100,\n                charsPerLine: 10000\n            } :\n            options.previewOptions;\n        const parsedInclude = parseSearchExcludeInclude(GlobPattern.from(options.include));\n        const excludePattern = (typeof options.exclude === 'string') ? options.exclude :\n            options.exclude ? options.exclude.pattern : undefined;\n        const queryOptions = {\n            ignoreSymlinks: typeof options.followSymlinks === 'boolean' ? !options.followSymlinks : undefined,\n            disregardIgnoreFiles: typeof options.useIgnoreFiles === 'boolean' ? !options.useIgnoreFiles : undefined,\n            disregardGlobalIgnoreFiles: typeof options.useGlobalIgnoreFiles === 'boolean' ? !options.useGlobalIgnoreFiles : undefined,\n            disregardParentIgnoreFiles: typeof options.useParentIgnoreFiles === 'boolean' ? !options.useParentIgnoreFiles : undefined,\n            disregardExcludeSettings: typeof options.useDefaultExcludes === 'boolean' ? !options.useDefaultExcludes : true,\n            disregardSearchExcludeSettings: typeof options.useSearchExclude === 'boolean' ? !options.useSearchExclude : true,\n            fileEncoding: options.encoding,\n            maxResults: options.maxResults,\n            previewOptions,\n            surroundingContext: options.afterContext,\n            includePattern: parsedInclude?.pattern,\n            excludePattern: excludePattern ? [{ pattern: excludePattern }] : undefined,\n        };\n        const progress = (result, uri) => {\n            if (resultIsMatch(result)) {\n                callback({\n                    uri,\n                    preview: {\n                        text: result.previewText,\n                        matches: mapArrayOrNot(result.rangeLocations, m => ( (new Range(\n                            m.preview.startLineNumber,\n                            m.preview.startColumn,\n                            m.preview.endLineNumber,\n                            m.preview.endColumn\n                        ))))\n                    },\n                    ranges: mapArrayOrNot(result.rangeLocations, r => ( (new Range(\n                        r.source.startLineNumber,\n                        r.source.startColumn,\n                        r.source.endLineNumber,\n                        r.source.endColumn\n                    ))))\n                });\n            }\n            else {\n                callback({\n                    uri,\n                    text: result.text,\n                    lineNumber: result.lineNumber\n                });\n            }\n        };\n        return this.findTextInFilesBase(query, [{ options: queryOptions, folder: parsedInclude?.folder }], progress, token);\n    }\n    $handleTextSearchResult(result, requestId) {\n        this._activeSearchCallbacks[requestId]?.(result);\n    }\n    async save(uri) {\n        const result = await this._proxy.$save(uri, { saveAs: false });\n        return URI.revive(result);\n    }\n    async saveAs(uri) {\n        const result = await this._proxy.$save(uri, { saveAs: true });\n        return URI.revive(result);\n    }\n    saveAll(includeUntitled) {\n        return this._proxy.$saveAll(includeUntitled);\n    }\n    resolveProxy(url) {\n        return this._proxy.$resolveProxy(url);\n    }\n    lookupAuthorization(authInfo) {\n        return this._proxy.$lookupAuthorization(authInfo);\n    }\n    lookupKerberosAuthorization(url) {\n        return this._proxy.$lookupKerberosAuthorization(url);\n    }\n    loadCertificates() {\n        return this._proxy.$loadCertificates();\n    }\n    get trusted() {\n        return this._trusted;\n    }\n    requestWorkspaceTrust(options) {\n        return this._proxy.$requestWorkspaceTrust(options);\n    }\n    $onDidGrantWorkspaceTrust() {\n        if (!this._trusted) {\n            this._trusted = true;\n            this._onDidGrantWorkspaceTrust.fire();\n        }\n    }\n    registerEditSessionIdentityProvider(scheme, provider) {\n        if (( (this._editSessionIdentityProviders.has(scheme)))) {\n            throw ( (new Error(`A provider has already been registered for scheme ${scheme}`)));\n        }\n        this._editSessionIdentityProviders.set(scheme, provider);\n        const outgoingScheme = this._uriTransformerService.transformOutgoingScheme(scheme);\n        const handle = this._providerHandlePool++;\n        this._proxy.$registerEditSessionIdentityProvider(handle, outgoingScheme);\n        return toDisposable(() => {\n            this._editSessionIdentityProviders.delete(scheme);\n            this._proxy.$unregisterEditSessionIdentityProvider(handle);\n        });\n    }\n    async $getEditSessionIdentifier(workspaceFolder, cancellationToken) {\n        this._logService.info('Getting edit session identifier for workspaceFolder', workspaceFolder);\n        const folder = await this.resolveWorkspaceFolder(URI.revive(workspaceFolder));\n        if (!folder) {\n            this._logService.warn('Unable to resolve workspace folder');\n            return undefined;\n        }\n        this._logService.info('Invoking #provideEditSessionIdentity for workspaceFolder', folder);\n        const provider = this._editSessionIdentityProviders.get(folder.uri.scheme);\n        this._logService.info(`Provider for scheme ${folder.uri.scheme} is defined: `, !!provider);\n        if (!provider) {\n            return undefined;\n        }\n        const result = await provider.provideEditSessionIdentity(folder, cancellationToken);\n        this._logService.info('Provider returned edit session identifier: ', result);\n        if (!result) {\n            return undefined;\n        }\n        return result;\n    }\n    async $provideEditSessionIdentityMatch(workspaceFolder, identity1, identity2, cancellationToken) {\n        this._logService.info('Getting edit session identifier for workspaceFolder', workspaceFolder);\n        const folder = await this.resolveWorkspaceFolder(URI.revive(workspaceFolder));\n        if (!folder) {\n            this._logService.warn('Unable to resolve workspace folder');\n            return undefined;\n        }\n        this._logService.info('Invoking #provideEditSessionIdentity for workspaceFolder', folder);\n        const provider = this._editSessionIdentityProviders.get(folder.uri.scheme);\n        this._logService.info(`Provider for scheme ${folder.uri.scheme} is defined: `, !!provider);\n        if (!provider) {\n            return undefined;\n        }\n        const result = await provider.provideEditSessionIdentityMatch?.(identity1, identity2, cancellationToken);\n        this._logService.info('Provider returned edit session identifier match result: ', result);\n        if (!result) {\n            return undefined;\n        }\n        return result;\n    }\n    getOnWillCreateEditSessionIdentityEvent(extension) {\n        return (listener, thisArg, disposables) => {\n            const wrappedListener = function wrapped(e) { listener.call(thisArg, e); };\n            wrappedListener.extension = extension;\n            return this._onWillCreateEditSessionIdentityEvent.event(wrappedListener, undefined, disposables);\n        };\n    }\n    async $onWillCreateEditSessionIdentity(workspaceFolder, token, timeout) {\n        const folder = await this.resolveWorkspaceFolder(URI.revive(workspaceFolder));\n        if (folder === undefined) {\n            throw ( (new Error('Unable to resolve workspace folder')));\n        }\n        await this._onWillCreateEditSessionIdentityEvent.fireAsync({ workspaceFolder: folder }, token, async (thenable, listener) => {\n            const now = Date.now();\n            await Promise.resolve(thenable);\n            if (Date.now() - now > timeout) {\n                this._logService.warn('SLOW edit session create-participant', listener.extension.identifier);\n            }\n        });\n        if (token.isCancellationRequested) {\n            return undefined;\n        }\n    }\n    registerCanonicalUriProvider(scheme, provider) {\n        if (( (this._canonicalUriProviders.has(scheme)))) {\n            throw ( (new Error(`A provider has already been registered for scheme ${scheme}`)));\n        }\n        this._canonicalUriProviders.set(scheme, provider);\n        const outgoingScheme = this._uriTransformerService.transformOutgoingScheme(scheme);\n        const handle = this._providerHandlePool++;\n        this._proxy.$registerCanonicalUriProvider(handle, outgoingScheme);\n        return toDisposable(() => {\n            this._canonicalUriProviders.delete(scheme);\n            this._proxy.$unregisterCanonicalUriProvider(handle);\n        });\n    }\n    async provideCanonicalUri(uri, options, cancellationToken) {\n        const provider = this._canonicalUriProviders.get(uri.scheme);\n        if (!provider) {\n            return undefined;\n        }\n        const result = await provider.provideCanonicalUri?.(URI.revive(uri), options, cancellationToken);\n        if (!result) {\n            return undefined;\n        }\n        return result;\n    }\n    async $provideCanonicalUri(uri, targetScheme, cancellationToken) {\n        return this.provideCanonicalUri(URI.revive(uri), { targetScheme }, cancellationToken);\n    }\n};\nExtHostWorkspace = ( (__decorate([\n    ( (__param(0, IExtHostRpcService))),\n    ( (__param(1, IExtHostInitDataService))),\n    ( (__param(2, IExtHostFileSystemInfo))),\n    ( (__param(3, ILogService))),\n    ( (__param(4, IURITransformerService)))\n], ExtHostWorkspace)));\nconst IExtHostWorkspace = ( (createDecorator('IExtHostWorkspace')));\nfunction parseSearchExcludeInclude(include) {\n    let pattern;\n    let includeFolder;\n    if (include) {\n        if (typeof include === 'string') {\n            pattern = include;\n        }\n        else {\n            pattern = include.pattern;\n            includeFolder = URI.revive(include.baseUri);\n        }\n        return {\n            pattern,\n            folder: includeFolder\n        };\n    }\n    return undefined;\n}\nfunction globsToISearchPatternBuilder(excludes) {\n    return (excludes?.map((exclude) => {\n        if (typeof exclude === 'string') {\n            if (exclude === '') {\n                return undefined;\n            }\n            return {\n                pattern: exclude,\n                uri: undefined\n            };\n        }\n        else {\n            const parsedExclude = parseSearchExcludeInclude(exclude);\n            if (!parsedExclude) {\n                return undefined;\n            }\n            return {\n                pattern: parsedExclude.pattern,\n                uri: parsedExclude.folder\n            };\n        }\n    }) ?? []).filter((e) => !!e);\n}\nexport { ExtHostWorkspace, IExtHostWorkspace };\n","import { setUnexpectedErrorHandler, transformErrorForSerialization } from '../../../base/common/errors.js';\nimport { mark } from '../../../base/common/performance.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { MainContext } from './extHost.protocol.js';\nimport { RPCProtocol } from '../../services/extensions/common/rpcProtocol.js';\nimport { ILogService, ILoggerService } from '../../../platform/log/common/log.service.js';\nimport { getSingletonServiceDescriptors } from '../../../platform/instantiation/common/extensions.js';\nimport { ServiceCollection } from '../../../platform/instantiation/common/serviceCollection.js';\nimport { IExtHostInitDataService } from './extHostInitDataService.js';\nimport { InstantiationService } from '../../../platform/instantiation/common/instantiationService.js';\nimport { IExtHostRpcService, ExtHostRpcService } from './extHostRpcService.js';\nimport { IURITransformerService, URITransformerService } from './extHostUriTransformerService.js';\nimport { IHostUtils, IExtHostExtensionService } from './extHostExtensionService.js';\nimport { IExtHostTelemetry } from './extHostTelemetry.js';\nimport { isWebWorker } from '../../../base/common/platform.js';\nimport { SyncDescriptor } from '../../../platform/instantiation/common/descriptors.js';\nimport { ExtHostLoggerService } from './extHostLoggerService.js';\nimport { ExtHostLogService } from './extHostLogService.js';\nclass ErrorHandler {\n    static async installEarlyHandler(accessor) {\n        Error.stackTraceLimit = 100;\n        const logService = accessor.get(ILogService);\n        const rpcService = accessor.get(IExtHostRpcService);\n        const mainThreadErrors = ( rpcService.getProxy(MainContext.MainThreadErrors));\n        setUnexpectedErrorHandler(err => {\n            logService.error(err);\n            const data = transformErrorForSerialization(err);\n            mainThreadErrors.$onUnexpectedError(data);\n        });\n    }\n    static async installFullHandler(accessor) {\n        const logService = accessor.get(ILogService);\n        const rpcService = accessor.get(IExtHostRpcService);\n        const extensionService = accessor.get(IExtHostExtensionService);\n        const extensionTelemetry = accessor.get(IExtHostTelemetry);\n        const mainThreadExtensions = ( rpcService.getProxy(MainContext.MainThreadExtensionService));\n        const mainThreadErrors = ( rpcService.getProxy(MainContext.MainThreadErrors));\n        const map = await extensionService.getExtensionPathIndex();\n        const extensionErrors = ( new WeakMap());\n        function prepareStackTraceAndFindExtension(error, stackTrace) {\n            if (( extensionErrors.has(error))) {\n                return extensionErrors.get(error).stack;\n            }\n            let stackTraceMessage = '';\n            let extension;\n            let fileName;\n            for (const call of stackTrace) {\n                stackTraceMessage += `\\n\\tat ${( call.toString())}`;\n                fileName = call.getFileName();\n                if (!extension && fileName) {\n                    extension = map.findSubstr(URI.file(fileName));\n                }\n            }\n            const result = `${error.name || 'Error'}: ${error.message || ''}${stackTraceMessage}`;\n            extensionErrors.set(error, { extensionIdentifier: extension?.identifier, stack: result });\n            return result;\n        }\n        const _wasWrapped = Symbol('prepareStackTrace wrapped');\n        let _prepareStackTrace = prepareStackTraceAndFindExtension;\n        Object.defineProperty(Error, 'prepareStackTrace', {\n            configurable: false,\n            get() {\n                return _prepareStackTrace;\n            },\n            set(v) {\n                if (v === prepareStackTraceAndFindExtension || !v || v[_wasWrapped]) {\n                    _prepareStackTrace = v || prepareStackTraceAndFindExtension;\n                    return;\n                }\n                _prepareStackTrace = function (error, stackTrace) {\n                    prepareStackTraceAndFindExtension(error, stackTrace);\n                    return v.call(Error, error, stackTrace);\n                };\n                Object.assign(_prepareStackTrace, { [_wasWrapped]: true });\n            },\n        });\n        setUnexpectedErrorHandler(err => {\n            logService.error(err);\n            const errorData = transformErrorForSerialization(err);\n            const stackData = extensionErrors.get(err);\n            if (!stackData?.extensionIdentifier) {\n                mainThreadErrors.$onUnexpectedError(errorData);\n                return;\n            }\n            mainThreadExtensions.$onExtensionRuntimeError(stackData.extensionIdentifier, errorData);\n            const reported = extensionTelemetry.onExtensionError(stackData.extensionIdentifier, err);\n            logService.trace('forwarded error to extension?', reported, stackData);\n        });\n    }\n}\nclass ExtensionHostMain {\n    constructor(protocol, initData, hostUtils, uriTransformer, messagePorts) {\n        this._hostUtils = hostUtils;\n        this._rpcProtocol = ( new RPCProtocol(protocol, null, uriTransformer));\n        initData = ExtensionHostMain._transform(initData, this._rpcProtocol);\n        const services = ( new ServiceCollection(...getSingletonServiceDescriptors()));\n        services.set(IExtHostInitDataService, { _serviceBrand: undefined, ...initData, messagePorts });\n        services.set(IExtHostRpcService, ( new ExtHostRpcService(this._rpcProtocol)));\n        services.set(IURITransformerService, ( new URITransformerService(uriTransformer)));\n        services.set(IHostUtils, hostUtils);\n        services.set(ILogService, ( new SyncDescriptor(ExtHostLogService, [true], true)));\n        services.set(ILoggerService, ( new SyncDescriptor(ExtHostLoggerService, [], true)));\n        const instaService = ( new InstantiationService(services, true));\n        if (isWebWorker) {\n            instaService.invokeFunction(ErrorHandler.installEarlyHandler);\n        }\n        this._logService = instaService.invokeFunction(accessor => accessor.get(ILogService));\n        mark(`code/extHost/didCreateServices`);\n        if (this._hostUtils.pid) {\n            this._logService.info(`Extension host with pid ${this._hostUtils.pid} started`);\n        }\n        else {\n            this._logService.info(`Extension host started`);\n        }\n        this._logService.trace('initData', initData);\n        this._extensionService = instaService.invokeFunction(accessor => accessor.get(IExtHostExtensionService));\n        this._extensionService.initialize();\n        if (isWebWorker) {\n            instaService.invokeFunction(ErrorHandler.installFullHandler);\n        }\n    }\n    async asBrowserUri(uri) {\n        const mainThreadExtensionsProxy = ( this._rpcProtocol.getProxy(MainContext.MainThreadExtensionService));\n        return URI.revive(await mainThreadExtensionsProxy.$asBrowserUri(uri));\n    }\n    async getAllStaticBrowserUris() {\n        const mainThreadExtensionsProxy = ( this._rpcProtocol.getProxy(MainContext.MainThreadExtensionService));\n        return ( (await mainThreadExtensionsProxy.$getAllStaticBrowserUris()).map(([from, to]) => [URI.revive(from), URI.revive(to)]));\n    }\n    terminate(reason) {\n        this._extensionService.terminate(reason);\n    }\n    getExtHostExtensionService() {\n        return this._extensionService;\n    }\n    static _transform(initData, rpcProtocol) {\n        initData.extensions.allExtensions.forEach((ext) => {\n            ext.extensionLocation = URI.revive(rpcProtocol.transformIncomingURIs(ext.extensionLocation));\n        });\n        initData.environment.appRoot = URI.revive(rpcProtocol.transformIncomingURIs(initData.environment.appRoot));\n        const extDevLocs = initData.environment.extensionDevelopmentLocationURI;\n        if (extDevLocs) {\n            initData.environment.extensionDevelopmentLocationURI = ( extDevLocs.map(url => URI.revive(rpcProtocol.transformIncomingURIs(url))));\n        }\n        initData.environment.extensionTestsLocationURI = URI.revive(rpcProtocol.transformIncomingURIs(initData.environment.extensionTestsLocationURI));\n        initData.environment.globalStorageHome = URI.revive(rpcProtocol.transformIncomingURIs(initData.environment.globalStorageHome));\n        initData.environment.workspaceStorageHome = URI.revive(rpcProtocol.transformIncomingURIs(initData.environment.workspaceStorageHome));\n        initData.environment.extensionTelemetryLogResource = URI.revive(rpcProtocol.transformIncomingURIs(initData.environment.extensionTelemetryLogResource));\n        initData.nlsBaseUrl = URI.revive(rpcProtocol.transformIncomingURIs(initData.nlsBaseUrl));\n        initData.logsLocation = URI.revive(rpcProtocol.transformIncomingURIs(initData.logsLocation));\n        initData.workspace = rpcProtocol.transformIncomingURIs(initData.workspace);\n        return initData;\n    }\n}\nexport { ErrorHandler, ExtensionHostMain };\n","import { registerSingleton } from '../../../platform/instantiation/common/extensions.js';\nimport { IExtHostExtensionService } from '../common/extHostExtensionService.js';\nimport { ExtensionStoragePaths, IExtensionStoragePaths } from '../common/extHostStoragePaths.js';\nimport { ExtHostExtensionService } from './extHostExtensionService.js';\nregisterSingleton(IExtHostExtensionService, ExtHostExtensionService, 0 );\nregisterSingleton(IExtensionStoragePaths, ExtensionStoragePaths, 0 );\n","import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';\nimport { AbstractExtHostConsoleForwarder } from '../common/extHostConsoleForwarder.js';\nimport { IExtHostInitDataService } from '../common/extHostInitDataService.js';\nimport { IExtHostRpcService } from '../common/extHostRpcService.js';\nlet ExtHostConsoleForwarder = class ExtHostConsoleForwarder extends AbstractExtHostConsoleForwarder {\n    constructor(extHostRpc, initData) {\n        super(extHostRpc, initData);\n    }\n    _nativeConsoleLogMessage(_method, original, args) {\n        original.apply(console, args);\n    }\n};\nExtHostConsoleForwarder = ( __decorate([\n    ( __param(0, IExtHostRpcService)),\n    ( __param(1, IExtHostInitDataService))\n], ExtHostConsoleForwarder));\nexport { ExtHostConsoleForwarder };\n","import { createApiFactoryAndRegisterActors } from '../common/extHost.api.impl.js';\nimport { AbstractExtHostExtensionService } from '../common/extHostExtensionService.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { RequireInterceptor } from '../common/extHostRequireInterceptor.js';\nimport { ExtensionRuntime } from '../common/extHostTypes.js';\nimport { timeout } from '../../../base/common/async.js';\nimport { ExtHostConsoleForwarder } from './extHostConsoleForwarder.js';\nimport { isWebWorker } from '../../../base/common/platform.js';\nclass WorkerRequireInterceptor extends RequireInterceptor {\n    _installInterceptor() { }\n    getModule(request, parent) {\n        for (const alternativeModuleName of this._alternatives) {\n            const alternative = alternativeModuleName(request);\n            if (alternative) {\n                request = alternative;\n                break;\n            }\n        }\n        if (( this._factories.has(request))) {\n            return this._factories.get(request).load(request, parent, () => { throw ( new Error('CANNOT LOAD MODULE from here.')); });\n        }\n        return undefined;\n    }\n}\nclass ExtHostExtensionService extends AbstractExtHostExtensionService {\n    constructor() {\n        super(...arguments);\n        this.extensionRuntime = ExtensionRuntime.Webworker;\n    }\n    async _beforeAlmostReadyToRunExtensions() {\n        if (isWebWorker) {\n            this._instaService.createInstance(ExtHostConsoleForwarder);\n        }\n        this._apiFactory = this._instaService.invokeFunction(createApiFactoryAndRegisterActors);\n        this._fakeModules = this._instaService.createInstance(WorkerRequireInterceptor, this._apiFactory, { mine: this._myRegistry, all: this._globalRegistry });\n        await this._fakeModules.install();\n        performance.mark('code/extHost/didInitAPI');\n        await this._waitForDebuggerAttachment();\n    }\n    _getEntryPoint(extensionDescription) {\n        return extensionDescription.browser;\n    }\n    async _loadCommonJSModule(extension, module, activationTimesBuilder) {\n        module = module.with({ path: ensureSuffix(module.path, '.js') });\n        const extensionId = extension?.identifier.value;\n        if (extensionId) {\n            performance.mark(`code/extHost/willFetchExtensionCode/${extensionId}`);\n        }\n        const browserUri = URI.revive(await this._mainThreadExtensionsProxy.$asBrowserUri(module));\n        const response = await fetch(( browserUri.toString(true)));\n        if (extensionId) {\n            performance.mark(`code/extHost/didFetchExtensionCode/${extensionId}`);\n        }\n        if (response.status !== 200) {\n            throw ( new Error(response.statusText));\n        }\n        const source = await response.text();\n        const sourceURL = `${( module.toString(true))}#vscode-extension`;\n        const fullSource = `${source}\\n//# sourceURL=${sourceURL}`;\n        let initFn;\n        try {\n            initFn = ( new Function('module', 'exports', 'require', fullSource));\n        }\n        catch (err) {\n            if (extensionId) {\n                console.error(`Loading code for extension ${extensionId} failed: ${err.message}`);\n            }\n            else {\n                console.error(`Loading code failed: ${err.message}`);\n            }\n            console.error(`${( module.toString(true))}${typeof err.line === 'number' ? ` line ${err.line}` : ''}${typeof err.column === 'number' ? ` column ${err.column}` : ''}`);\n            console.error(err);\n            throw err;\n        }\n        if (extension) {\n            await this._extHostLocalizationService.initializeLocalizedMessages(extension);\n        }\n        const _exports = {};\n        const _module = { exports: _exports };\n        const _require = (request) => {\n            const result = this._fakeModules.getModule(request, module);\n            if (result === undefined) {\n                throw ( new Error(`Cannot load module '${request}'`));\n            }\n            return result;\n        };\n        try {\n            activationTimesBuilder.codeLoadingStart();\n            if (extensionId) {\n                performance.mark(`code/extHost/willLoadExtensionCode/${extensionId}`);\n            }\n            initFn(_module, _exports, _require);\n            return (_module.exports !== _exports ? _module.exports : _exports);\n        }\n        finally {\n            if (extensionId) {\n                performance.mark(`code/extHost/didLoadExtensionCode/${extensionId}`);\n            }\n            activationTimesBuilder.codeLoadingStop();\n        }\n    }\n    async $setRemoteEnvironment(_env) {\n        return;\n    }\n    async _waitForDebuggerAttachment(waitTimeout = 5000) {\n        if (!this._initData.environment.isExtensionDevelopmentDebug) {\n            return;\n        }\n        const deadline = Date.now() + waitTimeout;\n        while (Date.now() < deadline && !('__jsDebugIsReady' in globalThis)) {\n            await timeout(10);\n        }\n    }\n}\nfunction ensureSuffix(path, suffix) {\n    return path.endsWith(suffix) ? path : path + suffix;\n}\nexport { ExtHostExtensionService };\n","import { create } from './extensionHostWorker.js';\nconst data = create();\nself.onmessage = (e) => data.onmessage(e.data);\n","import { VSBuffer } from '../../../base/common/buffer.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { createMessageOfType, isMessageOfType } from '../../services/extensions/common/extensionHostProtocol.js';\nimport { ExtensionHostMain } from '../common/extensionHostMain.js';\nimport { NestedWorker } from '../../services/extensions/worker/polyfillNestedWorker.js';\nimport { basename } from '../../../base/common/path.js';\nimport { mark } from '../../../base/common/performance.js';\nimport '../common/extHost.common.services.js';\nimport './extHost.worker.services.js';\nimport { URI } from '../../../base/common/uri.js';\nconst nativeClose = self.close.bind(self);\nself.close = () => console.trace(`'close' has been blocked`);\nconst nativePostMessage = postMessage.bind(self);\nself.postMessage = () => console.trace(`'postMessage' has been blocked`);\nfunction shouldTransformUri(uri) {\n    return /^(file|extension-file|vscode-remote):/i.test(uri);\n}\nconst nativeFetch = fetch.bind(self);\nfunction patchFetching(asBrowserUri) {\n    self.fetch = async function (input, init) {\n        if (input instanceof Request) {\n            return nativeFetch(input, init);\n        }\n        if (shouldTransformUri(String(input))) {\n            input = ( (await ( asBrowserUri(( URI.parse(String(input)))))).toString(true));\n        }\n        return nativeFetch(input, init);\n    };\n    self.XMLHttpRequest = class extends XMLHttpRequest {\n        open(method, url, async, username, password) {\n            (async () => {\n                if (shouldTransformUri(( url.toString()))) {\n                    url = ( (await ( asBrowserUri(( URI.parse(( url.toString())))))).toString(true));\n                }\n                super.open(method, url, async ?? true, username, password);\n            })();\n        }\n    };\n}\nself.importScripts = () => { throw ( new Error(`'importScripts' has been blocked`)); };\nself.addEventListener = () => console.trace(`'addEventListener' has been blocked`);\nself['AMDLoader'] = undefined;\nself['NLSLoaderPlugin'] = undefined;\nself['define'] = undefined;\nself['require'] = undefined;\nself['webkitRequestFileSystem'] = undefined;\nself['webkitRequestFileSystemSync'] = undefined;\nself['webkitResolveLocalFileSystemSyncURL'] = undefined;\nself['webkitResolveLocalFileSystemURL'] = undefined;\nfunction patchWorker(asBrowserUri, getAllStaticBrowserUris) {\n    if (self.Worker) {\n        const _Worker = self.Worker;\n        Worker = function (stringUrl, options) {\n            if (/^vscode-remote:/i.test(( stringUrl.toString()))) {\n                throw ( new Error(`Creating workers from remote extensions is currently not supported.`));\n            }\n            async function getWorkerUri(workerUri) {\n                const [browserUrl, staticBrowserUrls] = await Promise.all([\n                    ( asBrowserUri(workerUri)).then(uri => ( uri.toString(true))),\n                    getAllStaticBrowserUris().then(bindings => Object.fromEntries(( bindings.map(([from, to]) => [( from.toString(true)), ( to.toString(true))]))))\n                ]);\n                const bootstrapFnSource = ( (function bootstrapFn(workerUrl, staticBrowserUrls) {\n                    function asWorkerBrowserUrl(url) {\n                        if (typeof url === 'string' || url instanceof URL) {\n                            url = String(url).replace(/^file:\\/\\//i, 'vscode-file://vscode-app');\n                            return staticBrowserUrls[url] ?? url;\n                        }\n                        return url;\n                    }\n                    const nativeFetch = fetch.bind(self);\n                    self.fetch = function (input, init) {\n                        if (input instanceof Request) {\n                            return nativeFetch(input, init);\n                        }\n                        return nativeFetch(asWorkerBrowserUrl(input), init);\n                    };\n                    self.XMLHttpRequest = class extends XMLHttpRequest {\n                        constructor() {\n                            super(...arguments);\n                            this.notFound = false;\n                        }\n                        open(method, url, async, username, password) {\n                            const transformedUrl = asWorkerBrowserUrl(url);\n                            this.notFound = transformedUrl.startsWith('extension-file:');\n                            return super.open(method, transformedUrl, async ?? true, username, password);\n                        }\n                        send(body) {\n                            if (this.notFound) {\n                                return;\n                            }\n                            super.send(body);\n                        }\n                        get status() {\n                            return this.notFound ? 404 : super.status;\n                        }\n                    };\n                    const nativeImportScripts = importScripts.bind(self);\n                    self.importScripts = (...urls) => {\n                        nativeImportScripts(...( urls.map(asWorkerBrowserUrl)));\n                    };\n                    self.importExt = (url) => {\n                        return ( new Function('url', 'return import(url)'))(asWorkerBrowserUrl(url));\n                    };\n                    nativeImportScripts(workerUrl);\n                }).toString());\n                const js = `(${bootstrapFnSource}('${browserUrl}', ${JSON.stringify(staticBrowserUrls)}))`;\n                const blob = ( new Blob([js], { type: 'application/javascript' }));\n                return URL.createObjectURL(blob);\n            }\n            options = options || {};\n            options.name = `${name} -> ${options.name || basename(( stringUrl.toString()))}`;\n            class ExtensionWorker {\n                constructor(scriptURL, options) {\n                    this._onmessage = null;\n                    this._onmessageerror = null;\n                    this._onerror = null;\n                    this.workerPromise = getWorkerUri(( URI.parse(scriptURL instanceof URL ? ( scriptURL.toString()) : scriptURL))).then(url => {\n                        return ( new _Worker(url, options));\n                    });\n                }\n                set onmessage(cb) {\n                    this._onmessage = cb;\n                    this.workerPromise.then(worker => {\n                        worker.onmessage = cb;\n                    }, console.error);\n                }\n                get onmessage() {\n                    return this._onmessage;\n                }\n                set onmessageerror(cb) {\n                    this._onmessageerror = cb;\n                    this.workerPromise.then(worker => {\n                        worker.onmessageerror = cb;\n                    }, console.error);\n                }\n                get onmessageerror() {\n                    return this._onmessageerror;\n                }\n                set onerror(cb) {\n                    this._onerror = cb;\n                    this.workerPromise.then(worker => {\n                        worker.onerror = cb;\n                    }, console.error);\n                }\n                get onerror() {\n                    return this._onerror;\n                }\n                postMessage(message, options) {\n                    this.workerPromise.then(worker => {\n                        worker.postMessage(message, options);\n                    }, console.error);\n                }\n                terminate() {\n                    this.workerPromise.then(worker => {\n                        worker.terminate();\n                    }, console.error);\n                }\n                addEventListener(type, listener, options) {\n                    this.workerPromise.then(worker => {\n                        worker.addEventListener(type, listener, options);\n                    }, console.error);\n                }\n                removeEventListener(type, listener, options) {\n                    this.workerPromise.then(worker => {\n                        worker.removeEventListener(type, listener, options);\n                    }, console.error);\n                }\n                dispatchEvent(event) {\n                    this.workerPromise.then(worker => {\n                        worker.dispatchEvent(event);\n                    }, console.error);\n                    return false;\n                }\n            }\n            return ( new ExtensionWorker(stringUrl, options));\n        };\n    }\n    else {\n        self.Worker = class extends NestedWorker {\n            constructor(stringOrUrl, options) {\n                super(nativePostMessage, stringOrUrl, { name: basename(( stringOrUrl.toString())), ...options });\n            }\n        };\n    }\n}\nconst hostUtil = new (class {\n    constructor() {\n        this.pid = undefined;\n    }\n    exit(_code) {\n        nativeClose();\n    }\n});\nclass ExtensionWorker {\n    constructor() {\n        const channel = ( new MessageChannel());\n        const emitter = ( new Emitter());\n        let terminating = false;\n        nativePostMessage(channel.port2, [channel.port2]);\n        channel.port1.onmessage = event => {\n            const { data } = event;\n            if (!(data instanceof ArrayBuffer)) {\n                console.warn('UNKNOWN data received', data);\n                return;\n            }\n            const msg = VSBuffer.wrap(( new Uint8Array(data, 0, data.byteLength)));\n            if (isMessageOfType(msg, 2 )) {\n                terminating = true;\n                onTerminate('received terminate message from renderer');\n                return;\n            }\n            emitter.fire(msg);\n        };\n        this.protocol = {\n            onMessage: emitter.event,\n            send: vsbuf => {\n                if (!terminating) {\n                    const data = vsbuf.buffer.buffer.slice(vsbuf.buffer.byteOffset, vsbuf.buffer.byteOffset + vsbuf.buffer.byteLength);\n                    channel.port1.postMessage(data, [data]);\n                }\n            }\n        };\n    }\n}\nfunction connectToRenderer(protocol) {\n    return ( new Promise(resolve => {\n        const once = protocol.onMessage(raw => {\n            once.dispose();\n            const initData = JSON.parse(( raw.toString()));\n            protocol.send(createMessageOfType(0 ));\n            resolve({ protocol, initData });\n        });\n        protocol.send(createMessageOfType(1 ));\n    }));\n}\nlet onTerminate = (reason) => nativeClose();\nfunction isInitMessage(a) {\n    return !!a && typeof a === 'object' && a.type === 'vscode.init' && a.data instanceof Map;\n}\nfunction create() {\n    mark(`code/extHost/willConnectToRenderer`);\n    const res = ( new ExtensionWorker());\n    return {\n        onmessage(message) {\n            if (!isInitMessage(message)) {\n                return;\n            }\n            connectToRenderer(res.protocol).then(data => {\n                mark(`code/extHost/didWaitForInitData`);\n                const extHostMain = ( new ExtensionHostMain(data.protocol, data.initData, hostUtil, null, message.data));\n                patchFetching(uri => ( extHostMain.asBrowserUri(uri)));\n                patchWorker(uri => ( extHostMain.asBrowserUri(uri)), () => extHostMain.getAllStaticBrowserUris());\n                onTerminate = (reason) => extHostMain.terminate(reason);\n            });\n        }\n    };\n}\nexport { create };\n","import { __decorate, __param } from '../../../../../external/tslib/tslib.es6.js';\nimport { localize } from '../../nls.js';\nimport { Extensions as Extensions$1 } from '../../platform/configuration/common/configurationRegistry.js';\nimport { Registry } from '../../platform/registry/common/platform.js';\nimport { IWorkspaceContextService } from '../../platform/workspace/common/workspace.service.js';\nimport { IConfigurationService } from '../../platform/configuration/common/configuration.service.js';\nimport { Disposable } from '../../base/common/lifecycle.js';\nimport { Emitter } from '../../base/common/event.js';\nimport { IRemoteAgentService } from '../services/remote/common/remoteAgentService.service.js';\nimport { isWindows } from '../../base/common/platform.js';\nimport { equals } from '../../base/common/objects.js';\nimport { DeferredPromise } from '../../base/common/async.js';\nimport { IUserDataProfilesService } from '../../platform/userDataProfile/common/userDataProfile.service.js';\nconst applicationConfigurationNodeBase = ( (Object.freeze({\n    'id': 'application',\n    'order': 100,\n    'title': ( localize(4481, \"Application\")),\n    'type': 'object'\n})));\nconst workbenchConfigurationNodeBase = ( (Object.freeze({\n    'id': 'workbench',\n    'order': 7,\n    'title': ( localize(4482, \"Workbench\")),\n    'type': 'object',\n})));\nconst securityConfigurationNodeBase = ( (Object.freeze({\n    'id': 'security',\n    'scope': 1 ,\n    'title': ( localize(4483, \"Security\")),\n    'type': 'object',\n    'order': 7\n})));\nconst problemsConfigurationNodeBase = ( (Object.freeze({\n    'id': 'problems',\n    'title': ( localize(4484, \"Problems\")),\n    'type': 'object',\n    'order': 101\n})));\nconst windowConfigurationNodeBase = ( (Object.freeze({\n    'id': 'window',\n    'order': 8,\n    'title': ( localize(4485, \"Window\")),\n    'type': 'object',\n})));\nconst Extensions = {\n    ConfigurationMigration: 'base.contributions.configuration.migration'\n};\nclass ConfigurationMigrationRegistry {\n    constructor() {\n        this.migrations = [];\n        this._onDidRegisterConfigurationMigrations = ( (new Emitter()));\n        this.onDidRegisterConfigurationMigration = this._onDidRegisterConfigurationMigrations.event;\n    }\n    registerConfigurationMigrations(configurationMigrations) {\n        this.migrations.push(...configurationMigrations);\n    }\n}\nconst configurationMigrationRegistry = ( (new ConfigurationMigrationRegistry()));\nRegistry.add(Extensions.ConfigurationMigration, configurationMigrationRegistry);\nlet ConfigurationMigrationWorkbenchContribution = class ConfigurationMigrationWorkbenchContribution extends Disposable {\n    static { this.ID = 'workbench.contrib.configurationMigration'; }\n    constructor(configurationService, workspaceService) {\n        super();\n        this.configurationService = configurationService;\n        this.workspaceService = workspaceService;\n        this._register(this.workspaceService.onDidChangeWorkspaceFolders(async (e) => {\n            for (const folder of e.added) {\n                await this.migrateConfigurationsForFolder(folder, configurationMigrationRegistry.migrations);\n            }\n        }));\n        this.migrateConfigurations(configurationMigrationRegistry.migrations);\n        this._register(configurationMigrationRegistry.onDidRegisterConfigurationMigration(migration => this.migrateConfigurations(migration)));\n    }\n    async migrateConfigurations(migrations) {\n        await this.migrateConfigurationsForFolder(undefined, migrations);\n        for (const folder of this.workspaceService.getWorkspace().folders) {\n            await this.migrateConfigurationsForFolder(folder, migrations);\n        }\n    }\n    async migrateConfigurationsForFolder(folder, migrations) {\n        await Promise.all([( (migrations.map(\n            migration => this.migrateConfigurationsForFolderAndOverride(migration, folder?.uri)\n        )))]);\n    }\n    async migrateConfigurationsForFolderAndOverride(migration, resource) {\n        const inspectData = this.configurationService.inspect(migration.key, { resource });\n        const targetPairs = this.workspaceService.getWorkbenchState() === 3  ? [\n            ['user', 2 ],\n            ['userLocal', 3 ],\n            ['userRemote', 4 ],\n            ['workspace', 5 ],\n            ['workspaceFolder', 6 ],\n        ] : [\n            ['user', 2 ],\n            ['userLocal', 3 ],\n            ['userRemote', 4 ],\n            ['workspace', 5 ],\n        ];\n        for (const [dataKey, target] of targetPairs) {\n            const inspectValue = inspectData[dataKey];\n            if (!inspectValue) {\n                continue;\n            }\n            const migrationValues = [];\n            if (inspectValue.value !== undefined) {\n                const keyValuePairs = await this.runMigration(migration, dataKey, inspectValue.value, resource, undefined);\n                for (const keyValuePair of keyValuePairs ?? []) {\n                    migrationValues.push([keyValuePair, []]);\n                }\n            }\n            for (const { identifiers, value } of inspectValue.overrides ?? []) {\n                if (value !== undefined) {\n                    const keyValuePairs = await this.runMigration(migration, dataKey, value, resource, identifiers);\n                    for (const keyValuePair of keyValuePairs ?? []) {\n                        migrationValues.push([keyValuePair, identifiers]);\n                    }\n                }\n            }\n            if (migrationValues.length) {\n                await Promise.allSettled(( (migrationValues.map(\n                    async ([[key, value], overrideIdentifiers]) => this.configurationService.updateValue(key, value.value, { resource, overrideIdentifiers }, target)\n                ))));\n            }\n        }\n    }\n    async runMigration(migration, dataKey, value, resource, overrideIdentifiers) {\n        const valueAccessor = (key) => {\n            const inspectData = this.configurationService.inspect(key, { resource });\n            const inspectValue = inspectData[dataKey];\n            if (!inspectValue) {\n                return undefined;\n            }\n            if (!overrideIdentifiers) {\n                return inspectValue.value;\n            }\n            return inspectValue.overrides?.find(({ identifiers }) => equals(identifiers, overrideIdentifiers))?.value;\n        };\n        const result = await migration.migrateFn(value, valueAccessor);\n        return Array.isArray(result) ? result : [[migration.key, result]];\n    }\n};\nConfigurationMigrationWorkbenchContribution = ( (__decorate([\n    ( (__param(0, IConfigurationService))),\n    ( (__param(1, IWorkspaceContextService)))\n], ConfigurationMigrationWorkbenchContribution)));\nlet DynamicWorkbenchSecurityConfiguration = class DynamicWorkbenchSecurityConfiguration extends Disposable {\n    static { this.ID = 'workbench.contrib.dynamicWorkbenchSecurityConfiguration'; }\n    constructor(remoteAgentService) {\n        super();\n        this.remoteAgentService = remoteAgentService;\n        this._ready = ( (new DeferredPromise()));\n        this.ready = this._ready.p;\n        this.create();\n    }\n    async create() {\n        try {\n            await this.doCreate();\n        }\n        finally {\n            this._ready.complete();\n        }\n    }\n    async doCreate() {\n        if (!isWindows) {\n            const remoteEnvironment = await this.remoteAgentService.getEnvironment();\n            if (remoteEnvironment?.os !== 1 ) {\n                return;\n            }\n        }\n        const registry = ( (Registry.as(Extensions$1.Configuration)));\n        registry.registerConfiguration({\n            ...securityConfigurationNodeBase,\n            'properties': {\n                'security.allowedUNCHosts': {\n                    'type': 'array',\n                    'items': {\n                        'type': 'string',\n                        'pattern': '^[^\\\\\\\\]+$',\n                        'patternErrorMessage': ( localize(4486, 'UNC host names must not contain backslashes.'))\n                    },\n                    'default': [],\n                    'markdownDescription': ( localize(\n                        4487,\n                        'A set of UNC host names (without leading or trailing backslash, for example `192.168.0.1` or `my-server`) to allow without user confirmation. If a UNC host is being accessed that is not allowed via this setting or has not been acknowledged via user confirmation, an error will occur and the operation stopped. A restart is required when changing this setting. Find out more about this setting at https://aka.ms/vscode-windows-unc.'\n                    )),\n                    'scope': 2\n                },\n                'security.restrictUNCAccess': {\n                    'type': 'boolean',\n                    'default': true,\n                    'markdownDescription': ( localize(\n                        4488,\n                        'If enabled, only allows access to UNC host names that are allowed by the `#security.allowedUNCHosts#` setting or after user confirmation. Find out more about this setting at https://aka.ms/vscode-windows-unc.'\n                    )),\n                    'scope': 2\n                }\n            }\n        });\n    }\n};\nDynamicWorkbenchSecurityConfiguration = ( (__decorate([\n    ( (__param(0, IRemoteAgentService)))\n], DynamicWorkbenchSecurityConfiguration)));\nconst CONFIG_NEW_WINDOW_PROFILE = 'window.newWindowProfile';\nlet DynamicWindowConfiguration = class DynamicWindowConfiguration extends Disposable {\n    static { this.ID = 'workbench.contrib.dynamicWindowConfiguration'; }\n    constructor(userDataProfilesService, configurationService) {\n        super();\n        this.userDataProfilesService = userDataProfilesService;\n        this.configurationService = configurationService;\n        this.registerNewWindowProfileConfiguration();\n        this._register(this.userDataProfilesService.onDidChangeProfiles((e) => this.registerNewWindowProfileConfiguration()));\n        this.setNewWindowProfile();\n        this.checkAndResetNewWindowProfileConfig();\n        this._register(configurationService.onDidChangeConfiguration(e => {\n            if (e.source !== 7  && e.affectsConfiguration(CONFIG_NEW_WINDOW_PROFILE)) {\n                this.setNewWindowProfile();\n            }\n        }));\n        this._register(this.userDataProfilesService.onDidChangeProfiles(() => this.checkAndResetNewWindowProfileConfig()));\n    }\n    registerNewWindowProfileConfiguration() {\n        const registry = ( (Registry.as(Extensions$1.Configuration)));\n        const configurationNode = {\n            ...windowConfigurationNodeBase,\n            'properties': {\n                [CONFIG_NEW_WINDOW_PROFILE]: {\n                    'type': ['string', 'null'],\n                    'default': null,\n                    'enum': [...( (this.userDataProfilesService.profiles.map(profile => profile.name))), null],\n                    'enumItemLabels': [...( (this.userDataProfilesService.profiles.map(p => ''))), ( localize(4489, \"Active Window\"))],\n                    'description': ( localize(\n                        4490,\n                        \"Specifies the profile to use when opening a new window. If a profile name is provided, the new window will use that profile. If no profile name is provided, the new window will use the profile of the active window or the Default profile if no active window exists.\"\n                    )),\n                    'scope': 1 ,\n                }\n            }\n        };\n        if (this.configurationNode) {\n            registry.updateConfigurations({ add: [configurationNode], remove: [this.configurationNode] });\n        }\n        else {\n            registry.registerConfiguration(configurationNode);\n        }\n        this.configurationNode = configurationNode;\n    }\n    setNewWindowProfile() {\n        const newWindowProfileName = this.configurationService.getValue(CONFIG_NEW_WINDOW_PROFILE);\n        this.newWindowProfile = newWindowProfileName ? this.userDataProfilesService.profiles.find(profile => profile.name === newWindowProfileName) : undefined;\n    }\n    checkAndResetNewWindowProfileConfig() {\n        const newWindowProfileName = this.configurationService.getValue(CONFIG_NEW_WINDOW_PROFILE);\n        if (!newWindowProfileName) {\n            return;\n        }\n        const profile = this.newWindowProfile ? this.userDataProfilesService.profiles.find(profile => profile.id === this.newWindowProfile.id) : undefined;\n        if (newWindowProfileName === profile?.name) {\n            return;\n        }\n        this.configurationService.updateValue(CONFIG_NEW_WINDOW_PROFILE, profile?.name);\n    }\n};\nDynamicWindowConfiguration = ( (__decorate([\n    ( (__param(0, IUserDataProfilesService))),\n    ( (__param(1, IConfigurationService)))\n], DynamicWindowConfiguration)));\nexport { CONFIG_NEW_WINDOW_PROFILE, ConfigurationMigrationWorkbenchContribution, DynamicWindowConfiguration, DynamicWorkbenchSecurityConfiguration, Extensions, applicationConfigurationNodeBase, problemsConfigurationNodeBase, securityConfigurationNodeBase, windowConfigurationNodeBase, workbenchConfigurationNodeBase };\n","import { localize } from '../../nls.js';\nimport { assertIsDefined } from '../../base/common/types.js';\nimport { URI } from '../../base/common/uri.js';\nimport { toDisposable, Disposable } from '../../base/common/lifecycle.js';\nimport { IInstantiationService } from '../../platform/instantiation/common/instantiation.js';\nimport { Registry } from '../../platform/registry/common/platform.js';\nimport { FileType } from '../../platform/files/common/files.js';\nimport { Schemas } from '../../base/common/network.js';\nimport { isErrorWithActions, createErrorWithActions } from '../../base/common/errorMessage.js';\nimport { toAction } from '../../base/common/actions.js';\nimport Severity$1 from '../../base/common/severity.js';\nconst EditorExtensions = {\n    EditorPane: 'workbench.contributions.editors',\n    EditorFactory: 'workbench.contributions.editor.inputFactories'\n};\nconst DEFAULT_EDITOR_ASSOCIATION = {\n    id: 'default',\n    displayName: ( localize(447, \"Text Editor\")),\n    providerDisplayName: ( localize(448, \"Built-in\"))\n};\nconst SIDE_BY_SIDE_EDITOR_ID = 'workbench.editor.sidebysideEditor';\nconst TEXT_DIFF_EDITOR_ID = 'workbench.editors.textDiffEditor';\nconst BINARY_DIFF_EDITOR_ID = 'workbench.editors.binaryResourceDiffEditor';\nfunction isEditorPaneWithSelection(editorPane) {\n    const candidate = editorPane;\n    return !!candidate && typeof candidate.getSelection === 'function' && !!candidate.onDidChangeSelection;\n}\nfunction findViewStateForEditor(input, group, editorService) {\n    for (const editorPane of editorService.visibleEditorPanes) {\n        if (editorPane.group.id === group && input.matches(editorPane.input)) {\n            return editorPane.getViewState();\n        }\n    }\n    return undefined;\n}\nfunction isResourceEditorInput(editor) {\n    if (isEditorInput(editor)) {\n        return false;\n    }\n    const candidate = editor;\n    return URI.isUri(candidate?.resource);\n}\nfunction isResourceDiffEditorInput(editor) {\n    if (isEditorInput(editor)) {\n        return false;\n    }\n    const candidate = editor;\n    return candidate?.original !== undefined && candidate.modified !== undefined;\n}\nfunction isResourceMultiDiffEditorInput(editor) {\n    if (isEditorInput(editor)) {\n        return false;\n    }\n    const candidate = editor;\n    if (!candidate) {\n        return false;\n    }\n    if (candidate.resources && !Array.isArray(candidate.resources)) {\n        return false;\n    }\n    return !!candidate.resources || !!candidate.multiDiffSource;\n}\nfunction isResourceSideBySideEditorInput(editor) {\n    if (isEditorInput(editor)) {\n        return false;\n    }\n    if (isResourceDiffEditorInput(editor)) {\n        return false;\n    }\n    const candidate = editor;\n    return candidate?.primary !== undefined && candidate.secondary !== undefined;\n}\nfunction isUntitledResourceEditorInput(editor) {\n    if (isEditorInput(editor)) {\n        return false;\n    }\n    const candidate = editor;\n    if (!candidate) {\n        return false;\n    }\n    return candidate.resource === undefined || candidate.resource.scheme === Schemas.untitled || candidate.forceUntitled === true;\n}\nfunction isResourceMergeEditorInput(editor) {\n    if (isEditorInput(editor)) {\n        return false;\n    }\n    const candidate = editor;\n    return URI.isUri(candidate?.base?.resource) && URI.isUri(candidate?.input1?.resource) && URI.isUri(candidate?.input2?.resource) && URI.isUri(candidate?.result?.resource);\n}\nclass SaveSourceFactory {\n    constructor() {\n        this.mapIdToSaveSource = ( (new Map()));\n    }\n    registerSource(id, label) {\n        let sourceDescriptor = this.mapIdToSaveSource.get(id);\n        if (!sourceDescriptor) {\n            sourceDescriptor = { source: id, label };\n            this.mapIdToSaveSource.set(id, sourceDescriptor);\n        }\n        return sourceDescriptor.source;\n    }\n    getSourceLabel(source) {\n        return this.mapIdToSaveSource.get(source)?.label ?? source;\n    }\n}\nconst SaveSourceRegistry = ( (new SaveSourceFactory()));\nvar EditorInputCapabilities;\n( ((function(EditorInputCapabilities) {\n    EditorInputCapabilities[EditorInputCapabilities[\"None\"] = 0] = \"None\";\n    EditorInputCapabilities[EditorInputCapabilities[\"Readonly\"] = 2] = \"Readonly\";\n    EditorInputCapabilities[EditorInputCapabilities[\"Untitled\"] = 4] = \"Untitled\";\n    EditorInputCapabilities[EditorInputCapabilities[\"Singleton\"] = 8] = \"Singleton\";\n    EditorInputCapabilities[EditorInputCapabilities[\"RequiresTrust\"] = 16] = \"RequiresTrust\";\n    EditorInputCapabilities[EditorInputCapabilities[\"CanSplitInGroup\"] = 32] = \"CanSplitInGroup\";\n    EditorInputCapabilities[EditorInputCapabilities[\"ForceDescription\"] = 64] = \"ForceDescription\";\n    EditorInputCapabilities[EditorInputCapabilities[\"CanDropIntoEditor\"] = 128] = \"CanDropIntoEditor\";\n    EditorInputCapabilities[EditorInputCapabilities[\"MultipleEditors\"] = 256] = \"MultipleEditors\";\n    EditorInputCapabilities[EditorInputCapabilities[\"Scratchpad\"] = 512] = \"Scratchpad\";\n})(EditorInputCapabilities || (EditorInputCapabilities = {}))));\nclass AbstractEditorInput extends Disposable {\n}\nfunction isEditorInput(editor) {\n    return editor instanceof AbstractEditorInput;\n}\nfunction isEditorInputWithPreferredResource(editor) {\n    const candidate = editor;\n    return URI.isUri(candidate?.preferredResource);\n}\nfunction isSideBySideEditorInput(editor) {\n    const candidate = editor;\n    return isEditorInput(candidate?.primary) && isEditorInput(candidate?.secondary);\n}\nfunction isDiffEditorInput(editor) {\n    const candidate = editor;\n    return isEditorInput(candidate?.modified) && isEditorInput(candidate?.original);\n}\nfunction createTooLargeFileError(group, input, options, message, preferencesService) {\n    return createEditorOpenError(message, [\n        toAction({\n            id: 'workbench.action.openLargeFile', label: ( localize(449, \"Open Anyway\")), run: () => {\n                const fileEditorOptions = {\n                    ...options,\n                    limits: {\n                        size: Number.MAX_VALUE\n                    }\n                };\n                group.openEditor(input, fileEditorOptions);\n            }\n        }),\n        toAction({\n            id: 'workbench.action.configureEditorLargeFileConfirmation', label: ( localize(450, \"Configure Limit\")), run: () => {\n                return preferencesService.openUserSettings({ query: 'workbench.editorLargeFileConfirmation' });\n            }\n        }),\n    ], {\n        forceMessage: true,\n        forceSeverity: Severity$1.Warning\n    });\n}\nfunction isEditorInputWithOptions(editor) {\n    const candidate = editor;\n    return isEditorInput(candidate?.editor);\n}\nfunction isEditorInputWithOptionsAndGroup(editor) {\n    const candidate = editor;\n    return isEditorInputWithOptions(editor) && candidate?.group !== undefined;\n}\nfunction isEditorIdentifier(identifier) {\n    const candidate = identifier;\n    return typeof candidate?.groupId === 'number' && isEditorInput(candidate.editor);\n}\nfunction isEditorCommandsContext(context) {\n    const candidate = context;\n    return typeof candidate?.groupId === 'number';\n}\nvar EditorCloseContext;\n( ((function(EditorCloseContext) {\n    EditorCloseContext[EditorCloseContext[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    EditorCloseContext[EditorCloseContext[\"REPLACE\"] = 1] = \"REPLACE\";\n    EditorCloseContext[EditorCloseContext[\"MOVE\"] = 2] = \"MOVE\";\n    EditorCloseContext[EditorCloseContext[\"UNPIN\"] = 3] = \"UNPIN\";\n})(EditorCloseContext || (EditorCloseContext = {}))));\nvar SideBySideEditor;\n( ((function(SideBySideEditor) {\n    SideBySideEditor[SideBySideEditor[\"PRIMARY\"] = 1] = \"PRIMARY\";\n    SideBySideEditor[SideBySideEditor[\"SECONDARY\"] = 2] = \"SECONDARY\";\n    SideBySideEditor[SideBySideEditor[\"BOTH\"] = 3] = \"BOTH\";\n    SideBySideEditor[SideBySideEditor[\"ANY\"] = 4] = \"ANY\";\n})(SideBySideEditor || (SideBySideEditor = {}))));\nclass EditorResourceAccessorImpl {\n    getOriginalUri(editor, options) {\n        if (!editor) {\n            return undefined;\n        }\n        if (isResourceMergeEditorInput(editor)) {\n            return EditorResourceAccessor.getOriginalUri(editor.result, options);\n        }\n        if (options?.supportSideBySide) {\n            const { primary, secondary } = this.getSideEditors(editor);\n            if (primary && secondary) {\n                if (options?.supportSideBySide === SideBySideEditor.BOTH) {\n                    return {\n                        primary: this.getOriginalUri(primary, { filterByScheme: options.filterByScheme }),\n                        secondary: this.getOriginalUri(secondary, { filterByScheme: options.filterByScheme })\n                    };\n                }\n                else if (options?.supportSideBySide === SideBySideEditor.ANY) {\n                    return this.getOriginalUri(primary, { filterByScheme: options.filterByScheme }) ?? this.getOriginalUri(secondary, { filterByScheme: options.filterByScheme });\n                }\n                editor = options.supportSideBySide === SideBySideEditor.PRIMARY ? primary : secondary;\n            }\n        }\n        if (isResourceDiffEditorInput(editor) || isResourceMultiDiffEditorInput(editor) || isResourceSideBySideEditorInput(editor) || isResourceMergeEditorInput(editor)) {\n            return undefined;\n        }\n        const originalResource = isEditorInputWithPreferredResource(editor) ? editor.preferredResource : editor.resource;\n        if (!originalResource || !options || !options.filterByScheme) {\n            return originalResource;\n        }\n        return this.filterUri(originalResource, options.filterByScheme);\n    }\n    getSideEditors(editor) {\n        if (isSideBySideEditorInput(editor) || isResourceSideBySideEditorInput(editor)) {\n            return { primary: editor.primary, secondary: editor.secondary };\n        }\n        if (isDiffEditorInput(editor) || isResourceDiffEditorInput(editor)) {\n            return { primary: editor.modified, secondary: editor.original };\n        }\n        return { primary: undefined, secondary: undefined };\n    }\n    getCanonicalUri(editor, options) {\n        if (!editor) {\n            return undefined;\n        }\n        if (isResourceMergeEditorInput(editor)) {\n            return EditorResourceAccessor.getCanonicalUri(editor.result, options);\n        }\n        if (options?.supportSideBySide) {\n            const { primary, secondary } = this.getSideEditors(editor);\n            if (primary && secondary) {\n                if (options?.supportSideBySide === SideBySideEditor.BOTH) {\n                    return {\n                        primary: this.getCanonicalUri(primary, { filterByScheme: options.filterByScheme }),\n                        secondary: this.getCanonicalUri(secondary, { filterByScheme: options.filterByScheme })\n                    };\n                }\n                else if (options?.supportSideBySide === SideBySideEditor.ANY) {\n                    return this.getCanonicalUri(primary, { filterByScheme: options.filterByScheme }) ?? this.getCanonicalUri(secondary, { filterByScheme: options.filterByScheme });\n                }\n                editor = options.supportSideBySide === SideBySideEditor.PRIMARY ? primary : secondary;\n            }\n        }\n        if (isResourceDiffEditorInput(editor) || isResourceMultiDiffEditorInput(editor) || isResourceSideBySideEditorInput(editor) || isResourceMergeEditorInput(editor)) {\n            return undefined;\n        }\n        const canonicalResource = editor.resource;\n        if (!canonicalResource || !options || !options.filterByScheme) {\n            return canonicalResource;\n        }\n        return this.filterUri(canonicalResource, options.filterByScheme);\n    }\n    filterUri(resource, filter) {\n        if (Array.isArray(filter)) {\n            if (( (filter.some(scheme => resource.scheme === scheme)))) {\n                return resource;\n            }\n        }\n        else {\n            if (filter === resource.scheme) {\n                return resource;\n            }\n        }\n        return undefined;\n    }\n}\nvar EditorCloseMethod;\n( ((function(EditorCloseMethod) {\n    EditorCloseMethod[EditorCloseMethod[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    EditorCloseMethod[EditorCloseMethod[\"KEYBOARD\"] = 1] = \"KEYBOARD\";\n    EditorCloseMethod[EditorCloseMethod[\"MOUSE\"] = 2] = \"MOUSE\";\n})(EditorCloseMethod || (EditorCloseMethod = {}))));\nfunction preventEditorClose(group, editor, method, configuration) {\n    if (!group.isSticky(editor)) {\n        return false;\n    }\n    switch (configuration.preventPinnedEditorClose) {\n        case 'keyboardAndMouse': return method === EditorCloseMethod.MOUSE || method === EditorCloseMethod.KEYBOARD;\n        case 'mouse': return method === EditorCloseMethod.MOUSE;\n        case 'keyboard': return method === EditorCloseMethod.KEYBOARD;\n    }\n    return false;\n}\nconst EditorResourceAccessor = ( (new EditorResourceAccessorImpl()));\nvar CloseDirection;\n( ((function(CloseDirection) {\n    CloseDirection[CloseDirection[\"LEFT\"] = 0] = \"LEFT\";\n    CloseDirection[CloseDirection[\"RIGHT\"] = 1] = \"RIGHT\";\n})(CloseDirection || (CloseDirection = {}))));\nclass EditorFactoryRegistry {\n    constructor() {\n        this.editorSerializerConstructors = ( (new Map()));\n        this.editorSerializerInstances = ( (new Map()));\n    }\n    start(accessor) {\n        const instantiationService = this.instantiationService = accessor.get(IInstantiationService);\n        for (const [key, ctor] of this.editorSerializerConstructors) {\n            this.createEditorSerializer(key, ctor, instantiationService);\n        }\n        this.editorSerializerConstructors.clear();\n    }\n    createEditorSerializer(editorTypeId, ctor, instantiationService) {\n        const instance = instantiationService.createInstance(ctor);\n        this.editorSerializerInstances.set(editorTypeId, instance);\n    }\n    registerFileEditorFactory(factory) {\n        if (this.fileEditorFactory) {\n            throw ( (new Error('Can only register one file editor factory.')));\n        }\n        this.fileEditorFactory = factory;\n    }\n    getFileEditorFactory() {\n        return assertIsDefined(this.fileEditorFactory);\n    }\n    registerEditorSerializer(editorTypeId, ctor) {\n        if (( (this.editorSerializerConstructors.has(editorTypeId))) || ( (this.editorSerializerInstances.has(editorTypeId)))) {\n            throw ( (new Error(\n                `A editor serializer with type ID '${editorTypeId}' was already registered.`\n            )));\n        }\n        if (!this.instantiationService) {\n            this.editorSerializerConstructors.set(editorTypeId, ctor);\n        }\n        else {\n            this.createEditorSerializer(editorTypeId, ctor, this.instantiationService);\n        }\n        return toDisposable(() => {\n            this.editorSerializerConstructors.delete(editorTypeId);\n            this.editorSerializerInstances.delete(editorTypeId);\n        });\n    }\n    getEditorSerializer(arg1) {\n        return this.editorSerializerInstances.get(typeof arg1 === 'string' ? arg1 : arg1.typeId);\n    }\n}\nRegistry.add(EditorExtensions.EditorFactory, ( (new EditorFactoryRegistry())));\nasync function pathsToEditors(paths, fileService, logService) {\n    if (!paths || !paths.length) {\n        return [];\n    }\n    return await Promise.all(( (paths.map(async (path) => {\n        const resource = URI.revive(path.fileUri);\n        if (!resource) {\n            logService.info('Cannot resolve the path because it is not valid.', path);\n            return undefined;\n        }\n        const canHandleResource = await fileService.canHandleResource(resource);\n        if (!canHandleResource) {\n            logService.info('Cannot resolve the path because it cannot be handled', path);\n            return undefined;\n        }\n        let exists = path.exists;\n        let type = path.type;\n        if (typeof exists !== 'boolean' || typeof type !== 'number') {\n            try {\n                type = (await fileService.stat(resource)).isDirectory ? FileType.Directory : FileType.Unknown;\n                exists = true;\n            }\n            catch (error) {\n                logService.error(error);\n                exists = false;\n            }\n        }\n        if (!exists && path.openOnlyIfExists) {\n            logService.info('Cannot resolve the path because it does not exist', path);\n            return undefined;\n        }\n        if (type === FileType.Directory) {\n            logService.info('Cannot resolve the path because it is a directory', path);\n            return undefined;\n        }\n        const options = {\n            ...path.options,\n            pinned: true\n        };\n        if (!exists) {\n            return { resource, options, forceUntitled: true };\n        }\n        return { resource, options };\n    }))));\n}\nvar EditorsOrder;\n( ((function(EditorsOrder) {\n    EditorsOrder[EditorsOrder[\"MOST_RECENTLY_ACTIVE\"] = 0] = \"MOST_RECENTLY_ACTIVE\";\n    EditorsOrder[EditorsOrder[\"SEQUENTIAL\"] = 1] = \"SEQUENTIAL\";\n})(EditorsOrder || (EditorsOrder = {}))));\nfunction isTextEditorViewState(candidate) {\n    const viewState = candidate;\n    if (!viewState) {\n        return false;\n    }\n    const diffEditorViewState = viewState;\n    if (diffEditorViewState.modified) {\n        return isTextEditorViewState(diffEditorViewState.modified);\n    }\n    const codeEditorViewState = viewState;\n    return !!(codeEditorViewState.contributionsState && codeEditorViewState.viewState && Array.isArray(codeEditorViewState.cursorState));\n}\nfunction isEditorOpenError(obj) {\n    return isErrorWithActions(obj);\n}\nfunction createEditorOpenError(messageOrError, actions, options) {\n    const error = createErrorWithActions(messageOrError, actions);\n    error.forceMessage = options?.forceMessage;\n    error.forceSeverity = options?.forceSeverity;\n    error.allowDialog = options?.allowDialog;\n    return error;\n}\nexport { AbstractEditorInput, BINARY_DIFF_EDITOR_ID, CloseDirection, DEFAULT_EDITOR_ASSOCIATION, EditorCloseContext, EditorCloseMethod, EditorExtensions, EditorInputCapabilities, EditorResourceAccessor, EditorsOrder, SIDE_BY_SIDE_EDITOR_ID, SaveSourceRegistry, SideBySideEditor, TEXT_DIFF_EDITOR_ID, createEditorOpenError, createTooLargeFileError, findViewStateForEditor, isDiffEditorInput, isEditorCommandsContext, isEditorIdentifier, isEditorInput, isEditorInputWithOptions, isEditorInputWithOptionsAndGroup, isEditorOpenError, isEditorPaneWithSelection, isResourceDiffEditorInput, isResourceEditorInput, isResourceMergeEditorInput, isResourceMultiDiffEditorInput, isResourceSideBySideEditorInput, isSideBySideEditorInput, isTextEditorViewState, isUntitledResourceEditorInput, pathsToEditors, preventEditorClose };\n","import { Emitter } from '../../base/common/event.js';\nimport { localize } from '../../nls.js';\nimport { Disposable, toDisposable } from '../../base/common/lifecycle.js';\nimport { getOrSet, SetMap } from '../../base/common/map.js';\nimport { Registry } from '../../platform/registry/common/platform.js';\nimport { mixin } from '../../base/common/objects.js';\nimport { Codicon } from '../../base/common/codicons.js';\nimport { registerIcon } from '../../platform/theme/common/iconRegistry.js';\nconst VIEWS_LOG_ID = 'views';\nconst VIEWS_LOG_NAME = ( localize(5282, \"Views\"));\nconst defaultViewIcon = registerIcon('default-view-icon', Codicon.window, ( localize(5283, 'Default view icon.')));\nvar Extensions;\n( ((function(Extensions) {\n    Extensions.ViewContainersRegistry = 'workbench.registry.view.containers';\n    Extensions.ViewsRegistry = 'workbench.registry.view';\n})(Extensions || (Extensions = {}))));\nvar ViewContainerLocation;\n( ((function(ViewContainerLocation) {\n    ViewContainerLocation[ViewContainerLocation[\"Sidebar\"] = 0] = \"Sidebar\";\n    ViewContainerLocation[ViewContainerLocation[\"Panel\"] = 1] = \"Panel\";\n    ViewContainerLocation[ViewContainerLocation[\"AuxiliaryBar\"] = 2] = \"AuxiliaryBar\";\n})(ViewContainerLocation || (ViewContainerLocation = {}))));\nconst ViewContainerLocations = [0 , 1 , 2 ];\nfunction ViewContainerLocationToString(viewContainerLocation) {\n    switch (viewContainerLocation) {\n        case 0 : return 'sidebar';\n        case 1 : return 'panel';\n        case 2 : return 'auxiliarybar';\n    }\n}\nclass ViewContainersRegistryImpl extends Disposable {\n    constructor() {\n        super(...arguments);\n        this._onDidRegister = this._register(( (new Emitter())));\n        this.onDidRegister = this._onDidRegister.event;\n        this._onDidDeregister = this._register(( (new Emitter())));\n        this.onDidDeregister = this._onDidDeregister.event;\n        this.viewContainers = ( (new Map()));\n        this.defaultViewContainers = [];\n    }\n    get all() {\n        return [...( (this.viewContainers.values()))].flat();\n    }\n    registerViewContainer(viewContainerDescriptor, viewContainerLocation, options) {\n        const existing = this.get(viewContainerDescriptor.id);\n        if (existing) {\n            return existing;\n        }\n        const viewContainer = viewContainerDescriptor;\n        viewContainer.openCommandActionDescriptor = options?.doNotRegisterOpenCommand ? undefined : (viewContainer.openCommandActionDescriptor ?? { id: viewContainer.id });\n        const viewContainers = getOrSet(this.viewContainers, viewContainerLocation, []);\n        viewContainers.push(viewContainer);\n        if (options?.isDefault) {\n            this.defaultViewContainers.push(viewContainer);\n        }\n        this._onDidRegister.fire({ viewContainer, viewContainerLocation });\n        return viewContainer;\n    }\n    deregisterViewContainer(viewContainer) {\n        for (const viewContainerLocation of ( (this.viewContainers.keys()))) {\n            const viewContainers = this.viewContainers.get(viewContainerLocation);\n            const index = viewContainers?.indexOf(viewContainer);\n            if (index !== -1) {\n                viewContainers?.splice(index, 1);\n                if (viewContainers.length === 0) {\n                    this.viewContainers.delete(viewContainerLocation);\n                }\n                this._onDidDeregister.fire({ viewContainer, viewContainerLocation });\n                return;\n            }\n        }\n    }\n    get(id) {\n        return this.all.filter(viewContainer => viewContainer.id === id)[0];\n    }\n    getViewContainers(location) {\n        return [...(this.viewContainers.get(location) || [])];\n    }\n    getViewContainerLocation(container) {\n        return [...( (this.viewContainers.keys()))].filter(location => this.getViewContainers(location).filter(viewContainer => viewContainer?.id === container.id).length > 0)[0];\n    }\n    getDefaultViewContainer(location) {\n        return this.defaultViewContainers.find(viewContainer => this.getViewContainerLocation(viewContainer) === location);\n    }\n}\nRegistry.add(Extensions.ViewContainersRegistry, ( (new ViewContainersRegistryImpl())));\nvar ViewContentGroups;\n( ((function(ViewContentGroups) {\n    ViewContentGroups[\"Open\"] = \"2_open\";\n    ViewContentGroups[\"Debug\"] = \"4_debug\";\n    ViewContentGroups[\"SCM\"] = \"5_scm\";\n    ViewContentGroups[\"More\"] = \"9_more\";\n})(ViewContentGroups || (ViewContentGroups = {}))));\nfunction compareViewContentDescriptors(a, b) {\n    const aGroup = a.group ?? ViewContentGroups.More;\n    const bGroup = b.group ?? ViewContentGroups.More;\n    if (aGroup !== bGroup) {\n        return aGroup.localeCompare(bGroup);\n    }\n    return (a.order ?? 5) - (b.order ?? 5);\n}\nclass ViewsRegistry extends Disposable {\n    constructor() {\n        super(...arguments);\n        this._onViewsRegistered = this._register(( (new Emitter())));\n        this.onViewsRegistered = this._onViewsRegistered.event;\n        this._onViewsDeregistered = this._register(( (new Emitter())));\n        this.onViewsDeregistered = this._onViewsDeregistered.event;\n        this._onDidChangeContainer = this._register(( (new Emitter())));\n        this.onDidChangeContainer = this._onDidChangeContainer.event;\n        this._onDidChangeViewWelcomeContent = this._register(( (new Emitter())));\n        this.onDidChangeViewWelcomeContent = this._onDidChangeViewWelcomeContent.event;\n        this._viewContainers = [];\n        this._views = ( (new Map()));\n        this._viewWelcomeContents = ( (new SetMap()));\n    }\n    registerViews(views, viewContainer) {\n        this.registerViews2([{ views, viewContainer }]);\n    }\n    registerViews2(views) {\n        views.forEach(({ views, viewContainer }) => this.addViews(views, viewContainer));\n        this._onViewsRegistered.fire(views);\n    }\n    deregisterViews(viewDescriptors, viewContainer) {\n        const views = this.removeViews(viewDescriptors, viewContainer);\n        if (views.length) {\n            this._onViewsDeregistered.fire({ views, viewContainer });\n        }\n    }\n    moveViews(viewsToMove, viewContainer) {\n        for (const container of ( (this._views.keys()))) {\n            if (container !== viewContainer) {\n                const views = this.removeViews(viewsToMove, container);\n                if (views.length) {\n                    this.addViews(views, viewContainer);\n                    this._onDidChangeContainer.fire({ views, from: container, to: viewContainer });\n                }\n            }\n        }\n    }\n    getViews(loc) {\n        return this._views.get(loc) || [];\n    }\n    getView(id) {\n        for (const viewContainer of this._viewContainers) {\n            const viewDescriptor = (this._views.get(viewContainer) || []).filter(v => v.id === id)[0];\n            if (viewDescriptor) {\n                return viewDescriptor;\n            }\n        }\n        return null;\n    }\n    getViewContainer(viewId) {\n        for (const viewContainer of this._viewContainers) {\n            const viewDescriptor = (this._views.get(viewContainer) || []).filter(v => v.id === viewId)[0];\n            if (viewDescriptor) {\n                return viewContainer;\n            }\n        }\n        return null;\n    }\n    registerViewWelcomeContent(id, viewContent) {\n        this._viewWelcomeContents.add(id, viewContent);\n        this._onDidChangeViewWelcomeContent.fire(id);\n        return toDisposable(() => {\n            this._viewWelcomeContents.delete(id, viewContent);\n            this._onDidChangeViewWelcomeContent.fire(id);\n        });\n    }\n    registerViewWelcomeContent2(id, viewContentMap) {\n        const disposables = ( (new Map()));\n        for (const [key, content] of viewContentMap) {\n            this._viewWelcomeContents.add(id, content);\n            disposables.set(key, toDisposable(() => {\n                this._viewWelcomeContents.delete(id, content);\n                this._onDidChangeViewWelcomeContent.fire(id);\n            }));\n        }\n        this._onDidChangeViewWelcomeContent.fire(id);\n        return disposables;\n    }\n    getViewWelcomeContent(id) {\n        const result = [];\n        this._viewWelcomeContents.forEach(id, descriptor => result.push(descriptor));\n        return result.sort(compareViewContentDescriptors);\n    }\n    addViews(viewDescriptors, viewContainer) {\n        let views = this._views.get(viewContainer);\n        if (!views) {\n            views = [];\n            this._views.set(viewContainer, views);\n            this._viewContainers.push(viewContainer);\n        }\n        for (const viewDescriptor of viewDescriptors) {\n            if (this.getView(viewDescriptor.id) !== null) {\n                throw ( (new Error(\n                    localize(5284, \"A view with id '{0}' is already registered\", viewDescriptor.id)\n                )));\n            }\n            views.push(viewDescriptor);\n        }\n    }\n    removeViews(viewDescriptors, viewContainer) {\n        const views = this._views.get(viewContainer);\n        if (!views) {\n            return [];\n        }\n        const viewsToDeregister = [];\n        const remaningViews = [];\n        for (const view of views) {\n            if (!viewDescriptors.includes(view)) {\n                remaningViews.push(view);\n            }\n            else {\n                viewsToDeregister.push(view);\n            }\n        }\n        if (viewsToDeregister.length) {\n            if (remaningViews.length) {\n                this._views.set(viewContainer, remaningViews);\n            }\n            else {\n                this._views.delete(viewContainer);\n                this._viewContainers.splice(this._viewContainers.indexOf(viewContainer), 1);\n            }\n        }\n        return viewsToDeregister;\n    }\n}\nRegistry.add(Extensions.ViewsRegistry, ( (new ViewsRegistry())));\nvar ViewVisibilityState;\n( ((function(ViewVisibilityState) {\n    ViewVisibilityState[ViewVisibilityState[\"Default\"] = 0] = \"Default\";\n    ViewVisibilityState[ViewVisibilityState[\"Expand\"] = 1] = \"Expand\";\n})(ViewVisibilityState || (ViewVisibilityState = {}))));\nvar TreeItemCollapsibleState;\n( ((function(TreeItemCollapsibleState) {\n    TreeItemCollapsibleState[TreeItemCollapsibleState[\"None\"] = 0] = \"None\";\n    TreeItemCollapsibleState[TreeItemCollapsibleState[\"Collapsed\"] = 1] = \"Collapsed\";\n    TreeItemCollapsibleState[TreeItemCollapsibleState[\"Expanded\"] = 2] = \"Expanded\";\n})(TreeItemCollapsibleState || (TreeItemCollapsibleState = {}))));\nclass ResolvableTreeItem {\n    constructor(treeItem, resolve) {\n        this.resolved = false;\n        this._hasResolve = false;\n        mixin(this, treeItem);\n        this._hasResolve = !!resolve;\n        this.resolve = async (token) => {\n            if (resolve && !this.resolved) {\n                const resolvedItem = await resolve(token);\n                if (resolvedItem) {\n                    this.tooltip = this.tooltip ?? resolvedItem.tooltip;\n                    this.command = this.command ?? resolvedItem.command;\n                }\n            }\n            if (!token.isCancellationRequested) {\n                this.resolved = true;\n            }\n        };\n    }\n    get hasResolve() {\n        return this._hasResolve;\n    }\n    resetResolve() {\n        this.resolved = false;\n    }\n    asTreeItem() {\n        return {\n            handle: this.handle,\n            parentHandle: this.parentHandle,\n            collapsibleState: this.collapsibleState,\n            label: this.label,\n            description: this.description,\n            icon: this.icon,\n            iconDark: this.iconDark,\n            themeIcon: this.themeIcon,\n            resourceUri: this.resourceUri,\n            tooltip: this.tooltip,\n            contextValue: this.contextValue,\n            command: this.command,\n            children: this.children,\n            accessibilityInformation: this.accessibilityInformation\n        };\n    }\n}\nclass NoTreeViewError extends Error {\n    constructor(treeViewId) {\n        super(( localize(5285, 'No tree view with id \\'{0}\\' registered.', treeViewId)));\n        this.name = 'NoTreeViewError';\n    }\n    static is(err) {\n        return !!err && err.name === 'NoTreeViewError';\n    }\n}\nexport { Extensions, NoTreeViewError, ResolvableTreeItem, TreeItemCollapsibleState, VIEWS_LOG_ID, VIEWS_LOG_NAME, ViewContainerLocation, ViewContainerLocationToString, ViewContainerLocations, ViewContentGroups, ViewVisibilityState, defaultViewIcon };\n","import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';\nimport { findLast } from '../../../../base/common/arraysFind.js';\nimport { timeout } from '../../../../base/common/async.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { isMarkdownString } from '../../../../base/common/htmlContent.js';\nimport { Iterable } from '../../../../base/common/iterator.js';\nimport { toDisposable } from '../../../../base/common/lifecycle.js';\nimport { revive } from '../../../../base/common/marshalling.js';\nimport { observableValue } from '../../../../base/common/observableInternal/base.js';\nimport '../../../../base/common/arrays.js';\nimport '../../../../base/common/observableInternal/autorun.js';\nimport '../../../../base/common/observableInternal/derived.js';\nimport '../../../../base/common/observableInternal/utils.js';\nimport { equalsIgnoreCase } from '../../../../base/common/strings.js';\nimport { ThemeIcon } from '../../../../base/common/themables.js';\nimport { ContextKeyExpr } from '../../../../platform/contextkey/common/contextkey.js';\nimport { IContextKeyService } from '../../../../platform/contextkey/common/contextkey.service.js';\nimport { ExtensionIdentifier } from '../../../../platform/extensions/common/extensions.js';\nimport { ILogService } from '../../../../platform/log/common/log.service.js';\nimport { IProductService } from '../../../../platform/product/common/productService.service.js';\nimport { asJson } from '../../../../platform/request/common/request.js';\nimport { IRequestService } from '../../../../platform/request/common/request.service.js';\nimport { IStorageService } from '../../../../platform/storage/common/storage.service.js';\nimport { CONTEXT_CHAT_ENABLED, CONTEXT_CHAT_PANEL_PARTICIPANT_REGISTERED } from './chatContextKeys.js';\nvar ChatAgentNameService_1;\nvar ChatAgentLocation;\n( (function(ChatAgentLocation) {\n    ChatAgentLocation[\"Panel\"] = \"panel\";\n    ChatAgentLocation[\"Terminal\"] = \"terminal\";\n    ChatAgentLocation[\"Notebook\"] = \"notebook\";\n    ChatAgentLocation[\"Editor\"] = \"editor\";\n})(ChatAgentLocation || (ChatAgentLocation = {})));\n( (function(ChatAgentLocation) {\n    function fromRaw(value) {\n        switch (value) {\n            case 'panel': return ChatAgentLocation.Panel;\n            case 'terminal': return ChatAgentLocation.Terminal;\n            case 'notebook': return ChatAgentLocation.Notebook;\n            case 'editor': return ChatAgentLocation.Editor;\n        }\n        return ChatAgentLocation.Panel;\n    }\n    ChatAgentLocation.fromRaw = fromRaw;\n})(ChatAgentLocation || (ChatAgentLocation = {})));\nfunction isChatWelcomeMessageContent(obj) {\n    return obj &&\n        ThemeIcon.isThemeIcon(obj.icon) &&\n        typeof obj.title === 'string' &&\n        isMarkdownString(obj.message);\n}\nlet ChatAgentService = class ChatAgentService {\n    static { this.AGENT_LEADER = '@'; }\n    constructor(contextKeyService) {\n        this.contextKeyService = contextKeyService;\n        this._agents = ( new Map());\n        this._onDidChangeAgents = ( new Emitter());\n        this.onDidChangeAgents = this._onDidChangeAgents.event;\n        this._agentCompletionProviders = ( new Map());\n        this._chatParticipantDetectionProviders = ( new Map());\n        this._hasDefaultAgent = CONTEXT_CHAT_ENABLED.bindTo(this.contextKeyService);\n        this._defaultAgentRegistered = CONTEXT_CHAT_PANEL_PARTICIPANT_REGISTERED.bindTo(this.contextKeyService);\n    }\n    registerAgent(id, data) {\n        const existingAgent = this.getAgent(id);\n        if (existingAgent) {\n            throw ( new Error(`Agent already registered: ${JSON.stringify(id)}`));\n        }\n        if (data.isDefault) {\n            this._defaultAgentRegistered.set(true);\n        }\n        const that = this;\n        const commands = data.slashCommands;\n        data = {\n            ...data,\n            get slashCommands() {\n                return commands.filter(c => !c.when || that.contextKeyService.contextMatchesRules(ContextKeyExpr.deserialize(c.when)));\n            }\n        };\n        const entry = { data };\n        this._agents.set(id, entry);\n        this._onDidChangeAgents.fire(undefined);\n        return toDisposable(() => {\n            this._agents.delete(id);\n            if (data.isDefault) {\n                this._defaultAgentRegistered.set(false);\n            }\n            this._onDidChangeAgents.fire(undefined);\n        });\n    }\n    registerAgentImplementation(id, agentImpl) {\n        const entry = this._agents.get(id);\n        if (!entry) {\n            throw ( new Error(`Unknown agent: ${JSON.stringify(id)}`));\n        }\n        if (entry.impl) {\n            throw ( new Error(`Agent already has implementation: ${JSON.stringify(id)}`));\n        }\n        if (entry.data.isDefault) {\n            this._hasDefaultAgent.set(true);\n        }\n        entry.impl = agentImpl;\n        this._onDidChangeAgents.fire(( new MergedChatAgent(entry.data, agentImpl)));\n        return toDisposable(() => {\n            entry.impl = undefined;\n            this._onDidChangeAgents.fire(undefined);\n            if (entry.data.isDefault) {\n                this._hasDefaultAgent.set(false);\n            }\n        });\n    }\n    registerDynamicAgent(data, agentImpl) {\n        data.isDynamic = true;\n        const agent = { data, impl: agentImpl };\n        this._agents.set(data.id, agent);\n        this._onDidChangeAgents.fire(( new MergedChatAgent(data, agentImpl)));\n        return toDisposable(() => {\n            this._agents.delete(data.id);\n            this._onDidChangeAgents.fire(undefined);\n        });\n    }\n    registerAgentCompletionProvider(id, provider) {\n        this._agentCompletionProviders.set(id, provider);\n        return {\n            dispose: () => { this._agentCompletionProviders.delete(id); }\n        };\n    }\n    async getAgentCompletionItems(id, query, token) {\n        return (await this._agentCompletionProviders.get(id)?.(query, token)) ?? [];\n    }\n    updateAgent(id, updateMetadata) {\n        const agent = this._agents.get(id);\n        if (!agent?.impl) {\n            throw ( new Error(`No activated agent with id ${JSON.stringify(id)} registered`));\n        }\n        agent.data.metadata = { ...agent.data.metadata, ...updateMetadata };\n        this._onDidChangeAgents.fire(( new MergedChatAgent(agent.data, agent.impl)));\n    }\n    getDefaultAgent(location) {\n        return findLast(this.getActivatedAgents(), a => !!a.isDefault && a.locations.includes(location));\n    }\n    getContributedDefaultAgent(location) {\n        return this.getAgents().find(a => !!a.isDefault && a.locations.includes(location));\n    }\n    getSecondaryAgent() {\n        return Iterable.find(( this._agents.values()), a => !!a.data.metadata.isSecondary)?.data;\n    }\n    getAgent(id) {\n        if (!this._agentIsEnabled(id)) {\n            return;\n        }\n        return this._agents.get(id)?.data;\n    }\n    _agentIsEnabled(id) {\n        const entry = this._agents.get(id);\n        return !entry?.data.when || this.contextKeyService.contextMatchesRules(ContextKeyExpr.deserialize(entry.data.when));\n    }\n    getAgentByFullyQualifiedId(id) {\n        const agent = Iterable.find(( this._agents.values()), a => getFullyQualifiedId(a.data) === id)?.data;\n        if (agent && !this._agentIsEnabled(agent.id)) {\n            return;\n        }\n        return agent;\n    }\n    getAgents() {\n        return ( Array.from(( this._agents.values()))\n            .map(entry => entry.data))\n            .filter(a => this._agentIsEnabled(a.id));\n    }\n    getActivatedAgents() {\n        return ( Array.from(( this._agents.values()))\n            .filter(a => !!a.impl)\n            .filter(a => this._agentIsEnabled(a.data.id))\n            .map(a => ( new MergedChatAgent(a.data, a.impl))));\n    }\n    getAgentsByName(name) {\n        return this.getAgents().filter(a => a.name === name);\n    }\n    agentHasDupeName(id) {\n        const agent = this.getAgent(id);\n        if (!agent) {\n            return false;\n        }\n        return this.getAgentsByName(agent.name)\n            .filter(a => a.extensionId.value !== agent.extensionId.value).length > 0;\n    }\n    async invokeAgent(id, request, progress, history, token) {\n        const data = this._agents.get(id);\n        if (!data?.impl) {\n            throw ( new Error(`No activated agent with id \"${id}\"`));\n        }\n        return await data.impl.invoke(request, progress, history, token);\n    }\n    async getFollowups(id, request, result, history, token) {\n        const data = this._agents.get(id);\n        if (!data?.impl) {\n            throw ( new Error(`No activated agent with id \"${id}\"`));\n        }\n        if (!data.impl?.provideFollowups) {\n            return [];\n        }\n        return data.impl.provideFollowups(request, result, history, token);\n    }\n    async getChatTitle(id, history, token) {\n        const data = this._agents.get(id);\n        if (!data?.impl) {\n            throw ( new Error(`No activated agent with id \"${id}\"`));\n        }\n        if (!data.impl?.provideChatTitle) {\n            return undefined;\n        }\n        return data.impl.provideChatTitle(history, token);\n    }\n    registerChatParticipantDetectionProvider(handle, provider) {\n        this._chatParticipantDetectionProviders.set(handle, provider);\n        return toDisposable(() => {\n            this._chatParticipantDetectionProviders.delete(handle);\n        });\n    }\n    hasChatParticipantDetectionProviders() {\n        return this._chatParticipantDetectionProviders.size > 0;\n    }\n    async detectAgentOrCommand(request, history, options, token) {\n        const provider = Iterable.first(( this._chatParticipantDetectionProviders.values()));\n        if (!provider) {\n            return;\n        }\n        const participants = this.getAgents().reduce((acc, a) => {\n            acc.push({ participant: a.id, disambiguation: a.disambiguation ?? [] });\n            for (const command of a.slashCommands) {\n                acc.push({ participant: a.id, command: command.name, disambiguation: command.disambiguation ?? [] });\n            }\n            return acc;\n        }, []);\n        const result = await provider.provideParticipantDetection(request, history, { ...options, participants }, token);\n        if (!result) {\n            return;\n        }\n        const agent = this.getAgent(result.participant);\n        if (!agent) {\n            return;\n        }\n        if (!result.command) {\n            return { agent };\n        }\n        const command = agent?.slashCommands.find(c => c.name === result.command);\n        if (!command) {\n            return;\n        }\n        return { agent, command };\n    }\n};\nChatAgentService = ( __decorate([\n    ( __param(0, IContextKeyService))\n], ChatAgentService));\nclass MergedChatAgent {\n    constructor(data, impl) {\n        this.data = data;\n        this.impl = impl;\n    }\n    get id() { return this.data.id; }\n    get name() { return this.data.name ?? ''; }\n    get fullName() { return this.data.fullName ?? ''; }\n    get description() { return this.data.description ?? ''; }\n    get extensionId() { return this.data.extensionId; }\n    get extensionPublisherId() { return this.data.extensionPublisherId; }\n    get extensionPublisherDisplayName() { return this.data.publisherDisplayName; }\n    get extensionDisplayName() { return this.data.extensionDisplayName; }\n    get isDefault() { return this.data.isDefault; }\n    get metadata() { return this.data.metadata; }\n    get slashCommands() { return this.data.slashCommands; }\n    get locations() { return this.data.locations; }\n    get disambiguation() { return this.data.disambiguation; }\n    async invoke(request, progress, history, token) {\n        return this.impl.invoke(request, progress, history, token);\n    }\n    async provideFollowups(request, result, history, token) {\n        if (this.impl.provideFollowups) {\n            return this.impl.provideFollowups(request, result, history, token);\n        }\n        return [];\n    }\n    provideWelcomeMessage(token) {\n        if (this.impl.provideWelcomeMessage) {\n            return this.impl.provideWelcomeMessage(token);\n        }\n        return undefined;\n    }\n    provideSampleQuestions(location, token) {\n        if (this.impl.provideSampleQuestions) {\n            return this.impl.provideSampleQuestions(location, token);\n        }\n        return undefined;\n    }\n    toJSON() {\n        return this.data;\n    }\n}\nlet ChatAgentNameService = class ChatAgentNameService {\n    static { ChatAgentNameService_1 = this; }\n    static { this.StorageKey = 'chat.participantNameRegistry'; }\n    constructor(productService, requestService, logService, storageService) {\n        this.requestService = requestService;\n        this.logService = logService;\n        this.storageService = storageService;\n        this.registry = observableValue(this, Object.create(null));\n        this.disposed = false;\n        if (!productService.chatParticipantRegistry) {\n            return;\n        }\n        this.url = productService.chatParticipantRegistry;\n        const raw = storageService.get(ChatAgentNameService_1.StorageKey, -1 );\n        try {\n            this.registry.set(JSON.parse(raw ?? '{}'), undefined);\n        }\n        catch (err) {\n            storageService.remove(ChatAgentNameService_1.StorageKey, -1 );\n        }\n        this.refresh();\n    }\n    refresh() {\n        if (this.disposed) {\n            return;\n        }\n        this.update()\n            .catch(err => this.logService.warn('Failed to fetch chat participant registry', err))\n            .then(() => timeout(5 * 60 * 1000))\n            .then(() => this.refresh());\n    }\n    async update() {\n        const context = await this.requestService.request({ type: 'GET', url: this.url }, CancellationToken.None);\n        if (context.res.statusCode !== 200) {\n            throw ( new Error('Could not get extensions report.'));\n        }\n        const result = await asJson(context);\n        if (!result || result.version !== 1) {\n            throw ( new Error('Unexpected chat participant registry response.'));\n        }\n        const registry = result.restrictedChatParticipants;\n        this.registry.set(registry, undefined);\n        this.storageService.store(ChatAgentNameService_1.StorageKey, JSON.stringify(registry), -1 , 1 );\n    }\n    getAgentNameRestriction(chatAgentData) {\n        const nameAllowed = this.checkAgentNameRestriction(chatAgentData.name, chatAgentData).get();\n        const fullNameAllowed = !chatAgentData.fullName || this.checkAgentNameRestriction(chatAgentData.fullName.replace(/\\s/g, ''), chatAgentData).get();\n        return nameAllowed && fullNameAllowed;\n    }\n    checkAgentNameRestriction(name, chatAgentData) {\n        const allowList = ( this.registry.map(registry => registry[name.toLowerCase()]));\n        return ( allowList.map(allowList => {\n            if (!allowList) {\n                return true;\n            }\n            return ( allowList.some(\n                id => equalsIgnoreCase(id, id.includes('.') ? chatAgentData.extensionId.value : chatAgentData.extensionPublisherId)\n            ));\n        }));\n    }\n    dispose() {\n        this.disposed = true;\n    }\n};\nChatAgentNameService = ChatAgentNameService_1 = ( __decorate([\n    ( __param(0, IProductService)),\n    ( __param(1, IRequestService)),\n    ( __param(2, ILogService)),\n    ( __param(3, IStorageService))\n], ChatAgentNameService));\nfunction getFullyQualifiedId(chatAgentData) {\n    return `${chatAgentData.extensionId.value}.${chatAgentData.id}`;\n}\nfunction reviveSerializedAgent(raw) {\n    const agent = 'name' in raw ?\n        raw :\n        {\n            ...raw,\n            name: raw.id,\n        };\n    if (!('extensionPublisherId' in agent)) {\n        agent.extensionPublisherId = agent.extensionPublisher ?? '';\n    }\n    if (!('extensionDisplayName' in agent)) {\n        agent.extensionDisplayName = '';\n    }\n    if (!('extensionId' in agent)) {\n        agent.extensionId = ( new ExtensionIdentifier(''));\n    }\n    return revive(agent);\n}\nexport { ChatAgentLocation, ChatAgentNameService, ChatAgentService, MergedChatAgent, getFullyQualifiedId, isChatWelcomeMessageContent, reviveSerializedAgent };\n","import { localize } from '../../../../nls.js';\nimport { RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\nconst CONTEXT_RESPONSE_VOTE = ( (new RawContextKey(\n 'chatSessionResponseVote',\n '',\n { type: 'string', description: ( localize(\n  7117,\n  \"When the response has been voted up, is set to 'up'. When voted down, is set to 'down'. Otherwise an empty string.\"\n )) }\n)));\nconst CONTEXT_RESPONSE_DETECTED_AGENT_COMMAND = ( (new RawContextKey(\n 'chatSessionResponseDetectedAgentOrCommand',\n false,\n { type: 'boolean', description: ( localize(7118, \"When the agent or command was automatically detected\")) }\n)));\nconst CONTEXT_CHAT_RESPONSE_SUPPORT_ISSUE_REPORTING = ( (new RawContextKey(\n 'chatResponseSupportsIssueReporting',\n false,\n { type: 'boolean', description: ( localize(7119, \"True when the current chat response supports issue reporting.\")) }\n)));\nconst CONTEXT_RESPONSE_FILTERED = ( (new RawContextKey(\n 'chatSessionResponseFiltered',\n false,\n { type: 'boolean', description: ( localize(7120, \"True when the chat response was filtered out by the server.\")) }\n)));\nconst CONTEXT_RESPONSE_ERROR = ( (new RawContextKey(\n 'chatSessionResponseError',\n false,\n { type: 'boolean', description: ( localize(7121, \"True when the chat response resulted in an error.\")) }\n)));\nconst CONTEXT_CHAT_REQUEST_IN_PROGRESS = ( (new RawContextKey(\n 'chatSessionRequestInProgress',\n false,\n { type: 'boolean', description: ( localize(7122, \"True when the current request is still in progress.\")) }\n)));\nconst CONTEXT_RESPONSE = ( (new RawContextKey('chatResponse', false, { type: 'boolean', description: ( localize(7123, \"The chat item is a response.\")) })));\nconst CONTEXT_REQUEST = ( (new RawContextKey('chatRequest', false, { type: 'boolean', description: ( localize(7124, \"The chat item is a request\")) })));\nconst CONTEXT_ITEM_ID = ( (new RawContextKey('chatItemId', '', { type: 'string', description: ( localize(7125, \"The id of the chat item.\")) })));\nconst CONTEXT_LAST_ITEM_ID = ( (new RawContextKey('chatLastItemId', [], { type: 'string', description: ( localize(7126, \"The id of the last chat item.\")) })));\nconst CONTEXT_CHAT_EDIT_APPLIED = ( (new RawContextKey('chatEditApplied', false, { type: 'boolean', description: ( localize(7127, \"True when the chat text edits have been applied.\")) })));\nconst CONTEXT_CHAT_INPUT_HAS_TEXT = ( (new RawContextKey('chatInputHasText', false, { type: 'boolean', description: ( localize(7128, \"True when the chat input has text.\")) })));\nconst CONTEXT_CHAT_INPUT_HAS_FOCUS = ( (new RawContextKey('chatInputHasFocus', false, { type: 'boolean', description: ( localize(7129, \"True when the chat input has focus.\")) })));\nconst CONTEXT_IN_CHAT_INPUT = ( (new RawContextKey('inChatInput', false, { type: 'boolean', description: ( localize(7130, \"True when focus is in the chat input, false otherwise.\")) })));\nconst CONTEXT_IN_CHAT_SESSION = ( (new RawContextKey('inChat', false, { type: 'boolean', description: ( localize(7131, \"True when focus is in the chat widget, false otherwise.\")) })));\nconst CONTEXT_CHAT_ENABLED = ( (new RawContextKey('chatIsEnabled', false, { type: 'boolean', description: ( localize(\n 7132,\n \"True when chat is enabled because a default chat participant is activated with an implementation.\"\n)) })));\nconst CONTEXT_CHAT_PANEL_PARTICIPANT_REGISTERED = ( (new RawContextKey(\n 'chatPanelParticipantRegistered',\n false,\n { type: 'boolean', description: ( localize(7133, \"True when a default chat participant is registered for the panel.\")) }\n)));\nconst CONTEXT_CHAT_EXTENSION_INVALID = ( (new RawContextKey(\n 'chatExtensionInvalid',\n false,\n { type: 'boolean', description: ( localize(\n  7134,\n  \"True when the installed chat extension is invalid and needs to be updated.\"\n )) }\n)));\nconst CONTEXT_CHAT_INPUT_CURSOR_AT_TOP = ( (new RawContextKey('chatCursorAtTop', false)));\nconst CONTEXT_CHAT_INPUT_HAS_AGENT = ( (new RawContextKey('chatInputHasAgent', false)));\nconst CONTEXT_CHAT_LOCATION = ( (new RawContextKey('chatLocation', undefined)));\nconst CONTEXT_IN_QUICK_CHAT = ( (new RawContextKey('quickChatHasFocus', false, { type: 'boolean', description: ( localize(7135, \"True when the quick chat UI has focus, false otherwise.\")) })));\nconst CONTEXT_LANGUAGE_MODELS_ARE_USER_SELECTABLE = ( (new RawContextKey(\n 'chatModelsAreUserSelectable',\n false,\n { type: 'boolean', description: ( localize(7136, \"True when the chat model can be selected manually by the user.\")) }\n)));\nconst CONTEXT_PARTICIPANT_SUPPORTS_MODEL_PICKER = ( (new RawContextKey(\n 'chatParticipantSupportsModelPicker',\n true,\n { type: 'boolean', description: ( localize(\n  7137,\n  \"True when the current chat participant supports picking the model manually.\"\n )) }\n)));\nconst CONTEXT_CHAT_EDITING_ENABLED = ( (new RawContextKey('chatEditingEnabled', false)));\nexport { CONTEXT_CHAT_EDITING_ENABLED, CONTEXT_CHAT_EDIT_APPLIED, CONTEXT_CHAT_ENABLED, CONTEXT_CHAT_EXTENSION_INVALID, CONTEXT_CHAT_INPUT_CURSOR_AT_TOP, CONTEXT_CHAT_INPUT_HAS_AGENT, CONTEXT_CHAT_INPUT_HAS_FOCUS, CONTEXT_CHAT_INPUT_HAS_TEXT, CONTEXT_CHAT_LOCATION, CONTEXT_CHAT_PANEL_PARTICIPANT_REGISTERED, CONTEXT_CHAT_REQUEST_IN_PROGRESS, CONTEXT_CHAT_RESPONSE_SUPPORT_ISSUE_REPORTING, CONTEXT_IN_CHAT_INPUT, CONTEXT_IN_CHAT_SESSION, CONTEXT_IN_QUICK_CHAT, CONTEXT_ITEM_ID, CONTEXT_LANGUAGE_MODELS_ARE_USER_SELECTABLE, CONTEXT_LAST_ITEM_ID, CONTEXT_PARTICIPANT_SUPPORTS_MODEL_PICKER, CONTEXT_REQUEST, CONTEXT_RESPONSE, CONTEXT_RESPONSE_DETECTED_AGENT_COMMAND, CONTEXT_RESPONSE_ERROR, CONTEXT_RESPONSE_FILTERED, CONTEXT_RESPONSE_VOTE };\n","import { URI } from '../../../../base/common/uri.js';\nimport { Range } from '../../../../editor/common/core/range.js';\nfunction isIDocumentContext(obj) {\n    return (!!obj &&\n        typeof obj === 'object' &&\n        'uri' in obj && obj.uri instanceof URI &&\n        'version' in obj && typeof obj.version === 'number' &&\n        'ranges' in obj && Array.isArray(obj.ranges) && obj.ranges.every(Range.isIRange));\n}\nfunction isIUsedContext(obj) {\n    return (!!obj &&\n        typeof obj === 'object' &&\n        'documents' in obj &&\n        Array.isArray(obj.documents) &&\n        obj.documents.every(isIDocumentContext));\n}\nvar ChatResponseReferencePartStatusKind;\n( (function(ChatResponseReferencePartStatusKind) {\n    ChatResponseReferencePartStatusKind[ChatResponseReferencePartStatusKind[\"Complete\"] = 1] = \"Complete\";\n    ChatResponseReferencePartStatusKind[ChatResponseReferencePartStatusKind[\"Partial\"] = 2] = \"Partial\";\n    ChatResponseReferencePartStatusKind[ChatResponseReferencePartStatusKind[\"Omitted\"] = 3] = \"Omitted\";\n})(\n    ChatResponseReferencePartStatusKind || (ChatResponseReferencePartStatusKind = {})\n));\nvar ChatAgentVoteDirection;\n( (function(ChatAgentVoteDirection) {\n    ChatAgentVoteDirection[ChatAgentVoteDirection[\"Down\"] = 0] = \"Down\";\n    ChatAgentVoteDirection[ChatAgentVoteDirection[\"Up\"] = 1] = \"Up\";\n})(ChatAgentVoteDirection || (ChatAgentVoteDirection = {})));\nvar ChatAgentVoteDownReason;\n( (function(ChatAgentVoteDownReason) {\n    ChatAgentVoteDownReason[\"IncorrectCode\"] = \"incorrectCode\";\n    ChatAgentVoteDownReason[\"DidNotFollowInstructions\"] = \"didNotFollowInstructions\";\n    ChatAgentVoteDownReason[\"IncompleteCode\"] = \"incompleteCode\";\n    ChatAgentVoteDownReason[\"MissingContext\"] = \"missingContext\";\n    ChatAgentVoteDownReason[\"PoorlyWrittenOrFormatted\"] = \"poorlyWrittenOrFormatted\";\n    ChatAgentVoteDownReason[\"RefusedAValidRequest\"] = \"refusedAValidRequest\";\n    ChatAgentVoteDownReason[\"OffensiveOrUnsafe\"] = \"offensiveOrUnsafe\";\n    ChatAgentVoteDownReason[\"Other\"] = \"other\";\n    ChatAgentVoteDownReason[\"WillReportIssue\"] = \"willReportIssue\";\n})(ChatAgentVoteDownReason || (ChatAgentVoteDownReason = {})));\nvar ChatCopyKind;\n( (function(ChatCopyKind) {\n    ChatCopyKind[ChatCopyKind[\"Action\"] = 1] = \"Action\";\n    ChatCopyKind[ChatCopyKind[\"Toolbar\"] = 2] = \"Toolbar\";\n})(ChatCopyKind || (ChatCopyKind = {})));\nexport { ChatAgentVoteDirection, ChatAgentVoteDownReason, ChatCopyKind, ChatResponseReferencePartStatusKind, isIDocumentContext, isIUsedContext };\n","import { Emitter } from '../../../../base/common/event.js';\nimport { timeout } from '../../../../base/common/async.js';\nimport { localize } from '../../../../nls.js';\nclass AbstractDebugAdapter {\n    constructor() {\n        this.pendingRequests = ( (new Map()));\n        this.queue = [];\n        this._onError = ( (new Emitter()));\n        this._onExit = ( (new Emitter()));\n        this.sequence = 1;\n    }\n    get onError() {\n        return this._onError.event;\n    }\n    get onExit() {\n        return this._onExit.event;\n    }\n    onMessage(callback) {\n        if (this.messageCallback) {\n            this._onError.fire(( (new Error(`attempt to set more than one 'Message' callback`))));\n        }\n        this.messageCallback = callback;\n    }\n    onEvent(callback) {\n        if (this.eventCallback) {\n            this._onError.fire(( (new Error(`attempt to set more than one 'Event' callback`))));\n        }\n        this.eventCallback = callback;\n    }\n    onRequest(callback) {\n        if (this.requestCallback) {\n            this._onError.fire(( (new Error(`attempt to set more than one 'Request' callback`))));\n        }\n        this.requestCallback = callback;\n    }\n    sendResponse(response) {\n        if (response.seq > 0) {\n            this._onError.fire(( (new Error(`attempt to send more than one response for command ${response.command}`))));\n        }\n        else {\n            this.internalSend('response', response);\n        }\n    }\n    sendRequest(command, args, clb, timeout) {\n        const request = {\n            command: command\n        };\n        if (args && ( (Object.keys(args))).length > 0) {\n            request.arguments = args;\n        }\n        this.internalSend('request', request);\n        if (typeof timeout === 'number') {\n            const timer = setTimeout(() => {\n                clearTimeout(timer);\n                const clb = this.pendingRequests.get(request.seq);\n                if (clb) {\n                    this.pendingRequests.delete(request.seq);\n                    const err = {\n                        type: 'response',\n                        seq: 0,\n                        request_seq: request.seq,\n                        success: false,\n                        command,\n                        message: ( localize(3871, \"Timeout after {0} ms for '{1}'\", timeout, command))\n                    };\n                    clb(err);\n                }\n            }, timeout);\n        }\n        if (clb) {\n            this.pendingRequests.set(request.seq, clb);\n        }\n        return request.seq;\n    }\n    acceptMessage(message) {\n        if (this.messageCallback) {\n            this.messageCallback(message);\n        }\n        else {\n            this.queue.push(message);\n            if (this.queue.length === 1) {\n                this.processQueue();\n            }\n        }\n    }\n    needsTaskBoundaryBetween(messageA, messageB) {\n        return messageA.type !== 'event' || messageB.type !== 'event';\n    }\n    async processQueue() {\n        let message;\n        while (this.queue.length) {\n            if (!message || this.needsTaskBoundaryBetween(this.queue[0], message)) {\n                await timeout(0);\n            }\n            message = this.queue.shift();\n            if (!message) {\n                return;\n            }\n            switch (message.type) {\n                case 'event':\n                    this.eventCallback?.(message);\n                    break;\n                case 'request':\n                    this.requestCallback?.(message);\n                    break;\n                case 'response': {\n                    const response = message;\n                    const clb = this.pendingRequests.get(response.request_seq);\n                    if (clb) {\n                        this.pendingRequests.delete(response.request_seq);\n                        clb(response);\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    internalSend(typ, message) {\n        message.type = typ;\n        message.seq = this.sequence++;\n        this.sendMessage(message);\n    }\n    async cancelPendingRequests() {\n        if (this.pendingRequests.size === 0) {\n            return Promise.resolve();\n        }\n        const pending = ( (new Map()));\n        this.pendingRequests.forEach((value, key) => pending.set(key, value));\n        await timeout(500);\n        pending.forEach((callback, request_seq) => {\n            const err = {\n                type: 'response',\n                seq: 0,\n                request_seq,\n                success: false,\n                command: 'canceled',\n                message: 'canceled'\n            };\n            callback(err);\n            this.pendingRequests.delete(request_seq);\n        });\n    }\n    getPendingRequestIds() {\n        return Array.from(( (this.pendingRequests.keys())));\n    }\n    dispose() {\n        this.queue = [];\n    }\n}\nexport { AbstractDebugAdapter };\n","import { URI } from '../../../../base/common/uri.js';\nimport { localize } from '../../../../nls.js';\nimport { RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\nconst VIEWLET_ID = 'workbench.view.debug';\nconst VARIABLES_VIEW_ID = 'workbench.debug.variablesView';\nconst WATCH_VIEW_ID = 'workbench.debug.watchExpressionsView';\nconst CALLSTACK_VIEW_ID = 'workbench.debug.callStackView';\nconst LOADED_SCRIPTS_VIEW_ID = 'workbench.debug.loadedScriptsView';\nconst BREAKPOINTS_VIEW_ID = 'workbench.debug.breakPointsView';\nconst DISASSEMBLY_VIEW_ID = 'workbench.debug.disassemblyView';\nconst DEBUG_PANEL_ID = 'workbench.panel.repl';\nconst REPL_VIEW_ID = 'workbench.panel.repl.view';\nconst CONTEXT_DEBUG_TYPE = ( (new RawContextKey('debugType', undefined, { type: 'string', description: ( localize(6, \"Debug type of the active debug session. For example 'python'.\")) })));\nconst CONTEXT_DEBUG_CONFIGURATION_TYPE = ( (new RawContextKey(\n    'debugConfigurationType',\n    undefined,\n    { type: 'string', description: ( localize(\n        7,\n        \"Debug type of the selected launch configuration. For example 'python'.\"\n    )) }\n)));\nconst CONTEXT_DEBUG_STATE = ( (new RawContextKey('debugState', 'inactive', { type: 'string', description: ( localize(\n    8,\n    \"State that the focused debug session is in. One of the following: 'inactive', 'initializing', 'stopped' or 'running'.\"\n)) })));\nconst CONTEXT_DEBUG_UX_KEY = 'debugUx';\nconst CONTEXT_DEBUG_UX = ( (new RawContextKey(\n    CONTEXT_DEBUG_UX_KEY,\n    'default',\n    { type: 'string', description: ( localize(\n        9,\n        \"Debug UX state. When there are no debug configurations it is 'simple', otherwise 'default'. Used to decide when to show welcome views in the debug viewlet.\"\n    )) }\n)));\nconst CONTEXT_HAS_DEBUGGED = ( (new RawContextKey('hasDebugged', false, { type: 'boolean', description: ( localize(\n    10,\n    \"True when a debug session has been started at least once, false otherwise.\"\n)) })));\nconst CONTEXT_IN_DEBUG_MODE = ( (new RawContextKey('inDebugMode', false, { type: 'boolean', description: ( localize(11, \"True when debugging, false otherwise.\")) })));\nconst CONTEXT_IN_DEBUG_REPL = ( (new RawContextKey('inDebugRepl', false, { type: 'boolean', description: ( localize(12, \"True when focus is in the debug console, false otherwise.\")) })));\nconst CONTEXT_BREAKPOINT_WIDGET_VISIBLE = ( (new RawContextKey(\n    'breakpointWidgetVisible',\n    false,\n    { type: 'boolean', description: ( localize(13, \"True when breakpoint editor zone widget is visible, false otherwise.\")) }\n)));\nconst CONTEXT_IN_BREAKPOINT_WIDGET = ( (new RawContextKey(\n    'inBreakpointWidget',\n    false,\n    { type: 'boolean', description: ( localize(\n        14,\n        \"True when focus is in the breakpoint editor zone widget, false otherwise.\"\n    )) }\n)));\nconst CONTEXT_BREAKPOINTS_FOCUSED = ( (new RawContextKey('breakpointsFocused', true, { type: 'boolean', description: ( localize(15, \"True when the BREAKPOINTS view is focused, false otherwise.\")) })));\nconst CONTEXT_WATCH_EXPRESSIONS_FOCUSED = ( (new RawContextKey(\n    'watchExpressionsFocused',\n    true,\n    { type: 'boolean', description: ( localize(16, \"True when the WATCH view is focused, false otherwise.\")) }\n)));\nconst CONTEXT_WATCH_EXPRESSIONS_EXIST = ( (new RawContextKey(\n    'watchExpressionsExist',\n    false,\n    { type: 'boolean', description: ( localize(17, \"True when at least one watch expression exists, false otherwise.\")) }\n)));\nconst CONTEXT_VARIABLES_FOCUSED = ( (new RawContextKey('variablesFocused', true, { type: 'boolean', description: ( localize(18, \"True when the VARIABLES views is focused, false otherwise\")) })));\nconst CONTEXT_EXPRESSION_SELECTED = ( (new RawContextKey(\n    'expressionSelected',\n    false,\n    { type: 'boolean', description: ( localize(\n        19,\n        \"True when an expression input box is open in either the WATCH or the VARIABLES view, false otherwise.\"\n    )) }\n)));\nconst CONTEXT_BREAKPOINT_INPUT_FOCUSED = ( (new RawContextKey(\n    'breakpointInputFocused',\n    false,\n    { type: 'boolean', description: ( localize(20, \"True when the input box has focus in the BREAKPOINTS view.\")) }\n)));\nconst CONTEXT_CALLSTACK_ITEM_TYPE = ( (new RawContextKey(\n    'callStackItemType',\n    undefined,\n    { type: 'string', description: ( localize(\n        21,\n        \"Represents the item type of the focused element in the CALL STACK view. For example: 'session', 'thread', 'stackFrame'\"\n    )) }\n)));\nconst CONTEXT_CALLSTACK_SESSION_IS_ATTACH = ( (new RawContextKey(\n    'callStackSessionIsAttach',\n    false,\n    { type: 'boolean', description: ( localize(\n        22,\n        \"True when the session in the CALL STACK view is attach, false otherwise. Used internally for inline menus in the CALL STACK view.\"\n    )) }\n)));\nconst CONTEXT_CALLSTACK_ITEM_STOPPED = ( (new RawContextKey(\n    'callStackItemStopped',\n    false,\n    { type: 'boolean', description: ( localize(\n        23,\n        \"True when the focused item in the CALL STACK is stopped. Used internaly for inline menus in the CALL STACK view.\"\n    )) }\n)));\nconst CONTEXT_CALLSTACK_SESSION_HAS_ONE_THREAD = ( (new RawContextKey(\n    'callStackSessionHasOneThread',\n    false,\n    { type: 'boolean', description: ( localize(\n        24,\n        \"True when the focused session in the CALL STACK view has exactly one thread. Used internally for inline menus in the CALL STACK view.\"\n    )) }\n)));\nconst CONTEXT_WATCH_ITEM_TYPE = ( (new RawContextKey('watchItemType', undefined, { type: 'string', description: ( localize(\n    25,\n    \"Represents the item type of the focused element in the WATCH view. For example: 'expression', 'variable'\"\n)) })));\nconst CONTEXT_CAN_VIEW_MEMORY = ( (new RawContextKey('canViewMemory', undefined, { type: 'boolean', description: ( localize(\n    26,\n    \"Indicates whether the item in the view has an associated memory refrence.\"\n)) })));\nconst CONTEXT_BREAKPOINT_ITEM_TYPE = ( (new RawContextKey(\n    'breakpointItemType',\n    undefined,\n    { type: 'string', description: ( localize(\n        27,\n        \"Represents the item type of the focused element in the BREAKPOINTS view. For example: 'breakpoint', 'exceptionBreakppint', 'functionBreakpoint', 'dataBreakpoint'\"\n    )) }\n)));\nconst CONTEXT_BREAKPOINT_ITEM_IS_DATA_BYTES = ( (new RawContextKey(\n    'breakpointItemBytes',\n    undefined,\n    { type: 'boolean', description: ( localize(28, \"Whether the breakpoint item is a data breakpoint on a byte range.\")) }\n)));\nconst CONTEXT_BREAKPOINT_HAS_MODES = ( (new RawContextKey(\n    'breakpointHasModes',\n    false,\n    { type: 'boolean', description: ( localize(29, \"Whether the breakpoint has multiple modes it can switch to.\")) }\n)));\nconst CONTEXT_BREAKPOINT_SUPPORTS_CONDITION = ( (new RawContextKey(\n    'breakpointSupportsCondition',\n    false,\n    { type: 'boolean', description: ( localize(30, \"True when the focused breakpoint supports conditions.\")) }\n)));\nconst CONTEXT_LOADED_SCRIPTS_SUPPORTED = ( (new RawContextKey(\n    'loadedScriptsSupported',\n    false,\n    { type: 'boolean', description: ( localize(31, \"True when the focused sessions supports the LOADED SCRIPTS view\")) }\n)));\nconst CONTEXT_LOADED_SCRIPTS_ITEM_TYPE = ( (new RawContextKey(\n    'loadedScriptsItemType',\n    undefined,\n    { type: 'string', description: ( localize(\n        32,\n        \"Represents the item type of the focused element in the LOADED SCRIPTS view.\"\n    )) }\n)));\nconst CONTEXT_FOCUSED_SESSION_IS_ATTACH = ( (new RawContextKey(\n    'focusedSessionIsAttach',\n    false,\n    { type: 'boolean', description: ( localize(33, \"True when the focused session is 'attach'.\")) }\n)));\nconst CONTEXT_FOCUSED_SESSION_IS_NO_DEBUG = ( (new RawContextKey(\n    'focusedSessionIsNoDebug',\n    false,\n    { type: 'boolean', description: ( localize(34, \"True when the focused session is run without debugging.\")) }\n)));\nconst CONTEXT_STEP_BACK_SUPPORTED = ( (new RawContextKey('stepBackSupported', false, { type: 'boolean', description: ( localize(35, \"True when the focused session supports 'stepBack' requests.\")) })));\nconst CONTEXT_RESTART_FRAME_SUPPORTED = ( (new RawContextKey(\n    'restartFrameSupported',\n    false,\n    { type: 'boolean', description: ( localize(36, \"True when the focused session supports 'restartFrame' requests.\")) }\n)));\nconst CONTEXT_STACK_FRAME_SUPPORTS_RESTART = ( (new RawContextKey(\n    'stackFrameSupportsRestart',\n    false,\n    { type: 'boolean', description: ( localize(37, \"True when the focused stack frame supports 'restartFrame'.\")) }\n)));\nconst CONTEXT_JUMP_TO_CURSOR_SUPPORTED = ( (new RawContextKey(\n    'jumpToCursorSupported',\n    false,\n    { type: 'boolean', description: ( localize(38, \"True when the focused session supports 'jumpToCursor' request.\")) }\n)));\nconst CONTEXT_STEP_INTO_TARGETS_SUPPORTED = ( (new RawContextKey(\n    'stepIntoTargetsSupported',\n    false,\n    { type: 'boolean', description: ( localize(39, \"True when the focused session supports 'stepIntoTargets' request.\")) }\n)));\nconst CONTEXT_BREAKPOINTS_EXIST = ( (new RawContextKey('breakpointsExist', false, { type: 'boolean', description: ( localize(40, \"True when at least one breakpoint exists.\")) })));\nconst CONTEXT_DEBUGGERS_AVAILABLE = ( (new RawContextKey(\n    'debuggersAvailable',\n    false,\n    { type: 'boolean', description: ( localize(41, \"True when there is at least one debug extensions active.\")) }\n)));\nconst CONTEXT_DEBUG_EXTENSION_AVAILABLE = ( (new RawContextKey(\n    'debugExtensionAvailable',\n    true,\n    { type: 'boolean', description: ( localize(\n        42,\n        \"True when there is at least one debug extension installed and enabled.\"\n    )) }\n)));\nconst CONTEXT_DEBUG_PROTOCOL_VARIABLE_MENU_CONTEXT = ( (new RawContextKey(\n    'debugProtocolVariableMenuContext',\n    undefined,\n    { type: 'string', description: ( localize(\n        43,\n        \"Represents the context the debug adapter sets on the focused variable in the VARIABLES view.\"\n    )) }\n)));\nconst CONTEXT_SET_VARIABLE_SUPPORTED = ( (new RawContextKey(\n    'debugSetVariableSupported',\n    false,\n    { type: 'boolean', description: ( localize(44, \"True when the focused session supports 'setVariable' request.\")) }\n)));\nconst CONTEXT_SET_DATA_BREAKPOINT_BYTES_SUPPORTED = ( (new RawContextKey(\n    'debugSetDataBreakpointAddressSupported',\n    false,\n    { type: 'boolean', description: ( localize(\n        45,\n        \"True when the focused session supports 'getBreakpointInfo' request on an address.\"\n    )) }\n)));\nconst CONTEXT_SET_EXPRESSION_SUPPORTED = ( (new RawContextKey(\n    'debugSetExpressionSupported',\n    false,\n    { type: 'boolean', description: ( localize(46, \"True when the focused session supports 'setExpression' request.\")) }\n)));\nconst CONTEXT_BREAK_WHEN_VALUE_CHANGES_SUPPORTED = ( (new RawContextKey(\n    'breakWhenValueChangesSupported',\n    false,\n    { type: 'boolean', description: ( localize(47, \"True when the focused session supports to break when value changes.\")) }\n)));\nconst CONTEXT_BREAK_WHEN_VALUE_IS_ACCESSED_SUPPORTED = ( (new RawContextKey(\n    'breakWhenValueIsAccessedSupported',\n    false,\n    { type: 'boolean', description: ( localize(\n        48,\n        \"True when the focused breakpoint supports to break when value is accessed.\"\n    )) }\n)));\nconst CONTEXT_BREAK_WHEN_VALUE_IS_READ_SUPPORTED = ( (new RawContextKey(\n    'breakWhenValueIsReadSupported',\n    false,\n    { type: 'boolean', description: ( localize(\n        49,\n        \"True when the focused breakpoint supports to break when value is read.\"\n    )) }\n)));\nconst CONTEXT_TERMINATE_DEBUGGEE_SUPPORTED = ( (new RawContextKey(\n    'terminateDebuggeeSupported',\n    false,\n    { type: 'boolean', description: ( localize(\n        50,\n        \"True when the focused session supports the terminate debuggee capability.\"\n    )) }\n)));\nconst CONTEXT_SUSPEND_DEBUGGEE_SUPPORTED = ( (new RawContextKey(\n    'suspendDebuggeeSupported',\n    false,\n    { type: 'boolean', description: ( localize(\n        51,\n        \"True when the focused session supports the suspend debuggee capability.\"\n    )) }\n)));\nconst CONTEXT_VARIABLE_EVALUATE_NAME_PRESENT = ( (new RawContextKey(\n    'variableEvaluateNamePresent',\n    false,\n    { type: 'boolean', description: ( localize(52, \"True when the focused variable has an 'evalauteName' field set.\")) }\n)));\nconst CONTEXT_VARIABLE_IS_READONLY = ( (new RawContextKey(\n    'variableIsReadonly',\n    false,\n    { type: 'boolean', description: ( localize(53, \"True when the focused variable is read-only.\")) }\n)));\nconst CONTEXT_VARIABLE_VALUE = ( (new RawContextKey('variableValue', false, { type: 'string', description: ( localize(54, \"Value of the variable, present for debug visualization clauses.\")) })));\nconst CONTEXT_VARIABLE_TYPE = ( (new RawContextKey('variableType', false, { type: 'string', description: ( localize(55, \"Type of the variable, present for debug visualization clauses.\")) })));\nconst CONTEXT_VARIABLE_INTERFACES = ( (new RawContextKey('variableInterfaces', false, { type: 'array', description: ( localize(\n    56,\n    \"Any interfaces or contracts that the variable satisfies, present for debug visualization clauses.\"\n)) })));\nconst CONTEXT_VARIABLE_NAME = ( (new RawContextKey('variableName', false, { type: 'string', description: ( localize(57, \"Name of the variable, present for debug visualization clauses.\")) })));\nconst CONTEXT_VARIABLE_LANGUAGE = ( (new RawContextKey('variableLanguage', false, { type: 'string', description: ( localize(\n    58,\n    \"Language of the variable source, present for debug visualization clauses.\"\n)) })));\nconst CONTEXT_VARIABLE_EXTENSIONID = ( (new RawContextKey(\n    'variableExtensionId',\n    false,\n    { type: 'string', description: ( localize(\n        59,\n        \"Extension ID of the variable source, present for debug visualization clauses.\"\n    )) }\n)));\nconst CONTEXT_EXCEPTION_WIDGET_VISIBLE = ( (new RawContextKey(\n    'exceptionWidgetVisible',\n    false,\n    { type: 'boolean', description: ( localize(60, \"True when the exception widget is visible.\")) }\n)));\nconst CONTEXT_MULTI_SESSION_REPL = ( (new RawContextKey('multiSessionRepl', false, { type: 'boolean', description: ( localize(61, \"True when there is more than 1 debug console.\")) })));\nconst CONTEXT_MULTI_SESSION_DEBUG = ( (new RawContextKey('multiSessionDebug', false, { type: 'boolean', description: ( localize(62, \"True when there is more than 1 active debug session.\")) })));\nconst CONTEXT_DISASSEMBLE_REQUEST_SUPPORTED = ( (new RawContextKey(\n    'disassembleRequestSupported',\n    false,\n    { type: 'boolean', description: ( localize(63, \"True when the focused sessions supports disassemble request.\")) }\n)));\nconst CONTEXT_DISASSEMBLY_VIEW_FOCUS = ( (new RawContextKey(\n    'disassemblyViewFocus',\n    false,\n    { type: 'boolean', description: ( localize(64, \"True when the Disassembly View is focused.\")) }\n)));\nconst CONTEXT_LANGUAGE_SUPPORTS_DISASSEMBLE_REQUEST = ( (new RawContextKey(\n    'languageSupportsDisassembleRequest',\n    false,\n    { type: 'boolean', description: ( localize(\n        65,\n        \"True when the language in the current editor supports disassemble request.\"\n    )) }\n)));\nconst CONTEXT_FOCUSED_STACK_FRAME_HAS_INSTRUCTION_POINTER_REFERENCE = ( (new RawContextKey(\n    'focusedStackFrameHasInstructionReference',\n    false,\n    { type: 'boolean', description: ( localize(66, \"True when the focused stack frame has instruction pointer reference.\")) }\n)));\nconst debuggerDisabledMessage = (debugType) => ( localize(\n    67,\n    \"Configured debug type '{0}' is installed but not supported in this environment.\",\n    debugType\n));\nconst EDITOR_CONTRIBUTION_ID = 'editor.contrib.debug';\nconst BREAKPOINT_EDITOR_CONTRIBUTION_ID = 'editor.contrib.breakpoint';\nconst DEBUG_SCHEME = 'debug';\nconst INTERNAL_CONSOLE_OPTIONS_SCHEMA = {\n    enum: ['neverOpen', 'openOnSessionStart', 'openOnFirstSessionStart'],\n    default: 'openOnFirstSessionStart',\n    description: ( localize(68, \"Controls when the internal Debug Console should open.\"))\n};\nfunction getStateLabel(state) {\n    switch (state) {\n        case 1 : return 'initializing';\n        case 2 : return 'stopped';\n        case 3 : return 'running';\n        default: return 'inactive';\n    }\n}\nconst DEBUG_MEMORY_SCHEME = 'vscode-debug-memory';\nfunction isFrameDeemphasized(frame) {\n    const hint = frame.presentationHint ?? frame.source.presentationHint;\n    return hint === 'deemphasize' || hint === 'subtle';\n}\nvar DebugConfigurationProviderTriggerKind;\n( ((function(DebugConfigurationProviderTriggerKind) {\n    DebugConfigurationProviderTriggerKind[DebugConfigurationProviderTriggerKind[\"Initial\"] = 1] = \"Initial\";\n    DebugConfigurationProviderTriggerKind[DebugConfigurationProviderTriggerKind[\"Dynamic\"] = 2] = \"Dynamic\";\n})(\n    DebugConfigurationProviderTriggerKind || (DebugConfigurationProviderTriggerKind = {})\n)));\nvar DebuggerString;\n( ((function(DebuggerString) {\n    DebuggerString[\"UnverifiedBreakpoints\"] = \"unverifiedBreakpoints\";\n})(DebuggerString || (DebuggerString = {}))));\nvar IDebugVisualization;\n( ((function(IDebugVisualization) {\n    IDebugVisualization.deserialize = (v) => ({\n        id: v.id,\n        name: v.name,\n        iconPath: v.iconPath && { light: URI.revive(v.iconPath.light), dark: URI.revive(v.iconPath.dark) },\n        iconClass: v.iconClass,\n        visualization: v.visualization,\n    });\n    IDebugVisualization.serialize = (visualizer) => visualizer;\n})(IDebugVisualization || (IDebugVisualization = {}))));\nexport { BREAKPOINTS_VIEW_ID, BREAKPOINT_EDITOR_CONTRIBUTION_ID, CALLSTACK_VIEW_ID, CONTEXT_BREAKPOINTS_EXIST, CONTEXT_BREAKPOINTS_FOCUSED, CONTEXT_BREAKPOINT_HAS_MODES, CONTEXT_BREAKPOINT_INPUT_FOCUSED, CONTEXT_BREAKPOINT_ITEM_IS_DATA_BYTES, CONTEXT_BREAKPOINT_ITEM_TYPE, CONTEXT_BREAKPOINT_SUPPORTS_CONDITION, CONTEXT_BREAKPOINT_WIDGET_VISIBLE, CONTEXT_BREAK_WHEN_VALUE_CHANGES_SUPPORTED, CONTEXT_BREAK_WHEN_VALUE_IS_ACCESSED_SUPPORTED, CONTEXT_BREAK_WHEN_VALUE_IS_READ_SUPPORTED, CONTEXT_CALLSTACK_ITEM_STOPPED, CONTEXT_CALLSTACK_ITEM_TYPE, CONTEXT_CALLSTACK_SESSION_HAS_ONE_THREAD, CONTEXT_CALLSTACK_SESSION_IS_ATTACH, CONTEXT_CAN_VIEW_MEMORY, CONTEXT_DEBUGGERS_AVAILABLE, CONTEXT_DEBUG_CONFIGURATION_TYPE, CONTEXT_DEBUG_EXTENSION_AVAILABLE, CONTEXT_DEBUG_PROTOCOL_VARIABLE_MENU_CONTEXT, CONTEXT_DEBUG_STATE, CONTEXT_DEBUG_TYPE, CONTEXT_DEBUG_UX, CONTEXT_DEBUG_UX_KEY, CONTEXT_DISASSEMBLE_REQUEST_SUPPORTED, CONTEXT_DISASSEMBLY_VIEW_FOCUS, CONTEXT_EXCEPTION_WIDGET_VISIBLE, CONTEXT_EXPRESSION_SELECTED, CONTEXT_FOCUSED_SESSION_IS_ATTACH, CONTEXT_FOCUSED_SESSION_IS_NO_DEBUG, CONTEXT_FOCUSED_STACK_FRAME_HAS_INSTRUCTION_POINTER_REFERENCE, CONTEXT_HAS_DEBUGGED, CONTEXT_IN_BREAKPOINT_WIDGET, CONTEXT_IN_DEBUG_MODE, CONTEXT_IN_DEBUG_REPL, CONTEXT_JUMP_TO_CURSOR_SUPPORTED, CONTEXT_LANGUAGE_SUPPORTS_DISASSEMBLE_REQUEST, CONTEXT_LOADED_SCRIPTS_ITEM_TYPE, CONTEXT_LOADED_SCRIPTS_SUPPORTED, CONTEXT_MULTI_SESSION_DEBUG, CONTEXT_MULTI_SESSION_REPL, CONTEXT_RESTART_FRAME_SUPPORTED, CONTEXT_SET_DATA_BREAKPOINT_BYTES_SUPPORTED, CONTEXT_SET_EXPRESSION_SUPPORTED, CONTEXT_SET_VARIABLE_SUPPORTED, CONTEXT_STACK_FRAME_SUPPORTS_RESTART, CONTEXT_STEP_BACK_SUPPORTED, CONTEXT_STEP_INTO_TARGETS_SUPPORTED, CONTEXT_SUSPEND_DEBUGGEE_SUPPORTED, CONTEXT_TERMINATE_DEBUGGEE_SUPPORTED, CONTEXT_VARIABLES_FOCUSED, CONTEXT_VARIABLE_EVALUATE_NAME_PRESENT, CONTEXT_VARIABLE_EXTENSIONID, CONTEXT_VARIABLE_INTERFACES, CONTEXT_VARIABLE_IS_READONLY, CONTEXT_VARIABLE_LANGUAGE, CONTEXT_VARIABLE_NAME, CONTEXT_VARIABLE_TYPE, CONTEXT_VARIABLE_VALUE, CONTEXT_WATCH_EXPRESSIONS_EXIST, CONTEXT_WATCH_EXPRESSIONS_FOCUSED, CONTEXT_WATCH_ITEM_TYPE, DEBUG_MEMORY_SCHEME, DEBUG_PANEL_ID, DEBUG_SCHEME, DISASSEMBLY_VIEW_ID, DebugConfigurationProviderTriggerKind, DebuggerString, EDITOR_CONTRIBUTION_ID, IDebugVisualization, INTERNAL_CONSOLE_OPTIONS_SCHEMA, LOADED_SCRIPTS_VIEW_ID, REPL_VIEW_ID, VARIABLES_VIEW_ID, VIEWLET_ID, WATCH_VIEW_ID, debuggerDisabledMessage, getStateLabel, isFrameDeemphasized };\n","import { equalsIgnoreCase } from '../../../../base/common/strings.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { isAbsolute } from '../../../../base/common/path.js';\nimport { deepClone } from '../../../../base/common/objects.js';\nimport { Schemas } from '../../../../base/common/network.js';\nimport { Range } from '../../../../editor/common/core/range.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { coalesce } from '../../../../base/common/arrays.js';\nconst _formatPIIRegexp = /{([^}]+)}/g;\nfunction formatPII(value, excludePII, args) {\n    return value.replace(_formatPIIRegexp, function (match, group) {\n        return args && args.hasOwnProperty(group) ?\n            args[group] :\n            match;\n    });\n}\nfunction filterExceptionsFromTelemetry(data) {\n    const output = {};\n    for (const key of ( (Object.keys(data)))) {\n        if (!key.startsWith('!')) {\n            output[key] = data[key];\n        }\n    }\n    return output;\n}\nfunction isSessionAttach(session) {\n    return session.configuration.request === 'attach' && !getExtensionHostDebugSession(session) && (!session.parentSession || isSessionAttach(session.parentSession));\n}\nfunction getExtensionHostDebugSession(session) {\n    let type = session.configuration.type;\n    if (!type) {\n        return;\n    }\n    if (type === 'vslsShare') {\n        type = session.configuration.adapterProxy.configuration.type;\n    }\n    if (equalsIgnoreCase(type, 'extensionhost') || equalsIgnoreCase(type, 'pwa-extensionhost')) {\n        return session;\n    }\n    return session.parentSession ? getExtensionHostDebugSession(session.parentSession) : undefined;\n}\nfunction isDebuggerMainContribution(dbg) {\n    return dbg.type && (dbg.label || dbg.program || dbg.runtime);\n}\nfunction getExactExpressionStartAndEnd(lineContent, looseStart, looseEnd) {\n    let matchingExpression = undefined;\n    let startOffset = 0;\n    const expression = /([^()\\[\\]{}<>\\s+\\-/%~#^;=|,`!]|\\->)+/g;\n    let result = null;\n    while (result = expression.exec(lineContent)) {\n        const start = result.index + 1;\n        const end = start + result[0].length;\n        if (start <= looseStart && end >= looseEnd) {\n            matchingExpression = result[0];\n            startOffset = start;\n            break;\n        }\n    }\n    if (matchingExpression) {\n        const subExpression = /(\\w|\\p{L})+/gu;\n        let subExpressionResult = null;\n        while (subExpressionResult = subExpression.exec(matchingExpression)) {\n            const subEnd = subExpressionResult.index + 1 + startOffset + subExpressionResult[0].length;\n            if (subEnd >= looseEnd) {\n                break;\n            }\n        }\n        if (subExpressionResult) {\n            matchingExpression = matchingExpression.substring(0, subExpression.lastIndex);\n        }\n    }\n    return matchingExpression ?\n        { start: startOffset, end: startOffset + matchingExpression.length - 1 } :\n        { start: 0, end: 0 };\n}\nasync function getEvaluatableExpressionAtPosition(languageFeaturesService, model, position, token) {\n    if (( (languageFeaturesService.evaluatableExpressionProvider.has(model)))) {\n        const supports = languageFeaturesService.evaluatableExpressionProvider.ordered(model);\n        const results = coalesce(await Promise.all(( (supports.map(async (support) => {\n            try {\n                return await support.provideEvaluatableExpression(model, position, token ?? CancellationToken.None);\n            }\n            catch (err) {\n                return undefined;\n            }\n        })))));\n        if (results.length > 0) {\n            let matchingExpression = results[0].expression;\n            const range = results[0].range;\n            if (!matchingExpression) {\n                const lineContent = model.getLineContent(position.lineNumber);\n                matchingExpression = lineContent.substring(range.startColumn - 1, range.endColumn - 1);\n            }\n            return { range, matchingExpression };\n        }\n    }\n    else {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const { start, end } = getExactExpressionStartAndEnd(lineContent, position.column, position.column);\n        const matchingExpression = lineContent.substring(start - 1, end);\n        return {\n            matchingExpression,\n            range: ( (new Range(\n                position.lineNumber,\n                start,\n                position.lineNumber,\n                start + matchingExpression.length\n            )))\n        };\n    }\n    return null;\n}\nconst _schemePattern = /^[a-zA-Z][a-zA-Z0-9\\+\\-\\.]+:/;\nfunction isUri(s) {\n    return !!(s && s.match(_schemePattern));\n}\nfunction stringToUri(source) {\n    if (typeof source.path === 'string') {\n        if (typeof source.sourceReference === 'number' && source.sourceReference > 0) ;\n        else {\n            if (isUri(source.path)) {\n                return ( URI.parse(source.path));\n            }\n            else {\n                if (isAbsolute(source.path)) {\n                    return URI.file(source.path);\n                }\n            }\n        }\n    }\n    return source.path;\n}\nfunction uriToString(source) {\n    if (typeof source.path === 'object') {\n        const u = URI.revive(source.path);\n        if (u) {\n            if (u.scheme === Schemas.file) {\n                return u.fsPath;\n            }\n            else {\n                return (\n                     (u.toString())\n                );\n            }\n        }\n    }\n    return source.path;\n}\nfunction convertToDAPaths(message, toUri) {\n    const fixPath = toUri ? stringToUri : uriToString;\n    const msg = deepClone(message);\n    convertPaths(msg, (toDA, source) => {\n        if (toDA && source) {\n            source.path = fixPath(source);\n        }\n    });\n    return msg;\n}\nfunction convertToVSCPaths(message, toUri) {\n    const fixPath = toUri ? stringToUri : uriToString;\n    const msg = deepClone(message);\n    convertPaths(msg, (toDA, source) => {\n        if (!toDA && source) {\n            source.path = fixPath(source);\n        }\n    });\n    return msg;\n}\nfunction convertPaths(msg, fixSourcePath) {\n    switch (msg.type) {\n        case 'event': {\n            const event = msg;\n            switch (event.event) {\n                case 'output':\n                    fixSourcePath(false, event.body.source);\n                    break;\n                case 'loadedSource':\n                    fixSourcePath(false, event.body.source);\n                    break;\n                case 'breakpoint':\n                    fixSourcePath(false, event.body.breakpoint.source);\n                    break;\n            }\n            break;\n        }\n        case 'request': {\n            const request = msg;\n            switch (request.command) {\n                case 'setBreakpoints':\n                    fixSourcePath(true, request.arguments.source);\n                    break;\n                case 'breakpointLocations':\n                    fixSourcePath(true, request.arguments.source);\n                    break;\n                case 'source':\n                    fixSourcePath(true, request.arguments.source);\n                    break;\n                case 'gotoTargets':\n                    fixSourcePath(true, request.arguments.source);\n                    break;\n                case 'launchVSCode':\n                    request.arguments.args.forEach((arg) => fixSourcePath(false, arg));\n                    break;\n            }\n            break;\n        }\n        case 'response': {\n            const response = msg;\n            if (response.success && response.body) {\n                switch (response.command) {\n                    case 'stackTrace':\n                        response.body.stackFrames.forEach(frame => fixSourcePath(false, frame.source));\n                        break;\n                    case 'loadedSources':\n                        response.body.sources.forEach(source => fixSourcePath(false, source));\n                        break;\n                    case 'scopes':\n                        response.body.scopes.forEach(scope => fixSourcePath(false, scope.source));\n                        break;\n                    case 'setFunctionBreakpoints':\n                        response.body.breakpoints.forEach(bp => fixSourcePath(false, bp.source));\n                        break;\n                    case 'setBreakpoints':\n                        response.body.breakpoints.forEach(bp => fixSourcePath(false, bp.source));\n                        break;\n                    case 'disassemble':\n                        {\n                            const di = response;\n                            di.body?.instructions.forEach(di => fixSourcePath(false, di.location));\n                        }\n                        break;\n                    case 'locations':\n                        fixSourcePath(false, response.body?.source);\n                        break;\n                }\n            }\n            break;\n        }\n    }\n}\nfunction getVisibleAndSorted(array) {\n    return array.filter(config => !config.presentation?.hidden).sort((first, second) => {\n        if (!first.presentation) {\n            if (!second.presentation) {\n                return 0;\n            }\n            return 1;\n        }\n        if (!second.presentation) {\n            return -1;\n        }\n        if (!first.presentation.group) {\n            if (!second.presentation.group) {\n                return compareOrders(first.presentation.order, second.presentation.order);\n            }\n            return 1;\n        }\n        if (!second.presentation.group) {\n            return -1;\n        }\n        if (first.presentation.group !== second.presentation.group) {\n            return first.presentation.group.localeCompare(second.presentation.group);\n        }\n        return compareOrders(first.presentation.order, second.presentation.order);\n    });\n}\nfunction compareOrders(first, second) {\n    if (typeof first !== 'number') {\n        if (typeof second !== 'number') {\n            return 0;\n        }\n        return 1;\n    }\n    if (typeof second !== 'number') {\n        return -1;\n    }\n    return first - second;\n}\nasync function saveAllBeforeDebugStart(configurationService, editorService) {\n    const saveBeforeStartConfig = configurationService.getValue('debug.saveBeforeStart', { overrideIdentifier: editorService.activeTextEditorLanguageId });\n    if (saveBeforeStartConfig !== 'none') {\n        await editorService.saveAll();\n        if (saveBeforeStartConfig === 'allEditorsInActiveGroup') {\n            const activeEditor = editorService.activeEditorPane;\n            if (activeEditor && activeEditor.input.resource?.scheme === Schemas.untitled) {\n                await editorService.save({ editor: activeEditor.input, groupId: activeEditor.group.id });\n            }\n        }\n    }\n    await configurationService.reloadConfiguration();\n}\nconst sourcesEqual = (a, b) => !a || !b ? a === b : a.name === b.name && a.path === b.path && a.sourceReference === b.sourceReference;\nexport { convertToDAPaths, convertToVSCPaths, filterExceptionsFromTelemetry, formatPII, getEvaluatableExpressionAtPosition, getExactExpressionStartAndEnd, getExtensionHostDebugSession, getVisibleAndSorted, isDebuggerMainContribution, isSessionAttach, isUri, saveAllBeforeDebugStart, sourcesEqual };\n","import { VSBuffer } from '../../../../base/common/buffer.js';\nimport { isRelativePattern, parse as parse$1 } from '../../../../base/common/glob.js';\nimport { Iterable } from '../../../../base/common/iterator.js';\nimport { Mimes } from '../../../../base/common/mime.js';\nimport { Schemas } from '../../../../base/common/network.js';\nimport '../../../../base/common/path.js';\nimport { isWindows } from '../../../../base/common/platform.js';\nimport { RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\nimport { generateMetadataUri, parseMetadataUri, generate, parse } from '../../../services/notebook/common/notebookDocumentService.js';\nconst NOTEBOOK_EDITOR_ID = 'workbench.editor.notebook';\nconst NOTEBOOK_DIFF_EDITOR_ID = 'workbench.editor.notebookTextDiffEditor';\nconst NOTEBOOK_MULTI_DIFF_EDITOR_ID = 'workbench.editor.notebookMultiTextDiffEditor';\nconst INTERACTIVE_WINDOW_EDITOR_ID = 'workbench.editor.interactive';\nvar CellKind;\n( (function(CellKind) {\n    CellKind[CellKind[\"Markup\"] = 1] = \"Markup\";\n    CellKind[CellKind[\"Code\"] = 2] = \"Code\";\n})(CellKind || (CellKind = {})));\nconst NOTEBOOK_DISPLAY_ORDER = [\n    'application/json',\n    'application/javascript',\n    'text/html',\n    'image/svg+xml',\n    Mimes.latex,\n    Mimes.markdown,\n    'image/png',\n    'image/jpeg',\n    Mimes.text\n];\nconst ACCESSIBLE_NOTEBOOK_DISPLAY_ORDER = [\n    Mimes.latex,\n    Mimes.markdown,\n    'application/json',\n    'text/html',\n    'image/svg+xml',\n    'image/png',\n    'image/jpeg',\n    Mimes.text,\n];\nconst RENDERER_EQUIVALENT_EXTENSIONS = ( new Map([\n    ['ms-toolsai.jupyter', ( new Set(['jupyter-notebook', 'interactive']))],\n    ['ms-toolsai.jupyter-renderers', ( new Set(['jupyter-notebook', 'interactive']))],\n]));\nconst RENDERER_NOT_AVAILABLE = '_notAvailable';\nvar NotebookCellExecutionState;\n( (function(NotebookCellExecutionState) {\n    NotebookCellExecutionState[NotebookCellExecutionState[\"Unconfirmed\"] = 1] = \"Unconfirmed\";\n    NotebookCellExecutionState[NotebookCellExecutionState[\"Pending\"] = 2] = \"Pending\";\n    NotebookCellExecutionState[NotebookCellExecutionState[\"Executing\"] = 3] = \"Executing\";\n})(NotebookCellExecutionState || (NotebookCellExecutionState = {})));\nvar NotebookExecutionState;\n( (function(NotebookExecutionState) {\n    NotebookExecutionState[NotebookExecutionState[\"Unconfirmed\"] = 1] = \"Unconfirmed\";\n    NotebookExecutionState[NotebookExecutionState[\"Pending\"] = 2] = \"Pending\";\n    NotebookExecutionState[NotebookExecutionState[\"Executing\"] = 3] = \"Executing\";\n})(NotebookExecutionState || (NotebookExecutionState = {})));\nvar NotebookCellsChangeType;\n( (function(NotebookCellsChangeType) {\n    NotebookCellsChangeType[NotebookCellsChangeType[\"ModelChange\"] = 1] = \"ModelChange\";\n    NotebookCellsChangeType[NotebookCellsChangeType[\"Move\"] = 2] = \"Move\";\n    NotebookCellsChangeType[NotebookCellsChangeType[\"ChangeCellLanguage\"] = 5] = \"ChangeCellLanguage\";\n    NotebookCellsChangeType[NotebookCellsChangeType[\"Initialize\"] = 6] = \"Initialize\";\n    NotebookCellsChangeType[NotebookCellsChangeType[\"ChangeCellMetadata\"] = 7] = \"ChangeCellMetadata\";\n    NotebookCellsChangeType[NotebookCellsChangeType[\"Output\"] = 8] = \"Output\";\n    NotebookCellsChangeType[NotebookCellsChangeType[\"OutputItem\"] = 9] = \"OutputItem\";\n    NotebookCellsChangeType[NotebookCellsChangeType[\"ChangeCellContent\"] = 10] = \"ChangeCellContent\";\n    NotebookCellsChangeType[NotebookCellsChangeType[\"ChangeDocumentMetadata\"] = 11] = \"ChangeDocumentMetadata\";\n    NotebookCellsChangeType[NotebookCellsChangeType[\"ChangeCellInternalMetadata\"] = 12] = \"ChangeCellInternalMetadata\";\n    NotebookCellsChangeType[NotebookCellsChangeType[\"ChangeCellMime\"] = 13] = \"ChangeCellMime\";\n    NotebookCellsChangeType[NotebookCellsChangeType[\"Unknown\"] = 100] = \"Unknown\";\n})(NotebookCellsChangeType || (NotebookCellsChangeType = {})));\nvar SelectionStateType;\n( (function(SelectionStateType) {\n    SelectionStateType[SelectionStateType[\"Handle\"] = 0] = \"Handle\";\n    SelectionStateType[SelectionStateType[\"Index\"] = 1] = \"Index\";\n})(SelectionStateType || (SelectionStateType = {})));\nvar NotebookMetadataUri;\n( (function(NotebookMetadataUri) {\n    NotebookMetadataUri.scheme = Schemas.vscodeNotebookMetadata;\n    function generate(notebook) {\n        return generateMetadataUri(notebook);\n    }\n    NotebookMetadataUri.generate = generate;\n    function parse(metadata) {\n        return parseMetadataUri(metadata);\n    }\n    NotebookMetadataUri.parse = parse;\n})(NotebookMetadataUri || (NotebookMetadataUri = {})));\nvar CellUri;\n( (function(CellUri) {\n    CellUri.scheme = Schemas.vscodeNotebookCell;\n    function generate$1(notebook, handle) {\n        return generate(notebook, handle);\n    }\n    CellUri.generate = generate$1;\n    function parse$1(cell) {\n        return parse(cell);\n    }\n    CellUri.parse = parse$1;\n    function generateCellOutputUri(notebook, outputId) {\n        return notebook.with({\n            scheme: Schemas.vscodeNotebookCellOutput,\n            fragment: `op${outputId ?? ''},${notebook.scheme !== Schemas.file ? notebook.scheme : ''}`\n        });\n    }\n    CellUri.generateCellOutputUri = generateCellOutputUri;\n    function parseCellOutputUri(uri) {\n        if (uri.scheme !== Schemas.vscodeNotebookCellOutput) {\n            return;\n        }\n        const match = /^op([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})?\\,(.*)$/i.exec(uri.fragment);\n        if (!match) {\n            return undefined;\n        }\n        const outputId = (match[1] && match[1] !== '') ? match[1] : undefined;\n        const scheme = match[2];\n        return {\n            outputId,\n            notebook: uri.with({\n                scheme: scheme || Schemas.file,\n                fragment: null\n            })\n        };\n    }\n    CellUri.parseCellOutputUri = parseCellOutputUri;\n    function generateCellPropertyUri(notebook, handle, scheme) {\n        return CellUri.generate(notebook, handle).with({ scheme: scheme });\n    }\n    CellUri.generateCellPropertyUri = generateCellPropertyUri;\n    function parseCellPropertyUri(uri, propertyScheme) {\n        if (uri.scheme !== propertyScheme) {\n            return undefined;\n        }\n        return CellUri.parse(uri.with({ scheme: CellUri.scheme }));\n    }\n    CellUri.parseCellPropertyUri = parseCellPropertyUri;\n})(CellUri || (CellUri = {})));\nconst normalizeSlashes = (str) => isWindows ? str.replace(/\\//g, '\\\\') : str;\nclass MimeTypeDisplayOrder {\n    constructor(initialValue = [], defaultOrder = NOTEBOOK_DISPLAY_ORDER) {\n        this.defaultOrder = defaultOrder;\n        this.order = ( [...( new Set(initialValue))].map(pattern => ({\n            pattern,\n            matches: parse$1(normalizeSlashes(pattern))\n        })));\n    }\n    sort(mimetypes) {\n        const remaining = ( new Map(( Iterable.map(mimetypes, m => [m, normalizeSlashes(m)]))));\n        let sorted = [];\n        for (const { matches } of this.order) {\n            for (const [original, normalized] of remaining) {\n                if (matches(normalized)) {\n                    sorted.push(original);\n                    remaining.delete(original);\n                    break;\n                }\n            }\n        }\n        if (remaining.size) {\n            sorted = sorted.concat([...( remaining.keys())].sort((a, b) => this.defaultOrder.indexOf(a) - this.defaultOrder.indexOf(b)));\n        }\n        return sorted;\n    }\n    prioritize(chosenMimetype, otherMimetypes) {\n        const chosenIndex = this.findIndex(chosenMimetype);\n        if (chosenIndex === -1) {\n            this.order.unshift({ pattern: chosenMimetype, matches: parse$1(normalizeSlashes(chosenMimetype)) });\n            return;\n        }\n        const uniqueIndicies = ( new Set(( otherMimetypes.map(m => this.findIndex(m, chosenIndex)))));\n        uniqueIndicies.delete(-1);\n        const otherIndices = Array.from(uniqueIndicies).sort();\n        this.order.splice(chosenIndex + 1, 0, ...( otherIndices.map(i => this.order[i])));\n        for (let oi = otherIndices.length - 1; oi >= 0; oi--) {\n            this.order.splice(otherIndices[oi], 1);\n        }\n    }\n    toArray() {\n        return ( this.order.map(o => o.pattern));\n    }\n    findIndex(mimeType, maxIndex = this.order.length) {\n        const normalized = normalizeSlashes(mimeType);\n        for (let i = 0; i < maxIndex; i++) {\n            if (this.order[i].matches(normalized)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\nfunction diff(before, after, contains, equal = (a, b) => a === b) {\n    const result = [];\n    function pushSplice(start, deleteCount, toInsert) {\n        if (deleteCount === 0 && toInsert.length === 0) {\n            return;\n        }\n        const latest = result[result.length - 1];\n        if (latest && latest.start + latest.deleteCount === start) {\n            latest.deleteCount += deleteCount;\n            latest.toInsert.push(...toInsert);\n        }\n        else {\n            result.push({ start, deleteCount, toInsert });\n        }\n    }\n    let beforeIdx = 0;\n    let afterIdx = 0;\n    while (true) {\n        if (beforeIdx === before.length) {\n            pushSplice(beforeIdx, 0, after.slice(afterIdx));\n            break;\n        }\n        if (afterIdx === after.length) {\n            pushSplice(beforeIdx, before.length - beforeIdx, []);\n            break;\n        }\n        const beforeElement = before[beforeIdx];\n        const afterElement = after[afterIdx];\n        if (equal(beforeElement, afterElement)) {\n            beforeIdx += 1;\n            afterIdx += 1;\n            continue;\n        }\n        if (contains(afterElement)) {\n            pushSplice(beforeIdx, 1, []);\n            beforeIdx += 1;\n        }\n        else {\n            pushSplice(beforeIdx, 0, [afterElement]);\n            afterIdx += 1;\n        }\n    }\n    return result;\n}\nconst NOTEBOOK_EDITOR_CURSOR_BOUNDARY = ( new RawContextKey('notebookEditorCursorAtBoundary', 'none'));\nconst NOTEBOOK_EDITOR_CURSOR_LINE_BOUNDARY = ( new RawContextKey('notebookEditorCursorAtLineBoundary', 'none'));\nvar NotebookEditorPriority;\n( (function(NotebookEditorPriority) {\n    NotebookEditorPriority[\"default\"] = \"default\";\n    NotebookEditorPriority[\"option\"] = \"option\";\n})(NotebookEditorPriority || (NotebookEditorPriority = {})));\nvar NotebookFindScopeType;\n( (function(NotebookFindScopeType) {\n    NotebookFindScopeType[\"Cells\"] = \"cells\";\n    NotebookFindScopeType[\"Text\"] = \"text\";\n    NotebookFindScopeType[\"None\"] = \"none\";\n})(NotebookFindScopeType || (NotebookFindScopeType = {})));\nfunction isDocumentExcludePattern(filenamePattern) {\n    const arg = filenamePattern;\n    if ((typeof arg.include === 'string' || isRelativePattern(arg.include))\n        && (typeof arg.exclude === 'string' || isRelativePattern(arg.exclude))) {\n        return true;\n    }\n    return false;\n}\nconst NotebookSetting = {\n    displayOrder: 'notebook.displayOrder',\n    cellToolbarLocation: 'notebook.cellToolbarLocation',\n    cellToolbarVisibility: 'notebook.cellToolbarVisibility',\n    showCellStatusBar: 'notebook.showCellStatusBar',\n    textDiffEditorPreview: 'notebook.diff.enablePreview',\n    diffOverviewRuler: 'notebook.diff.overviewRuler',\n    experimentalInsertToolbarAlignment: 'notebook.experimental.insertToolbarAlignment',\n    compactView: 'notebook.compactView',\n    focusIndicator: 'notebook.cellFocusIndicator',\n    insertToolbarLocation: 'notebook.insertToolbarLocation',\n    globalToolbar: 'notebook.globalToolbar',\n    stickyScrollEnabled: 'notebook.stickyScroll.enabled',\n    stickyScrollMode: 'notebook.stickyScroll.mode',\n    undoRedoPerCell: 'notebook.undoRedoPerCell',\n    consolidatedOutputButton: 'notebook.consolidatedOutputButton',\n    showFoldingControls: 'notebook.showFoldingControls',\n    dragAndDropEnabled: 'notebook.dragAndDropEnabled',\n    cellEditorOptionsCustomizations: 'notebook.editorOptionsCustomizations',\n    consolidatedRunButton: 'notebook.consolidatedRunButton',\n    openGettingStarted: 'notebook.experimental.openGettingStarted',\n    globalToolbarShowLabel: 'notebook.globalToolbarShowLabel',\n    markupFontSize: 'notebook.markup.fontSize',\n    markdownLineHeight: 'notebook.markdown.lineHeight',\n    interactiveWindowCollapseCodeCells: 'interactiveWindow.collapseCellInputCode',\n    outputScrollingDeprecated: 'notebook.experimental.outputScrolling',\n    outputScrolling: 'notebook.output.scrolling',\n    textOutputLineLimit: 'notebook.output.textLineLimit',\n    LinkifyOutputFilePaths: 'notebook.output.linkifyFilePaths',\n    minimalErrorRendering: 'notebook.output.minimalErrorRendering',\n    formatOnSave: 'notebook.formatOnSave.enabled',\n    insertFinalNewline: 'notebook.insertFinalNewline',\n    defaultFormatter: 'notebook.defaultFormatter',\n    formatOnCellExecution: 'notebook.formatOnCellExecution',\n    codeActionsOnSave: 'notebook.codeActionsOnSave',\n    outputWordWrap: 'notebook.output.wordWrap',\n    outputLineHeightDeprecated: 'notebook.outputLineHeight',\n    outputLineHeight: 'notebook.output.lineHeight',\n    outputFontSizeDeprecated: 'notebook.outputFontSize',\n    outputFontSize: 'notebook.output.fontSize',\n    outputFontFamilyDeprecated: 'notebook.outputFontFamily',\n    outputFontFamily: 'notebook.output.fontFamily',\n    findFilters: 'notebook.find.filters',\n    logging: 'notebook.logging',\n    confirmDeleteRunningCell: 'notebook.confirmDeleteRunningCell',\n    remoteSaving: 'notebook.experimental.remoteSave',\n    gotoSymbolsAllSymbols: 'notebook.gotoSymbols.showAllSymbols',\n    outlineShowMarkdownHeadersOnly: 'notebook.outline.showMarkdownHeadersOnly',\n    outlineShowCodeCells: 'notebook.outline.showCodeCells',\n    outlineShowCodeCellSymbols: 'notebook.outline.showCodeCellSymbols',\n    breadcrumbsShowCodeCells: 'notebook.breadcrumbs.showCodeCells',\n    scrollToRevealCell: 'notebook.scrolling.revealNextCellOnExecute',\n    cellChat: 'notebook.experimental.cellChat',\n    cellGenerate: 'notebook.experimental.generate',\n    notebookVariablesView: 'notebook.experimental.variablesView',\n    InteractiveWindowPromptToSave: 'interactiveWindow.promptToSaveOnClose',\n    cellFailureDiagnostics: 'notebook.cellFailureDiagnostics',\n    outputBackupSizeLimit: 'notebook.backup.sizeLimit',\n    multiCursor: 'notebook.multiCursor.enabled',\n};\nclass NotebookWorkingCopyTypeIdentifier {\n    static { this._prefix = 'notebook/'; }\n    static create(notebookType, viewType) {\n        return `${NotebookWorkingCopyTypeIdentifier._prefix}${notebookType}/${viewType ?? notebookType}`;\n    }\n    static parse(candidate) {\n        if (candidate.startsWith(NotebookWorkingCopyTypeIdentifier._prefix)) {\n            const split = candidate.substring(NotebookWorkingCopyTypeIdentifier._prefix.length).split('/');\n            if (split.length === 2) {\n                return { notebookType: split[0], viewType: split[1] };\n            }\n        }\n        return undefined;\n    }\n}\nfunction isTextStreamMime(mimeType) {\n    return ['application/vnd.code.notebook.stdout', 'application/vnd.code.notebook.stderr'].includes(mimeType);\n}\nconst textDecoder = ( new TextDecoder());\nfunction compressOutputItemStreams(outputs) {\n    const buffers = [];\n    let startAppending = false;\n    for (const output of outputs) {\n        if ((buffers.length === 0 || startAppending)) {\n            buffers.push(output);\n            startAppending = true;\n        }\n    }\n    let didCompression = compressStreamBuffer(buffers);\n    const concatenated = VSBuffer.concat(( buffers.map(buffer => VSBuffer.wrap(buffer))));\n    const data = formatStreamText(concatenated);\n    didCompression = didCompression || data.byteLength !== concatenated.byteLength;\n    return { data, didCompression };\n}\nconst MOVE_CURSOR_1_LINE_COMMAND = `${String.fromCharCode(27)}[A`;\nconst MOVE_CURSOR_1_LINE_COMMAND_BYTES = ( MOVE_CURSOR_1_LINE_COMMAND.split('').map(c => c.charCodeAt(0)));\nconst LINE_FEED = 10;\nfunction compressStreamBuffer(streams) {\n    let didCompress = false;\n    streams.forEach((stream, index) => {\n        if (index === 0 || stream.length < MOVE_CURSOR_1_LINE_COMMAND.length) {\n            return;\n        }\n        const previousStream = streams[index - 1];\n        const command = stream.subarray(0, MOVE_CURSOR_1_LINE_COMMAND.length);\n        if (command[0] === MOVE_CURSOR_1_LINE_COMMAND_BYTES[0] && command[1] === MOVE_CURSOR_1_LINE_COMMAND_BYTES[1] && command[2] === MOVE_CURSOR_1_LINE_COMMAND_BYTES[2]) {\n            const lastIndexOfLineFeed = previousStream.lastIndexOf(LINE_FEED);\n            if (lastIndexOfLineFeed === -1) {\n                return;\n            }\n            didCompress = true;\n            streams[index - 1] = previousStream.subarray(0, lastIndexOfLineFeed);\n            streams[index] = stream.subarray(MOVE_CURSOR_1_LINE_COMMAND.length);\n        }\n    });\n    return didCompress;\n}\nfunction fixBackspace(txt) {\n    let tmp = txt;\n    do {\n        txt = tmp;\n        tmp = txt.replace(/[^\\n]\\x08/gm, '');\n    } while (tmp.length < txt.length);\n    return txt;\n}\nfunction fixCarriageReturn(txt) {\n    txt = txt.replace(/\\r+\\n/gm, '\\n');\n    while (txt.search(/\\r[^$]/g) > -1) {\n        const base = txt.match(/^(.*)\\r+/m)[1];\n        let insert = txt.match(/\\r+(.*)$/m)[1];\n        insert = insert + base.slice(insert.length, base.length);\n        txt = txt.replace(/\\r+.*$/m, '\\r').replace(/^.*\\r/m, insert);\n    }\n    return txt;\n}\nconst BACKSPACE_CHARACTER = '\\b'.charCodeAt(0);\nconst CARRIAGE_RETURN_CHARACTER = '\\r'.charCodeAt(0);\nfunction formatStreamText(buffer) {\n    if (!buffer.buffer.includes(BACKSPACE_CHARACTER) && !buffer.buffer.includes(CARRIAGE_RETURN_CHARACTER)) {\n        return buffer;\n    }\n    return VSBuffer.fromString(fixCarriageReturn(fixBackspace(textDecoder.decode(buffer.buffer))));\n}\nexport { ACCESSIBLE_NOTEBOOK_DISPLAY_ORDER, CellKind, CellUri, INTERACTIVE_WINDOW_EDITOR_ID, MOVE_CURSOR_1_LINE_COMMAND, MimeTypeDisplayOrder, NOTEBOOK_DIFF_EDITOR_ID, NOTEBOOK_DISPLAY_ORDER, NOTEBOOK_EDITOR_CURSOR_BOUNDARY, NOTEBOOK_EDITOR_CURSOR_LINE_BOUNDARY, NOTEBOOK_EDITOR_ID, NOTEBOOK_MULTI_DIFF_EDITOR_ID, NotebookCellExecutionState, NotebookCellsChangeType, NotebookEditorPriority, NotebookExecutionState, NotebookFindScopeType, NotebookMetadataUri, NotebookSetting, NotebookWorkingCopyTypeIdentifier, RENDERER_EQUIVALENT_EXTENSIONS, RENDERER_NOT_AVAILABLE, SelectionStateType, compressOutputItemStreams, diff, isDocumentExcludePattern, isTextStreamMime };\n","var CellExecutionUpdateType;\n( (function(CellExecutionUpdateType) {\n    CellExecutionUpdateType[CellExecutionUpdateType[\"Output\"] = 1] = \"Output\";\n    CellExecutionUpdateType[CellExecutionUpdateType[\"OutputItems\"] = 2] = \"OutputItems\";\n    CellExecutionUpdateType[CellExecutionUpdateType[\"ExecutionState\"] = 3] = \"ExecutionState\";\n})(CellExecutionUpdateType || (CellExecutionUpdateType = {})));\nexport { CellExecutionUpdateType };\n","const variablePageSize = 100;\nexport { variablePageSize };\n","import { Disposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../../../editor/common/core/range.js';\nimport { PieceTreeTextBufferBuilder } from '../../../../editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\nimport { SearchParams } from '../../../../editor/common/model/textModelSearch.js';\nclass CellSearchModel extends Disposable {\n    constructor(_source, _inputTextBuffer, _outputs) {\n        super();\n        this._source = _source;\n        this._inputTextBuffer = _inputTextBuffer;\n        this._outputs = _outputs;\n        this._outputTextBuffers = undefined;\n    }\n    _getFullModelRange(buffer) {\n        const lineCount = buffer.getLineCount();\n        return ( new Range(1, 1, lineCount, this._getLineMaxColumn(buffer, lineCount)));\n    }\n    _getLineMaxColumn(buffer, lineNumber) {\n        if (lineNumber < 1 || lineNumber > buffer.getLineCount()) {\n            throw ( new Error('Illegal value for lineNumber'));\n        }\n        return buffer.getLineLength(lineNumber) + 1;\n    }\n    get inputTextBuffer() {\n        if (!this._inputTextBuffer) {\n            const builder = ( new PieceTreeTextBufferBuilder());\n            builder.acceptChunk(this._source);\n            const bufferFactory = builder.finish(true);\n            const { textBuffer, disposable } = bufferFactory.create(1 );\n            this._inputTextBuffer = textBuffer;\n            this._register(disposable);\n        }\n        return this._inputTextBuffer;\n    }\n    get outputTextBuffers() {\n        if (!this._outputTextBuffers) {\n            this._outputTextBuffers = ( this._outputs.map((output) => {\n                const builder = ( new PieceTreeTextBufferBuilder());\n                builder.acceptChunk(output);\n                const bufferFactory = builder.finish(true);\n                const { textBuffer, disposable } = bufferFactory.create(1 );\n                this._register(disposable);\n                return textBuffer;\n            }));\n        }\n        return this._outputTextBuffers;\n    }\n    findInInputs(target) {\n        const searchParams = ( new SearchParams(target, false, false, null));\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return [];\n        }\n        const fullInputRange = this._getFullModelRange(this.inputTextBuffer);\n        return this.inputTextBuffer.findMatchesLineByLine(fullInputRange, searchData, true, 5000);\n    }\n    findInOutputs(target) {\n        const searchParams = ( new SearchParams(target, false, false, null));\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return [];\n        }\n        return ( this.outputTextBuffers.map(buffer => {\n            const matches = buffer.findMatchesLineByLine(this._getFullModelRange(buffer), searchData, true, 5000);\n            if (matches.length === 0) {\n                return undefined;\n            }\n            return {\n                textBuffer: buffer,\n                matches\n            };\n        })).filter((item) => !!item);\n    }\n}\nexport { CellSearchModel };\n","import { TextSearchMatch } from '../../../services/search/common/search.js';\nimport { Range } from '../../../../editor/common/core/range.js';\nfunction isINotebookFileMatchNoModel(object) {\n    return 'cellResults' in object;\n}\nconst rawCellPrefix = 'rawCell#';\nfunction genericCellMatchesToTextSearchMatches(contentMatches, buffer) {\n    let previousEndLine = -1;\n    const contextGroupings = [];\n    let currentContextGrouping = [];\n    contentMatches.forEach((match) => {\n        if (match.range.startLineNumber !== previousEndLine) {\n            if (currentContextGrouping.length > 0) {\n                contextGroupings.push([...currentContextGrouping]);\n                currentContextGrouping = [];\n            }\n        }\n        currentContextGrouping.push(match);\n        previousEndLine = match.range.endLineNumber;\n    });\n    if (currentContextGrouping.length > 0) {\n        contextGroupings.push([...currentContextGrouping]);\n    }\n    const textSearchResults = ( contextGroupings.map((grouping) => {\n        const lineTexts = [];\n        const firstLine = grouping[0].range.startLineNumber;\n        const lastLine = grouping[grouping.length - 1].range.endLineNumber;\n        for (let i = firstLine; i <= lastLine; i++) {\n            lineTexts.push(buffer.getLineContent(i));\n        }\n        return ( new TextSearchMatch(lineTexts.join('\\n') + '\\n', ( grouping.map(m => ( new Range(\n            m.range.startLineNumber - 1,\n            m.range.startColumn - 1,\n            m.range.endLineNumber - 1,\n            m.range.endColumn - 1\n        ))))));\n    }));\n    return textSearchResults;\n}\nexport { genericCellMatchesToTextSearchMatches, isINotebookFileMatchNoModel, rawCellPrefix };\n","import { localize } from '../../../../nls.js';\nimport { isString } from '../../../../base/common/types.js';\nimport { deepClone } from '../../../../base/common/objects.js';\nimport { ExtensionsRegistry } from '../../../services/extensions/common/extensionsRegistry.js';\nimport { ContextKeyExpr } from '../../../../platform/contextkey/common/contextkey.js';\nimport { Emitter } from '../../../../base/common/event.js';\nconst taskDefinitionSchema = {\n    type: 'object',\n    additionalProperties: false,\n    properties: {\n        type: {\n            type: 'string',\n            description: ( localize(\n                6618,\n                'The actual task type. Please note that types starting with a \\'$\\' are reserved for internal usage.'\n            ))\n        },\n        required: {\n            type: 'array',\n            items: {\n                type: 'string'\n            }\n        },\n        properties: {\n            type: 'object',\n            description: ( localize(6619, 'Additional properties of the task type')),\n            additionalProperties: {\n                $ref: 'http://json-schema.org/draft-07/schema#'\n            }\n        },\n        when: {\n            type: 'string',\n            markdownDescription: ( localize(\n                6620,\n                'Condition which must be true to enable this type of task. Consider using `shellExecutionSupported`, `processExecutionSupported`, and `customExecutionSupported` as appropriate for this task definition. See the [API documentation](https://code.visualstudio.com/api/extension-guides/task-provider#when-clause) for more information.'\n            )),\n            default: ''\n        }\n    }\n};\nvar Configuration;\n( ((function(Configuration) {\n    function from(value, extensionId, messageCollector) {\n        if (!value) {\n            return undefined;\n        }\n        const taskType = isString(value.type) ? value.type : undefined;\n        if (!taskType || taskType.length === 0) {\n            messageCollector.error(( localize(\n                6621,\n                'The task type configuration is missing the required \\'taskType\\' property'\n            )));\n            return undefined;\n        }\n        const required = [];\n        if (Array.isArray(value.required)) {\n            for (const element of value.required) {\n                if (isString(element)) {\n                    required.push(element);\n                }\n            }\n        }\n        return {\n            extensionId: extensionId.value,\n            taskType, required: required,\n            properties: value.properties ? deepClone(value.properties) : {},\n            when: value.when ? ContextKeyExpr.deserialize(value.when) : undefined\n        };\n    }\n    Configuration.from = from;\n})(Configuration || (Configuration = {}))));\nconst taskDefinitionsExtPoint = ExtensionsRegistry.registerExtensionPoint({\n    extensionPoint: 'taskDefinitions',\n    activationEventsGenerator: (contributions, result) => {\n        for (const task of contributions) {\n            if (task.type) {\n                result.push(`onTaskType:${task.type}`);\n            }\n        }\n    },\n    jsonSchema: {\n        description: ( localize(6622, 'Contributes task kinds')),\n        type: 'array',\n        items: taskDefinitionSchema\n    }\n});\nclass TaskDefinitionRegistryImpl {\n    constructor() {\n        this._onDefinitionsChanged = ( (new Emitter()));\n        this.onDefinitionsChanged = this._onDefinitionsChanged.event;\n        this.taskTypes = Object.create(null);\n        this.readyPromise = ( (new Promise((resolve, reject) => {\n            taskDefinitionsExtPoint.setHandler((extensions, delta) => {\n                this._schema = undefined;\n                try {\n                    for (const extension of delta.removed) {\n                        const taskTypes = extension.value;\n                        for (const taskType of taskTypes) {\n                            if (this.taskTypes && taskType.type && this.taskTypes[taskType.type]) {\n                                delete this.taskTypes[taskType.type];\n                            }\n                        }\n                    }\n                    for (const extension of delta.added) {\n                        const taskTypes = extension.value;\n                        for (const taskType of taskTypes) {\n                            const type = Configuration.from(taskType, extension.description.identifier, extension.collector);\n                            if (type) {\n                                this.taskTypes[type.taskType] = type;\n                            }\n                        }\n                    }\n                    if ((delta.removed.length > 0) || (delta.added.length > 0)) {\n                        this._onDefinitionsChanged.fire();\n                    }\n                }\n                catch (error) {\n                }\n                resolve(undefined);\n            });\n        })));\n    }\n    onReady() {\n        return this.readyPromise;\n    }\n    get(key) {\n        return this.taskTypes[key];\n    }\n    all() {\n        return (\n             (( (Object.keys(this.taskTypes))).map(key => this.taskTypes[key]))\n        );\n    }\n    getJsonSchema() {\n        if (this._schema === undefined) {\n            const schemas = [];\n            for (const definition of this.all()) {\n                const schema = {\n                    type: 'object',\n                    additionalProperties: false\n                };\n                if (definition.required.length > 0) {\n                    schema.required = definition.required.slice(0);\n                }\n                if (definition.properties !== undefined) {\n                    schema.properties = deepClone(definition.properties);\n                }\n                else {\n                    schema.properties = Object.create(null);\n                }\n                schema.properties.type = {\n                    type: 'string',\n                    enum: [definition.taskType]\n                };\n                schemas.push(schema);\n            }\n            this._schema = { oneOf: schemas };\n        }\n        return this._schema;\n    }\n}\nconst TaskDefinitionRegistry = ( (new TaskDefinitionRegistryImpl()));\nexport { TaskDefinitionRegistry };\n","import { localize, localize2 } from '../../../../nls.js';\nimport { isString } from '../../../../base/common/types.js';\nimport { basename } from '../../../../base/common/resources.js';\nimport { deepClone } from '../../../../base/common/objects.js';\nimport { RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\nimport { TaskDefinitionRegistry } from './taskDefinitionRegistry.js';\nconst USER_TASKS_GROUP_KEY = 'settings';\nconst TASK_RUNNING_STATE = ( (new RawContextKey('taskRunning', false, ( localize(3868, \"Whether a task is currently running.\")))));\nconst TASKS_CATEGORY = ( localize2(3869, \"Tasks\"));\nvar ShellQuoting;\n( ((function(ShellQuoting) {\n    ShellQuoting[ShellQuoting[\"Escape\"] = 1] = \"Escape\";\n    ShellQuoting[ShellQuoting[\"Strong\"] = 2] = \"Strong\";\n    ShellQuoting[ShellQuoting[\"Weak\"] = 3] = \"Weak\";\n})(ShellQuoting || (ShellQuoting = {}))));\nconst CUSTOMIZED_TASK_TYPE = '$customized';\n( ((function(ShellQuoting) {\n    function from(value) {\n        if (!value) {\n            return ShellQuoting.Strong;\n        }\n        switch (value.toLowerCase()) {\n            case 'escape':\n                return ShellQuoting.Escape;\n            case 'strong':\n                return ShellQuoting.Strong;\n            case 'weak':\n                return ShellQuoting.Weak;\n            default:\n                return ShellQuoting.Strong;\n        }\n    }\n    ShellQuoting.from = from;\n})(ShellQuoting || (ShellQuoting = {}))));\nvar CommandOptions;\n( ((function(CommandOptions) {\n    CommandOptions.defaults = { cwd: '${workspaceFolder}' };\n})(CommandOptions || (CommandOptions = {}))));\nvar RevealKind;\n( ((function(RevealKind) {\n    RevealKind[RevealKind[\"Always\"] = 1] = \"Always\";\n    RevealKind[RevealKind[\"Silent\"] = 2] = \"Silent\";\n    RevealKind[RevealKind[\"Never\"] = 3] = \"Never\";\n})(RevealKind || (RevealKind = {}))));\n( ((function(RevealKind) {\n    function fromString(value) {\n        switch (value.toLowerCase()) {\n            case 'always':\n                return RevealKind.Always;\n            case 'silent':\n                return RevealKind.Silent;\n            case 'never':\n                return RevealKind.Never;\n            default:\n                return RevealKind.Always;\n        }\n    }\n    RevealKind.fromString = fromString;\n})(RevealKind || (RevealKind = {}))));\nvar RevealProblemKind;\n( ((function(RevealProblemKind) {\n    RevealProblemKind[RevealProblemKind[\"Never\"] = 1] = \"Never\";\n    RevealProblemKind[RevealProblemKind[\"OnProblem\"] = 2] = \"OnProblem\";\n    RevealProblemKind[RevealProblemKind[\"Always\"] = 3] = \"Always\";\n})(RevealProblemKind || (RevealProblemKind = {}))));\n( ((function(RevealProblemKind) {\n    function fromString(value) {\n        switch (value.toLowerCase()) {\n            case 'always':\n                return RevealProblemKind.Always;\n            case 'never':\n                return RevealProblemKind.Never;\n            case 'onproblem':\n                return RevealProblemKind.OnProblem;\n            default:\n                return RevealProblemKind.OnProblem;\n        }\n    }\n    RevealProblemKind.fromString = fromString;\n})(RevealProblemKind || (RevealProblemKind = {}))));\nvar PanelKind;\n( ((function(PanelKind) {\n    PanelKind[PanelKind[\"Shared\"] = 1] = \"Shared\";\n    PanelKind[PanelKind[\"Dedicated\"] = 2] = \"Dedicated\";\n    PanelKind[PanelKind[\"New\"] = 3] = \"New\";\n})(PanelKind || (PanelKind = {}))));\n( ((function(PanelKind) {\n    function fromString(value) {\n        switch (value.toLowerCase()) {\n            case 'shared':\n                return PanelKind.Shared;\n            case 'dedicated':\n                return PanelKind.Dedicated;\n            case 'new':\n                return PanelKind.New;\n            default:\n                return PanelKind.Shared;\n        }\n    }\n    PanelKind.fromString = fromString;\n})(PanelKind || (PanelKind = {}))));\nvar PresentationOptions;\n( ((function(PresentationOptions) {\n    PresentationOptions.defaults = {\n        echo: true, reveal: RevealKind.Always, revealProblems: RevealProblemKind.Never, focus: false, panel: PanelKind.Shared, showReuseMessage: true, clear: false\n    };\n})(PresentationOptions || (PresentationOptions = {}))));\nvar RuntimeType;\n( ((function(RuntimeType) {\n    RuntimeType[RuntimeType[\"Shell\"] = 1] = \"Shell\";\n    RuntimeType[RuntimeType[\"Process\"] = 2] = \"Process\";\n    RuntimeType[RuntimeType[\"CustomExecution\"] = 3] = \"CustomExecution\";\n})(RuntimeType || (RuntimeType = {}))));\n( ((function(RuntimeType) {\n    function fromString(value) {\n        switch (value.toLowerCase()) {\n            case 'shell':\n                return RuntimeType.Shell;\n            case 'process':\n                return RuntimeType.Process;\n            case 'customExecution':\n                return RuntimeType.CustomExecution;\n            default:\n                return RuntimeType.Process;\n        }\n    }\n    RuntimeType.fromString = fromString;\n    function toString(value) {\n        switch (value) {\n            case RuntimeType.Shell: return 'shell';\n            case RuntimeType.Process: return 'process';\n            case RuntimeType.CustomExecution: return 'customExecution';\n            default: return 'process';\n        }\n    }\n    RuntimeType.toString = toString;\n})(RuntimeType || (RuntimeType = {}))));\nvar CommandString;\n( ((function(CommandString) {\n    function value(value) {\n        if (isString(value)) {\n            return value;\n        }\n        else {\n            return value.value;\n        }\n    }\n    CommandString.value = value;\n})(CommandString || (CommandString = {}))));\nvar TaskGroup;\n( ((function(TaskGroup) {\n    TaskGroup.Clean = { _id: 'clean', isDefault: false };\n    TaskGroup.Build = { _id: 'build', isDefault: false };\n    TaskGroup.Rebuild = { _id: 'rebuild', isDefault: false };\n    TaskGroup.Test = { _id: 'test', isDefault: false };\n    function is(value) {\n        return value === TaskGroup.Clean._id || value === TaskGroup.Build._id || value === TaskGroup.Rebuild._id || value === TaskGroup.Test._id;\n    }\n    TaskGroup.is = is;\n    function from(value) {\n        if (value === undefined) {\n            return undefined;\n        }\n        else if (isString(value)) {\n            if (is(value)) {\n                return { _id: value, isDefault: false };\n            }\n            return undefined;\n        }\n        else {\n            return value;\n        }\n    }\n    TaskGroup.from = from;\n})(TaskGroup || (TaskGroup = {}))));\nvar TaskSourceKind;\n( ((function(TaskSourceKind) {\n    TaskSourceKind.Workspace = 'workspace';\n    TaskSourceKind.Extension = 'extension';\n    TaskSourceKind.InMemory = 'inMemory';\n    TaskSourceKind.WorkspaceFile = 'workspaceFile';\n    TaskSourceKind.User = 'user';\n    function toConfigurationTarget(kind) {\n        switch (kind) {\n            case TaskSourceKind.User: return 2 ;\n            case TaskSourceKind.WorkspaceFile: return 5 ;\n            default: return 6 ;\n        }\n    }\n    TaskSourceKind.toConfigurationTarget = toConfigurationTarget;\n})(TaskSourceKind || (TaskSourceKind = {}))));\nvar RunOnOptions;\n( ((function(RunOnOptions) {\n    RunOnOptions[RunOnOptions[\"default\"] = 1] = \"default\";\n    RunOnOptions[RunOnOptions[\"folderOpen\"] = 2] = \"folderOpen\";\n})(RunOnOptions || (RunOnOptions = {}))));\nvar RunOptions;\n( ((function(RunOptions) {\n    RunOptions.defaults = { reevaluateOnRerun: true, runOn: RunOnOptions.default, instanceLimit: 1 };\n})(RunOptions || (RunOptions = {}))));\nclass CommonTask {\n    constructor(id, label, type, runOptions, configurationProperties, source) {\n        this._label = '';\n        this._id = id;\n        if (label) {\n            this._label = label;\n        }\n        if (type) {\n            this.type = type;\n        }\n        this.runOptions = runOptions;\n        this.configurationProperties = configurationProperties;\n        this._source = source;\n    }\n    getDefinition(useSource) {\n        return undefined;\n    }\n    getMapKey() {\n        return this._id;\n    }\n    getKey() {\n        return undefined;\n    }\n    getCommonTaskId() {\n        const key = { folder: this.getFolderId(), id: this._id };\n        return JSON.stringify(key);\n    }\n    clone() {\n        return this.fromObject(Object.assign({}, this));\n    }\n    getWorkspaceFolder() {\n        return undefined;\n    }\n    getWorkspaceFileName() {\n        return undefined;\n    }\n    getTelemetryKind() {\n        return 'unknown';\n    }\n    matches(key, compareId = false) {\n        if (key === undefined) {\n            return false;\n        }\n        if (isString(key)) {\n            return key === this._label || key === this.configurationProperties.identifier || (compareId && key === this._id);\n        }\n        const identifier = this.getDefinition(true);\n        return identifier !== undefined && identifier._key === key._key;\n    }\n    getQualifiedLabel() {\n        const workspaceFolder = this.getWorkspaceFolder();\n        if (workspaceFolder) {\n            return `${this._label} (${workspaceFolder.name})`;\n        }\n        else {\n            return this._label;\n        }\n    }\n    getTaskExecution() {\n        const result = {\n            id: this._id,\n            task: this\n        };\n        return result;\n    }\n    addTaskLoadMessages(messages) {\n        if (this._taskLoadMessages === undefined) {\n            this._taskLoadMessages = [];\n        }\n        if (messages) {\n            this._taskLoadMessages = this._taskLoadMessages.concat(messages);\n        }\n    }\n    get taskLoadMessages() {\n        return this._taskLoadMessages;\n    }\n}\nclass CustomTask extends CommonTask {\n    constructor(id, source, label, type, command, hasDefinedMatchers, runOptions, configurationProperties) {\n        super(id, label, undefined, runOptions, configurationProperties, source);\n        this.command = {};\n        this._source = source;\n        this.hasDefinedMatchers = hasDefinedMatchers;\n        if (command) {\n            this.command = command;\n        }\n    }\n    clone() {\n        return (\n             (new CustomTask(\n                this._id,\n                this._source,\n                this._label,\n                this.type,\n                this.command,\n                this.hasDefinedMatchers,\n                this.runOptions,\n                this.configurationProperties\n            ))\n        );\n    }\n    customizes() {\n        if (this._source && this._source.customizes) {\n            return this._source.customizes;\n        }\n        return undefined;\n    }\n    getDefinition(useSource = false) {\n        if (useSource && this._source.customizes !== undefined) {\n            return this._source.customizes;\n        }\n        else {\n            let type;\n            const commandRuntime = this.command ? this.command.runtime : undefined;\n            switch (commandRuntime) {\n                case RuntimeType.Shell:\n                    type = 'shell';\n                    break;\n                case RuntimeType.Process:\n                    type = 'process';\n                    break;\n                case RuntimeType.CustomExecution:\n                    type = 'customExecution';\n                    break;\n                case undefined:\n                    type = '$composite';\n                    break;\n                default:\n                    throw ( (new Error('Unexpected task runtime')));\n            }\n            const result = {\n                type,\n                _key: this._id,\n                id: this._id\n            };\n            return result;\n        }\n    }\n    static is(value) {\n        return value instanceof CustomTask;\n    }\n    getMapKey() {\n        const workspaceFolder = this._source.config.workspaceFolder;\n        return workspaceFolder ? `${( (workspaceFolder.uri.toString()))}|${this._id}|${this.instance}` : `${this._id}|${this.instance}`;\n    }\n    getFolderId() {\n        return this._source.kind === TaskSourceKind.User ? USER_TASKS_GROUP_KEY : this._source.config.workspaceFolder?.uri.toString();\n    }\n    getCommonTaskId() {\n        return this._source.customizes ? super.getCommonTaskId() : (this.getKey() ?? super.getCommonTaskId());\n    }\n    getKey() {\n        const workspaceFolder = this.getFolderId();\n        if (!workspaceFolder) {\n            return undefined;\n        }\n        let id = this.configurationProperties.identifier;\n        if (this._source.kind !== TaskSourceKind.Workspace) {\n            id += this._source.kind;\n        }\n        const key = { type: CUSTOMIZED_TASK_TYPE, folder: workspaceFolder, id };\n        return JSON.stringify(key);\n    }\n    getWorkspaceFolder() {\n        return this._source.config.workspaceFolder;\n    }\n    getWorkspaceFileName() {\n        return (this._source.config.workspace && this._source.config.workspace.configuration) ? basename(this._source.config.workspace.configuration) : undefined;\n    }\n    getTelemetryKind() {\n        if (this._source.customizes) {\n            return 'workspace>extension';\n        }\n        else {\n            return 'workspace';\n        }\n    }\n    fromObject(object) {\n        return (\n             (new CustomTask(\n                object._id,\n                object._source,\n                object._label,\n                object.type,\n                object.command,\n                object.hasDefinedMatchers,\n                object.runOptions,\n                object.configurationProperties\n            ))\n        );\n    }\n}\nclass ConfiguringTask extends CommonTask {\n    constructor(id, source, label, type, configures, runOptions, configurationProperties) {\n        super(id, label, type, runOptions, configurationProperties, source);\n        this._source = source;\n        this.configures = configures;\n    }\n    static is(value) {\n        return value instanceof ConfiguringTask;\n    }\n    fromObject(object) {\n        return object;\n    }\n    getDefinition() {\n        return this.configures;\n    }\n    getWorkspaceFileName() {\n        return (this._source.config.workspace && this._source.config.workspace.configuration) ? basename(this._source.config.workspace.configuration) : undefined;\n    }\n    getWorkspaceFolder() {\n        return this._source.config.workspaceFolder;\n    }\n    getFolderId() {\n        return this._source.kind === TaskSourceKind.User ? USER_TASKS_GROUP_KEY : this._source.config.workspaceFolder?.uri.toString();\n    }\n    getKey() {\n        const workspaceFolder = this.getFolderId();\n        if (!workspaceFolder) {\n            return undefined;\n        }\n        let id = this.configurationProperties.identifier;\n        if (this._source.kind !== TaskSourceKind.Workspace) {\n            id += this._source.kind;\n        }\n        const key = { type: CUSTOMIZED_TASK_TYPE, folder: workspaceFolder, id };\n        return JSON.stringify(key);\n    }\n}\nclass ContributedTask extends CommonTask {\n    constructor(id, source, label, type, defines, command, hasDefinedMatchers, runOptions, configurationProperties) {\n        super(id, label, type, runOptions, configurationProperties, source);\n        this.defines = defines;\n        this.hasDefinedMatchers = hasDefinedMatchers;\n        this.command = command;\n        this.icon = configurationProperties.icon;\n        this.hide = configurationProperties.hide;\n    }\n    clone() {\n        return (\n             (new ContributedTask(\n                this._id,\n                this._source,\n                this._label,\n                this.type,\n                this.defines,\n                this.command,\n                this.hasDefinedMatchers,\n                this.runOptions,\n                this.configurationProperties\n            ))\n        );\n    }\n    getDefinition() {\n        return this.defines;\n    }\n    static is(value) {\n        return value instanceof ContributedTask;\n    }\n    getMapKey() {\n        const workspaceFolder = this._source.workspaceFolder;\n        return workspaceFolder\n            ? `${( (this._source.scope.toString()))}|${( (workspaceFolder.uri.toString()))}|${this._id}|${this.instance}`\n            : `${( (this._source.scope.toString()))}|${this._id}|${this.instance}`;\n    }\n    getFolderId() {\n        if (this._source.scope === 3  && this._source.workspaceFolder) {\n            return (\n                 (this._source.workspaceFolder.uri.toString())\n            );\n        }\n        return undefined;\n    }\n    getKey() {\n        const key = { type: 'contributed', scope: this._source.scope, id: this._id };\n        key.folder = this.getFolderId();\n        return JSON.stringify(key);\n    }\n    getWorkspaceFolder() {\n        return this._source.workspaceFolder;\n    }\n    getTelemetryKind() {\n        return 'extension';\n    }\n    fromObject(object) {\n        return (\n             (new ContributedTask(\n                object._id,\n                object._source,\n                object._label,\n                object.type,\n                object.defines,\n                object.command,\n                object.hasDefinedMatchers,\n                object.runOptions,\n                object.configurationProperties\n            ))\n        );\n    }\n}\nclass InMemoryTask extends CommonTask {\n    constructor(id, source, label, type, runOptions, configurationProperties) {\n        super(id, label, type, runOptions, configurationProperties, source);\n        this._source = source;\n    }\n    clone() {\n        return (\n             (new InMemoryTask(\n                this._id,\n                this._source,\n                this._label,\n                this.type,\n                this.runOptions,\n                this.configurationProperties\n            ))\n        );\n    }\n    static is(value) {\n        return value instanceof InMemoryTask;\n    }\n    getTelemetryKind() {\n        return 'composite';\n    }\n    getMapKey() {\n        return `${this._id}|${this.instance}`;\n    }\n    getFolderId() {\n        return undefined;\n    }\n    fromObject(object) {\n        return (\n             (new InMemoryTask(\n                object._id,\n                object._source,\n                object._label,\n                object.type,\n                object.runOptions,\n                object.configurationProperties\n            ))\n        );\n    }\n}\nvar ExecutionEngine;\n( ((function(ExecutionEngine) {\n    ExecutionEngine[ExecutionEngine[\"Process\"] = 1] = \"Process\";\n    ExecutionEngine[ExecutionEngine[\"Terminal\"] = 2] = \"Terminal\";\n})(ExecutionEngine || (ExecutionEngine = {}))));\n( ((function(ExecutionEngine) {\n    ExecutionEngine._default = ExecutionEngine.Terminal;\n})(ExecutionEngine || (ExecutionEngine = {}))));\nclass TaskSorter {\n    constructor(workspaceFolders) {\n        this._order = ( (new Map()));\n        for (let i = 0; i < workspaceFolders.length; i++) {\n            this._order.set(( (workspaceFolders[i].uri.toString())), i);\n        }\n    }\n    compare(a, b) {\n        const aw = a.getWorkspaceFolder();\n        const bw = b.getWorkspaceFolder();\n        if (aw && bw) {\n            let ai = this._order.get(( (aw.uri.toString())));\n            ai = ai === undefined ? 0 : ai + 1;\n            let bi = this._order.get(( (bw.uri.toString())));\n            bi = bi === undefined ? 0 : bi + 1;\n            if (ai === bi) {\n                return a._label.localeCompare(b._label);\n            }\n            else {\n                return ai - bi;\n            }\n        }\n        else if (!aw && bw) {\n            return -1;\n        }\n        else if (aw && !bw) {\n            return +1;\n        }\n        else {\n            return 0;\n        }\n    }\n}\nvar TaskEvent;\n( ((function(TaskEvent) {\n    function common(task) {\n        return {\n            taskId: task._id,\n            taskName: task.configurationProperties.name,\n            runType: task.configurationProperties.isBackground ? \"background\"  : \"singleRun\" ,\n            group: task.configurationProperties.group,\n            __task: task,\n        };\n    }\n    function start(task, terminalId, resolvedVariables) {\n        return {\n            ...common(task),\n            kind: \"start\" ,\n            terminalId,\n            resolvedVariables,\n        };\n    }\n    TaskEvent.start = start;\n    function processStarted(task, terminalId, processId) {\n        return {\n            ...common(task),\n            kind: \"processStarted\" ,\n            terminalId,\n            processId,\n        };\n    }\n    TaskEvent.processStarted = processStarted;\n    function processEnded(task, terminalId, exitCode) {\n        return {\n            ...common(task),\n            kind: \"processEnded\" ,\n            terminalId,\n            exitCode,\n        };\n    }\n    TaskEvent.processEnded = processEnded;\n    function terminated(task, terminalId, exitReason) {\n        return {\n            ...common(task),\n            kind: \"terminated\" ,\n            exitReason,\n            terminalId,\n        };\n    }\n    TaskEvent.terminated = terminated;\n    function general(kind, task, terminalId) {\n        return {\n            ...common(task),\n            kind,\n            terminalId,\n        };\n    }\n    TaskEvent.general = general;\n    function changed() {\n        return { kind: \"changed\"  };\n    }\n    TaskEvent.changed = changed;\n})(TaskEvent || (TaskEvent = {}))));\nvar KeyedTaskIdentifier;\n( ((function(KeyedTaskIdentifier) {\n    function sortedStringify(literal) {\n        const keys = ( (Object.keys(literal))).sort();\n        let result = '';\n        for (const key of keys) {\n            let stringified = literal[key];\n            if (stringified instanceof Object) {\n                stringified = sortedStringify(stringified);\n            }\n            else if (typeof stringified === 'string') {\n                stringified = stringified.replace(/,/g, ',,');\n            }\n            result += key + ',' + stringified + ',';\n        }\n        return result;\n    }\n    function create(value) {\n        const resultKey = sortedStringify(value);\n        const result = { _key: resultKey, type: value.taskType };\n        Object.assign(result, value);\n        return result;\n    }\n    KeyedTaskIdentifier.create = create;\n})(KeyedTaskIdentifier || (KeyedTaskIdentifier = {}))));\nvar TaskDefinition;\n( ((function(TaskDefinition) {\n    function createTaskIdentifier(external, reporter) {\n        const definition = TaskDefinitionRegistry.get(external.type);\n        if (definition === undefined) {\n            const copy = deepClone(external);\n            delete copy._key;\n            return KeyedTaskIdentifier.create(copy);\n        }\n        const literal = Object.create(null);\n        literal.type = definition.taskType;\n        const required = ( (new Set()));\n        definition.required.forEach(element => required.add(element));\n        const properties = definition.properties;\n        for (const property of ( (Object.keys(properties)))) {\n            const value = external[property];\n            if (value !== undefined && value !== null) {\n                literal[property] = value;\n            }\n            else if (( (required.has(property)))) {\n                const schema = properties[property];\n                if (schema.default !== undefined) {\n                    literal[property] = deepClone(schema.default);\n                }\n                else {\n                    switch (schema.type) {\n                        case 'boolean':\n                            literal[property] = false;\n                            break;\n                        case 'number':\n                        case 'integer':\n                            literal[property] = 0;\n                            break;\n                        case 'string':\n                            literal[property] = '';\n                            break;\n                        default:\n                            reporter.error(( localize(\n                                3870,\n                                'Error: the task identifier \\'{0}\\' is missing the required property \\'{1}\\'. The task identifier will be ignored.',\n                                JSON.stringify(external, undefined, 0),\n                                property\n                            )));\n                            return undefined;\n                    }\n                }\n            }\n        }\n        return KeyedTaskIdentifier.create(literal);\n    }\n    TaskDefinition.createTaskIdentifier = createTaskIdentifier;\n})(TaskDefinition || (TaskDefinition = {}))));\nexport { CUSTOMIZED_TASK_TYPE, CommandOptions, CommandString, CommonTask, ConfiguringTask, ContributedTask, CustomTask, ExecutionEngine, InMemoryTask, KeyedTaskIdentifier, PanelKind, PresentationOptions, RevealKind, RevealProblemKind, RunOnOptions, RunOptions, RuntimeType, ShellQuoting, TASKS_CATEGORY, TASK_RUNNING_STATE, TaskDefinition, TaskEvent, TaskGroup, TaskSorter, TaskSourceKind, USER_TASKS_GROUP_KEY };\n","class TestId {\n    static fromExtHostTestItem(item, rootId, parent = item.parent) {\n        if (item._isRoot) {\n            return ( new TestId([rootId]));\n        }\n        const path = [item.id];\n        for (let i = parent; i && i.id !== rootId; i = i.parent) {\n            path.push(i.id);\n        }\n        path.push(rootId);\n        return ( new TestId(path.reverse()));\n    }\n    static isRoot(idString) {\n        return !idString.includes(\"\\0\" );\n    }\n    static root(idString) {\n        const idx = idString.indexOf(\"\\0\" );\n        return idx === -1 ? idString : idString.slice(0, idx);\n    }\n    static fromString(idString) {\n        return ( new TestId(idString.split(\"\\0\" )));\n    }\n    static join(base, b) {\n        return ( new TestId([...base.path, b]));\n    }\n    static joinToString(base, b) {\n        return ( base.toString()) + \"\\0\"  + b;\n    }\n    static parentId(idString) {\n        const idx = idString.lastIndexOf(\"\\0\" );\n        return idx === -1 ? undefined : idString.slice(0, idx);\n    }\n    static localId(idString) {\n        const idx = idString.lastIndexOf(\"\\0\" );\n        return idx === -1 ? idString : idString.slice(idx + \"\\0\" .length);\n    }\n    static isChild(maybeParent, maybeChild) {\n        return maybeChild[maybeParent.length] === \"\\0\"  && maybeChild.startsWith(maybeParent);\n    }\n    static compare(a, b) {\n        if (a === b) {\n            return 0 ;\n        }\n        if (TestId.isChild(a, b)) {\n            return 2 ;\n        }\n        if (TestId.isChild(b, a)) {\n            return 3 ;\n        }\n        return 1 ;\n    }\n    static getLengthOfCommonPrefix(length, getId) {\n        if (length === 0) {\n            return 0;\n        }\n        let commonPrefix = 0;\n        while (commonPrefix < length - 1) {\n            for (let i = 1; i < length; i++) {\n                const a = getId(i - 1);\n                const b = getId(i);\n                if (a.path[commonPrefix] !== b.path[commonPrefix]) {\n                    return commonPrefix;\n                }\n            }\n            commonPrefix++;\n        }\n        return commonPrefix;\n    }\n    constructor(path, viewEnd = path.length) {\n        this.path = path;\n        this.viewEnd = viewEnd;\n        if (path.length === 0 || viewEnd < 1) {\n            throw ( new Error('cannot create test with empty path'));\n        }\n    }\n    get rootId() {\n        return ( new TestId(this.path, 1));\n    }\n    get parentId() {\n        return this.viewEnd > 1 ? ( new TestId(this.path, this.viewEnd - 1)) : undefined;\n    }\n    get localId() {\n        return this.path[this.viewEnd - 1];\n    }\n    get controllerId() {\n        return this.path[0];\n    }\n    get isRoot() {\n        return this.viewEnd === 1;\n    }\n    *idsFromRoot() {\n        for (let i = 1; i <= this.viewEnd; i++) {\n            yield ( new TestId(this.path, i));\n        }\n    }\n    *idsToRoot() {\n        for (let i = this.viewEnd; i > 0; i--) {\n            yield ( new TestId(this.path, i));\n        }\n    }\n    compare(other) {\n        if (typeof other === 'string') {\n            return TestId.compare(( this.toString()), other);\n        }\n        for (let i = 0; i < other.viewEnd && i < this.viewEnd; i++) {\n            if (other.path[i] !== this.path[i]) {\n                return 1 ;\n            }\n        }\n        if (other.viewEnd > this.viewEnd) {\n            return 2 ;\n        }\n        if (other.viewEnd < this.viewEnd) {\n            return 3 ;\n        }\n        return 0 ;\n    }\n    toJSON() {\n        return ( this.toString());\n    }\n    toString() {\n        if (!this.stringifed) {\n            this.stringifed = this.path[0];\n            for (let i = 1; i < this.viewEnd; i++) {\n                this.stringifed += \"\\0\" ;\n                this.stringifed += this.path[i];\n            }\n        }\n        return this.stringifed;\n    }\n}\nexport { TestId };\n","import { RunOnceScheduler, Barrier, isThenable } from '../../../../base/common/async.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { assertNever } from '../../../../base/common/assert.js';\nimport { applyTestItemUpdate, namespaceTestTag } from './testTypes.js';\nimport { TestId } from './testId.js';\nconst strictEqualComparator = (a, b) => a === b;\nconst diffableProps = {\n    range: (a, b) => {\n        if (a === b) {\n            return true;\n        }\n        if (!a || !b) {\n            return false;\n        }\n        return a.equalsRange(b);\n    },\n    busy: strictEqualComparator,\n    label: strictEqualComparator,\n    description: strictEqualComparator,\n    error: strictEqualComparator,\n    sortText: strictEqualComparator,\n    tags: (a, b) => {\n        if (a.length !== b.length) {\n            return false;\n        }\n        if (( a.some(t1 => !b.includes(t1)))) {\n            return false;\n        }\n        return true;\n    },\n};\nconst diffableEntries = Object.entries(diffableProps);\nconst diffTestItems = (a, b) => {\n    let output;\n    for (const [key, cmp] of diffableEntries) {\n        if (!cmp(a[key], b[key])) {\n            if (output) {\n                output[key] = b[key];\n            }\n            else {\n                output = { [key]: b[key] };\n            }\n        }\n    }\n    return output;\n};\nclass TestItemCollection extends Disposable {\n    get root() {\n        return this.options.root;\n    }\n    constructor(options) {\n        super();\n        this.options = options;\n        this.debounceSendDiff = this._register(( new RunOnceScheduler(() => this.flushDiff(), 200)));\n        this.diffOpEmitter = this._register(( new Emitter()));\n        this.tree = ( new Map());\n        this.tags = ( new Map());\n        this.diff = [];\n        this.onDidGenerateDiff = this.diffOpEmitter.event;\n        this.root.canResolveChildren = true;\n        this.upsertItem(this.root, undefined);\n    }\n    set resolveHandler(handler) {\n        this._resolveHandler = handler;\n        for (const test of ( this.tree.values())) {\n            this.updateExpandability(test);\n        }\n    }\n    get resolveHandler() {\n        return this._resolveHandler;\n    }\n    collectDiff() {\n        const diff = this.diff;\n        this.diff = [];\n        return diff;\n    }\n    pushDiff(diff) {\n        switch (diff.op) {\n            case 2 : {\n                for (const existing of this.diff) {\n                    if (existing.op === 2  && existing.uri === diff.uri) {\n                        existing.docv = diff.docv;\n                        return;\n                    }\n                }\n                break;\n            }\n            case 1 : {\n                const last = this.diff[this.diff.length - 1];\n                if (last) {\n                    if (last.op === 1  && last.item.extId === diff.item.extId) {\n                        applyTestItemUpdate(last.item, diff.item);\n                        return;\n                    }\n                    if (last.op === 0  && last.item.item.extId === diff.item.extId) {\n                        applyTestItemUpdate(last.item, diff.item);\n                        return;\n                    }\n                }\n                break;\n            }\n        }\n        this.diff.push(diff);\n        if (!this.debounceSendDiff.isScheduled()) {\n            this.debounceSendDiff.schedule();\n        }\n    }\n    expand(testId, levels) {\n        const internal = this.tree.get(testId);\n        if (!internal) {\n            return;\n        }\n        if (internal.expandLevels === undefined || levels > internal.expandLevels) {\n            internal.expandLevels = levels;\n        }\n        if (internal.expand === 1 ) {\n            const r = this.resolveChildren(internal);\n            return !r.isOpen()\n                ? r.wait().then(() => this.expandChildren(internal, levels - 1))\n                : this.expandChildren(internal, levels - 1);\n        }\n        else if (internal.expand === 3 ) {\n            return internal.resolveBarrier?.isOpen() === false\n                ? internal.resolveBarrier.wait().then(() => this.expandChildren(internal, levels - 1))\n                : this.expandChildren(internal, levels - 1);\n        }\n    }\n    dispose() {\n        for (const item of ( this.tree.values())) {\n            this.options.getApiFor(item.actual).listener = undefined;\n        }\n        this.tree.clear();\n        this.diff = [];\n        super.dispose();\n    }\n    onTestItemEvent(internal, evt) {\n        switch (evt.op) {\n            case 3 :\n                this.removeItem(TestId.joinToString(internal.fullId, evt.id));\n                break;\n            case 0 :\n                this.upsertItem(evt.item, internal);\n                break;\n            case 5 :\n                for (const op of evt.ops) {\n                    this.onTestItemEvent(internal, op);\n                }\n                break;\n            case 1 :\n                this.diffTagRefs(evt.new, evt.old, ( internal.fullId.toString()));\n                break;\n            case 2 :\n                this.updateExpandability(internal);\n                break;\n            case 4 :\n                this.pushDiff({\n                    op: 1 ,\n                    item: {\n                        extId: ( internal.fullId.toString()),\n                        item: evt.update,\n                    }\n                });\n                break;\n            case 6 :\n                this.documentSynced(internal.actual.uri);\n                break;\n            default:\n                assertNever();\n        }\n    }\n    documentSynced(uri) {\n        if (uri) {\n            this.pushDiff({\n                op: 2 ,\n                uri,\n                docv: this.options.getDocumentVersion(uri)\n            });\n        }\n    }\n    upsertItem(actual, parent) {\n        const fullId = TestId.fromExtHostTestItem(actual, this.root.id, parent?.actual);\n        const privateApi = this.options.getApiFor(actual);\n        if (privateApi.parent && privateApi.parent !== parent?.actual) {\n            this.options.getChildren(privateApi.parent).delete(actual.id);\n        }\n        let internal = this.tree.get(( fullId.toString()));\n        if (!internal) {\n            internal = {\n                fullId,\n                actual,\n                expandLevels: parent?.expandLevels  ? parent.expandLevels - 1 : undefined,\n                expand: 0 ,\n            };\n            actual.tags.forEach(this.incrementTagRefs, this);\n            this.tree.set(( internal.fullId.toString()), internal);\n            this.setItemParent(actual, parent);\n            this.pushDiff({\n                op: 0 ,\n                item: {\n                    controllerId: this.options.controllerId,\n                    expand: internal.expand,\n                    item: this.options.toITestItem(actual),\n                },\n            });\n            this.connectItemAndChildren(actual, internal, parent);\n            return;\n        }\n        if (internal.actual === actual) {\n            this.connectItem(actual, internal, parent);\n            return;\n        }\n        if (internal.actual.uri?.toString() !== actual.uri?.toString()) {\n            this.removeItem(( fullId.toString()));\n            return this.upsertItem(actual, parent);\n        }\n        const oldChildren = this.options.getChildren(internal.actual);\n        const oldActual = internal.actual;\n        const update = diffTestItems(this.options.toITestItem(oldActual), this.options.toITestItem(actual));\n        this.options.getApiFor(oldActual).listener = undefined;\n        internal.actual = actual;\n        internal.resolveBarrier = undefined;\n        internal.expand = 0 ;\n        if (update) {\n            if (update.hasOwnProperty('tags')) {\n                this.diffTagRefs(actual.tags, oldActual.tags, ( fullId.toString()));\n                delete update.tags;\n            }\n            this.onTestItemEvent(internal, { op: 4 , update });\n        }\n        this.connectItemAndChildren(actual, internal, parent);\n        for (const [_, child] of oldChildren) {\n            if (!this.options.getChildren(actual).get(child.id)) {\n                this.removeItem(TestId.joinToString(fullId, child.id));\n            }\n        }\n        const expandLevels = internal.expandLevels;\n        if (expandLevels !== undefined) {\n            queueMicrotask(() => {\n                if (internal.expand === 1 ) {\n                    internal.expandLevels = undefined;\n                    this.expand(( fullId.toString()), expandLevels);\n                }\n            });\n        }\n        this.documentSynced(internal.actual.uri);\n    }\n    diffTagRefs(newTags, oldTags, extId) {\n        const toDelete = ( new Set(( oldTags.map(t => t.id))));\n        for (const tag of newTags) {\n            if (!toDelete.delete(tag.id)) {\n                this.incrementTagRefs(tag);\n            }\n        }\n        this.pushDiff({\n            op: 1 ,\n            item: { extId, item: { tags: ( newTags.map(v => namespaceTestTag(this.options.controllerId, v.id))) } }\n        });\n        toDelete.forEach(this.decrementTagRefs, this);\n    }\n    incrementTagRefs(tag) {\n        const existing = this.tags.get(tag.id);\n        if (existing) {\n            existing.refCount++;\n        }\n        else {\n            this.tags.set(tag.id, { refCount: 1 });\n            this.pushDiff({\n                op: 6 , tag: {\n                    id: namespaceTestTag(this.options.controllerId, tag.id),\n                }\n            });\n        }\n    }\n    decrementTagRefs(tagId) {\n        const existing = this.tags.get(tagId);\n        if (existing && !--existing.refCount) {\n            this.tags.delete(tagId);\n            this.pushDiff({ op: 7 , id: namespaceTestTag(this.options.controllerId, tagId) });\n        }\n    }\n    setItemParent(actual, parent) {\n        this.options.getApiFor(actual).parent = parent && parent.actual !== this.root ? parent.actual : undefined;\n    }\n    connectItem(actual, internal, parent) {\n        this.setItemParent(actual, parent);\n        const api = this.options.getApiFor(actual);\n        api.parent = parent?.actual;\n        api.listener = evt => this.onTestItemEvent(internal, evt);\n        this.updateExpandability(internal);\n    }\n    connectItemAndChildren(actual, internal, parent) {\n        this.connectItem(actual, internal, parent);\n        for (const [_, child] of this.options.getChildren(actual)) {\n            this.upsertItem(child, internal);\n        }\n    }\n    updateExpandability(internal) {\n        let newState;\n        if (!this._resolveHandler) {\n            newState = 0 ;\n        }\n        else if (internal.resolveBarrier) {\n            newState = internal.resolveBarrier.isOpen()\n                ? 3\n                : 2 ;\n        }\n        else {\n            newState = internal.actual.canResolveChildren\n                ? 1\n                : 0 ;\n        }\n        if (newState === internal.expand) {\n            return;\n        }\n        internal.expand = newState;\n        this.pushDiff({ op: 1 , item: { extId: ( internal.fullId.toString()), expand: newState } });\n        if (newState === 1  && internal.expandLevels !== undefined) {\n            this.resolveChildren(internal);\n        }\n    }\n    expandChildren(internal, levels) {\n        if (levels < 0) {\n            return;\n        }\n        const expandRequests = [];\n        for (const [_, child] of this.options.getChildren(internal.actual)) {\n            const promise = this.expand(TestId.joinToString(internal.fullId, child.id), levels);\n            if (isThenable(promise)) {\n                expandRequests.push(promise);\n            }\n        }\n        if (expandRequests.length) {\n            return Promise.all(expandRequests).then(() => { });\n        }\n    }\n    resolveChildren(internal) {\n        if (internal.resolveBarrier) {\n            return internal.resolveBarrier;\n        }\n        if (!this._resolveHandler) {\n            const b = ( new Barrier());\n            b.open();\n            return b;\n        }\n        internal.expand = 2 ;\n        this.pushExpandStateUpdate(internal);\n        const barrier = internal.resolveBarrier = ( new Barrier());\n        const applyError = (err) => {\n            console.error(`Unhandled error in resolveHandler of test controller \"${this.options.controllerId}\"`, err);\n        };\n        let r;\n        try {\n            r = this._resolveHandler(internal.actual === this.root ? undefined : internal.actual);\n        }\n        catch (err) {\n            applyError(err);\n        }\n        if (isThenable(r)) {\n            r.catch(applyError).then(() => {\n                barrier.open();\n                this.updateExpandability(internal);\n            });\n        }\n        else {\n            barrier.open();\n            this.updateExpandability(internal);\n        }\n        return internal.resolveBarrier;\n    }\n    pushExpandStateUpdate(internal) {\n        this.pushDiff({ op: 1 , item: { extId: ( internal.fullId.toString()), expand: internal.expand } });\n    }\n    removeItem(childId) {\n        const childItem = this.tree.get(childId);\n        if (!childItem) {\n            throw ( new Error('attempting to remove non-existent child'));\n        }\n        this.pushDiff({ op: 3 , itemId: childId });\n        const queue = [childItem];\n        while (queue.length) {\n            const item = queue.pop();\n            if (!item) {\n                continue;\n            }\n            this.options.getApiFor(item.actual).listener = undefined;\n            for (const tag of item.actual.tags) {\n                this.decrementTagRefs(tag.id);\n            }\n            this.tree.delete(( item.fullId.toString()));\n            for (const [_, child] of this.options.getChildren(item.actual)) {\n                queue.push(this.tree.get(TestId.joinToString(item.fullId, child.id)));\n            }\n        }\n    }\n    flushDiff() {\n        const diff = this.collectDiff();\n        if (diff.length) {\n            this.diffOpEmitter.fire(diff);\n        }\n    }\n}\nclass DuplicateTestItemError extends Error {\n    constructor(id) {\n        super(`Attempted to insert a duplicate test item ID ${id}`);\n    }\n}\nclass InvalidTestItemError extends Error {\n    constructor(id) {\n        super(`TestItem with ID \"${id}\" is invalid. Make sure to create it from the createTestItem method.`);\n    }\n}\nclass MixedTestItemController extends Error {\n    constructor(id, ctrlA, ctrlB) {\n        super(`TestItem with ID \"${id}\" is from controller \"${ctrlA}\" and cannot be added as a child of an item from controller \"${ctrlB}\".`);\n    }\n}\nconst createTestItemChildren = (api, getApi, checkCtor) => {\n    let mapped = ( new Map());\n    return {\n        get size() {\n            return mapped.size;\n        },\n        forEach(callback, thisArg) {\n            for (const item of ( mapped.values())) {\n                callback.call(thisArg, item, this);\n            }\n        },\n        [Symbol.iterator]() {\n            return mapped.entries();\n        },\n        replace(items) {\n            const newMapped = ( new Map());\n            const toDelete = ( new Set(( mapped.keys())));\n            const bulk = { op: 5 , ops: [] };\n            for (const item of items) {\n                if (!(item instanceof checkCtor)) {\n                    throw ( new InvalidTestItemError(item.id));\n                }\n                const itemController = getApi(item).controllerId;\n                if (itemController !== api.controllerId) {\n                    throw ( new MixedTestItemController(item.id, itemController, api.controllerId));\n                }\n                if (( newMapped.has(item.id))) {\n                    throw ( new DuplicateTestItemError(item.id));\n                }\n                newMapped.set(item.id, item);\n                toDelete.delete(item.id);\n                bulk.ops.push({ op: 0 , item });\n            }\n            for (const id of ( toDelete.keys())) {\n                bulk.ops.push({ op: 3 , id });\n            }\n            api.listener?.(bulk);\n            mapped = newMapped;\n        },\n        add(item) {\n            if (!(item instanceof checkCtor)) {\n                throw ( new InvalidTestItemError(item.id));\n            }\n            mapped.set(item.id, item);\n            api.listener?.({ op: 0 , item });\n        },\n        delete(id) {\n            if (mapped.delete(id)) {\n                api.listener?.({ op: 3 , id });\n            }\n        },\n        get(itemId) {\n            return mapped.get(itemId);\n        },\n        toJSON() {\n            return Array.from(( mapped.values()));\n        },\n    };\n};\nexport { DuplicateTestItemError, InvalidTestItemError, MixedTestItemController, TestItemCollection, createTestItemChildren };\n","import { URI } from '../../../../base/common/uri.js';\nimport { Position } from '../../../../editor/common/core/position.js';\nimport { Range } from '../../../../editor/common/core/range.js';\nimport { TestId } from './testId.js';\nconst testResultStateToContextValues = {\n    [0 ]: 'unset',\n    [1 ]: 'queued',\n    [2 ]: 'running',\n    [3 ]: 'passed',\n    [4 ]: 'failed',\n    [5 ]: 'skipped',\n    [6 ]: 'errored',\n};\nconst testRunProfileBitsetList = [\n    2 ,\n    4 ,\n    8 ,\n    16 ,\n    32 ,\n    64 ,\n];\nconst isStartControllerTests = (t) => 'runId' in t;\nvar IRichLocation;\n( (function(IRichLocation) {\n    IRichLocation.serialize = (location) => ({\n        range: location.range.toJSON(),\n        uri: location.uri.toJSON(),\n    });\n    IRichLocation.deserialize = (uriIdentity, location) => ({\n        range: Range.lift(location.range),\n        uri: uriIdentity.asCanonicalUri(URI.revive(location.uri)),\n    });\n})(IRichLocation || (IRichLocation = {})));\nvar ITestMessageStackFrame;\n( (function(ITestMessageStackFrame) {\n    ITestMessageStackFrame.serialize = (stack) => ({\n        label: stack.label,\n        uri: stack.uri?.toJSON(),\n        position: stack.position?.toJSON(),\n    });\n    ITestMessageStackFrame.deserialize = (uriIdentity, stack) => ({\n        label: stack.label,\n        uri: stack.uri ? uriIdentity.asCanonicalUri(URI.revive(stack.uri)) : undefined,\n        position: stack.position ? Position.lift(stack.position) : undefined,\n    });\n})(ITestMessageStackFrame || (ITestMessageStackFrame = {})));\nvar ITestErrorMessage;\n( (function(ITestErrorMessage) {\n    ITestErrorMessage.serialize = (message) => ({\n        message: message.message,\n        type: 0 ,\n        expected: message.expected,\n        actual: message.actual,\n        contextValue: message.contextValue,\n        location: message.location && IRichLocation.serialize(message.location),\n        stackTrace: message.stackTrace?.map(ITestMessageStackFrame.serialize),\n    });\n    ITestErrorMessage.deserialize = (uriIdentity, message) => ({\n        message: message.message,\n        type: 0 ,\n        expected: message.expected,\n        actual: message.actual,\n        contextValue: message.contextValue,\n        location: message.location && IRichLocation.deserialize(uriIdentity, message.location),\n        stackTrace: message.stackTrace && ( message.stackTrace.map(s => ITestMessageStackFrame.deserialize(uriIdentity, s))),\n    });\n})(ITestErrorMessage || (ITestErrorMessage = {})));\nconst getMarkId = (marker, start) => `${start ? 's' : 'e'}${marker}`;\nvar ITestOutputMessage;\n( (function(ITestOutputMessage) {\n    ITestOutputMessage.serialize = (message) => ({\n        message: message.message,\n        type: 1 ,\n        offset: message.offset,\n        length: message.length,\n        location: message.location && IRichLocation.serialize(message.location),\n    });\n    ITestOutputMessage.deserialize = (uriIdentity, message) => ({\n        message: message.message,\n        type: 1 ,\n        offset: message.offset,\n        length: message.length,\n        location: message.location && IRichLocation.deserialize(uriIdentity, message.location),\n    });\n})(ITestOutputMessage || (ITestOutputMessage = {})));\nvar ITestMessage;\n( (function(ITestMessage) {\n    ITestMessage.serialize = (message) => message.type === 0  ? ITestErrorMessage.serialize(message) : ITestOutputMessage.serialize(message);\n    ITestMessage.deserialize = (uriIdentity, message) => message.type === 0  ? ITestErrorMessage.deserialize(uriIdentity, message) : ITestOutputMessage.deserialize(uriIdentity, message);\n    ITestMessage.isDiffable = (message) => message.type === 0  && message.actual !== undefined && message.expected !== undefined;\n})(ITestMessage || (ITestMessage = {})));\nvar ITestTaskState;\n( (function(ITestTaskState) {\n    ITestTaskState.serializeWithoutMessages = (state) => ({\n        state: state.state,\n        duration: state.duration,\n        messages: [],\n    });\n    ITestTaskState.serialize = (state) => ({\n        state: state.state,\n        duration: state.duration,\n        messages: ( state.messages.map(ITestMessage.serialize)),\n    });\n    ITestTaskState.deserialize = (uriIdentity, state) => ({\n        state: state.state,\n        duration: state.duration,\n        messages: ( state.messages.map(m => ITestMessage.deserialize(uriIdentity, m))),\n    });\n})(ITestTaskState || (ITestTaskState = {})));\nconst testTagDelimiter = '\\0';\nconst namespaceTestTag = (ctrlId, tagId) => ctrlId + testTagDelimiter + tagId;\nconst denamespaceTestTag = (namespaced) => {\n    const index = namespaced.indexOf(testTagDelimiter);\n    return { ctrlId: namespaced.slice(0, index), tagId: namespaced.slice(index + 1) };\n};\nvar ITestItem;\n( (function(ITestItem) {\n    ITestItem.serialize = (item) => ({\n        extId: item.extId,\n        label: item.label,\n        tags: item.tags,\n        busy: item.busy,\n        children: undefined,\n        uri: item.uri?.toJSON(),\n        range: item.range?.toJSON() || null,\n        description: item.description,\n        error: item.error,\n        sortText: item.sortText\n    });\n    ITestItem.deserialize = (uriIdentity, serialized) => ({\n        extId: serialized.extId,\n        label: serialized.label,\n        tags: serialized.tags,\n        busy: serialized.busy,\n        children: undefined,\n        uri: serialized.uri ? uriIdentity.asCanonicalUri(URI.revive(serialized.uri)) : undefined,\n        range: serialized.range ? Range.lift(serialized.range) : null,\n        description: serialized.description,\n        error: serialized.error,\n        sortText: serialized.sortText\n    });\n})(ITestItem || (ITestItem = {})));\nvar InternalTestItem;\n( (function(InternalTestItem) {\n    InternalTestItem.serialize = (item) => ({\n        expand: item.expand,\n        item: ITestItem.serialize(item.item)\n    });\n    InternalTestItem.deserialize = (uriIdentity, serialized) => ({\n        controllerId: TestId.root(serialized.item.extId),\n        expand: serialized.expand,\n        item: ITestItem.deserialize(uriIdentity, serialized.item)\n    });\n})(InternalTestItem || (InternalTestItem = {})));\nvar ITestItemUpdate;\n( (function(ITestItemUpdate) {\n    ITestItemUpdate.serialize = (u) => {\n        let item;\n        if (u.item) {\n            item = {};\n            if (u.item.label !== undefined) {\n                item.label = u.item.label;\n            }\n            if (u.item.tags !== undefined) {\n                item.tags = u.item.tags;\n            }\n            if (u.item.busy !== undefined) {\n                item.busy = u.item.busy;\n            }\n            if (u.item.uri !== undefined) {\n                item.uri = u.item.uri?.toJSON();\n            }\n            if (u.item.range !== undefined) {\n                item.range = u.item.range?.toJSON();\n            }\n            if (u.item.description !== undefined) {\n                item.description = u.item.description;\n            }\n            if (u.item.error !== undefined) {\n                item.error = u.item.error;\n            }\n            if (u.item.sortText !== undefined) {\n                item.sortText = u.item.sortText;\n            }\n        }\n        return { extId: u.extId, expand: u.expand, item };\n    };\n    ITestItemUpdate.deserialize = (u) => {\n        let item;\n        if (u.item) {\n            item = {};\n            if (u.item.label !== undefined) {\n                item.label = u.item.label;\n            }\n            if (u.item.tags !== undefined) {\n                item.tags = u.item.tags;\n            }\n            if (u.item.busy !== undefined) {\n                item.busy = u.item.busy;\n            }\n            if (u.item.range !== undefined) {\n                item.range = u.item.range ? Range.lift(u.item.range) : null;\n            }\n            if (u.item.description !== undefined) {\n                item.description = u.item.description;\n            }\n            if (u.item.error !== undefined) {\n                item.error = u.item.error;\n            }\n            if (u.item.sortText !== undefined) {\n                item.sortText = u.item.sortText;\n            }\n        }\n        return { extId: u.extId, expand: u.expand, item };\n    };\n})(ITestItemUpdate || (ITestItemUpdate = {})));\nconst applyTestItemUpdate = (internal, patch) => {\n    if (patch.expand !== undefined) {\n        internal.expand = patch.expand;\n    }\n    if (patch.item !== undefined) {\n        internal.item = internal.item ? Object.assign(internal.item, patch.item) : patch.item;\n    }\n};\nvar TestResultItem;\n( (function(TestResultItem) {\n    TestResultItem.serializeWithoutMessages = (original) => ({\n        ...InternalTestItem.serialize(original),\n        ownComputedState: original.ownComputedState,\n        computedState: original.computedState,\n        tasks: ( original.tasks.map(ITestTaskState.serializeWithoutMessages)),\n    });\n    TestResultItem.serialize = (original) => ({\n        ...InternalTestItem.serialize(original),\n        ownComputedState: original.ownComputedState,\n        computedState: original.computedState,\n        tasks: ( original.tasks.map(ITestTaskState.serialize)),\n    });\n    TestResultItem.deserialize = (uriIdentity, serialized) => ({\n        ...InternalTestItem.deserialize(uriIdentity, serialized),\n        ownComputedState: serialized.ownComputedState,\n        computedState: serialized.computedState,\n        tasks: ( serialized.tasks.map(m => ITestTaskState.deserialize(uriIdentity, m))),\n        retired: true,\n    });\n})(TestResultItem || (TestResultItem = {})));\nvar ICoverageCount;\n( (function(ICoverageCount) {\n    ICoverageCount.empty = () => ({ covered: 0, total: 0 });\n    ICoverageCount.sum = (target, src) => {\n        target.covered += src.covered;\n        target.total += src.total;\n    };\n})(ICoverageCount || (ICoverageCount = {})));\nvar IFileCoverage;\n( (function(IFileCoverage) {\n    IFileCoverage.serialize = (original) => ({\n        id: original.id,\n        statement: original.statement,\n        branch: original.branch,\n        declaration: original.declaration,\n        testIds: original.testIds,\n        uri: original.uri.toJSON(),\n    });\n    IFileCoverage.deserialize = (uriIdentity, serialized) => ({\n        id: serialized.id,\n        statement: serialized.statement,\n        branch: serialized.branch,\n        declaration: serialized.declaration,\n        testIds: serialized.testIds,\n        uri: uriIdentity.asCanonicalUri(URI.revive(serialized.uri)),\n    });\n    IFileCoverage.empty = (id, uri) => ({\n        id,\n        uri,\n        statement: ICoverageCount.empty(),\n    });\n})(IFileCoverage || (IFileCoverage = {})));\nfunction serializeThingWithLocation(serialized) {\n    return {\n        ...serialized,\n        location: serialized.location?.toJSON(),\n    };\n}\nfunction deserializeThingWithLocation(serialized) {\n    serialized.location = serialized.location ? (Position.isIPosition(serialized.location) ? Position.lift(serialized.location) : Range.lift(serialized.location)) : undefined;\n    return serialized;\n}\nvar CoverageDetails;\n( (function(CoverageDetails) {\n    CoverageDetails.serialize = (original) => original.type === 0  ? IDeclarationCoverage.serialize(original) : IStatementCoverage.serialize(original);\n    CoverageDetails.deserialize = (serialized) => serialized.type === 0  ? IDeclarationCoverage.deserialize(serialized) : IStatementCoverage.deserialize(serialized);\n})(CoverageDetails || (CoverageDetails = {})));\nvar IBranchCoverage;\n( (function(IBranchCoverage) {\n    IBranchCoverage.serialize = serializeThingWithLocation;\n    IBranchCoverage.deserialize = deserializeThingWithLocation;\n})(IBranchCoverage || (IBranchCoverage = {})));\nvar IDeclarationCoverage;\n( (function(IDeclarationCoverage) {\n    IDeclarationCoverage.serialize = serializeThingWithLocation;\n    IDeclarationCoverage.deserialize = deserializeThingWithLocation;\n})(IDeclarationCoverage || (IDeclarationCoverage = {})));\nvar IStatementCoverage;\n( (function(IStatementCoverage) {\n    IStatementCoverage.serialize = (original) => ({\n        ...serializeThingWithLocation(original),\n        branches: original.branches?.map(IBranchCoverage.serialize),\n    });\n    IStatementCoverage.deserialize = (serialized) => ({\n        ...deserializeThingWithLocation(serialized),\n        branches: serialized.branches?.map(IBranchCoverage.deserialize),\n    });\n})(IStatementCoverage || (IStatementCoverage = {})));\nvar TestsDiffOp;\n( (function(TestsDiffOp) {\n    TestsDiffOp.deserialize = (uriIdentity, u) => {\n        if (u.op === 0 ) {\n            return { op: u.op, item: InternalTestItem.deserialize(uriIdentity, u.item) };\n        }\n        else if (u.op === 1 ) {\n            return { op: u.op, item: ITestItemUpdate.deserialize(u.item) };\n        }\n        else if (u.op === 2 ) {\n            return { op: u.op, uri: uriIdentity.asCanonicalUri(URI.revive(u.uri)), docv: u.docv };\n        }\n        else {\n            return u;\n        }\n    };\n    TestsDiffOp.serialize = (u) => {\n        if (u.op === 0 ) {\n            return { op: u.op, item: InternalTestItem.serialize(u.item) };\n        }\n        else if (u.op === 1 ) {\n            return { op: u.op, item: ITestItemUpdate.serialize(u.item) };\n        }\n        else {\n            return u;\n        }\n    };\n})(TestsDiffOp || (TestsDiffOp = {})));\nclass AbstractIncrementalTestCollection {\n    constructor(uriIdentity) {\n        this.uriIdentity = uriIdentity;\n        this._tags = ( new Map());\n        this.items = ( new Map());\n        this.roots = ( new Set());\n        this.busyControllerCount = 0;\n        this.pendingRootCount = 0;\n        this.tags = this._tags;\n    }\n    apply(diff) {\n        const changes = this.createChangeCollector();\n        for (const op of diff) {\n            switch (op.op) {\n                case 0 :\n                    this.add(InternalTestItem.deserialize(this.uriIdentity, op.item), changes);\n                    break;\n                case 1 :\n                    this.update(ITestItemUpdate.deserialize(op.item), changes);\n                    break;\n                case 3 :\n                    this.remove(op.itemId, changes);\n                    break;\n                case 5 :\n                    this.retireTest(op.itemId);\n                    break;\n                case 4 :\n                    this.updatePendingRoots(op.amount);\n                    break;\n                case 6 :\n                    this._tags.set(op.tag.id, op.tag);\n                    break;\n                case 7 :\n                    this._tags.delete(op.id);\n                    break;\n            }\n        }\n        changes.complete?.();\n    }\n    add(item, changes) {\n        const parentId = TestId.parentId(item.item.extId)?.toString();\n        let created;\n        if (!parentId) {\n            created = this.createItem(item);\n            this.roots.add(created);\n            this.items.set(item.item.extId, created);\n        }\n        else if (( this.items.has(parentId))) {\n            const parent = this.items.get(parentId);\n            parent.children.add(item.item.extId);\n            created = this.createItem(item, parent);\n            this.items.set(item.item.extId, created);\n        }\n        else {\n            console.error(`Test with unknown parent ID: ${JSON.stringify(item)}`);\n            return;\n        }\n        changes.add?.(created);\n        if (item.expand === 2 ) {\n            this.busyControllerCount++;\n        }\n        return created;\n    }\n    update(patch, changes) {\n        const existing = this.items.get(patch.extId);\n        if (!existing) {\n            return;\n        }\n        if (patch.expand !== undefined) {\n            if (existing.expand === 2 ) {\n                this.busyControllerCount--;\n            }\n            if (patch.expand === 2 ) {\n                this.busyControllerCount++;\n            }\n        }\n        applyTestItemUpdate(existing, patch);\n        changes.update?.(existing);\n        return existing;\n    }\n    remove(itemId, changes) {\n        const toRemove = this.items.get(itemId);\n        if (!toRemove) {\n            return;\n        }\n        const parentId = TestId.parentId(toRemove.item.extId)?.toString();\n        if (parentId) {\n            const parent = this.items.get(parentId);\n            parent.children.delete(toRemove.item.extId);\n        }\n        else {\n            this.roots.delete(toRemove);\n        }\n        const queue = [[itemId]];\n        while (queue.length) {\n            for (const itemId of queue.pop()) {\n                const existing = this.items.get(itemId);\n                if (existing) {\n                    queue.push(existing.children);\n                    this.items.delete(itemId);\n                    changes.remove?.(existing, existing !== toRemove);\n                    if (existing.expand === 2 ) {\n                        this.busyControllerCount--;\n                    }\n                }\n            }\n        }\n    }\n    retireTest(testId) {\n    }\n    updatePendingRoots(delta) {\n        this.pendingRootCount += delta;\n    }\n    createChangeCollector() {\n        return {};\n    }\n}\nexport { AbstractIncrementalTestCollection, CoverageDetails, IBranchCoverage, ICoverageCount, IDeclarationCoverage, IFileCoverage, IRichLocation, IStatementCoverage, ITestErrorMessage, ITestItem, ITestItemUpdate, ITestMessage, ITestMessageStackFrame, ITestOutputMessage, ITestTaskState, InternalTestItem, TestResultItem, TestsDiffOp, applyTestItemUpdate, denamespaceTestTag, getMarkId, isStartControllerTests, namespaceTestTag, testResultStateToContextValues, testRunProfileBitsetList };\n","import { Schemas } from '../../../../base/common/network.js';\nimport { URI } from '../../../../base/common/uri.js';\nconst webviewResourceBaseHost = 'vscode-cdn.net';\nconst webviewRootResourceAuthority = `vscode-resource.${webviewResourceBaseHost}`;\nconst webviewGenericCspSource = `'self' https://*.${webviewResourceBaseHost}`;\nfunction asWebviewUri(resource, remoteInfo) {\n    if (resource.scheme === Schemas.http || resource.scheme === Schemas.https) {\n        return resource;\n    }\n    if (remoteInfo && remoteInfo.authority && remoteInfo.isRemote && resource.scheme === Schemas.file) {\n        resource = ( URI.from({\n            scheme: Schemas.vscodeRemote,\n            authority: remoteInfo.authority,\n            path: resource.path,\n        }));\n    }\n    return ( URI.from({\n        scheme: Schemas.https,\n        authority: `${resource.scheme}+${encodeAuthority(resource.authority)}.${webviewRootResourceAuthority}`,\n        path: resource.path,\n        fragment: resource.fragment,\n        query: resource.query,\n    }));\n}\nfunction encodeAuthority(authority) {\n    return authority.replace(/./g, char => {\n        const code = char.charCodeAt(0);\n        if (((code >= 97  && code <= 122) )\n            || ((code >= 65  && code <= 90) )\n            || ((code >= 48  && code <= 57) )) {\n            return char;\n        }\n        return '-' + ( code.toString(16)).padStart(4, '0');\n    });\n}\nfunction decodeAuthority(authority) {\n    return authority.replace(/-([0-9a-f]{4})/g, (_, code) => String.fromCharCode(parseInt(code, 16)));\n}\nexport { asWebviewUri, decodeAuthority, webviewGenericCspSource, webviewResourceBaseHost, webviewRootResourceAuthority };\n","const INTERNAL_AUTH_PROVIDER_PREFIX = '__';\nexport { INTERNAL_AUTH_PROVIDER_PREFIX };\n","import { ErrorNoTelemetry } from '../../../../base/common/errors.js';\nvar VariableKind;\n( (function(VariableKind) {\n    VariableKind[\"Unknown\"] = \"unknown\";\n    VariableKind[\"Env\"] = \"env\";\n    VariableKind[\"Config\"] = \"config\";\n    VariableKind[\"Command\"] = \"command\";\n    VariableKind[\"Input\"] = \"input\";\n    VariableKind[\"ExtensionInstallFolder\"] = \"extensionInstallFolder\";\n    VariableKind[\"WorkspaceFolder\"] = \"workspaceFolder\";\n    VariableKind[\"Cwd\"] = \"cwd\";\n    VariableKind[\"WorkspaceFolderBasename\"] = \"workspaceFolderBasename\";\n    VariableKind[\"UserHome\"] = \"userHome\";\n    VariableKind[\"LineNumber\"] = \"lineNumber\";\n    VariableKind[\"SelectedText\"] = \"selectedText\";\n    VariableKind[\"File\"] = \"file\";\n    VariableKind[\"FileWorkspaceFolder\"] = \"fileWorkspaceFolder\";\n    VariableKind[\"FileWorkspaceFolderBasename\"] = \"fileWorkspaceFolderBasename\";\n    VariableKind[\"RelativeFile\"] = \"relativeFile\";\n    VariableKind[\"RelativeFileDirname\"] = \"relativeFileDirname\";\n    VariableKind[\"FileDirname\"] = \"fileDirname\";\n    VariableKind[\"FileExtname\"] = \"fileExtname\";\n    VariableKind[\"FileBasename\"] = \"fileBasename\";\n    VariableKind[\"FileBasenameNoExtension\"] = \"fileBasenameNoExtension\";\n    VariableKind[\"FileDirnameBasename\"] = \"fileDirnameBasename\";\n    VariableKind[\"ExecPath\"] = \"execPath\";\n    VariableKind[\"ExecInstallFolder\"] = \"execInstallFolder\";\n    VariableKind[\"PathSeparator\"] = \"pathSeparator\";\n    VariableKind[\"PathSeparatorAlias\"] = \"/\";\n})(VariableKind || (VariableKind = {})));\nclass VariableError extends ErrorNoTelemetry {\n    constructor(variable, message) {\n        super(message);\n        this.variable = variable;\n    }\n}\nexport { VariableError, VariableKind };\n","import { sep, basename, dirname, extname, relative } from '../../../../base/common/path.js';\nimport { cwd } from '../../../../base/common/process.js';\nimport { isString, isObject, isUndefinedOrNull } from '../../../../base/common/types.js';\nimport { deepClone } from '../../../../base/common/objects.js';\nimport { isWindows, isMacintosh, isLinux } from '../../../../base/common/platform.js';\nimport { normalizeDriveLetter } from '../../../../base/common/labels.js';\nimport { localize } from '../../../../nls.js';\nimport { VariableKind, VariableError } from './configurationResolver.js';\nimport { replaceAsync } from '../../../../base/common/strings.js';\nclass AbstractVariableResolverService {\n    static { this.VARIABLE_LHS = '${'; }\n    static { this.VARIABLE_REGEXP = /\\$\\{(.*?)\\}/g; }\n    constructor(_context, _labelService, _userHomePromise, _envVariablesPromise) {\n        this._contributedVariables = ( new Map());\n        this._context = _context;\n        this._labelService = _labelService;\n        this._userHomePromise = _userHomePromise;\n        if (_envVariablesPromise) {\n            this._envVariablesPromise = _envVariablesPromise.then(envVariables => {\n                return this.prepareEnv(envVariables);\n            });\n        }\n    }\n    prepareEnv(envVariables) {\n        if (isWindows) {\n            const ev = Object.create(null);\n            ( Object.keys(envVariables)).forEach(key => {\n                ev[key.toLowerCase()] = envVariables[key];\n            });\n            return ev;\n        }\n        return envVariables;\n    }\n    resolveWithEnvironment(environment, root, value) {\n        return this.recursiveResolve({ env: this.prepareEnv(environment), userHome: undefined }, root ? root.uri : undefined, value);\n    }\n    async resolveAsync(root, value) {\n        const environment = {\n            env: await this._envVariablesPromise,\n            userHome: await this._userHomePromise\n        };\n        return this.recursiveResolve(environment, root ? root.uri : undefined, value);\n    }\n    async resolveAnyBase(workspaceFolder, config, commandValueMapping, resolvedVariables) {\n        const result = deepClone(config);\n        if (isWindows && result.windows) {\n            ( Object.keys(result.windows)).forEach(key => result[key] = result.windows[key]);\n        }\n        else if (isMacintosh && result.osx) {\n            ( Object.keys(result.osx)).forEach(key => result[key] = result.osx[key]);\n        }\n        else if (isLinux && result.linux) {\n            ( Object.keys(result.linux)).forEach(key => result[key] = result.linux[key]);\n        }\n        delete result.windows;\n        delete result.osx;\n        delete result.linux;\n        const environmentPromises = {\n            env: await this._envVariablesPromise,\n            userHome: await this._userHomePromise\n        };\n        return this.recursiveResolve(environmentPromises, workspaceFolder ? workspaceFolder.uri : undefined, result, commandValueMapping, resolvedVariables);\n    }\n    async resolveAnyAsync(workspaceFolder, config, commandValueMapping) {\n        return this.resolveAnyBase(workspaceFolder, config, commandValueMapping);\n    }\n    async resolveAnyMap(workspaceFolder, config, commandValueMapping) {\n        const resolvedVariables = ( new Map());\n        const newConfig = await this.resolveAnyBase(workspaceFolder, config, commandValueMapping, resolvedVariables);\n        return { newConfig, resolvedVariables };\n    }\n    resolveWithInteractionReplace(folder, config, section, variables) {\n        throw ( new Error('resolveWithInteractionReplace not implemented.'));\n    }\n    resolveWithInteraction(folder, config, section, variables) {\n        throw ( new Error('resolveWithInteraction not implemented.'));\n    }\n    contributeVariable(variable, resolution) {\n        if (( this._contributedVariables.has(variable))) {\n            throw ( new Error('Variable ' + variable + ' is contributed twice.'));\n        }\n        else {\n            this._contributedVariables.set(variable, resolution);\n        }\n    }\n    async recursiveResolve(environment, folderUri, value, commandValueMapping, resolvedVariables) {\n        if (isString(value)) {\n            return this.resolveString(environment, folderUri, value, commandValueMapping, resolvedVariables);\n        }\n        else if (Array.isArray(value)) {\n            return Promise.all(( value.map(\n                s => this.recursiveResolve(environment, folderUri, s, commandValueMapping, resolvedVariables)\n            )));\n        }\n        else if (isObject(value)) {\n            const result = Object.create(null);\n            const replaced = await Promise.all(( ( Object.keys(value)).map(async (key) => {\n                const replaced = await this.resolveString(environment, folderUri, key, commandValueMapping, resolvedVariables);\n                return [replaced, await this.recursiveResolve(environment, folderUri, value[key], commandValueMapping, resolvedVariables)];\n            })));\n            for (const [key, value] of replaced) {\n                result[key] = value;\n            }\n            return result;\n        }\n        return value;\n    }\n    resolveString(environment, folderUri, value, commandValueMapping, resolvedVariables) {\n        return replaceAsync(value, AbstractVariableResolverService.VARIABLE_REGEXP, async (match, variable) => {\n            if (variable.includes(AbstractVariableResolverService.VARIABLE_LHS)) {\n                return match;\n            }\n            let resolvedValue = await this.evaluateSingleVariable(environment, match, variable, folderUri, commandValueMapping);\n            resolvedVariables?.set(variable, resolvedValue);\n            if ((resolvedValue !== match) && isString(resolvedValue) && resolvedValue.match(AbstractVariableResolverService.VARIABLE_REGEXP)) {\n                resolvedValue = await this.resolveString(environment, folderUri, resolvedValue, commandValueMapping, resolvedVariables);\n            }\n            return resolvedValue;\n        });\n    }\n    fsPath(displayUri) {\n        return this._labelService ? this._labelService.getUriLabel(displayUri, { noPrefix: true }) : displayUri.fsPath;\n    }\n    async evaluateSingleVariable(environment, match, variable, folderUri, commandValueMapping) {\n        let argument;\n        const parts = variable.split(':');\n        if (parts.length > 1) {\n            variable = parts[0];\n            argument = parts[1];\n        }\n        const getFilePath = (variableKind) => {\n            const filePath = this._context.getFilePath();\n            if (filePath) {\n                return normalizeDriveLetter(filePath);\n            }\n            throw ( new VariableError(\n                variableKind,\n                localize(4134, \"Variable {0} can not be resolved. Please open an editor.\", match)\n            ));\n        };\n        const getFolderPathForFile = (variableKind) => {\n            const filePath = getFilePath(variableKind);\n            if (this._context.getWorkspaceFolderPathForFile) {\n                const folderPath = this._context.getWorkspaceFolderPathForFile();\n                if (folderPath) {\n                    return normalizeDriveLetter(folderPath);\n                }\n            }\n            throw ( new VariableError(variableKind, localize(\n                4135,\n                \"Variable {0}: can not find workspace folder of '{1}'.\",\n                match,\n                basename(filePath)\n            )));\n        };\n        const getFolderUri = (variableKind) => {\n            if (argument) {\n                const folder = this._context.getFolderUri(argument);\n                if (folder) {\n                    return folder;\n                }\n                throw ( new VariableError(variableKind, localize(\n                    4136,\n                    \"Variable {0} can not be resolved. No such folder '{1}'.\",\n                    match,\n                    argument\n                )));\n            }\n            if (folderUri) {\n                return folderUri;\n            }\n            if (this._context.getWorkspaceFolderCount() > 1) {\n                throw ( new VariableError(variableKind, localize(\n                    4137,\n                    \"Variable {0} can not be resolved in a multi folder workspace. Scope this variable using ':' and a workspace folder name.\",\n                    match\n                )));\n            }\n            throw ( new VariableError(\n                variableKind,\n                localize(4138, \"Variable {0} can not be resolved. Please open a folder.\", match)\n            ));\n        };\n        switch (variable) {\n            case 'env':\n                if (argument) {\n                    if (environment.env) {\n                        const env = environment.env[isWindows ? argument.toLowerCase() : argument];\n                        if (isString(env)) {\n                            return env;\n                        }\n                    }\n                    return '';\n                }\n                throw ( new VariableError(VariableKind.Env, localize(\n                    4139,\n                    \"Variable {0} can not be resolved because no environment variable name is given.\",\n                    match\n                )));\n            case 'config':\n                if (argument) {\n                    const config = this._context.getConfigurationValue(folderUri, argument);\n                    if (isUndefinedOrNull(config)) {\n                        throw ( new VariableError(VariableKind.Config, localize(\n                            4140,\n                            \"Variable {0} can not be resolved because setting '{1}' not found.\",\n                            match,\n                            argument\n                        )));\n                    }\n                    if (isObject(config)) {\n                        throw ( new VariableError(VariableKind.Config, localize(\n                            4141,\n                            \"Variable {0} can not be resolved because '{1}' is a structured value.\",\n                            match,\n                            argument\n                        )));\n                    }\n                    return config;\n                }\n                throw ( new VariableError(VariableKind.Config, localize(\n                    4142,\n                    \"Variable {0} can not be resolved because no settings name is given.\",\n                    match\n                )));\n            case 'command':\n                return this.resolveFromMap(VariableKind.Command, match, argument, commandValueMapping, 'command');\n            case 'input':\n                return this.resolveFromMap(VariableKind.Input, match, argument, commandValueMapping, 'input');\n            case 'extensionInstallFolder':\n                if (argument) {\n                    const ext = await this._context.getExtension(argument);\n                    if (!ext) {\n                        throw ( new VariableError(VariableKind.ExtensionInstallFolder, localize(\n                            4143,\n                            \"Variable {0} can not be resolved because the extension {1} is not installed.\",\n                            match,\n                            argument\n                        )));\n                    }\n                    return this.fsPath(ext.extensionLocation);\n                }\n                throw ( new VariableError(VariableKind.ExtensionInstallFolder, localize(\n                    4144,\n                    \"Variable {0} can not be resolved because no extension name is given.\",\n                    match\n                )));\n            default: {\n                switch (variable) {\n                    case 'workspaceRoot':\n                    case 'workspaceFolder':\n                        return normalizeDriveLetter(this.fsPath(getFolderUri(VariableKind.WorkspaceFolder)));\n                    case 'cwd':\n                        return ((folderUri || argument) ? normalizeDriveLetter(this.fsPath(getFolderUri(VariableKind.Cwd))) : cwd());\n                    case 'workspaceRootFolderName':\n                    case 'workspaceFolderBasename':\n                        return normalizeDriveLetter(basename(this.fsPath(getFolderUri(VariableKind.WorkspaceFolderBasename))));\n                    case 'userHome': {\n                        if (environment.userHome) {\n                            return environment.userHome;\n                        }\n                        throw ( new VariableError(VariableKind.UserHome, localize(\n                            4145,\n                            \"Variable {0} can not be resolved. UserHome path is not defined\",\n                            match\n                        )));\n                    }\n                    case 'lineNumber': {\n                        const lineNumber = this._context.getLineNumber();\n                        if (lineNumber) {\n                            return lineNumber;\n                        }\n                        throw ( new VariableError(VariableKind.LineNumber, localize(\n                            4146,\n                            \"Variable {0} can not be resolved. Make sure to have a line selected in the active editor.\",\n                            match\n                        )));\n                    }\n                    case 'selectedText': {\n                        const selectedText = this._context.getSelectedText();\n                        if (selectedText) {\n                            return selectedText;\n                        }\n                        throw ( new VariableError(VariableKind.SelectedText, localize(\n                            4147,\n                            \"Variable {0} can not be resolved. Make sure to have some text selected in the active editor.\",\n                            match\n                        )));\n                    }\n                    case 'file':\n                        return getFilePath(VariableKind.File);\n                    case 'fileWorkspaceFolder':\n                        return getFolderPathForFile(VariableKind.FileWorkspaceFolder);\n                    case 'fileWorkspaceFolderBasename':\n                        return basename(getFolderPathForFile(VariableKind.FileWorkspaceFolderBasename));\n                    case 'relativeFile':\n                        if (folderUri || argument) {\n                            return relative(this.fsPath(getFolderUri(VariableKind.RelativeFile)), getFilePath(VariableKind.RelativeFile));\n                        }\n                        return getFilePath(VariableKind.RelativeFile);\n                    case 'relativeFileDirname': {\n                        const dirname$1 = dirname(getFilePath(VariableKind.RelativeFileDirname));\n                        if (folderUri || argument) {\n                            const relative$1 = relative(this.fsPath(getFolderUri(VariableKind.RelativeFileDirname)), dirname$1);\n                            return relative$1.length === 0 ? '.' : relative$1;\n                        }\n                        return dirname$1;\n                    }\n                    case 'fileDirname':\n                        return dirname(getFilePath(VariableKind.FileDirname));\n                    case 'fileExtname':\n                        return extname(getFilePath(VariableKind.FileExtname));\n                    case 'fileBasename':\n                        return basename(getFilePath(VariableKind.FileBasename));\n                    case 'fileBasenameNoExtension': {\n                        const basename$1 = basename(getFilePath(VariableKind.FileBasenameNoExtension));\n                        return (basename$1.slice(0, basename$1.length - extname(basename$1).length));\n                    }\n                    case 'fileDirnameBasename':\n                        return basename(dirname(getFilePath(VariableKind.FileDirnameBasename)));\n                    case 'execPath': {\n                        const ep = this._context.getExecPath();\n                        if (ep) {\n                            return ep;\n                        }\n                        return match;\n                    }\n                    case 'execInstallFolder': {\n                        const ar = this._context.getAppRoot();\n                        if (ar) {\n                            return ar;\n                        }\n                        return match;\n                    }\n                    case 'pathSeparator':\n                    case '/':\n                        return sep;\n                    default:\n                        try {\n                            const key = argument ? `${variable}:${argument}` : variable;\n                            return this.resolveFromMap(VariableKind.Unknown, match, key, commandValueMapping, undefined);\n                        }\n                        catch (error) {\n                            return match;\n                        }\n                }\n            }\n        }\n    }\n    resolveFromMap(variableKind, match, argument, commandValueMapping, prefix) {\n        if (argument && commandValueMapping) {\n            const v = (prefix === undefined) ? commandValueMapping[argument] : commandValueMapping[prefix + ':' + argument];\n            if (typeof v === 'string') {\n                return v;\n            }\n            throw ( new VariableError(variableKind, localize(\n                4148,\n                \"Variable {0} can not be resolved because the command has no value.\",\n                match\n            )));\n        }\n        return match;\n    }\n}\nexport { AbstractVariableResolverService };\n","import { isEditorInput } from '../../../common/editor.js';\nvar GroupDirection;\n( (function(GroupDirection) {\n    GroupDirection[GroupDirection[\"UP\"] = 0] = \"UP\";\n    GroupDirection[GroupDirection[\"DOWN\"] = 1] = \"DOWN\";\n    GroupDirection[GroupDirection[\"LEFT\"] = 2] = \"LEFT\";\n    GroupDirection[GroupDirection[\"RIGHT\"] = 3] = \"RIGHT\";\n})(GroupDirection || (GroupDirection = {})));\nvar GroupOrientation;\n( (function(GroupOrientation) {\n    GroupOrientation[GroupOrientation[\"HORIZONTAL\"] = 0] = \"HORIZONTAL\";\n    GroupOrientation[GroupOrientation[\"VERTICAL\"] = 1] = \"VERTICAL\";\n})(GroupOrientation || (GroupOrientation = {})));\nvar GroupLocation;\n( (function(GroupLocation) {\n    GroupLocation[GroupLocation[\"FIRST\"] = 0] = \"FIRST\";\n    GroupLocation[GroupLocation[\"LAST\"] = 1] = \"LAST\";\n    GroupLocation[GroupLocation[\"NEXT\"] = 2] = \"NEXT\";\n    GroupLocation[GroupLocation[\"PREVIOUS\"] = 3] = \"PREVIOUS\";\n})(GroupLocation || (GroupLocation = {})));\nvar GroupsArrangement;\n( (function(GroupsArrangement) {\n    GroupsArrangement[GroupsArrangement[\"MAXIMIZE\"] = 0] = \"MAXIMIZE\";\n    GroupsArrangement[GroupsArrangement[\"EXPAND\"] = 1] = \"EXPAND\";\n    GroupsArrangement[GroupsArrangement[\"EVEN\"] = 2] = \"EVEN\";\n})(GroupsArrangement || (GroupsArrangement = {})));\nvar MergeGroupMode;\n( (function(MergeGroupMode) {\n    MergeGroupMode[MergeGroupMode[\"COPY_EDITORS\"] = 0] = \"COPY_EDITORS\";\n    MergeGroupMode[MergeGroupMode[\"MOVE_EDITORS\"] = 1] = \"MOVE_EDITORS\";\n})(MergeGroupMode || (MergeGroupMode = {})));\nfunction isEditorReplacement(replacement) {\n    const candidate = replacement;\n    return isEditorInput(candidate?.editor) && isEditorInput(candidate?.replacement);\n}\nvar GroupsOrder;\n( (function(GroupsOrder) {\n    GroupsOrder[GroupsOrder[\"CREATION_TIME\"] = 0] = \"CREATION_TIME\";\n    GroupsOrder[GroupsOrder[\"MOST_RECENTLY_ACTIVE\"] = 1] = \"MOST_RECENTLY_ACTIVE\";\n    GroupsOrder[GroupsOrder[\"GRID_APPEARANCE\"] = 2] = \"GRID_APPEARANCE\";\n})(GroupsOrder || (GroupsOrder = {})));\nfunction isEditorGroup(obj) {\n    const group = obj;\n    return !!group && typeof group.id === 'number' && Array.isArray(group.editors);\n}\nfunction preferredSideBySideGroupDirection(configurationService) {\n    const openSideBySideDirection = configurationService.getValue('workbench.editor.openSideBySideDirection');\n    if (openSideBySideDirection === 'down') {\n        return 1 ;\n    }\n    return 3 ;\n}\nexport { GroupDirection, GroupLocation, GroupOrientation, GroupsArrangement, GroupsOrder, MergeGroupMode, isEditorGroup, isEditorReplacement, preferredSideBySideGroupDirection };\n","import { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nconst IEditorGroupsService = ( createDecorator('editorGroupsService'));\nexport { IEditorGroupsService };\n","import { match } from '../../../../base/common/glob.js';\nimport { Schemas } from '../../../../base/common/network.js';\nimport { posix } from '../../../../base/common/path.js';\nimport { basename } from '../../../../base/common/resources.js';\nimport { localize } from '../../../../nls.js';\nimport { workbenchConfigurationNodeBase } from '../../../common/configuration.js';\nimport { Extensions } from '../../../../platform/configuration/common/configurationRegistry.js';\nimport { Registry } from '../../../../platform/registry/common/platform.js';\nconst editorsAssociationsSettingId = 'workbench.editorAssociations';\nconst configurationRegistry = ( (Registry.as(Extensions.Configuration)));\nconst editorAssociationsConfigurationNode = {\n    ...workbenchConfigurationNodeBase,\n    properties: {\n        'workbench.editorAssociations': {\n            type: 'object',\n            markdownDescription: ( localize(\n                5679,\n                \"Configure [glob patterns](https://aka.ms/vscode-glob-patterns) to editors (for example `\\\"*.hex\\\": \\\"hexEditor.hexedit\\\"`). These have precedence over the default behavior.\"\n            )),\n            additionalProperties: {\n                type: 'string'\n            }\n        }\n    }\n};\nconfigurationRegistry.registerConfiguration(editorAssociationsConfigurationNode);\nvar RegisteredEditorPriority;\n( ((function(RegisteredEditorPriority) {\n    RegisteredEditorPriority[\"builtin\"] = \"builtin\";\n    RegisteredEditorPriority[\"option\"] = \"option\";\n    RegisteredEditorPriority[\"exclusive\"] = \"exclusive\";\n    RegisteredEditorPriority[\"default\"] = \"default\";\n})(RegisteredEditorPriority || (RegisteredEditorPriority = {}))));\nfunction priorityToRank(priority) {\n    switch (priority) {\n        case RegisteredEditorPriority.exclusive:\n            return 5;\n        case RegisteredEditorPriority.default:\n            return 4;\n        case RegisteredEditorPriority.builtin:\n            return 3;\n        case RegisteredEditorPriority.option:\n        default:\n            return 1;\n    }\n}\nfunction globMatchesResource(globPattern, resource) {\n    const excludedSchemes = ( (new Set([\n        Schemas.extension,\n        Schemas.webviewPanel,\n        Schemas.vscodeWorkspaceTrust,\n        Schemas.vscodeSettings\n    ])));\n    if (( (excludedSchemes.has(resource.scheme)))) {\n        return false;\n    }\n    const matchOnPath = typeof globPattern === 'string' && globPattern.indexOf(posix.sep) >= 0;\n    const target = matchOnPath ? `${resource.scheme}:${resource.path}` : basename(resource);\n    return match(typeof globPattern === 'string' ? globPattern.toLowerCase() : globPattern, target.toLowerCase());\n}\nexport { RegisteredEditorPriority, editorsAssociationsSettingId, globMatchesResource, priorityToRank };\n","import { isEditorGroup } from './editorGroupsService.js';\nconst ACTIVE_GROUP = -1;\nconst SIDE_GROUP = -2;\nconst AUX_WINDOW_GROUP = -3;\nfunction isPreferredGroup(obj) {\n    const candidate = obj;\n    return typeof obj === 'number' || isEditorGroup(candidate);\n}\nexport { ACTIVE_GROUP, AUX_WINDOW_GROUP, SIDE_GROUP, isPreferredGroup };\n","import { ExtensionIdentifierMap, ExtensionIdentifier, ExtensionIdentifierSet } from '../../../../platform/extensions/common/extensions.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { posix } from '../../../../base/common/path.js';\nimport { Disposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { promiseWithResolvers } from '../../../../base/common/async.js';\nclass DeltaExtensionsResult {\n    constructor(versionId, removedDueToLooping) {\n        this.versionId = versionId;\n        this.removedDueToLooping = removedDueToLooping;\n    }\n}\nclass ExtensionDescriptionRegistry {\n    static isHostExtension(extensionId, myRegistry, globalRegistry) {\n        if (myRegistry.getExtensionDescription(extensionId)) {\n            return false;\n        }\n        const extensionDescription = globalRegistry.getExtensionDescription(extensionId);\n        if (!extensionDescription) {\n            return false;\n        }\n        if ((extensionDescription.main || extensionDescription.browser) && extensionDescription.api === 'none') {\n            return true;\n        }\n        return false;\n    }\n    constructor(_activationEventsReader, extensionDescriptions) {\n        this._activationEventsReader = _activationEventsReader;\n        this._onDidChange = ( new Emitter());\n        this.onDidChange = this._onDidChange.event;\n        this._versionId = 0;\n        this._extensionDescriptions = extensionDescriptions;\n        this._initialize();\n    }\n    _initialize() {\n        this._extensionDescriptions.sort(extensionCmp);\n        this._extensionsMap = ( new ExtensionIdentifierMap());\n        this._extensionsArr = [];\n        this._activationMap = ( new Map());\n        for (const extensionDescription of this._extensionDescriptions) {\n            if (( this._extensionsMap.has(extensionDescription.identifier))) {\n                console.error('Extension `' + extensionDescription.identifier.value + '` is already registered');\n                continue;\n            }\n            this._extensionsMap.set(extensionDescription.identifier, extensionDescription);\n            this._extensionsArr.push(extensionDescription);\n            const activationEvents = this._activationEventsReader.readActivationEvents(extensionDescription);\n            for (const activationEvent of activationEvents) {\n                if (!( this._activationMap.has(activationEvent))) {\n                    this._activationMap.set(activationEvent, []);\n                }\n                this._activationMap.get(activationEvent).push(extensionDescription);\n            }\n        }\n    }\n    set(extensionDescriptions) {\n        this._extensionDescriptions = extensionDescriptions;\n        this._initialize();\n        this._versionId++;\n        this._onDidChange.fire(undefined);\n        return {\n            versionId: this._versionId\n        };\n    }\n    deltaExtensions(toAdd, toRemove) {\n        this._extensionDescriptions = removeExtensions(this._extensionDescriptions, toRemove);\n        this._extensionDescriptions = this._extensionDescriptions.concat(toAdd);\n        const looping = ExtensionDescriptionRegistry._findLoopingExtensions(this._extensionDescriptions);\n        this._extensionDescriptions = removeExtensions(this._extensionDescriptions, ( looping.map(ext => ext.identifier)));\n        this._initialize();\n        this._versionId++;\n        this._onDidChange.fire(undefined);\n        return ( new DeltaExtensionsResult(this._versionId, looping));\n    }\n    static _findLoopingExtensions(extensionDescriptions) {\n        const G = new (class {\n            constructor() {\n                this._arcs = ( new Map());\n                this._nodesSet = ( new Set());\n                this._nodesArr = [];\n            }\n            addNode(id) {\n                if (!( this._nodesSet.has(id))) {\n                    this._nodesSet.add(id);\n                    this._nodesArr.push(id);\n                }\n            }\n            addArc(from, to) {\n                this.addNode(from);\n                this.addNode(to);\n                if (( this._arcs.has(from))) {\n                    this._arcs.get(from).push(to);\n                }\n                else {\n                    this._arcs.set(from, [to]);\n                }\n            }\n            getArcs(id) {\n                if (( this._arcs.has(id))) {\n                    return this._arcs.get(id);\n                }\n                return [];\n            }\n            hasOnlyGoodArcs(id, good) {\n                const dependencies = G.getArcs(id);\n                for (let i = 0; i < dependencies.length; i++) {\n                    if (!( good.has(dependencies[i]))) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            getNodes() {\n                return this._nodesArr;\n            }\n        });\n        const descs = ( new ExtensionIdentifierMap());\n        for (const extensionDescription of extensionDescriptions) {\n            descs.set(extensionDescription.identifier, extensionDescription);\n            if (extensionDescription.extensionDependencies) {\n                for (const depId of extensionDescription.extensionDependencies) {\n                    G.addArc(ExtensionIdentifier.toKey(extensionDescription.identifier), ExtensionIdentifier.toKey(depId));\n                }\n            }\n        }\n        const good = ( new Set());\n        G.getNodes().filter(id => G.getArcs(id).length === 0).forEach(id => good.add(id));\n        const nodes = G.getNodes().filter(id => !( good.has(id)));\n        let madeProgress;\n        do {\n            madeProgress = false;\n            for (let i = 0; i < nodes.length; i++) {\n                const id = nodes[i];\n                if (G.hasOnlyGoodArcs(id, good)) {\n                    nodes.splice(i, 1);\n                    i--;\n                    good.add(id);\n                    madeProgress = true;\n                }\n            }\n        } while (madeProgress);\n        return ( nodes.map(id => descs.get(id)));\n    }\n    containsActivationEvent(activationEvent) {\n        return ( this._activationMap.has(activationEvent));\n    }\n    containsExtension(extensionId) {\n        return ( this._extensionsMap.has(extensionId));\n    }\n    getExtensionDescriptionsForActivationEvent(activationEvent) {\n        const extensions = this._activationMap.get(activationEvent);\n        return extensions ? extensions.slice(0) : [];\n    }\n    getAllExtensionDescriptions() {\n        return this._extensionsArr.slice(0);\n    }\n    getSnapshot() {\n        return ( new ExtensionDescriptionRegistrySnapshot(this._versionId, this.getAllExtensionDescriptions()));\n    }\n    getExtensionDescription(extensionId) {\n        const extension = this._extensionsMap.get(extensionId);\n        return extension ? extension : undefined;\n    }\n    getExtensionDescriptionByUUID(uuid) {\n        for (const extensionDescription of this._extensionsArr) {\n            if (extensionDescription.uuid === uuid) {\n                return extensionDescription;\n            }\n        }\n        return undefined;\n    }\n    getExtensionDescriptionByIdOrUUID(extensionId, uuid) {\n        return (this.getExtensionDescription(extensionId)\n            ?? (uuid ? this.getExtensionDescriptionByUUID(uuid) : undefined));\n    }\n}\nclass ExtensionDescriptionRegistrySnapshot {\n    constructor(versionId, extensions) {\n        this.versionId = versionId;\n        this.extensions = extensions;\n    }\n}\nclass LockableExtensionDescriptionRegistry {\n    constructor(activationEventsReader) {\n        this._lock = ( new Lock());\n        this._actual = ( new ExtensionDescriptionRegistry(activationEventsReader, []));\n    }\n    async acquireLock(customerName) {\n        const lock = await this._lock.acquire(customerName);\n        return ( new ExtensionDescriptionRegistryLock(this, lock));\n    }\n    deltaExtensions(acquiredLock, toAdd, toRemove) {\n        if (!acquiredLock.isAcquiredFor(this)) {\n            throw ( new Error('Lock is not held'));\n        }\n        return this._actual.deltaExtensions(toAdd, toRemove);\n    }\n    containsActivationEvent(activationEvent) {\n        return this._actual.containsActivationEvent(activationEvent);\n    }\n    containsExtension(extensionId) {\n        return this._actual.containsExtension(extensionId);\n    }\n    getExtensionDescriptionsForActivationEvent(activationEvent) {\n        return this._actual.getExtensionDescriptionsForActivationEvent(activationEvent);\n    }\n    getAllExtensionDescriptions() {\n        return this._actual.getAllExtensionDescriptions();\n    }\n    getSnapshot() {\n        return this._actual.getSnapshot();\n    }\n    getExtensionDescription(extensionId) {\n        return this._actual.getExtensionDescription(extensionId);\n    }\n    getExtensionDescriptionByUUID(uuid) {\n        return this._actual.getExtensionDescriptionByUUID(uuid);\n    }\n    getExtensionDescriptionByIdOrUUID(extensionId, uuid) {\n        return this._actual.getExtensionDescriptionByIdOrUUID(extensionId, uuid);\n    }\n}\nclass ExtensionDescriptionRegistryLock extends Disposable {\n    constructor(_registry, lock) {\n        super();\n        this._registry = _registry;\n        this._isDisposed = false;\n        this._register(lock);\n    }\n    isAcquiredFor(registry) {\n        return !this._isDisposed && this._registry === registry;\n    }\n}\nclass LockCustomer {\n    constructor(name) {\n        this.name = name;\n        const withResolvers = promiseWithResolvers();\n        this.promise = withResolvers.promise;\n        this._resolve = withResolvers.resolve;\n    }\n    resolve(value) {\n        this._resolve(value);\n    }\n}\nclass Lock {\n    constructor() {\n        this._pendingCustomers = [];\n        this._isLocked = false;\n    }\n    async acquire(customerName) {\n        const customer = ( new LockCustomer(customerName));\n        this._pendingCustomers.push(customer);\n        this._advance();\n        return customer.promise;\n    }\n    _advance() {\n        if (this._isLocked) {\n            return;\n        }\n        if (this._pendingCustomers.length === 0) {\n            return;\n        }\n        const customer = this._pendingCustomers.shift();\n        this._isLocked = true;\n        let customerHoldsLock = true;\n        const logLongRunningCustomerTimeout = setTimeout(() => {\n            if (customerHoldsLock) {\n                console.warn(`The customer named ${customer.name} has been holding on to the lock for 30s. This might be a problem.`);\n            }\n        }, 30 * 1000 );\n        const releaseLock = () => {\n            if (!customerHoldsLock) {\n                return;\n            }\n            clearTimeout(logLongRunningCustomerTimeout);\n            customerHoldsLock = false;\n            this._isLocked = false;\n            this._advance();\n        };\n        customer.resolve(toDisposable(releaseLock));\n    }\n}\nfunction extensionCmp(a, b) {\n    const aSortBucket = ((a.isBuiltin ? 0  : a.isUnderDevelopment ? 2  : 1) );\n    const bSortBucket = ((b.isBuiltin ? 0  : b.isUnderDevelopment ? 2  : 1) );\n    if (aSortBucket !== bSortBucket) {\n        return aSortBucket - bSortBucket;\n    }\n    const aLastSegment = posix.basename(a.extensionLocation.path);\n    const bLastSegment = posix.basename(b.extensionLocation.path);\n    if (aLastSegment < bLastSegment) {\n        return -1;\n    }\n    if (aLastSegment > bLastSegment) {\n        return 1;\n    }\n    return 0;\n}\nfunction removeExtensions(arr, toRemove) {\n    const toRemoveSet = ( new ExtensionIdentifierSet(toRemove));\n    return arr.filter(extension => !( toRemoveSet.has(extension.identifier)));\n}\nexport { DeltaExtensionsResult, ExtensionDescriptionRegistry, ExtensionDescriptionRegistryLock, ExtensionDescriptionRegistrySnapshot, LockableExtensionDescriptionRegistry };\n","import { VSBuffer } from '../../../../base/common/buffer.js';\nvar UIKind;\n( (function(UIKind) {\n    UIKind[UIKind[\"Desktop\"] = 1] = \"Desktop\";\n    UIKind[UIKind[\"Web\"] = 2] = \"Web\";\n})(UIKind || (UIKind = {})));\nfunction createMessageOfType(type) {\n    const result = VSBuffer.alloc(1);\n    switch (type) {\n        case 0 :\n            result.writeUInt8(1, 0);\n            break;\n        case 1 :\n            result.writeUInt8(2, 0);\n            break;\n        case 2 :\n            result.writeUInt8(3, 0);\n            break;\n    }\n    return result;\n}\nfunction isMessageOfType(message, type) {\n    if (message.byteLength !== 1) {\n        return false;\n    }\n    switch (message.readUInt8(0)) {\n        case 1: return type === 0 ;\n        case 2: return type === 1 ;\n        case 3: return type === 2 ;\n        default: return false;\n    }\n}\nexport { UIKind, createMessageOfType, isMessageOfType };\n","import { Event } from '../../../../base/common/event.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { getGalleryExtensionId, getExtensionId } from '../../../../platform/extensionManagement/common/extensionManagementUtil.js';\nimport { ImplicitActivationEvents } from '../../../../platform/extensionManagement/common/implicitActivationEvents.js';\nimport { ExtensionIdentifier, ExtensionIdentifierSet, ExtensionIdentifierMap } from '../../../../platform/extensions/common/extensions.js';\nconst nullExtensionDescription = ( Object.freeze({\n    identifier: ( new ExtensionIdentifier('nullExtensionDescription')),\n    name: 'Null Extension Description',\n    version: '0.0.0',\n    publisher: 'vscode',\n    engines: { vscode: '' },\n    extensionLocation: ( URI.parse('void:location')),\n    isBuiltin: false,\n    targetPlatform: \"undefined\" ,\n    isUserBuiltin: false,\n    isUnderDevelopment: false\n}));\nconst webWorkerExtHostConfig = 'extensions.webWorker';\nclass MissingExtensionDependency {\n    constructor(dependency) {\n        this.dependency = dependency;\n    }\n}\nclass ExtensionHostExtensions {\n    get versionId() {\n        return this._versionId;\n    }\n    get allExtensions() {\n        return this._allExtensions;\n    }\n    get myExtensions() {\n        return this._myExtensions;\n    }\n    constructor(versionId, allExtensions, myExtensions) {\n        this._versionId = versionId;\n        this._allExtensions = allExtensions.slice(0);\n        this._myExtensions = myExtensions.slice(0);\n        this._myActivationEvents = null;\n    }\n    toSnapshot() {\n        return {\n            versionId: this._versionId,\n            allExtensions: this._allExtensions,\n            myExtensions: this._myExtensions,\n            activationEvents: ImplicitActivationEvents.createActivationEventsMap(this._allExtensions)\n        };\n    }\n    set(versionId, allExtensions, myExtensions) {\n        if (this._versionId > versionId) {\n            throw ( new Error(\n                `ExtensionHostExtensions: invalid versionId ${versionId} (current: ${this._versionId})`\n            ));\n        }\n        const toRemove = [];\n        const toAdd = [];\n        const myToRemove = [];\n        const myToAdd = [];\n        const oldExtensionsMap = extensionDescriptionArrayToMap(this._allExtensions);\n        const newExtensionsMap = extensionDescriptionArrayToMap(allExtensions);\n        const extensionsAreTheSame = (a, b) => {\n            return ((( a.extensionLocation.toString()) === ( b.extensionLocation.toString()))\n                || (a.isBuiltin === b.isBuiltin)\n                || (a.isUserBuiltin === b.isUserBuiltin) || (a.isUnderDevelopment === b.isUnderDevelopment));\n        };\n        for (const oldExtension of this._allExtensions) {\n            const newExtension = newExtensionsMap.get(oldExtension.identifier);\n            if (!newExtension) {\n                toRemove.push(oldExtension.identifier);\n                oldExtensionsMap.delete(oldExtension.identifier);\n                continue;\n            }\n            if (!extensionsAreTheSame(oldExtension, newExtension)) {\n                toRemove.push(oldExtension.identifier);\n                oldExtensionsMap.delete(oldExtension.identifier);\n                continue;\n            }\n        }\n        for (const newExtension of allExtensions) {\n            const oldExtension = oldExtensionsMap.get(newExtension.identifier);\n            if (!oldExtension) {\n                toAdd.push(newExtension);\n                continue;\n            }\n            if (!extensionsAreTheSame(oldExtension, newExtension)) {\n                toRemove.push(oldExtension.identifier);\n                oldExtensionsMap.delete(oldExtension.identifier);\n                continue;\n            }\n        }\n        const myOldExtensionsSet = ( new ExtensionIdentifierSet(this._myExtensions));\n        const myNewExtensionsSet = ( new ExtensionIdentifierSet(myExtensions));\n        for (const oldExtensionId of this._myExtensions) {\n            if (!( myNewExtensionsSet.has(oldExtensionId))) {\n                myToRemove.push(oldExtensionId);\n            }\n        }\n        for (const newExtensionId of myExtensions) {\n            if (!( myOldExtensionsSet.has(newExtensionId))) {\n                myToAdd.push(newExtensionId);\n            }\n        }\n        const addActivationEvents = ImplicitActivationEvents.createActivationEventsMap(toAdd);\n        const delta = { versionId, toRemove, toAdd, addActivationEvents, myToRemove, myToAdd };\n        this.delta(delta);\n        return delta;\n    }\n    delta(extensionsDelta) {\n        if (this._versionId >= extensionsDelta.versionId) {\n            return null;\n        }\n        const { toRemove, toAdd, myToRemove, myToAdd } = extensionsDelta;\n        const toRemoveSet = ( new ExtensionIdentifierSet(toRemove));\n        const myToRemoveSet = ( new ExtensionIdentifierSet(myToRemove));\n        for (let i = 0; i < this._allExtensions.length; i++) {\n            if (( toRemoveSet.has(this._allExtensions[i].identifier))) {\n                this._allExtensions.splice(i, 1);\n                i--;\n            }\n        }\n        for (let i = 0; i < this._myExtensions.length; i++) {\n            if (( myToRemoveSet.has(this._myExtensions[i]))) {\n                this._myExtensions.splice(i, 1);\n                i--;\n            }\n        }\n        for (const extension of toAdd) {\n            this._allExtensions.push(extension);\n        }\n        for (const extensionId of myToAdd) {\n            this._myExtensions.push(extensionId);\n        }\n        this._myActivationEvents = null;\n        return extensionsDelta;\n    }\n    containsExtension(extensionId) {\n        for (const myExtensionId of this._myExtensions) {\n            if (ExtensionIdentifier.equals(myExtensionId, extensionId)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    containsActivationEvent(activationEvent) {\n        if (!this._myActivationEvents) {\n            this._myActivationEvents = this._readMyActivationEvents();\n        }\n        return ( this._myActivationEvents.has(activationEvent));\n    }\n    _readMyActivationEvents() {\n        const result = ( new Set());\n        for (const extensionDescription of this._allExtensions) {\n            if (!this.containsExtension(extensionDescription.identifier)) {\n                continue;\n            }\n            const activationEvents = ImplicitActivationEvents.readActivationEvents(extensionDescription);\n            for (const activationEvent of activationEvents) {\n                result.add(activationEvent);\n            }\n        }\n        return result;\n    }\n}\nfunction extensionDescriptionArrayToMap(extensions) {\n    const result = ( new ExtensionIdentifierMap());\n    for (const extension of extensions) {\n        result.set(extension.identifier, extension);\n    }\n    return result;\n}\nfunction isProposedApiEnabled(extension, proposal) {\n    if (!extension.enabledApiProposals) {\n        return false;\n    }\n    return extension.enabledApiProposals.includes(proposal);\n}\nfunction checkProposedApiEnabled(extension, proposal) {\n    if (!isProposedApiEnabled(extension, proposal)) {\n        throw ( new Error(\n            `Extension '${extension.identifier.value}' CANNOT use API proposal: ${proposal}.\\nIts package.json#enabledApiProposals-property declares: ${extension.enabledApiProposals?.join(', ') ?? '[]'} but NOT ${proposal}.\\n The missing proposal MUST be added and you must start in extension development mode or use the following command line switch: --enable-proposed-api ${extension.identifier.value}`\n        ));\n    }\n}\nclass ActivationTimes {\n    constructor(codeLoadingTime, activateCallTime, activateResolvedTime, activationReason) {\n        this.codeLoadingTime = codeLoadingTime;\n        this.activateCallTime = activateCallTime;\n        this.activateResolvedTime = activateResolvedTime;\n        this.activationReason = activationReason;\n    }\n}\nclass ExtensionPointContribution {\n    constructor(description, value) {\n        this.description = description;\n        this.value = value;\n    }\n}\nfunction toExtension(extensionDescription) {\n    return {\n        type: extensionDescription.isBuiltin ? 0  : 1 ,\n        isBuiltin: extensionDescription.isBuiltin || extensionDescription.isUserBuiltin,\n        identifier: { id: getGalleryExtensionId(extensionDescription.publisher, extensionDescription.name), uuid: extensionDescription.uuid },\n        manifest: extensionDescription,\n        location: extensionDescription.extensionLocation,\n        targetPlatform: extensionDescription.targetPlatform,\n        validations: [],\n        isValid: true\n    };\n}\nfunction toExtensionDescription(extension, isUnderDevelopment) {\n    const id = getExtensionId(extension.manifest.publisher, extension.manifest.name);\n    return {\n        id,\n        identifier: ( new ExtensionIdentifier(id)),\n        isBuiltin: extension.type === 0 ,\n        isUserBuiltin: extension.type === 1  && extension.isBuiltin,\n        isUnderDevelopment: !!isUnderDevelopment,\n        extensionLocation: extension.location,\n        uuid: extension.identifier.uuid,\n        targetPlatform: extension.targetPlatform,\n        publisherDisplayName: extension.publisherDisplayName,\n        ...extension.manifest\n    };\n}\nclass NullExtensionService {\n    constructor() {\n        this.onDidRegisterExtensions = Event.None;\n        this.onDidChangeExtensionsStatus = Event.None;\n        this.onDidChangeExtensions = Event.None;\n        this.onWillActivateByEvent = Event.None;\n        this.onDidChangeResponsiveChange = Event.None;\n        this.onWillStop = Event.None;\n        this.extensions = [];\n    }\n    activateByEvent(_activationEvent) { return Promise.resolve(undefined); }\n    activateById(extensionId, reason) { return Promise.resolve(undefined); }\n    activationEventIsDone(_activationEvent) { return false; }\n    whenInstalledExtensionsRegistered() { return Promise.resolve(true); }\n    getExtension() { return Promise.resolve(undefined); }\n    readExtensionPointContributions(_extPoint) { return Promise.resolve(Object.create(null)); }\n    getExtensionsStatus() { return Object.create(null); }\n    getInspectPorts(_extensionHostKind, _tryEnableInspector) { return Promise.resolve([]); }\n    async stopExtensionHosts() { return true; }\n    async startExtensionHosts() { }\n    async setRemoteEnvironment(_env) { }\n    canAddExtension() { return false; }\n    canRemoveExtension() { return false; }\n}\nexport { ActivationTimes, ExtensionHostExtensions, ExtensionPointContribution, MissingExtensionDependency, NullExtensionService, checkProposedApiEnabled, isProposedApiEnabled, nullExtensionDescription, toExtension, toExtensionDescription, webWorkerExtHostConfig };\n","import { localize } from '../../../../nls.js';\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\nimport Severity$1 from '../../../../base/common/severity.js';\nimport { EXTENSION_IDENTIFIER_PATTERN } from '../../../../platform/extensionManagement/common/extensionManagement.js';\nimport { Extensions } from '../../../../platform/jsonschemas/common/jsonContributionRegistry.js';\nimport { Registry } from '../../../../platform/registry/common/platform.js';\nimport { EXTENSION_CATEGORIES, ExtensionIdentifierSet } from '../../../../platform/extensions/common/extensions.js';\nimport { productSchemaId } from '../../../../platform/product/common/productService.js';\nimport { ImplicitActivationEvents } from '../../../../platform/extensionManagement/common/implicitActivationEvents.js';\nimport { allApiProposals } from '../../../../platform/extensions/common/extensionsApiProposals.js';\nconst schemaRegistry = ( (Registry.as(Extensions.JSONContribution)));\nclass ExtensionMessageCollector {\n    constructor(messageHandler, extension, extensionPointId) {\n        this._messageHandler = messageHandler;\n        this._extension = extension;\n        this._extensionPointId = extensionPointId;\n    }\n    _msg(type, message) {\n        this._messageHandler({\n            type: type,\n            message: message,\n            extensionId: this._extension.identifier,\n            extensionPointId: this._extensionPointId\n        });\n    }\n    error(message) {\n        this._msg(Severity$1.Error, message);\n    }\n    warn(message) {\n        this._msg(Severity$1.Warning, message);\n    }\n    info(message) {\n        this._msg(Severity$1.Info, message);\n    }\n}\nclass ExtensionPointUserDelta {\n    static _toSet(arr) {\n        const result = ( (new ExtensionIdentifierSet()));\n        for (let i = 0, len = arr.length; i < len; i++) {\n            result.add(arr[i].description.identifier);\n        }\n        return result;\n    }\n    static compute(previous, current) {\n        if (!previous || !previous.length) {\n            return (\n                 (new ExtensionPointUserDelta(current, []))\n            );\n        }\n        if (!current || !current.length) {\n            return (\n                 (new ExtensionPointUserDelta([], previous))\n            );\n        }\n        const previousSet = this._toSet(previous);\n        const currentSet = this._toSet(current);\n        const added = current.filter(user => !( (previousSet.has(user.description.identifier))));\n        const removed = previous.filter(user => !( (currentSet.has(user.description.identifier))));\n        return (\n             (new ExtensionPointUserDelta(added, removed))\n        );\n    }\n    constructor(added, removed) {\n        this.added = added;\n        this.removed = removed;\n    }\n}\nclass ExtensionPoint {\n    constructor(name, defaultExtensionKind) {\n        this.name = name;\n        this.defaultExtensionKind = defaultExtensionKind;\n        this._handler = null;\n        this._users = null;\n        this._delta = null;\n    }\n    setHandler(handler) {\n        if (this._handler !== null) {\n            throw ( (new Error('Handler already set!')));\n        }\n        this._handler = handler;\n        this._handle();\n        return {\n            dispose: () => {\n                this._handler = null;\n            }\n        };\n    }\n    acceptUsers(users) {\n        this._delta = ExtensionPointUserDelta.compute(this._users, users);\n        this._users = users;\n        this._handle();\n    }\n    _handle() {\n        if (this._handler === null || this._users === null || this._delta === null) {\n            return;\n        }\n        try {\n            this._handler(this._users, this._delta);\n        }\n        catch (err) {\n            onUnexpectedError(err);\n        }\n    }\n}\nconst extensionKindSchema = {\n    type: 'string',\n    enum: [\n        'ui',\n        'workspace'\n    ],\n    enumDescriptions: [\n        ( localize(\n            3786,\n            \"UI extension kind. In a remote window, such extensions are enabled only when available on the local machine.\"\n        )),\n        ( localize(\n            3787,\n            \"Workspace extension kind. In a remote window, such extensions are enabled only when available on the remote.\"\n        )),\n    ],\n};\nconst schemaId = 'vscode://schemas/vscode-extensions';\nconst schema = {\n    properties: {\n        engines: {\n            type: 'object',\n            description: ( localize(3788, \"Engine compatibility.\")),\n            properties: {\n                'vscode': {\n                    type: 'string',\n                    description: ( localize(\n                        3789,\n                        'For VS Code extensions, specifies the VS Code version that the extension is compatible with. Cannot be *. For example: ^0.10.5 indicates compatibility with a minimum VS Code version of 0.10.5.'\n                    )),\n                    default: '^1.22.0',\n                }\n            }\n        },\n        publisher: {\n            description: ( localize(3790, 'The publisher of the VS Code extension.')),\n            type: 'string'\n        },\n        displayName: {\n            description: ( localize(3791, 'The display name for the extension used in the VS Code gallery.')),\n            type: 'string'\n        },\n        categories: {\n            description: ( localize(\n                3792,\n                'The categories used by the VS Code gallery to categorize the extension.'\n            )),\n            type: 'array',\n            uniqueItems: true,\n            items: {\n                oneOf: [{\n                        type: 'string',\n                        enum: EXTENSION_CATEGORIES,\n                    },\n                    {\n                        type: 'string',\n                        const: 'Languages',\n                        deprecationMessage: ( localize(3793, 'Use \\'Programming  Languages\\' instead')),\n                    }]\n            }\n        },\n        galleryBanner: {\n            type: 'object',\n            description: ( localize(3794, 'Banner used in the VS Code marketplace.')),\n            properties: {\n                color: {\n                    description: ( localize(3795, 'The banner color on the VS Code marketplace page header.')),\n                    type: 'string'\n                },\n                theme: {\n                    description: ( localize(3796, 'The color theme for the font used in the banner.')),\n                    type: 'string',\n                    enum: ['dark', 'light']\n                }\n            }\n        },\n        contributes: {\n            description: ( localize(\n                3797,\n                'All contributions of the VS Code extension represented by this package.'\n            )),\n            type: 'object',\n            properties: {\n            },\n            default: {}\n        },\n        preview: {\n            type: 'boolean',\n            description: ( localize(3798, 'Sets the extension to be flagged as a Preview in the Marketplace.')),\n        },\n        enableProposedApi: {\n            type: 'boolean',\n            deprecationMessage: ( localize(3799, 'Use `enabledApiProposals` instead.')),\n        },\n        enabledApiProposals: {\n            markdownDescription: ( localize(\n                3800,\n                'Enable API proposals to try them out. Only valid **during development**. Extensions **cannot be published** with this property. For more details visit: https://code.visualstudio.com/api/advanced-topics/using-proposed-api'\n            )),\n            type: 'array',\n            uniqueItems: true,\n            items: {\n                type: 'string',\n                enum: ( (( (Object.keys(allApiProposals))).map(proposalName => proposalName))),\n                markdownEnumDescriptions: ( (( (Object.values(allApiProposals))).map(value => value.proposal)))\n            }\n        },\n        api: {\n            markdownDescription: ( localize(\n                3801,\n                'Describe the API provided by this extension. For more details visit: https://code.visualstudio.com/api/advanced-topics/remote-extensions#handling-dependencies-with-remote-extensions'\n            )),\n            type: 'string',\n            enum: ['none'],\n            enumDescriptions: [\n                ( localize(\n                    3802,\n                    \"Give up entirely the ability to export any APIs. This allows other extensions that depend on this extension to run in a separate extension host process or in a remote machine.\"\n                ))\n            ]\n        },\n        activationEvents: {\n            description: ( localize(3803, 'Activation events for the VS Code extension.')),\n            type: 'array',\n            items: {\n                type: 'string',\n                defaultSnippets: [\n                    {\n                        label: 'onWebviewPanel',\n                        description: ( localize(\n                            3804,\n                            'An activation event emmited when a webview is loaded of a certain viewType'\n                        )),\n                        body: 'onWebviewPanel:viewType'\n                    },\n                    {\n                        label: 'onLanguage',\n                        description: ( localize(\n                            3805,\n                            'An activation event emitted whenever a file that resolves to the specified language gets opened.'\n                        )),\n                        body: 'onLanguage:${1:languageId}'\n                    },\n                    {\n                        label: 'onCommand',\n                        description: ( localize(\n                            3806,\n                            'An activation event emitted whenever the specified command gets invoked.'\n                        )),\n                        body: 'onCommand:${2:commandId}'\n                    },\n                    {\n                        label: 'onDebug',\n                        description: ( localize(\n                            3807,\n                            'An activation event emitted whenever a user is about to start debugging or about to setup debug configurations.'\n                        )),\n                        body: 'onDebug'\n                    },\n                    {\n                        label: 'onDebugInitialConfigurations',\n                        description: ( localize(\n                            3808,\n                            'An activation event emitted whenever a \"launch.json\" needs to be created (and all provideDebugConfigurations methods need to be called).'\n                        )),\n                        body: 'onDebugInitialConfigurations'\n                    },\n                    {\n                        label: 'onDebugDynamicConfigurations',\n                        description: ( localize(\n                            3809,\n                            'An activation event emitted whenever a list of all debug configurations needs to be created (and all provideDebugConfigurations methods for the \"dynamic\" scope need to be called).'\n                        )),\n                        body: 'onDebugDynamicConfigurations'\n                    },\n                    {\n                        label: 'onDebugResolve',\n                        description: ( localize(\n                            3810,\n                            'An activation event emitted whenever a debug session with the specific type is about to be launched (and a corresponding resolveDebugConfiguration method needs to be called).'\n                        )),\n                        body: 'onDebugResolve:${6:type}'\n                    },\n                    {\n                        label: 'onDebugAdapterProtocolTracker',\n                        description: ( localize(\n                            3811,\n                            'An activation event emitted whenever a debug session with the specific type is about to be launched and a debug protocol tracker might be needed.'\n                        )),\n                        body: 'onDebugAdapterProtocolTracker:${6:type}'\n                    },\n                    {\n                        label: 'workspaceContains',\n                        description: ( localize(\n                            3812,\n                            'An activation event emitted whenever a folder is opened that contains at least a file matching the specified glob pattern.'\n                        )),\n                        body: 'workspaceContains:${4:filePattern}'\n                    },\n                    {\n                        label: 'onStartupFinished',\n                        description: ( localize(\n                            3813,\n                            'An activation event emitted after the start-up finished (after all `*` activated extensions have finished activating).'\n                        )),\n                        body: 'onStartupFinished'\n                    },\n                    {\n                        label: 'onTaskType',\n                        description: ( localize(\n                            3814,\n                            'An activation event emitted whenever tasks of a certain type need to be listed or resolved.'\n                        )),\n                        body: 'onTaskType:${1:taskType}'\n                    },\n                    {\n                        label: 'onFileSystem',\n                        description: ( localize(\n                            3815,\n                            'An activation event emitted whenever a file or folder is accessed with the given scheme.'\n                        )),\n                        body: 'onFileSystem:${1:scheme}'\n                    },\n                    {\n                        label: 'onEditSession',\n                        description: ( localize(\n                            3816,\n                            'An activation event emitted whenever an edit session is accessed with the given scheme.'\n                        )),\n                        body: 'onEditSession:${1:scheme}'\n                    },\n                    {\n                        label: 'onSearch',\n                        description: ( localize(\n                            3817,\n                            'An activation event emitted whenever a search is started in the folder with the given scheme.'\n                        )),\n                        body: 'onSearch:${7:scheme}'\n                    },\n                    {\n                        label: 'onView',\n                        body: 'onView:${5:viewId}',\n                        description: ( localize(\n                            3818,\n                            'An activation event emitted whenever the specified view is expanded.'\n                        )),\n                    },\n                    {\n                        label: 'onUri',\n                        body: 'onUri',\n                        description: ( localize(\n                            3819,\n                            'An activation event emitted whenever a system-wide Uri directed towards this extension is open.'\n                        )),\n                    },\n                    {\n                        label: 'onOpenExternalUri',\n                        body: 'onOpenExternalUri',\n                        description: ( localize(\n                            3820,\n                            'An activation event emitted whenever a external uri (such as an http or https link) is being opened.'\n                        )),\n                    },\n                    {\n                        label: 'onCustomEditor',\n                        body: 'onCustomEditor:${9:viewType}',\n                        description: ( localize(\n                            3821,\n                            'An activation event emitted whenever the specified custom editor becomes visible.'\n                        )),\n                    },\n                    {\n                        label: 'onNotebook',\n                        body: 'onNotebook:${1:type}',\n                        description: ( localize(\n                            3822,\n                            'An activation event emitted whenever the specified notebook document is opened.'\n                        )),\n                    },\n                    {\n                        label: 'onAuthenticationRequest',\n                        body: 'onAuthenticationRequest:${11:authenticationProviderId}',\n                        description: ( localize(\n                            3823,\n                            'An activation event emitted whenever sessions are requested from the specified authentication provider.'\n                        ))\n                    },\n                    {\n                        label: 'onRenderer',\n                        description: ( localize(\n                            3824,\n                            'An activation event emitted whenever a notebook output renderer is used.'\n                        )),\n                        body: 'onRenderer:${11:rendererId}'\n                    },\n                    {\n                        label: 'onTerminalProfile',\n                        body: 'onTerminalProfile:${1:terminalId}',\n                        description: ( localize(\n                            3825,\n                            'An activation event emitted when a specific terminal profile is launched.'\n                        )),\n                    },\n                    {\n                        label: 'onTerminalQuickFixRequest',\n                        body: 'onTerminalQuickFixRequest:${1:quickFixId}',\n                        description: ( localize(\n                            3826,\n                            'An activation event emitted when a command matches the selector associated with this ID'\n                        )),\n                    },\n                    {\n                        label: 'onWalkthrough',\n                        body: 'onWalkthrough:${1:walkthroughID}',\n                        description: ( localize(\n                            3827,\n                            'An activation event emitted when a specified walkthrough is opened.'\n                        )),\n                    },\n                    {\n                        label: 'onIssueReporterOpened',\n                        body: 'onIssueReporterOpened',\n                        description: ( localize(3828, 'An activation event emitted when the issue reporter is opened.')),\n                    },\n                    {\n                        label: 'onChatParticipant',\n                        body: 'onChatParticipant:${1:participantId}',\n                        description: ( localize(\n                            3829,\n                            'An activation event emitted when the specified chat participant is invoked.'\n                        )),\n                    },\n                    {\n                        label: 'onLanguageModelTool',\n                        body: 'onLanguageModelTool:${1:toolId}',\n                        description: ( localize(\n                            3830,\n                            'An activation event emitted when the specified language model tool is invoked.'\n                        )),\n                    },\n                    {\n                        label: '*',\n                        description: ( localize(\n                            3831,\n                            'An activation event emitted on VS Code startup. To ensure a great end user experience, please use this activation event in your extension only when no other activation events combination works in your use-case.'\n                        )),\n                        body: '*'\n                    }\n                ],\n            }\n        },\n        badges: {\n            type: 'array',\n            description: ( localize(\n                3832,\n                'Array of badges to display in the sidebar of the Marketplace\\'s extension page.'\n            )),\n            items: {\n                type: 'object',\n                required: ['url', 'href', 'description'],\n                properties: {\n                    url: {\n                        type: 'string',\n                        description: ( localize(3833, 'Badge image URL.'))\n                    },\n                    href: {\n                        type: 'string',\n                        description: ( localize(3834, 'Badge link.'))\n                    },\n                    description: {\n                        type: 'string',\n                        description: ( localize(3835, 'Badge description.'))\n                    }\n                }\n            }\n        },\n        markdown: {\n            type: 'string',\n            description: ( localize(\n                3836,\n                \"Controls the Markdown rendering engine used in the Marketplace. Either github (default) or standard.\"\n            )),\n            enum: ['github', 'standard'],\n            default: 'github'\n        },\n        qna: {\n            default: 'marketplace',\n            description: ( localize(\n                3837,\n                \"Controls the Q&A link in the Marketplace. Set to marketplace to enable the default Marketplace Q & A site. Set to a string to provide the URL of a custom Q & A site. Set to false to disable Q & A altogether.\"\n            )),\n            anyOf: [\n                {\n                    type: ['string', 'boolean'],\n                    enum: ['marketplace', false]\n                },\n                {\n                    type: 'string'\n                }\n            ]\n        },\n        extensionDependencies: {\n            description: ( localize(\n                3838,\n                'Dependencies to other extensions. The identifier of an extension is always ${publisher}.${name}. For example: vscode.csharp.'\n            )),\n            type: 'array',\n            uniqueItems: true,\n            items: {\n                type: 'string',\n                pattern: EXTENSION_IDENTIFIER_PATTERN\n            }\n        },\n        extensionPack: {\n            description: ( localize(\n                3839,\n                \"A set of extensions that can be installed together. The identifier of an extension is always ${publisher}.${name}. For example: vscode.csharp.\"\n            )),\n            type: 'array',\n            uniqueItems: true,\n            items: {\n                type: 'string',\n                pattern: EXTENSION_IDENTIFIER_PATTERN\n            }\n        },\n        extensionKind: {\n            description: ( localize(\n                3840,\n                \"Define the kind of an extension. `ui` extensions are installed and run on the local machine while `workspace` extensions run on the remote.\"\n            )),\n            type: 'array',\n            items: extensionKindSchema,\n            default: ['workspace'],\n            defaultSnippets: [\n                {\n                    body: ['ui'],\n                    description: ( localize(\n                        3841,\n                        \"Define an extension which can run only on the local machine when connected to remote window.\"\n                    ))\n                },\n                {\n                    body: ['workspace'],\n                    description: ( localize(\n                        3842,\n                        \"Define an extension which can run only on the remote machine when connected remote window.\"\n                    ))\n                },\n                {\n                    body: ['ui', 'workspace'],\n                    description: ( localize(\n                        3843,\n                        \"Define an extension which can run on either side, with a preference towards running on the local machine.\"\n                    ))\n                },\n                {\n                    body: ['workspace', 'ui'],\n                    description: ( localize(\n                        3844,\n                        \"Define an extension which can run on either side, with a preference towards running on the remote machine.\"\n                    ))\n                },\n                {\n                    body: [],\n                    description: ( localize(\n                        3845,\n                        \"Define an extension which cannot run in a remote context, neither on the local, nor on the remote machine.\"\n                    ))\n                }\n            ]\n        },\n        capabilities: {\n            description: ( localize(3846, \"Declare the set of supported capabilities by the extension.\")),\n            type: 'object',\n            properties: {\n                virtualWorkspaces: {\n                    description: ( localize(\n                        3847,\n                        \"Declares whether the extension should be enabled in virtual workspaces. A virtual workspace is a workspace which is not backed by any on-disk resources. When false, this extension will be automatically disabled in virtual workspaces. Default is true.\"\n                    )),\n                    type: ['boolean', 'object'],\n                    defaultSnippets: [\n                        { label: 'limited', body: { supported: '${1:limited}', description: '${2}' } },\n                        { label: 'false', body: { supported: false, description: '${2}' } },\n                    ],\n                    default: true.valueOf,\n                    properties: {\n                        supported: {\n                            markdownDescription: ( localize(\n                                3848,\n                                \"Declares the level of support for virtual workspaces by the extension.\"\n                            )),\n                            type: ['string', 'boolean'],\n                            enum: ['limited', true, false],\n                            enumDescriptions: [\n                                ( localize(\n                                    3849,\n                                    \"The extension will be enabled in virtual workspaces with some functionality disabled.\"\n                                )),\n                                ( localize(\n                                    3850,\n                                    \"The extension will be enabled in virtual workspaces with all functionality enabled.\"\n                                )),\n                                ( localize(3851, \"The extension will not be enabled in virtual workspaces.\")),\n                            ]\n                        },\n                        description: {\n                            type: 'string',\n                            markdownDescription: ( localize(\n                                3852,\n                                \"A description of how virtual workspaces affects the extensions behavior and why it is needed. This only applies when `supported` is not `true`.\"\n                            )),\n                        }\n                    }\n                },\n                untrustedWorkspaces: {\n                    description: ( localize(\n                        3853,\n                        'Declares how the extension should be handled in untrusted workspaces.'\n                    )),\n                    type: 'object',\n                    required: ['supported'],\n                    defaultSnippets: [\n                        { body: { supported: '${1:limited}', description: '${2}' } },\n                    ],\n                    properties: {\n                        supported: {\n                            markdownDescription: ( localize(\n                                3854,\n                                \"Declares the level of support for untrusted workspaces by the extension.\"\n                            )),\n                            type: ['string', 'boolean'],\n                            enum: ['limited', true, false],\n                            enumDescriptions: [\n                                ( localize(\n                                    3855,\n                                    \"The extension will be enabled in untrusted workspaces with some functionality disabled.\"\n                                )),\n                                ( localize(\n                                    3856,\n                                    \"The extension will be enabled in untrusted workspaces with all functionality enabled.\"\n                                )),\n                                ( localize(3857, \"The extension will not be enabled in untrusted workspaces.\")),\n                            ]\n                        },\n                        restrictedConfigurations: {\n                            description: ( localize(\n                                3858,\n                                \"A list of configuration keys contributed by the extension that should not use workspace values in untrusted workspaces.\"\n                            )),\n                            type: 'array',\n                            items: {\n                                type: 'string'\n                            }\n                        },\n                        description: {\n                            type: 'string',\n                            markdownDescription: ( localize(\n                                3859,\n                                \"A description of how workspace trust affects the extensions behavior and why it is needed. This only applies when `supported` is not `true`.\"\n                            )),\n                        }\n                    }\n                }\n            }\n        },\n        sponsor: {\n            description: ( localize(3860, \"Specify the location from where users can sponsor your extension.\")),\n            type: 'object',\n            defaultSnippets: [\n                { body: { url: '${1:https:}' } },\n            ],\n            properties: {\n                'url': {\n                    description: ( localize(\n                        3861,\n                        \"URL from where users can sponsor your extension. It must be a valid URL with a HTTP or HTTPS protocol. Example value: https://github.com/sponsors/nvaccess\"\n                    )),\n                    type: 'string',\n                }\n            }\n        },\n        scripts: {\n            type: 'object',\n            properties: {\n                'vscode:prepublish': {\n                    description: ( localize(\n                        3862,\n                        'Script executed before the package is published as a VS Code extension.'\n                    )),\n                    type: 'string'\n                },\n                'vscode:uninstall': {\n                    description: ( localize(\n                        3863,\n                        'Uninstall hook for VS Code extension. Script that gets executed when the extension is completely uninstalled from VS Code which is when VS Code is restarted (shutdown and start) after the extension is uninstalled. Only Node scripts are supported.'\n                    )),\n                    type: 'string'\n                }\n            }\n        },\n        icon: {\n            type: 'string',\n            description: ( localize(3864, 'The path to a 128x128 pixel icon.'))\n        },\n        l10n: {\n            type: 'string',\n            description: ( localize(\n                3865,\n                'The relative path to a folder containing localization (bundle.l10n.*.json) files. Must be specified if you are using the vscode.l10n API.'\n            ))\n        },\n        pricing: {\n            type: 'string',\n            markdownDescription: ( localize(\n                3866,\n                'The pricing information for the extension. Can be Free (default) or Trial. For more details visit: https://code.visualstudio.com/api/working-with-extensions/publishing-extension#extension-pricing-label'\n            )),\n            enum: ['Free', 'Trial'],\n            default: 'Free'\n        }\n    }\n};\nclass ExtensionsRegistryImpl {\n    constructor() {\n        this._extensionPoints = ( (new Map()));\n    }\n    registerExtensionPoint(desc) {\n        if (( (this._extensionPoints.has(desc.extensionPoint)))) {\n            throw ( (new Error('Duplicate extension point: ' + desc.extensionPoint)));\n        }\n        const result = ( (new ExtensionPoint(desc.extensionPoint, desc.defaultExtensionKind)));\n        this._extensionPoints.set(desc.extensionPoint, result);\n        if (desc.activationEventsGenerator) {\n            ImplicitActivationEvents.register(desc.extensionPoint, desc.activationEventsGenerator);\n        }\n        schema.properties['contributes'].properties[desc.extensionPoint] = desc.jsonSchema;\n        schemaRegistry.registerSchema(schemaId, schema);\n        return result;\n    }\n    getExtensionPoints() {\n        return Array.from(( (this._extensionPoints.values())));\n    }\n}\nconst PRExtensions = {\n    ExtensionsRegistry: 'ExtensionsRegistry'\n};\nRegistry.add(PRExtensions.ExtensionsRegistry, ( (new ExtensionsRegistryImpl())));\nconst ExtensionsRegistry = ( (Registry.as(PRExtensions.ExtensionsRegistry)));\nschemaRegistry.registerSchema(schemaId, schema);\nschemaRegistry.registerSchema(productSchemaId, {\n    properties: {\n        extensionEnabledApiProposals: {\n            description: ( localize(3867, \"API proposals that the respective extensions can freely use.\")),\n            type: 'object',\n            properties: {},\n            additionalProperties: {\n                anyOf: [{\n                        type: 'array',\n                        uniqueItems: true,\n                        items: {\n                            type: 'string',\n                            enum: ( (Object.keys(allApiProposals))),\n                            markdownEnumDescriptions: ( (( (Object.values(allApiProposals))).map(value => value.proposal)))\n                        }\n                    }]\n            }\n        }\n    }\n});\nexport { ExtensionMessageCollector, ExtensionPoint, ExtensionPointUserDelta, ExtensionsRegistry, ExtensionsRegistryImpl, schema };\n","import { CancellationError, onUnexpectedError } from '../../../../base/common/errors.js';\nclass LazyPromise {\n    constructor() {\n        this._actual = null;\n        this._actualOk = null;\n        this._actualErr = null;\n        this._hasValue = false;\n        this._value = null;\n        this._hasErr = false;\n        this._err = null;\n    }\n    get [Symbol.toStringTag]() {\n        return ( this.toString());\n    }\n    _ensureActual() {\n        if (!this._actual) {\n            this._actual = ( new Promise((c, e) => {\n                this._actualOk = c;\n                this._actualErr = e;\n                if (this._hasValue) {\n                    this._actualOk(this._value);\n                }\n                if (this._hasErr) {\n                    this._actualErr(this._err);\n                }\n            }));\n        }\n        return this._actual;\n    }\n    resolveOk(value) {\n        if (this._hasValue || this._hasErr) {\n            return;\n        }\n        this._hasValue = true;\n        this._value = value;\n        if (this._actual) {\n            this._actualOk(value);\n        }\n    }\n    resolveErr(err) {\n        if (this._hasValue || this._hasErr) {\n            return;\n        }\n        this._hasErr = true;\n        this._err = err;\n        if (this._actual) {\n            this._actualErr(err);\n        }\n        else {\n            onUnexpectedError(err);\n        }\n    }\n    then(success, error) {\n        return this._ensureActual().then(success, error);\n    }\n    catch(error) {\n        return this._ensureActual().then(undefined, error);\n    }\n    finally(callback) {\n        return this._ensureActual().finally(callback);\n    }\n}\nclass CanceledLazyPromise extends LazyPromise {\n    constructor() {\n        super();\n        this._hasErr = true;\n        this._err = ( new CancellationError());\n    }\n}\nexport { CanceledLazyPromise, LazyPromise };\n","class ProxyIdentifier {\n    static { this.count = 0; }\n    constructor(sid) {\n        this._proxyIdentifierBrand = undefined;\n        this.sid = sid;\n        this.nid = (++ProxyIdentifier.count);\n    }\n}\nconst identifiers = [];\nfunction createProxyIdentifier(identifier) {\n    const result = ( new ProxyIdentifier(identifier));\n    identifiers[result.nid] = result;\n    return result;\n}\nfunction getStringIdentifierForProxy(nid) {\n    return identifiers[nid].sid;\n}\nclass SerializableObjectWithBuffers {\n    constructor(value) {\n        this.value = value;\n    }\n}\nexport { ProxyIdentifier, SerializableObjectWithBuffers, createProxyIdentifier, getStringIdentifierForProxy };\n","import { RunOnceScheduler } from '../../../../base/common/async.js';\nimport { VSBuffer } from '../../../../base/common/buffer.js';\nimport { CancellationToken, CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { canceled, transformErrorForSerialization } from '../../../../base/common/errors.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable, DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { transformIncomingURIs } from '../../../../base/common/uriIpc.js';\nimport { CanceledLazyPromise, LazyPromise } from './lazyPromise.js';\nimport { getStringIdentifierForProxy, SerializableObjectWithBuffers, ProxyIdentifier } from './proxyIdentifier.js';\nvar _a;\nfunction safeStringify(obj, replacer) {\n    try {\n        return JSON.stringify(obj, replacer);\n    }\n    catch (err) {\n        return 'null';\n    }\n}\nconst refSymbolName = '$$ref$$';\nconst undefinedRef = { [refSymbolName]: -1 };\nfunction stringifyJsonWithBufferRefs(obj, replacer = null, useSafeStringify = false) {\n    const foundBuffers = [];\n    const serialized = (useSafeStringify ? safeStringify : JSON.stringify)(obj, (key, value) => {\n        if (typeof value === 'undefined') {\n            return undefinedRef;\n        }\n        else if (typeof value === 'object') {\n            if (value instanceof VSBuffer) {\n                const bufferIndex = foundBuffers.push(value) - 1;\n                return { [refSymbolName]: bufferIndex };\n            }\n            if (replacer) {\n                return replacer(key, value);\n            }\n        }\n        return value;\n    });\n    return {\n        jsonString: serialized,\n        referencedBuffers: foundBuffers\n    };\n}\nfunction parseJsonAndRestoreBufferRefs(jsonString, buffers, uriTransformer) {\n    return JSON.parse(jsonString, (_key, value) => {\n        if (value) {\n            const ref = value[refSymbolName];\n            if (typeof ref === 'number') {\n                return buffers[ref];\n            }\n            if (uriTransformer && value.$mid === 1 ) {\n                return uriTransformer.transformIncoming(value);\n            }\n        }\n        return value;\n    });\n}\nfunction stringify(obj, replacer) {\n    return JSON.stringify(obj, replacer);\n}\nfunction createURIReplacer(transformer) {\n    if (!transformer) {\n        return null;\n    }\n    return (key, value) => {\n        if (value && value.$mid === 1 ) {\n            return transformer.transformOutgoing(value);\n        }\n        return value;\n    };\n}\nconst noop = () => { };\nconst _RPCProtocolSymbol = Symbol.for('rpcProtocol');\nconst _RPCProxySymbol = Symbol.for('rpcProxy');\nclass RPCProtocol extends Disposable {\n    static { _a = _RPCProtocolSymbol; }\n    static { this.UNRESPONSIVE_TIME = 3 * 1000; }\n    constructor(protocol, logger = null, transformer = null) {\n        super();\n        this[_a] = true;\n        this._onDidChangeResponsiveState = this._register(( new Emitter()));\n        this.onDidChangeResponsiveState = this._onDidChangeResponsiveState.event;\n        this._protocol = protocol;\n        this._logger = logger;\n        this._uriTransformer = transformer;\n        this._uriReplacer = createURIReplacer(this._uriTransformer);\n        this._isDisposed = false;\n        this._locals = [];\n        this._proxies = [];\n        for (let i = 0, len = ProxyIdentifier.count; i < len; i++) {\n            this._locals[i] = null;\n            this._proxies[i] = null;\n        }\n        this._lastMessageId = 0;\n        this._cancelInvokedHandlers = Object.create(null);\n        this._pendingRPCReplies = {};\n        this._responsiveState = 0 ;\n        this._unacknowledgedCount = 0;\n        this._unresponsiveTime = 0;\n        this._asyncCheckUresponsive = this._register(( new RunOnceScheduler(() => this._checkUnresponsive(), 1000)));\n        this._register(this._protocol.onMessage((msg) => this._receiveOneMessage(msg)));\n    }\n    dispose() {\n        this._isDisposed = true;\n        ( Object.keys(this._pendingRPCReplies)).forEach((msgId) => {\n            const pending = this._pendingRPCReplies[msgId];\n            delete this._pendingRPCReplies[msgId];\n            pending.resolveErr(canceled());\n        });\n        super.dispose();\n    }\n    drain() {\n        if (typeof this._protocol.drain === 'function') {\n            return this._protocol.drain();\n        }\n        return Promise.resolve();\n    }\n    _onWillSendRequest(req) {\n        if (this._unacknowledgedCount === 0) {\n            this._unresponsiveTime = Date.now() + RPCProtocol.UNRESPONSIVE_TIME;\n        }\n        this._unacknowledgedCount++;\n        if (!this._asyncCheckUresponsive.isScheduled()) {\n            this._asyncCheckUresponsive.schedule();\n        }\n    }\n    _onDidReceiveAcknowledge(req) {\n        this._unresponsiveTime = Date.now() + RPCProtocol.UNRESPONSIVE_TIME;\n        this._unacknowledgedCount--;\n        if (this._unacknowledgedCount === 0) {\n            this._asyncCheckUresponsive.cancel();\n        }\n        this._setResponsiveState(0 );\n    }\n    _checkUnresponsive() {\n        if (this._unacknowledgedCount === 0) {\n            return;\n        }\n        if (Date.now() > this._unresponsiveTime) {\n            this._setResponsiveState(1 );\n        }\n        else {\n            this._asyncCheckUresponsive.schedule();\n        }\n    }\n    _setResponsiveState(newResponsiveState) {\n        if (this._responsiveState === newResponsiveState) {\n            return;\n        }\n        this._responsiveState = newResponsiveState;\n        this._onDidChangeResponsiveState.fire(this._responsiveState);\n    }\n    get responsiveState() {\n        return this._responsiveState;\n    }\n    transformIncomingURIs(obj) {\n        if (!this._uriTransformer) {\n            return obj;\n        }\n        return transformIncomingURIs(obj, this._uriTransformer);\n    }\n    getProxy(identifier) {\n        const { nid: rpcId, sid } = identifier;\n        if (!this._proxies[rpcId]) {\n            this._proxies[rpcId] = this._createProxy(rpcId, sid);\n        }\n        return this._proxies[rpcId];\n    }\n    _createProxy(rpcId, debugName) {\n        const handler = {\n            get: (target, name) => {\n                if (typeof name === 'string' && !target[name] && name.charCodeAt(0) === 36 ) {\n                    target[name] = (...myArgs) => {\n                        return this._remoteCall(rpcId, name, myArgs);\n                    };\n                }\n                if (name === _RPCProxySymbol) {\n                    return debugName;\n                }\n                return target[name];\n            }\n        };\n        return ( new Proxy(Object.create(null), handler));\n    }\n    set(identifier, value) {\n        this._locals[identifier.nid] = value;\n        return value;\n    }\n    assertRegistered(identifiers) {\n        for (let i = 0, len = identifiers.length; i < len; i++) {\n            const identifier = identifiers[i];\n            if (!this._locals[identifier.nid]) {\n                throw ( new Error(`Missing proxy instance ${identifier.sid}`));\n            }\n        }\n    }\n    _receiveOneMessage(rawmsg) {\n        if (this._isDisposed) {\n            return;\n        }\n        const msgLength = rawmsg.byteLength;\n        const buff = MessageBuffer.read(rawmsg, 0);\n        const messageType = buff.readUInt8();\n        const req = buff.readUInt32();\n        switch (messageType) {\n            case 1 :\n            case 2 : {\n                let { rpcId, method, args } = MessageIO.deserializeRequestJSONArgs(buff);\n                if (this._uriTransformer) {\n                    args = transformIncomingURIs(args, this._uriTransformer);\n                }\n                this._receiveRequest(msgLength, req, rpcId, method, args, ((messageType === 2) ));\n                break;\n            }\n            case 3 :\n            case 4 : {\n                let { rpcId, method, args } = MessageIO.deserializeRequestMixedArgs(buff);\n                if (this._uriTransformer) {\n                    args = transformIncomingURIs(args, this._uriTransformer);\n                }\n                this._receiveRequest(msgLength, req, rpcId, method, args, ((messageType === 4) ));\n                break;\n            }\n            case 5 : {\n                this._logger?.logIncoming(msgLength, req, 0 , `ack`);\n                this._onDidReceiveAcknowledge(req);\n                break;\n            }\n            case 6 : {\n                this._receiveCancel(msgLength, req);\n                break;\n            }\n            case 7 : {\n                this._receiveReply(msgLength, req, undefined);\n                break;\n            }\n            case 9 : {\n                let value = MessageIO.deserializeReplyOKJSON(buff);\n                if (this._uriTransformer) {\n                    value = transformIncomingURIs(value, this._uriTransformer);\n                }\n                this._receiveReply(msgLength, req, value);\n                break;\n            }\n            case 10 : {\n                const value = MessageIO.deserializeReplyOKJSONWithBuffers(buff, this._uriTransformer);\n                this._receiveReply(msgLength, req, value);\n                break;\n            }\n            case 8 : {\n                const value = MessageIO.deserializeReplyOKVSBuffer(buff);\n                this._receiveReply(msgLength, req, value);\n                break;\n            }\n            case 11 : {\n                let err = MessageIO.deserializeReplyErrError(buff);\n                if (this._uriTransformer) {\n                    err = transformIncomingURIs(err, this._uriTransformer);\n                }\n                this._receiveReplyErr(msgLength, req, err);\n                break;\n            }\n            case 12 : {\n                this._receiveReplyErr(msgLength, req, undefined);\n                break;\n            }\n            default:\n                console.error(`received unexpected message`);\n                console.error(rawmsg);\n        }\n    }\n    _receiveRequest(msgLength, req, rpcId, method, args, usesCancellationToken) {\n        this._logger?.logIncoming(msgLength, req, 1 , `receiveRequest ${getStringIdentifierForProxy(rpcId)}.${method}(`, args);\n        const callId = String(req);\n        let promise;\n        let cancel;\n        if (usesCancellationToken) {\n            const cancellationTokenSource = ( new CancellationTokenSource());\n            args.push(cancellationTokenSource.token);\n            promise = this._invokeHandler(rpcId, method, args);\n            cancel = () => cancellationTokenSource.cancel();\n        }\n        else {\n            promise = this._invokeHandler(rpcId, method, args);\n            cancel = noop;\n        }\n        this._cancelInvokedHandlers[callId] = cancel;\n        const msg = MessageIO.serializeAcknowledged(req);\n        this._logger?.logOutgoing(msg.byteLength, req, 1 , `ack`);\n        this._protocol.send(msg);\n        promise.then((r) => {\n            delete this._cancelInvokedHandlers[callId];\n            const msg = MessageIO.serializeReplyOK(req, r, this._uriReplacer);\n            this._logger?.logOutgoing(msg.byteLength, req, 1 , `reply:`, r);\n            this._protocol.send(msg);\n        }, (err) => {\n            delete this._cancelInvokedHandlers[callId];\n            const msg = MessageIO.serializeReplyErr(req, err);\n            this._logger?.logOutgoing(msg.byteLength, req, 1 , `replyErr:`, err);\n            this._protocol.send(msg);\n        });\n    }\n    _receiveCancel(msgLength, req) {\n        this._logger?.logIncoming(msgLength, req, 1 , `receiveCancel`);\n        const callId = String(req);\n        this._cancelInvokedHandlers[callId]?.();\n    }\n    _receiveReply(msgLength, req, value) {\n        this._logger?.logIncoming(msgLength, req, 0 , `receiveReply:`, value);\n        const callId = String(req);\n        if (!this._pendingRPCReplies.hasOwnProperty(callId)) {\n            return;\n        }\n        const pendingReply = this._pendingRPCReplies[callId];\n        delete this._pendingRPCReplies[callId];\n        pendingReply.resolveOk(value);\n    }\n    _receiveReplyErr(msgLength, req, value) {\n        this._logger?.logIncoming(msgLength, req, 0 , `receiveReplyErr:`, value);\n        const callId = String(req);\n        if (!this._pendingRPCReplies.hasOwnProperty(callId)) {\n            return;\n        }\n        const pendingReply = this._pendingRPCReplies[callId];\n        delete this._pendingRPCReplies[callId];\n        let err = undefined;\n        if (value) {\n            if (value.$isError) {\n                err = ( new Error());\n                err.name = value.name;\n                err.message = value.message;\n                err.stack = value.stack;\n            }\n            else {\n                err = value;\n            }\n        }\n        pendingReply.resolveErr(err);\n    }\n    _invokeHandler(rpcId, methodName, args) {\n        try {\n            return Promise.resolve(this._doInvokeHandler(rpcId, methodName, args));\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    _doInvokeHandler(rpcId, methodName, args) {\n        const actor = this._locals[rpcId];\n        if (!actor) {\n            throw ( new Error('Unknown actor ' + getStringIdentifierForProxy(rpcId)));\n        }\n        const method = actor[methodName];\n        if (typeof method !== 'function') {\n            throw ( new Error(\n                'Unknown method ' + methodName + ' on actor ' + getStringIdentifierForProxy(rpcId)\n            ));\n        }\n        return method.apply(actor, args);\n    }\n    _remoteCall(rpcId, methodName, args) {\n        if (this._isDisposed) {\n            return ( new CanceledLazyPromise());\n        }\n        let cancellationToken = null;\n        if (args.length > 0 && CancellationToken.isCancellationToken(args[args.length - 1])) {\n            cancellationToken = args.pop();\n        }\n        if (cancellationToken && cancellationToken.isCancellationRequested) {\n            return Promise.reject(canceled());\n        }\n        const serializedRequestArguments = MessageIO.serializeRequestArguments(args, this._uriReplacer);\n        const req = ++this._lastMessageId;\n        const callId = String(req);\n        const result = ( new LazyPromise());\n        const disposable = ( new DisposableStore());\n        if (cancellationToken) {\n            disposable.add(cancellationToken.onCancellationRequested(() => {\n                const msg = MessageIO.serializeCancel(req);\n                this._logger?.logOutgoing(msg.byteLength, req, 0 , `cancel`);\n                this._protocol.send(MessageIO.serializeCancel(req));\n            }));\n        }\n        this._pendingRPCReplies[callId] = ( new PendingRPCReply(result, disposable));\n        this._onWillSendRequest(req);\n        const msg = MessageIO.serializeRequest(req, rpcId, methodName, serializedRequestArguments, !!cancellationToken);\n        this._logger?.logOutgoing(msg.byteLength, req, 0 , `request: ${getStringIdentifierForProxy(rpcId)}.${methodName}(`, args);\n        this._protocol.send(msg);\n        return result;\n    }\n}\nclass PendingRPCReply {\n    constructor(_promise, _disposable) {\n        this._promise = _promise;\n        this._disposable = _disposable;\n    }\n    resolveOk(value) {\n        this._promise.resolveOk(value);\n        this._disposable.dispose();\n    }\n    resolveErr(err) {\n        this._promise.resolveErr(err);\n        this._disposable.dispose();\n    }\n}\nclass MessageBuffer {\n    static alloc(type, req, messageSize) {\n        const result = ( new MessageBuffer(VSBuffer.alloc(messageSize + 1  + 4 ), 0));\n        result.writeUInt8(type);\n        result.writeUInt32(req);\n        return result;\n    }\n    static read(buff, offset) {\n        return ( new MessageBuffer(buff, offset));\n    }\n    get buffer() {\n        return this._buff;\n    }\n    constructor(buff, offset) {\n        this._buff = buff;\n        this._offset = offset;\n    }\n    static sizeUInt8() {\n        return 1;\n    }\n    static { this.sizeUInt32 = 4; }\n    writeUInt8(n) {\n        this._buff.writeUInt8(n, this._offset);\n        this._offset += 1;\n    }\n    readUInt8() {\n        const n = this._buff.readUInt8(this._offset);\n        this._offset += 1;\n        return n;\n    }\n    writeUInt32(n) {\n        this._buff.writeUInt32BE(n, this._offset);\n        this._offset += 4;\n    }\n    readUInt32() {\n        const n = this._buff.readUInt32BE(this._offset);\n        this._offset += 4;\n        return n;\n    }\n    static sizeShortString(str) {\n        return 1  + str.byteLength ;\n    }\n    writeShortString(str) {\n        this._buff.writeUInt8(str.byteLength, this._offset);\n        this._offset += 1;\n        this._buff.set(str, this._offset);\n        this._offset += str.byteLength;\n    }\n    readShortString() {\n        const strByteLength = this._buff.readUInt8(this._offset);\n        this._offset += 1;\n        const strBuff = this._buff.slice(this._offset, this._offset + strByteLength);\n        const str = ( strBuff.toString());\n        this._offset += strByteLength;\n        return str;\n    }\n    static sizeLongString(str) {\n        return 4  + str.byteLength ;\n    }\n    writeLongString(str) {\n        this._buff.writeUInt32BE(str.byteLength, this._offset);\n        this._offset += 4;\n        this._buff.set(str, this._offset);\n        this._offset += str.byteLength;\n    }\n    readLongString() {\n        const strByteLength = this._buff.readUInt32BE(this._offset);\n        this._offset += 4;\n        const strBuff = this._buff.slice(this._offset, this._offset + strByteLength);\n        const str = ( strBuff.toString());\n        this._offset += strByteLength;\n        return str;\n    }\n    writeBuffer(buff) {\n        this._buff.writeUInt32BE(buff.byteLength, this._offset);\n        this._offset += 4;\n        this._buff.set(buff, this._offset);\n        this._offset += buff.byteLength;\n    }\n    static sizeVSBuffer(buff) {\n        return 4  + buff.byteLength ;\n    }\n    writeVSBuffer(buff) {\n        this._buff.writeUInt32BE(buff.byteLength, this._offset);\n        this._offset += 4;\n        this._buff.set(buff, this._offset);\n        this._offset += buff.byteLength;\n    }\n    readVSBuffer() {\n        const buffLength = this._buff.readUInt32BE(this._offset);\n        this._offset += 4;\n        const buff = this._buff.slice(this._offset, this._offset + buffLength);\n        this._offset += buffLength;\n        return buff;\n    }\n    static sizeMixedArray(arr) {\n        let size = 0;\n        size += 1;\n        for (let i = 0, len = arr.length; i < len; i++) {\n            const el = arr[i];\n            size += 1;\n            switch (el.type) {\n                case 1 :\n                    size += this.sizeLongString(el.value);\n                    break;\n                case 2 :\n                    size += this.sizeVSBuffer(el.value);\n                    break;\n                case 3 :\n                    size += this.sizeUInt32;\n                    size += this.sizeLongString(el.value);\n                    for (let i = 0; i < el.buffers.length; ++i) {\n                        size += this.sizeVSBuffer(el.buffers[i]);\n                    }\n                    break;\n            }\n        }\n        return size;\n    }\n    writeMixedArray(arr) {\n        this._buff.writeUInt8(arr.length, this._offset);\n        this._offset += 1;\n        for (let i = 0, len = arr.length; i < len; i++) {\n            const el = arr[i];\n            switch (el.type) {\n                case 1 :\n                    this.writeUInt8(1 );\n                    this.writeLongString(el.value);\n                    break;\n                case 2 :\n                    this.writeUInt8(2 );\n                    this.writeVSBuffer(el.value);\n                    break;\n                case 3 :\n                    this.writeUInt8(3 );\n                    this.writeUInt32(el.buffers.length);\n                    this.writeLongString(el.value);\n                    for (let i = 0; i < el.buffers.length; ++i) {\n                        this.writeBuffer(el.buffers[i]);\n                    }\n                    break;\n                case 4 :\n                    this.writeUInt8(4 );\n                    break;\n            }\n        }\n    }\n    readMixedArray() {\n        const arrLen = this._buff.readUInt8(this._offset);\n        this._offset += 1;\n        const arr = ( new Array(arrLen));\n        for (let i = 0; i < arrLen; i++) {\n            const argType = this.readUInt8();\n            switch (argType) {\n                case 1 :\n                    arr[i] = this.readLongString();\n                    break;\n                case 2 :\n                    arr[i] = this.readVSBuffer();\n                    break;\n                case 3 : {\n                    const bufferCount = this.readUInt32();\n                    const jsonString = this.readLongString();\n                    const buffers = [];\n                    for (let i = 0; i < bufferCount; ++i) {\n                        buffers.push(this.readVSBuffer());\n                    }\n                    arr[i] = ( new SerializableObjectWithBuffers(parseJsonAndRestoreBufferRefs(jsonString, buffers, null)));\n                    break;\n                }\n                case 4 :\n                    arr[i] = undefined;\n                    break;\n            }\n        }\n        return arr;\n    }\n}\nclass MessageIO {\n    static _useMixedArgSerialization(arr) {\n        for (let i = 0, len = arr.length; i < len; i++) {\n            if (arr[i] instanceof VSBuffer) {\n                return true;\n            }\n            if (arr[i] instanceof SerializableObjectWithBuffers) {\n                return true;\n            }\n            if (typeof arr[i] === 'undefined') {\n                return true;\n            }\n        }\n        return false;\n    }\n    static serializeRequestArguments(args, replacer) {\n        if (this._useMixedArgSerialization(args)) {\n            const massagedArgs = [];\n            for (let i = 0, len = args.length; i < len; i++) {\n                const arg = args[i];\n                if (arg instanceof VSBuffer) {\n                    massagedArgs[i] = { type: 2 , value: arg };\n                }\n                else if (typeof arg === 'undefined') {\n                    massagedArgs[i] = { type: 4  };\n                }\n                else if (arg instanceof SerializableObjectWithBuffers) {\n                    const { jsonString, referencedBuffers } = stringifyJsonWithBufferRefs(arg.value, replacer);\n                    massagedArgs[i] = { type: 3 , value: VSBuffer.fromString(jsonString), buffers: referencedBuffers };\n                }\n                else {\n                    massagedArgs[i] = { type: 1 , value: VSBuffer.fromString(stringify(arg, replacer)) };\n                }\n            }\n            return {\n                type: 1 ,\n                args: massagedArgs,\n            };\n        }\n        return {\n            type: 0 ,\n            args: stringify(args, replacer)\n        };\n    }\n    static serializeRequest(req, rpcId, method, serializedArgs, usesCancellationToken) {\n        switch (serializedArgs.type) {\n            case 0 :\n                return this._requestJSONArgs(req, rpcId, method, serializedArgs.args, usesCancellationToken);\n            case 1 :\n                return this._requestMixedArgs(req, rpcId, method, serializedArgs.args, usesCancellationToken);\n        }\n    }\n    static _requestJSONArgs(req, rpcId, method, args, usesCancellationToken) {\n        const methodBuff = VSBuffer.fromString(method);\n        const argsBuff = VSBuffer.fromString(args);\n        let len = 0;\n        len += MessageBuffer.sizeUInt8();\n        len += MessageBuffer.sizeShortString(methodBuff);\n        len += MessageBuffer.sizeLongString(argsBuff);\n        const result = MessageBuffer.alloc(usesCancellationToken ? 2  : 1 , req, len);\n        result.writeUInt8(rpcId);\n        result.writeShortString(methodBuff);\n        result.writeLongString(argsBuff);\n        return result.buffer;\n    }\n    static deserializeRequestJSONArgs(buff) {\n        const rpcId = buff.readUInt8();\n        const method = buff.readShortString();\n        const args = buff.readLongString();\n        return {\n            rpcId: rpcId,\n            method: method,\n            args: JSON.parse(args)\n        };\n    }\n    static _requestMixedArgs(req, rpcId, method, args, usesCancellationToken) {\n        const methodBuff = VSBuffer.fromString(method);\n        let len = 0;\n        len += MessageBuffer.sizeUInt8();\n        len += MessageBuffer.sizeShortString(methodBuff);\n        len += MessageBuffer.sizeMixedArray(args);\n        const result = MessageBuffer.alloc(usesCancellationToken ? 4  : 3 , req, len);\n        result.writeUInt8(rpcId);\n        result.writeShortString(methodBuff);\n        result.writeMixedArray(args);\n        return result.buffer;\n    }\n    static deserializeRequestMixedArgs(buff) {\n        const rpcId = buff.readUInt8();\n        const method = buff.readShortString();\n        const rawargs = buff.readMixedArray();\n        const args = ( new Array(rawargs.length));\n        for (let i = 0, len = rawargs.length; i < len; i++) {\n            const rawarg = rawargs[i];\n            if (typeof rawarg === 'string') {\n                args[i] = JSON.parse(rawarg);\n            }\n            else {\n                args[i] = rawarg;\n            }\n        }\n        return {\n            rpcId: rpcId,\n            method: method,\n            args: args\n        };\n    }\n    static serializeAcknowledged(req) {\n        return MessageBuffer.alloc(5 , req, 0).buffer;\n    }\n    static serializeCancel(req) {\n        return MessageBuffer.alloc(6 , req, 0).buffer;\n    }\n    static serializeReplyOK(req, res, replacer) {\n        if (typeof res === 'undefined') {\n            return this._serializeReplyOKEmpty(req);\n        }\n        else if (res instanceof VSBuffer) {\n            return this._serializeReplyOKVSBuffer(req, res);\n        }\n        else if (res instanceof SerializableObjectWithBuffers) {\n            const { jsonString, referencedBuffers } = stringifyJsonWithBufferRefs(res.value, replacer, true);\n            return this._serializeReplyOKJSONWithBuffers(req, jsonString, referencedBuffers);\n        }\n        else {\n            return this._serializeReplyOKJSON(req, safeStringify(res, replacer));\n        }\n    }\n    static _serializeReplyOKEmpty(req) {\n        return MessageBuffer.alloc(7 , req, 0).buffer;\n    }\n    static _serializeReplyOKVSBuffer(req, res) {\n        let len = 0;\n        len += MessageBuffer.sizeVSBuffer(res);\n        const result = MessageBuffer.alloc(8 , req, len);\n        result.writeVSBuffer(res);\n        return result.buffer;\n    }\n    static deserializeReplyOKVSBuffer(buff) {\n        return buff.readVSBuffer();\n    }\n    static _serializeReplyOKJSON(req, res) {\n        const resBuff = VSBuffer.fromString(res);\n        let len = 0;\n        len += MessageBuffer.sizeLongString(resBuff);\n        const result = MessageBuffer.alloc(9 , req, len);\n        result.writeLongString(resBuff);\n        return result.buffer;\n    }\n    static _serializeReplyOKJSONWithBuffers(req, res, buffers) {\n        const resBuff = VSBuffer.fromString(res);\n        let len = 0;\n        len += MessageBuffer.sizeUInt32;\n        len += MessageBuffer.sizeLongString(resBuff);\n        for (const buffer of buffers) {\n            len += MessageBuffer.sizeVSBuffer(buffer);\n        }\n        const result = MessageBuffer.alloc(10 , req, len);\n        result.writeUInt32(buffers.length);\n        result.writeLongString(resBuff);\n        for (const buffer of buffers) {\n            result.writeBuffer(buffer);\n        }\n        return result.buffer;\n    }\n    static deserializeReplyOKJSON(buff) {\n        const res = buff.readLongString();\n        return JSON.parse(res);\n    }\n    static deserializeReplyOKJSONWithBuffers(buff, uriTransformer) {\n        const bufferCount = buff.readUInt32();\n        const res = buff.readLongString();\n        const buffers = [];\n        for (let i = 0; i < bufferCount; ++i) {\n            buffers.push(buff.readVSBuffer());\n        }\n        return ( new SerializableObjectWithBuffers(parseJsonAndRestoreBufferRefs(res, buffers, uriTransformer)));\n    }\n    static serializeReplyErr(req, err) {\n        const errStr = (err ? safeStringify(transformErrorForSerialization(err), null) : undefined);\n        if (typeof errStr !== 'string') {\n            return this._serializeReplyErrEmpty(req);\n        }\n        const errBuff = VSBuffer.fromString(errStr);\n        let len = 0;\n        len += MessageBuffer.sizeLongString(errBuff);\n        const result = MessageBuffer.alloc(11 , req, len);\n        result.writeLongString(errBuff);\n        return result.buffer;\n    }\n    static deserializeReplyErrError(buff) {\n        const err = buff.readLongString();\n        return JSON.parse(err);\n    }\n    static _serializeReplyErrEmpty(req) {\n        return MessageBuffer.alloc(12 , req, 0).buffer;\n    }\n}\nexport { RPCProtocol, parseJsonAndRestoreBufferRefs, stringifyJsonWithBufferRefs };\n","import { joinPath } from '../../../../base/common/resources.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { isCancellationError, onUnexpectedError } from '../../../../base/common/errors.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { QueryBuilder } from '../../search/common/queryBuilder.js';\nimport { ISearchService } from '../../search/common/search.service.js';\nimport { toWorkspaceFolder } from '../../../../platform/workspace/common/workspace.js';\nimport { promiseWithResolvers } from '../../../../base/common/async.js';\nconst WORKSPACE_CONTAINS_TIMEOUT = 7000;\nfunction checkActivateWorkspaceContainsExtension(host, desc) {\n    const activationEvents = desc.activationEvents;\n    if (!activationEvents) {\n        return Promise.resolve(undefined);\n    }\n    const fileNames = [];\n    const globPatterns = [];\n    for (const activationEvent of activationEvents) {\n        if (/^workspaceContains:/.test(activationEvent)) {\n            const fileNameOrGlob = activationEvent.substr('workspaceContains:'.length);\n            if (fileNameOrGlob.indexOf('*') >= 0 || fileNameOrGlob.indexOf('?') >= 0 || host.forceUsingSearch) {\n                globPatterns.push(fileNameOrGlob);\n            }\n            else {\n                fileNames.push(fileNameOrGlob);\n            }\n        }\n    }\n    if (fileNames.length === 0 && globPatterns.length === 0) {\n        return Promise.resolve(undefined);\n    }\n    const { promise, resolve } = promiseWithResolvers();\n    const activate = (activationEvent) => resolve({ activationEvent });\n    const fileNamePromise = Promise.all(( fileNames.map((fileName) => _activateIfFileName(host, fileName, activate)))).then(() => { });\n    const globPatternPromise = _activateIfGlobPatterns(host, desc.identifier, globPatterns, activate);\n    Promise.all([fileNamePromise, globPatternPromise]).then(() => {\n        resolve(undefined);\n    });\n    return promise;\n}\nasync function _activateIfFileName(host, fileName, activate) {\n    for (const uri of host.folders) {\n        if (await host.exists(joinPath(URI.revive(uri), fileName))) {\n            activate(`workspaceContains:${fileName}`);\n            return;\n        }\n    }\n}\nasync function _activateIfGlobPatterns(host, extensionId, globPatterns, activate) {\n    if (globPatterns.length === 0) {\n        return Promise.resolve(undefined);\n    }\n    const tokenSource = ( new CancellationTokenSource());\n    const searchP = host.checkExists(host.folders, globPatterns, tokenSource.token);\n    const timer = setTimeout(async () => {\n        tokenSource.cancel();\n        host.logService.info(`Not activating extension '${extensionId.value}': Timed out while searching for 'workspaceContains' pattern ${globPatterns.join(',')}`);\n    }, WORKSPACE_CONTAINS_TIMEOUT);\n    let exists = false;\n    try {\n        exists = await searchP;\n    }\n    catch (err) {\n        if (!isCancellationError(err)) {\n            onUnexpectedError(err);\n        }\n    }\n    tokenSource.dispose();\n    clearTimeout(timer);\n    if (exists) {\n        activate(`workspaceContains:${globPatterns.join(',')}`);\n    }\n}\nfunction checkGlobFileExists(accessor, folders, includes, token) {\n    const instantiationService = accessor.get(IInstantiationService);\n    const searchService = accessor.get(ISearchService);\n    const queryBuilder = instantiationService.createInstance(QueryBuilder);\n    const query = queryBuilder.file(( folders.map(folder => toWorkspaceFolder(URI.revive(folder)))), {\n        _reason: 'checkExists',\n        includePattern: includes,\n        exists: true\n    });\n    return searchService.fileSearch(query, token).then(result => {\n        return !!result.limitHit;\n    }, err => {\n        if (!isCancellationError(err)) {\n            return Promise.reject(err);\n        }\n        return false;\n    });\n}\nexport { checkActivateWorkspaceContainsExtension, checkGlobFileExists };\n","const _bootstrapFnSource = ( (function _bootstrapFn(workerUrl) {\n    const listener = (event) => {\n        globalThis.removeEventListener('message', listener);\n        const port = event.data;\n        Object.defineProperties(globalThis, {\n            'postMessage': {\n                value(data, transferOrOptions) {\n                    port.postMessage(data, transferOrOptions);\n                }\n            },\n            'onmessage': {\n                get() {\n                    return port.onmessage;\n                },\n                set(value) {\n                    port.onmessage = value;\n                }\n            }\n        });\n        port.addEventListener('message', msg => {\n            globalThis.dispatchEvent(( new MessageEvent(\n                'message',\n                { data: msg.data, ports: msg.ports ? [...msg.ports] : undefined }\n            )));\n        });\n        port.start();\n        globalThis.Worker = class {\n            constructor() { throw ( new TypeError('Nested workers from within nested worker are NOT supported.')); }\n        };\n        importScripts(workerUrl);\n    };\n    globalThis.addEventListener('message', listener);\n}).toString());\nclass NestedWorker extends EventTarget {\n    constructor(nativePostMessage, stringOrUrl, options) {\n        super();\n        this.onmessage = null;\n        this.onmessageerror = null;\n        this.onerror = null;\n        const bootstrap = `((${_bootstrapFnSource})('${stringOrUrl}'))`;\n        const blob = ( new Blob([bootstrap], { type: 'application/javascript' }));\n        const blobUrl = URL.createObjectURL(blob);\n        const channel = ( new MessageChannel());\n        const id = blobUrl;\n        const msg = {\n            type: '_newWorker',\n            id,\n            port: channel.port2,\n            url: blobUrl,\n            options,\n        };\n        nativePostMessage(msg, [channel.port2]);\n        this.postMessage = channel.port1.postMessage.bind(channel.port1);\n        this.terminate = () => {\n            const msg = {\n                type: '_terminateWorker',\n                id\n            };\n            nativePostMessage(msg);\n            URL.revokeObjectURL(blobUrl);\n            channel.port1.close();\n            channel.port2.close();\n        };\n        Object.defineProperties(this, {\n            'onmessage': {\n                get() {\n                    return channel.port1.onmessage;\n                },\n                set(value) {\n                    channel.port1.onmessage = value;\n                }\n            },\n            'onmessageerror': {\n                get() {\n                    return channel.port1.onmessageerror;\n                },\n                set(value) {\n                    channel.port1.onmessageerror = value;\n                }\n            },\n        });\n        channel.port1.addEventListener('messageerror', evt => {\n            const msgEvent = ( new MessageEvent('messageerror', { data: evt.data }));\n            this.dispatchEvent(msgEvent);\n        });\n        channel.port1.addEventListener('message', evt => {\n            const msgEvent = ( new MessageEvent('message', { data: evt.data }));\n            this.dispatchEvent(msgEvent);\n        });\n        channel.port1.start();\n    }\n}\nexport { NestedWorker };\n","import { encodeBase64, VSBuffer, decodeBase64 } from '../../../../base/common/buffer.js';\nimport { ResourceMap } from '../../../../base/common/map.js';\nimport { Schemas } from '../../../../base/common/network.js';\nimport '../../../../platform/instantiation/common/instantiation.js';\nconst _lengths = ['W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f'];\nconst _padRegexp = ( new RegExp(`^[${_lengths.join('')}]+`));\nconst _radix = 7;\nfunction parse(cell) {\n    if (cell.scheme !== Schemas.vscodeNotebookCell) {\n        return undefined;\n    }\n    const idx = cell.fragment.indexOf('s');\n    if (idx < 0) {\n        return undefined;\n    }\n    const handle = parseInt(cell.fragment.substring(0, idx).replace(_padRegexp, ''), _radix);\n    const _scheme = ( decodeBase64(cell.fragment.substring(idx + 1)).toString());\n    if (isNaN(handle)) {\n        return undefined;\n    }\n    return {\n        handle,\n        notebook: cell.with({ scheme: _scheme, fragment: null })\n    };\n}\nfunction generate(notebook, handle) {\n    const s = ( handle.toString(_radix));\n    const p = s.length < _lengths.length ? _lengths[s.length - 1] : 'z';\n    const fragment = `${p}${s}s${encodeBase64(VSBuffer.fromString(notebook.scheme), true, true)}`;\n    return notebook.with({ scheme: Schemas.vscodeNotebookCell, fragment });\n}\nfunction parseMetadataUri(metadata) {\n    if (metadata.scheme !== Schemas.vscodeNotebookMetadata) {\n        return undefined;\n    }\n    const _scheme = ( decodeBase64(metadata.fragment).toString());\n    return metadata.with({ scheme: _scheme, fragment: null });\n}\nfunction generateMetadataUri(notebook) {\n    const fragment = `${encodeBase64(VSBuffer.fromString(notebook.scheme), true, true)}`;\n    return notebook.with({ scheme: Schemas.vscodeNotebookMetadata, fragment });\n}\nclass NotebookDocumentWorkbenchService {\n    constructor() {\n        this._documents = ( new ResourceMap());\n    }\n    getNotebook(uri) {\n        if (uri.scheme === Schemas.vscodeNotebookCell) {\n            const cellUri = parse(uri);\n            if (cellUri) {\n                const document = this._documents.get(cellUri.notebook);\n                if (document) {\n                    return document;\n                }\n            }\n        }\n        return this._documents.get(uri);\n    }\n    addNotebookDocument(document) {\n        this._documents.set(document.uri, document);\n    }\n    removeNotebookDocument(document) {\n        this._documents.delete(document.uri);\n    }\n}\nexport { NotebookDocumentWorkbenchService, generate, generateMetadataUri, parse, parseMetadataUri };\n","import { Emitter } from '../../../../base/common/event.js';\nimport { Registry } from '../../../../platform/registry/common/platform.js';\nimport { RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\nconst OUTPUT_MIME = 'text/x-code-output';\nconst OUTPUT_MODE_ID = 'Log';\nconst LOG_MIME = 'text/x-code-log-output';\nconst LOG_MODE_ID = 'log';\nconst OUTPUT_VIEW_ID = 'workbench.panel.output';\nconst CONTEXT_IN_OUTPUT = ( new RawContextKey('inOutput', false));\nconst CONTEXT_ACTIVE_FILE_OUTPUT = ( new RawContextKey('activeLogOutput', false));\nconst CONTEXT_ACTIVE_OUTPUT_LEVEL_SETTABLE = ( new RawContextKey('activeLogOutput.levelSettable', false));\nconst CONTEXT_ACTIVE_OUTPUT_LEVEL = ( new RawContextKey('activeLogOutput.level', ''));\nconst CONTEXT_ACTIVE_OUTPUT_LEVEL_IS_DEFAULT = ( new RawContextKey('activeLogOutput.levelIsDefault', false));\nconst CONTEXT_OUTPUT_SCROLL_LOCK = ( new RawContextKey(`outputView.scrollLock`, false));\nvar OutputChannelUpdateMode;\n( (function(OutputChannelUpdateMode) {\n    OutputChannelUpdateMode[OutputChannelUpdateMode[\"Append\"] = 1] = \"Append\";\n    OutputChannelUpdateMode[OutputChannelUpdateMode[\"Replace\"] = 2] = \"Replace\";\n    OutputChannelUpdateMode[OutputChannelUpdateMode[\"Clear\"] = 3] = \"Clear\";\n})(OutputChannelUpdateMode || (OutputChannelUpdateMode = {})));\nconst Extensions = {\n    OutputChannels: 'workbench.contributions.outputChannels'\n};\nclass OutputChannelRegistry {\n    constructor() {\n        this.channels = ( new Map());\n        this._onDidRegisterChannel = ( new Emitter());\n        this.onDidRegisterChannel = this._onDidRegisterChannel.event;\n        this._onDidRemoveChannel = ( new Emitter());\n        this.onDidRemoveChannel = this._onDidRemoveChannel.event;\n    }\n    registerChannel(descriptor) {\n        if (!( this.channels.has(descriptor.id))) {\n            this.channels.set(descriptor.id, descriptor);\n            this._onDidRegisterChannel.fire(descriptor.id);\n        }\n    }\n    getChannels() {\n        const result = [];\n        this.channels.forEach(value => result.push(value));\n        return result;\n    }\n    getChannel(id) {\n        return this.channels.get(id);\n    }\n    removeChannel(id) {\n        this.channels.delete(id);\n        this._onDidRemoveChannel.fire(id);\n    }\n}\nRegistry.add(Extensions.OutputChannels, ( new OutputChannelRegistry()));\nconst ACTIVE_OUTPUT_CHANNEL_CONTEXT = ( new RawContextKey('activeOutputChannel', ''));\nexport { ACTIVE_OUTPUT_CHANNEL_CONTEXT, CONTEXT_ACTIVE_FILE_OUTPUT, CONTEXT_ACTIVE_OUTPUT_LEVEL, CONTEXT_ACTIVE_OUTPUT_LEVEL_IS_DEFAULT, CONTEXT_ACTIVE_OUTPUT_LEVEL_SETTABLE, CONTEXT_IN_OUTPUT, CONTEXT_OUTPUT_SCROLL_LOCK, Extensions, LOG_MIME, LOG_MODE_ID, OUTPUT_MIME, OUTPUT_MODE_ID, OUTPUT_VIEW_ID, OutputChannelUpdateMode };\n","import { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nconst IPathService = ( createDecorator('pathService'));\nexport { IPathService };\n","import { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nconst IRemoteAgentService = ( createDecorator('remoteAgentService'));\nexport { IRemoteAgentService };\n","import { basename, posix, dirname } from '../../../../base/common/path.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { toErrorMessage } from '../../../../base/common/errorMessage.js';\nimport { parse } from '../../../../base/common/glob.js';\nimport { joinPath } from '../../../../base/common/resources.js';\nimport { StopWatch } from '../../../../base/common/stopwatch.js';\nimport { resolvePatternsForProvider, excludeToGlobPattern, DEFAULT_MAX_SEARCH_RESULTS, QueryGlobTester, hasSiblingFn } from './search.js';\nimport { TernarySearchTree } from '../../../../base/common/ternarySearchTree.js';\nimport { OldFileSearchProviderConverter } from './searchExtConversionTypes.js';\nclass FileSearchEngine {\n    constructor(config, provider, sessionLifecycle) {\n        this.config = config;\n        this.provider = provider;\n        this.sessionLifecycle = sessionLifecycle;\n        this.isLimitHit = false;\n        this.resultCount = 0;\n        this.isCanceled = false;\n        this.filePattern = config.filePattern;\n        this.includePattern = config.includePattern && parse(config.includePattern);\n        this.maxResults = config.maxResults || undefined;\n        this.exists = config.exists;\n        this.activeCancellationTokens = ( new Set());\n        this.globalExcludePattern = config.excludePattern && parse(config.excludePattern);\n    }\n    cancel() {\n        this.isCanceled = true;\n        this.activeCancellationTokens.forEach(t => t.cancel());\n        this.activeCancellationTokens = ( new Set());\n    }\n    search(_onResult) {\n        const folderQueries = this.config.folderQueries || [];\n        return ( new Promise((resolve, reject) => {\n            const onResult = (match) => {\n                this.resultCount++;\n                _onResult(match);\n            };\n            if (this.isCanceled) {\n                return resolve({ limitHit: this.isLimitHit });\n            }\n            if (this.config.extraFileResources) {\n                this.config.extraFileResources\n                    .forEach(extraFile => {\n                    const extraFileStr = ( extraFile.toString());\n                    const basename$1 = basename(extraFileStr);\n                    if (this.globalExcludePattern && this.globalExcludePattern(extraFileStr, basename$1)) {\n                        return;\n                    }\n                    this.matchFile(onResult, { base: extraFile, basename: basename$1 });\n                });\n            }\n            this.doSearch(folderQueries, onResult).then(stats => {\n                resolve({\n                    limitHit: this.isLimitHit,\n                    stats: stats || undefined\n                });\n            }, (err) => {\n                reject(( new Error(toErrorMessage(err))));\n            });\n        }));\n    }\n    async doSearch(fqs, onResult) {\n        const cancellation = ( new CancellationTokenSource());\n        const folderOptions = ( fqs.map(fq => this.getSearchOptionsForFolder(fq)));\n        const session = this.provider instanceof OldFileSearchProviderConverter ? this.sessionLifecycle?.tokenSource.token : this.sessionLifecycle?.obj;\n        const options = {\n            folderOptions,\n            maxResults: this.config.maxResults ?? DEFAULT_MAX_SEARCH_RESULTS,\n            session\n        };\n        const folderMappings = TernarySearchTree.forUris();\n        fqs.forEach(fq => {\n            const queryTester = ( new QueryGlobTester(this.config, fq));\n            const noSiblingsClauses = !queryTester.hasSiblingExcludeClauses();\n            folderMappings.set(fq.folder, { queryTester, noSiblingsClauses, folder: fq.folder, tree: this.initDirectoryTree() });\n        });\n        let providerSW;\n        try {\n            this.activeCancellationTokens.add(cancellation);\n            providerSW = StopWatch.create();\n            const results = await this.provider.provideFileSearchResults(this.config.filePattern || '', options, cancellation.token);\n            const providerTime = providerSW.elapsed();\n            const postProcessSW = StopWatch.create();\n            if (this.isCanceled && !this.isLimitHit) {\n                return null;\n            }\n            if (results) {\n                results.forEach(result => {\n                    const fqFolderInfo = folderMappings.findSubstr(result);\n                    const relativePath = posix.relative(fqFolderInfo.folder.path, result.path);\n                    if (fqFolderInfo.noSiblingsClauses) {\n                        const basename$1 = basename(result.path);\n                        this.matchFile(onResult, { base: fqFolderInfo.folder, relativePath, basename: basename$1 });\n                        return;\n                    }\n                    this.addDirectoryEntries(fqFolderInfo.tree, fqFolderInfo.folder, relativePath, onResult);\n                });\n            }\n            if (this.isCanceled && !this.isLimitHit) {\n                return null;\n            }\n            folderMappings.forEach(e => {\n                this.matchDirectoryTree(e.tree, e.queryTester, onResult);\n            });\n            return {\n                providerTime,\n                postProcessTime: postProcessSW.elapsed()\n            };\n        }\n        finally {\n            cancellation.dispose();\n            this.activeCancellationTokens.delete(cancellation);\n        }\n    }\n    getSearchOptionsForFolder(fq) {\n        const includes = resolvePatternsForProvider(this.config.includePattern, fq.includePattern);\n        let excludePattern = fq.excludePattern?.map(e => ({\n            folder: e.folder,\n            patterns: resolvePatternsForProvider(this.config.excludePattern, e.pattern)\n        }));\n        if (!excludePattern?.length) {\n            excludePattern = [{\n                    folder: undefined,\n                    patterns: resolvePatternsForProvider(this.config.excludePattern, undefined)\n                }];\n        }\n        const excludes = excludeToGlobPattern(excludePattern);\n        return {\n            folder: fq.folder,\n            excludes,\n            includes,\n            useIgnoreFiles: {\n                local: !fq.disregardIgnoreFiles,\n                parent: !fq.disregardParentIgnoreFiles,\n                global: !fq.disregardGlobalIgnoreFiles\n            },\n            followSymlinks: !fq.ignoreSymlinks,\n        };\n    }\n    initDirectoryTree() {\n        const tree = {\n            rootEntries: [],\n            pathToEntries: Object.create(null)\n        };\n        tree.pathToEntries['.'] = tree.rootEntries;\n        return tree;\n    }\n    addDirectoryEntries({ pathToEntries }, base, relativeFile, onResult) {\n        if (relativeFile === this.filePattern) {\n            const basename$1 = basename(this.filePattern);\n            this.matchFile(onResult, { base: base, relativePath: this.filePattern, basename: basename$1 });\n        }\n        function add(relativePath) {\n            const basename$1 = basename(relativePath);\n            const dirname$1 = dirname(relativePath);\n            let entries = pathToEntries[dirname$1];\n            if (!entries) {\n                entries = pathToEntries[dirname$1] = [];\n                add(dirname$1);\n            }\n            entries.push({\n                base,\n                relativePath,\n                basename: basename$1\n            });\n        }\n        add(relativeFile);\n    }\n    matchDirectoryTree({ rootEntries, pathToEntries }, queryTester, onResult) {\n        const self = this;\n        const filePattern = this.filePattern;\n        function matchDirectory(entries) {\n            const hasSibling = hasSiblingFn(() => ( entries.map(entry => entry.basename)));\n            for (let i = 0, n = entries.length; i < n; i++) {\n                const entry = entries[i];\n                const { relativePath, basename } = entry;\n                if (queryTester.matchesExcludesSync(relativePath, basename, filePattern !== basename ? hasSibling : undefined)) {\n                    continue;\n                }\n                const sub = pathToEntries[relativePath];\n                if (sub) {\n                    matchDirectory(sub);\n                }\n                else {\n                    if (relativePath === filePattern) {\n                        continue;\n                    }\n                    self.matchFile(onResult, entry);\n                }\n                if (self.isLimitHit) {\n                    break;\n                }\n            }\n        }\n        matchDirectory(rootEntries);\n    }\n    matchFile(onResult, candidate) {\n        if (!this.includePattern || (candidate.relativePath && this.includePattern(candidate.relativePath, candidate.basename))) {\n            if (this.exists || (this.maxResults && this.resultCount >= this.maxResults)) {\n                this.isLimitHit = true;\n                this.cancel();\n            }\n            if (!this.isLimitHit) {\n                onResult(candidate);\n            }\n        }\n    }\n}\nclass SessionLifecycle {\n    constructor() {\n        this._obj = ( new Object());\n        this.tokenSource = ( new CancellationTokenSource());\n    }\n    get obj() {\n        if (this._obj) {\n            return this._obj;\n        }\n        throw ( new Error('Session object has been dereferenced.'));\n    }\n    cancel() {\n        this.tokenSource.cancel();\n        this._obj = undefined;\n    }\n}\nclass FileSearchManager {\n    constructor() {\n        this.sessions = ( new Map());\n    }\n    static { this.BATCH_SIZE = 512; }\n    fileSearch(config, provider, onBatch, token) {\n        const sessionTokenSource = this.getSessionTokenSource(config.cacheKey);\n        const engine = ( new FileSearchEngine(config, provider, sessionTokenSource));\n        let resultCount = 0;\n        const onInternalResult = (batch) => {\n            resultCount += batch.length;\n            onBatch(( batch.map(m => this.rawMatchToSearchItem(m))));\n        };\n        return this.doSearch(engine, FileSearchManager.BATCH_SIZE, onInternalResult, token).then(result => {\n            return {\n                limitHit: result.limitHit,\n                stats: result.stats ? {\n                    fromCache: false,\n                    type: 'fileSearchProvider',\n                    resultCount,\n                    detailStats: result.stats\n                } : undefined,\n                messages: []\n            };\n        });\n    }\n    clearCache(cacheKey) {\n        this.sessions.get(cacheKey)?.cancel();\n        this.sessions.delete(cacheKey);\n    }\n    getSessionTokenSource(cacheKey) {\n        if (!cacheKey) {\n            return undefined;\n        }\n        if (!( this.sessions.has(cacheKey))) {\n            this.sessions.set(cacheKey, ( new SessionLifecycle()));\n        }\n        return this.sessions.get(cacheKey);\n    }\n    rawMatchToSearchItem(match) {\n        if (match.relativePath) {\n            return {\n                resource: joinPath(match.base, match.relativePath)\n            };\n        }\n        else {\n            return {\n                resource: match.base\n            };\n        }\n    }\n    doSearch(engine, batchSize, onResultBatch, token) {\n        const listener = token.onCancellationRequested(() => {\n            engine.cancel();\n        });\n        const _onResult = (match) => {\n            if (match) {\n                batch.push(match);\n                if (batchSize > 0 && batch.length >= batchSize) {\n                    onResultBatch(batch);\n                    batch = [];\n                }\n            }\n        };\n        let batch = [];\n        return engine.search(_onResult).then(result => {\n            if (batch.length) {\n                onResultBatch(batch);\n            }\n            listener.dispose();\n            return result;\n        }, error => {\n            if (batch.length) {\n                onResultBatch(batch);\n            }\n            listener.dispose();\n            return Promise.reject(error);\n        });\n    }\n}\nexport { FileSearchManager };\n","import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';\nimport { coalesce, distinct } from '../../../../base/common/arrays.js';\nimport { groupBy } from '../../../../base/common/collections.js';\nimport { splitGlobAware } from '../../../../base/common/glob.js';\nimport { untildify } from '../../../../base/common/labels.js';\nimport { ResourceMap } from '../../../../base/common/map.js';\nimport { Schemas } from '../../../../base/common/network.js';\nimport { relative, isAbsolute, normalize, posix } from '../../../../base/common/path.js';\nimport { isAbsolutePath, isEqual, basename, relativePath } from '../../../../base/common/resources.js';\nimport { containsUppercaseCharacter, escapeRegExpCharacters, rtrim } from '../../../../base/common/strings.js';\nimport { assertIsDefined, isDefined } from '../../../../base/common/types.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { isMultilineRegexSource } from '../../../../editor/common/model/textModelSearch.js';\nimport { localize } from '../../../../nls.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.service.js';\nimport { ILogService } from '../../../../platform/log/common/log.service.js';\nimport { IUriIdentityService } from '../../../../platform/uriIdentity/common/uriIdentity.service.js';\nimport { toWorkspaceFolder } from '../../../../platform/workspace/common/workspace.js';\nimport { IWorkspaceContextService } from '../../../../platform/workspace/common/workspace.service.js';\nimport { IEditorGroupsService } from '../../editor/common/editorGroupsService.service.js';\nimport { IPathService } from '../../path/common/pathService.service.js';\nimport { pathIncludedInQuery, getExcludes } from './search.js';\nfunction isISearchPatternBuilder(object) {\n    return (typeof object === 'object' && 'uri' in object && 'pattern' in object);\n}\nlet QueryBuilder = class QueryBuilder {\n    constructor(configurationService, workspaceContextService, editorGroupsService, logService, pathService, uriIdentityService) {\n        this.configurationService = configurationService;\n        this.workspaceContextService = workspaceContextService;\n        this.editorGroupsService = editorGroupsService;\n        this.logService = logService;\n        this.pathService = pathService;\n        this.uriIdentityService = uriIdentityService;\n    }\n    aiText(contentPattern, folderResources, options = {}) {\n        const commonQuery = this.commonQuery(folderResources?.map(toWorkspaceFolder), options);\n        return {\n            ...commonQuery,\n            type: 3 ,\n            contentPattern,\n        };\n    }\n    text(contentPattern, folderResources, options = {}) {\n        contentPattern = this.getContentPattern(contentPattern, options);\n        const searchConfig = this.configurationService.getValue();\n        const fallbackToPCRE = folderResources && ( (folderResources.some(folder => {\n            const folderConfig = this.configurationService.getValue({ resource: folder });\n            return !folderConfig.search.useRipgrep;\n        })));\n        const commonQuery = this.commonQuery(folderResources?.map(toWorkspaceFolder), options);\n        return {\n            ...commonQuery,\n            type: 2 ,\n            contentPattern,\n            previewOptions: options.previewOptions,\n            maxFileSize: options.maxFileSize,\n            usePCRE2: searchConfig.search.usePCRE2 || fallbackToPCRE || false,\n            surroundingContext: options.surroundingContext,\n            userDisabledExcludesAndIgnoreFiles: options.disregardExcludeSettings && options.disregardIgnoreFiles,\n        };\n    }\n    getContentPattern(inputPattern, options) {\n        const searchConfig = this.configurationService.getValue();\n        if (inputPattern.isRegExp) {\n            inputPattern.pattern = inputPattern.pattern.replace(/\\r?\\n/g, '\\\\n');\n        }\n        const newPattern = {\n            ...inputPattern,\n            wordSeparators: searchConfig.editor.wordSeparators\n        };\n        if (this.isCaseSensitive(inputPattern, options)) {\n            newPattern.isCaseSensitive = true;\n        }\n        if (this.isMultiline(inputPattern)) {\n            newPattern.isMultiline = true;\n        }\n        if (options.notebookSearchConfig?.includeMarkupInput) {\n            if (!newPattern.notebookInfo) {\n                newPattern.notebookInfo = {};\n            }\n            newPattern.notebookInfo.isInNotebookMarkdownInput = options.notebookSearchConfig.includeMarkupInput;\n        }\n        if (options.notebookSearchConfig?.includeMarkupPreview) {\n            if (!newPattern.notebookInfo) {\n                newPattern.notebookInfo = {};\n            }\n            newPattern.notebookInfo.isInNotebookMarkdownPreview = options.notebookSearchConfig.includeMarkupPreview;\n        }\n        if (options.notebookSearchConfig?.includeCodeInput) {\n            if (!newPattern.notebookInfo) {\n                newPattern.notebookInfo = {};\n            }\n            newPattern.notebookInfo.isInNotebookCellInput = options.notebookSearchConfig.includeCodeInput;\n        }\n        if (options.notebookSearchConfig?.includeOutput) {\n            if (!newPattern.notebookInfo) {\n                newPattern.notebookInfo = {};\n            }\n            newPattern.notebookInfo.isInNotebookCellOutput = options.notebookSearchConfig.includeOutput;\n        }\n        return newPattern;\n    }\n    file(folders, options = {}) {\n        const commonQuery = this.commonQuery(folders, options);\n        return {\n            ...commonQuery,\n            type: 1 ,\n            filePattern: options.filePattern\n                ? options.filePattern.trim()\n                : options.filePattern,\n            exists: options.exists,\n            sortByScore: options.sortByScore,\n            cacheKey: options.cacheKey,\n            shouldGlobMatchFilePattern: options.shouldGlobSearch\n        };\n    }\n    handleIncludeExclude(pattern, expandPatterns) {\n        if (!pattern) {\n            return {};\n        }\n        if (Array.isArray(pattern)) {\n            pattern = ( (pattern.filter(p => p.length > 0).map(normalizeSlashes)));\n            if (!pattern.length) {\n                return {};\n            }\n        }\n        else {\n            pattern = normalizeSlashes(pattern);\n        }\n        return expandPatterns\n            ? this.parseSearchPaths(pattern)\n            : { pattern: patternListToIExpression(...(Array.isArray(pattern) ? pattern : [pattern])) };\n    }\n    commonQuery(folderResources = [], options = {}) {\n        let excludePatterns = Array.isArray(options.excludePattern) ? ( (options.excludePattern.map(p => p.pattern))).flat() : options.excludePattern;\n        excludePatterns = excludePatterns?.length === 1 ? excludePatterns[0] : excludePatterns;\n        const includeSearchPathsInfo = this.handleIncludeExclude(options.includePattern, options.expandPatterns);\n        const excludeSearchPathsInfo = this.handleIncludeExclude(excludePatterns, options.expandPatterns);\n        const includeFolderName = folderResources.length > 1;\n        const folderQueries = (includeSearchPathsInfo.searchPaths && includeSearchPathsInfo.searchPaths.length ?\n            ( (includeSearchPathsInfo.searchPaths.map(\n            searchPath => this.getFolderQueryForSearchPath(searchPath, options, excludeSearchPathsInfo)\n        ))) :\n            ( (folderResources.map(\n            folder => this.getFolderQueryForRoot(folder, options, excludeSearchPathsInfo, includeFolderName)\n        ))))\n            .filter(query => !!query);\n        const queryProps = {\n            _reason: options._reason,\n            folderQueries,\n            usingSearchPaths: !!(includeSearchPathsInfo.searchPaths && includeSearchPathsInfo.searchPaths.length),\n            extraFileResources: options.extraFileResources,\n            excludePattern: excludeSearchPathsInfo.pattern,\n            includePattern: includeSearchPathsInfo.pattern,\n            onlyOpenEditors: options.onlyOpenEditors,\n            maxResults: options.maxResults,\n            onlyFileScheme: options.onlyFileScheme\n        };\n        if (options.onlyOpenEditors) {\n            const openEditors = coalesce(this.editorGroupsService.groups.flatMap(group => ( (group.editors.map(editor => editor.resource)))));\n            this.logService.trace('QueryBuilder#commonQuery - openEditor URIs', JSON.stringify(openEditors));\n            const openEditorsInQuery = openEditors.filter(editor => pathIncludedInQuery(queryProps, editor.fsPath));\n            const openEditorsQueryProps = this.commonQueryFromFileList(openEditorsInQuery);\n            this.logService.trace('QueryBuilder#commonQuery - openEditor Query', JSON.stringify(openEditorsQueryProps));\n            return { ...queryProps, ...openEditorsQueryProps };\n        }\n        const extraFileResources = options.extraFileResources && options.extraFileResources.filter(extraFile => pathIncludedInQuery(queryProps, extraFile.fsPath));\n        queryProps.extraFileResources = extraFileResources && extraFileResources.length ? extraFileResources : undefined;\n        return queryProps;\n    }\n    commonQueryFromFileList(files) {\n        const folderQueries = [];\n        const foldersToSearch = ( (new ResourceMap()));\n        const includePattern = {};\n        let hasIncludedFile = false;\n        files.forEach(file => {\n            if (file.scheme === Schemas.walkThrough) {\n                return;\n            }\n            const providerExists = isAbsolutePath(file);\n            if (providerExists) {\n                const searchRoot = this.workspaceContextService.getWorkspaceFolder(file)?.uri ?? this.uriIdentityService.extUri.dirname(file);\n                let folderQuery = foldersToSearch.get(searchRoot);\n                if (!folderQuery) {\n                    hasIncludedFile = true;\n                    folderQuery = { folder: searchRoot, includePattern: {} };\n                    folderQueries.push(folderQuery);\n                    foldersToSearch.set(searchRoot, folderQuery);\n                }\n                const relPath = relative(searchRoot.fsPath, file.fsPath);\n                assertIsDefined(folderQuery.includePattern)[relPath.replace(/\\\\/g, '/')] = true;\n            }\n            else {\n                if (file.fsPath) {\n                    hasIncludedFile = true;\n                    includePattern[file.fsPath] = true;\n                }\n            }\n        });\n        return {\n            folderQueries,\n            includePattern,\n            usingSearchPaths: true,\n            excludePattern: hasIncludedFile ? undefined : { '**/*': true }\n        };\n    }\n    isCaseSensitive(contentPattern, options) {\n        if (options.isSmartCase) {\n            if (contentPattern.isRegExp) {\n                if (containsUppercaseCharacter(contentPattern.pattern, true)) {\n                    return true;\n                }\n            }\n            else if (containsUppercaseCharacter(contentPattern.pattern)) {\n                return true;\n            }\n        }\n        return !!contentPattern.isCaseSensitive;\n    }\n    isMultiline(contentPattern) {\n        if (contentPattern.isMultiline) {\n            return true;\n        }\n        if (contentPattern.isRegExp && isMultilineRegexSource(contentPattern.pattern)) {\n            return true;\n        }\n        if (contentPattern.pattern.indexOf('\\n') >= 0) {\n            return true;\n        }\n        return !!contentPattern.isMultiline;\n    }\n    parseSearchPaths(pattern) {\n        const isSearchPath = (segment) => {\n            return isAbsolute(segment) || /^\\.\\.?([\\/\\\\]|$)/.test(segment);\n        };\n        const patterns = Array.isArray(pattern) ? pattern : splitGlobPattern(pattern);\n        const segments = ( (patterns\n            .map(segment => {\n            const userHome = this.pathService.resolvedUserHome;\n            if (userHome) {\n                return untildify(segment, userHome.scheme === Schemas.file ? userHome.fsPath : userHome.path);\n            }\n            return segment;\n        })));\n        const groups = groupBy(segments, segment => isSearchPath(segment) ? 'searchPaths' : 'exprSegments');\n        const expandedExprSegments = ( (( (( ((groups.exprSegments || [])\n            .map(s => rtrim(s, '/'))))\n            .map(s => rtrim(s, '\\\\'))))\n            .map(p => {\n            if (p[0] === '.') {\n                p = '*' + p;\n            }\n            return expandGlobalGlob(p);\n        })));\n        const result = {};\n        const searchPaths = this.expandSearchPathPatterns(groups.searchPaths || []);\n        if (searchPaths && searchPaths.length) {\n            result.searchPaths = searchPaths;\n        }\n        const exprSegments = expandedExprSegments.flat();\n        const includePattern = patternListToIExpression(...exprSegments);\n        if (includePattern) {\n            result.pattern = includePattern;\n        }\n        return result;\n    }\n    getExcludesForFolder(folderConfig, options) {\n        return options.disregardExcludeSettings ?\n            undefined :\n            getExcludes(folderConfig, !options.disregardSearchExcludeSettings);\n    }\n    expandSearchPathPatterns(searchPaths) {\n        if (!searchPaths || !searchPaths.length) {\n            return [];\n        }\n        const expandedSearchPaths = searchPaths.flatMap(searchPath => {\n            let { pathPortion, globPortion } = splitGlobFromPath(searchPath);\n            if (globPortion) {\n                globPortion = normalizeGlobPattern(globPortion);\n            }\n            const oneExpanded = this.expandOneSearchPath(pathPortion);\n            return oneExpanded.flatMap(oneExpandedResult => this.resolveOneSearchPathPattern(oneExpandedResult, globPortion));\n        });\n        const searchPathPatternMap = ( (new Map()));\n        expandedSearchPaths.forEach(oneSearchPathPattern => {\n            const key = ( (oneSearchPathPattern.searchPath.toString()));\n            const existing = searchPathPatternMap.get(key);\n            if (existing) {\n                if (oneSearchPathPattern.pattern) {\n                    existing.pattern = existing.pattern || {};\n                    existing.pattern[oneSearchPathPattern.pattern] = true;\n                }\n            }\n            else {\n                searchPathPatternMap.set(key, {\n                    searchPath: oneSearchPathPattern.searchPath,\n                    pattern: oneSearchPathPattern.pattern ? patternListToIExpression(oneSearchPathPattern.pattern) : undefined\n                });\n            }\n        });\n        return Array.from(( (searchPathPatternMap.values())));\n    }\n    expandOneSearchPath(searchPath) {\n        if (isAbsolute(searchPath)) {\n            const workspaceFolders = this.workspaceContextService.getWorkspace().folders;\n            if (workspaceFolders[0] && workspaceFolders[0].uri.scheme !== Schemas.file) {\n                return [{\n                        searchPath: workspaceFolders[0].uri.with({ path: searchPath })\n                    }];\n            }\n            return [{\n                    searchPath: URI.file(normalize(searchPath))\n                }];\n        }\n        if (this.workspaceContextService.getWorkbenchState() === 2 ) {\n            const workspaceUri = this.workspaceContextService.getWorkspace().folders[0].uri;\n            searchPath = normalizeSlashes(searchPath);\n            if (searchPath.startsWith('../') || searchPath === '..') {\n                const resolvedPath = posix.resolve(workspaceUri.path, searchPath);\n                return [{\n                        searchPath: workspaceUri.with({ path: resolvedPath })\n                    }];\n            }\n            const cleanedPattern = normalizeGlobPattern(searchPath);\n            return [{\n                    searchPath: workspaceUri,\n                    pattern: cleanedPattern\n                }];\n        }\n        else if (searchPath === './' || searchPath === '.\\\\') {\n            return [];\n        }\n        else {\n            const searchPathWithoutDotSlash = searchPath.replace(/^\\.[\\/\\\\]/, '');\n            const folders = this.workspaceContextService.getWorkspace().folders;\n            const folderMatches = ( (folders.map(folder => {\n                const match = searchPathWithoutDotSlash.match(( (new RegExp(`^${escapeRegExpCharacters(folder.name)}(?:/(.*)|$)`))));\n                return match ? {\n                    match,\n                    folder\n                } : null;\n            }))).filter(isDefined);\n            if (folderMatches.length) {\n                return (\n                     (folderMatches.map(match => {\n                        const patternMatch = match.match[1];\n                        return {\n                            searchPath: match.folder.uri,\n                            pattern: patternMatch && normalizeGlobPattern(patternMatch)\n                        };\n                    }))\n                );\n            }\n            else {\n                const probableWorkspaceFolderNameMatch = searchPath.match(/\\.[\\/\\\\](.+)[\\/\\\\]?/);\n                const probableWorkspaceFolderName = probableWorkspaceFolderNameMatch ? probableWorkspaceFolderNameMatch[1] : searchPath;\n                const searchPathNotFoundError = ( localize(4557, \"Workspace folder does not exist: {0}\", probableWorkspaceFolderName));\n                throw ( (new Error(searchPathNotFoundError)));\n            }\n        }\n    }\n    resolveOneSearchPathPattern(oneExpandedResult, globPortion) {\n        const pattern = oneExpandedResult.pattern && globPortion ?\n            `${oneExpandedResult.pattern}/${globPortion}` :\n            oneExpandedResult.pattern || globPortion;\n        const results = [\n            {\n                searchPath: oneExpandedResult.searchPath,\n                pattern\n            }\n        ];\n        if (pattern && !pattern.endsWith('**')) {\n            results.push({\n                searchPath: oneExpandedResult.searchPath,\n                pattern: pattern + '/**'\n            });\n        }\n        return results;\n    }\n    getFolderQueryForSearchPath(searchPath, options, searchPathExcludes) {\n        const rootConfig = this.getFolderQueryForRoot(toWorkspaceFolder(searchPath.searchPath), options, searchPathExcludes, false);\n        if (!rootConfig) {\n            return null;\n        }\n        return {\n            ...rootConfig,\n            ...{\n                includePattern: searchPath.pattern\n            }\n        };\n    }\n    getFolderQueryForRoot(folder, options, searchPathExcludes, includeFolderName) {\n        let thisFolderExcludeSearchPathPattern;\n        const folderUri = URI.isUri(folder) ? folder : folder.uri;\n        let excludeFolderRoots = options.excludePattern?.map(excludePattern => {\n            const excludeRoot = options.excludePattern && isISearchPatternBuilder(excludePattern) ? excludePattern.uri : undefined;\n            const shouldUseExcludeRoot = (!excludeRoot || !(URI.isUri(folder) && this.uriIdentityService.extUri.isEqual(folder, excludeRoot)));\n            return shouldUseExcludeRoot ? excludeRoot : undefined;\n        });\n        if (!excludeFolderRoots?.length) {\n            excludeFolderRoots = [undefined];\n        }\n        if (searchPathExcludes.searchPaths) {\n            const thisFolderExcludeSearchPath = searchPathExcludes.searchPaths.filter(sp => isEqual(sp.searchPath, folderUri))[0];\n            if (thisFolderExcludeSearchPath && !thisFolderExcludeSearchPath.pattern) {\n                return null;\n            }\n            else if (thisFolderExcludeSearchPath) {\n                thisFolderExcludeSearchPathPattern = thisFolderExcludeSearchPath.pattern;\n            }\n        }\n        const folderConfig = this.configurationService.getValue({ resource: folderUri });\n        const settingExcludes = this.getExcludesForFolder(folderConfig, options);\n        const excludePattern = {\n            ...(settingExcludes || {}),\n            ...(thisFolderExcludeSearchPathPattern || {})\n        };\n        const folderName = URI.isUri(folder) ? basename(folder) : folder.name;\n        const excludePatternRet = ( (excludeFolderRoots.map(excludeFolderRoot => {\n            return ( (Object.keys(excludePattern))).length > 0 ? {\n                folder: excludeFolderRoot,\n                pattern: excludePattern\n            } : undefined;\n        }))).filter((e) => e);\n        return {\n            folder: folderUri,\n            folderName: includeFolderName ? folderName : undefined,\n            excludePattern: excludePatternRet,\n            fileEncoding: folderConfig.files && folderConfig.files.encoding,\n            disregardIgnoreFiles: typeof options.disregardIgnoreFiles === 'boolean' ? options.disregardIgnoreFiles : !folderConfig.search?.useIgnoreFiles,\n            disregardGlobalIgnoreFiles: typeof options.disregardGlobalIgnoreFiles === 'boolean' ? options.disregardGlobalIgnoreFiles : !folderConfig.search?.useGlobalIgnoreFiles,\n            disregardParentIgnoreFiles: typeof options.disregardParentIgnoreFiles === 'boolean' ? options.disregardParentIgnoreFiles : !folderConfig.search?.useParentIgnoreFiles,\n            ignoreSymlinks: typeof options.ignoreSymlinks === 'boolean' ? options.ignoreSymlinks : !folderConfig.search?.followSymlinks,\n        };\n    }\n};\nQueryBuilder = ( (__decorate([\n    ( (__param(0, IConfigurationService))),\n    ( (__param(1, IWorkspaceContextService))),\n    ( (__param(2, IEditorGroupsService))),\n    ( (__param(3, ILogService))),\n    ( (__param(4, IPathService))),\n    ( (__param(5, IUriIdentityService)))\n], QueryBuilder)));\nfunction splitGlobFromPath(searchPath) {\n    const globCharMatch = searchPath.match(/[\\*\\{\\}\\(\\)\\[\\]\\?]/);\n    if (globCharMatch) {\n        const globCharIdx = globCharMatch.index;\n        const lastSlashMatch = searchPath.substr(0, globCharIdx).match(/[/|\\\\][^/\\\\]*$/);\n        if (lastSlashMatch) {\n            let pathPortion = searchPath.substr(0, lastSlashMatch.index);\n            if (!pathPortion.match(/[/\\\\]/)) {\n                pathPortion += '/';\n            }\n            return {\n                pathPortion,\n                globPortion: searchPath.substr((lastSlashMatch.index || 0) + 1)\n            };\n        }\n    }\n    return {\n        pathPortion: searchPath\n    };\n}\nfunction patternListToIExpression(...patterns) {\n    return patterns.length ?\n        patterns.reduce((glob, cur) => { glob[cur] = true; return glob; }, Object.create(null)) :\n        undefined;\n}\nfunction splitGlobPattern(pattern) {\n    return ( (splitGlobAware(pattern, ',')\n        .map(s => s.trim())))\n        .filter(s => !!s.length);\n}\nfunction expandGlobalGlob(pattern) {\n    const patterns = [\n        `**/${pattern}/**`,\n        `**/${pattern}`\n    ];\n    return (\n         (patterns.map(p => p.replace(/\\*\\*\\/\\*\\*/g, '**')))\n    );\n}\nfunction normalizeSlashes(pattern) {\n    return pattern.replace(/\\\\/g, '/');\n}\nfunction normalizeGlobPattern(pattern) {\n    return normalizeSlashes(pattern)\n        .replace(/^\\.\\//, '')\n        .replace(/\\/+$/g, '');\n}\nfunction escapeGlobPattern(path) {\n    return path.replace(/([?*[\\]])/g, '[$1]');\n}\nfunction resolveResourcesForSearchIncludes(resources, contextService) {\n    resources = distinct(resources, resource => ( (resource.toString())));\n    const folderPaths = [];\n    const workspace = contextService.getWorkspace();\n    if (resources) {\n        resources.forEach(resource => {\n            let folderPath;\n            if (contextService.getWorkbenchState() === 2 ) {\n                folderPath = relativePath(workspace.folders[0].uri, resource);\n                if (folderPath && folderPath !== '.') {\n                    folderPath = './' + folderPath;\n                }\n            }\n            else {\n                const owningFolder = contextService.getWorkspaceFolder(resource);\n                if (owningFolder) {\n                    const owningRootName = owningFolder.name;\n                    const isUniqueFolder = workspace.folders.filter(folder => folder.name === owningRootName).length === 1;\n                    if (isUniqueFolder) {\n                        const relPath = relativePath(owningFolder.uri, resource);\n                        if (relPath === '') {\n                            folderPath = `./${owningFolder.name}`;\n                        }\n                        else {\n                            folderPath = `./${owningFolder.name}/${relPath}`;\n                        }\n                    }\n                    else {\n                        folderPath = resource.fsPath;\n                    }\n                }\n            }\n            if (folderPath) {\n                folderPaths.push(escapeGlobPattern(folderPath));\n            }\n        });\n    }\n    return folderPaths;\n}\nexport { QueryBuilder, isISearchPatternBuilder, resolveResourcesForSearchIncludes };\n","import { mapArrayOrNot } from '../../../../base/common/arrays.js';\nimport { match, parse } from '../../../../base/common/glob.js';\nimport { mixin, deepClone } from '../../../../base/common/objects.js';\nimport { isEqualOrParent } from '../../../../base/common/extpath.js';\nimport { getNLines } from '../../../../base/common/strings.js';\nimport { relative } from '../../../../base/common/path.js';\nimport { isCancellationError } from '../../../../base/common/errors.js';\nexport { TextSearchCompleteMessageType } from './searchExtTypes.js';\nimport { isThenable } from '../../../../base/common/async.js';\nconst VIEWLET_ID = 'workbench.view.search';\nconst VIEW_ID = 'workbench.view.search';\nconst SEARCH_RESULT_LANGUAGE_ID = 'search-result';\nconst SEARCH_EXCLUDE_CONFIG = 'search.exclude';\nconst DEFAULT_MAX_SEARCH_RESULTS = 20000;\nconst SEARCH_ELIDED_PREFIX = ' ';\nconst SEARCH_ELIDED_SUFFIX = ' characters skipped ';\nconst SEARCH_ELIDED_MIN_LEN = (SEARCH_ELIDED_PREFIX.length + SEARCH_ELIDED_SUFFIX.length + 5) * 2;\nfunction resultIsMatch(result) {\n    return !!result.rangeLocations && !!result.previewText;\n}\nfunction isFileMatch(p) {\n    return !!p.resource;\n}\nfunction isProgressMessage(p) {\n    return !!p.message;\n}\nclass FileMatch {\n    constructor(resource) {\n        this.resource = resource;\n        this.results = [];\n    }\n}\nclass TextSearchMatch {\n    constructor(text, ranges, previewOptions, webviewIndex) {\n        this.rangeLocations = [];\n        this.webviewIndex = webviewIndex;\n        const rangesArr = Array.isArray(ranges) ? ranges : [ranges];\n        if (previewOptions && previewOptions.matchLines === 1 && isSingleLineRangeList(rangesArr)) {\n            text = getNLines(text, previewOptions.matchLines);\n            let result = '';\n            let shift = 0;\n            let lastEnd = 0;\n            const leadingChars = Math.floor(previewOptions.charsPerLine / 5);\n            for (const range of rangesArr) {\n                const previewStart = Math.max(range.startColumn - leadingChars, 0);\n                const previewEnd = range.startColumn + previewOptions.charsPerLine;\n                if (previewStart > lastEnd + leadingChars + SEARCH_ELIDED_MIN_LEN) {\n                    const elision = SEARCH_ELIDED_PREFIX + (previewStart - lastEnd) + SEARCH_ELIDED_SUFFIX;\n                    result += elision + text.slice(previewStart, previewEnd);\n                    shift += previewStart - (lastEnd + elision.length);\n                }\n                else {\n                    result += text.slice(lastEnd, previewEnd);\n                }\n                lastEnd = previewEnd;\n                this.rangeLocations.push({\n                    source: range,\n                    preview: ( new OneLineRange(0, range.startColumn - shift, range.endColumn - shift))\n                });\n            }\n            this.previewText = result;\n        }\n        else {\n            const firstMatchLine = Array.isArray(ranges) ? ranges[0].startLineNumber : ranges.startLineNumber;\n            const rangeLocs = mapArrayOrNot(ranges, r => ({\n                preview: ( new SearchRange(\n                    r.startLineNumber - firstMatchLine,\n                    r.startColumn,\n                    r.endLineNumber - firstMatchLine,\n                    r.endColumn\n                )),\n                source: r\n            }));\n            this.rangeLocations = Array.isArray(rangeLocs) ? rangeLocs : [rangeLocs];\n            this.previewText = text;\n        }\n    }\n}\nfunction isSingleLineRangeList(ranges) {\n    const line = ranges[0].startLineNumber;\n    for (const r of ranges) {\n        if (r.startLineNumber !== line || r.endLineNumber !== line) {\n            return false;\n        }\n    }\n    return true;\n}\nclass SearchRange {\n    constructor(startLineNumber, startColumn, endLineNumber, endColumn) {\n        this.startLineNumber = startLineNumber;\n        this.startColumn = startColumn;\n        this.endLineNumber = endLineNumber;\n        this.endColumn = endColumn;\n    }\n}\nclass OneLineRange extends SearchRange {\n    constructor(lineNumber, startColumn, endColumn) {\n        super(lineNumber, startColumn, lineNumber, endColumn);\n    }\n}\nfunction getExcludes(configuration, includeSearchExcludes = true) {\n    const fileExcludes = configuration && configuration.files && configuration.files.exclude;\n    const searchExcludes = includeSearchExcludes && configuration && configuration.search && configuration.search.exclude;\n    if (!fileExcludes && !searchExcludes) {\n        return undefined;\n    }\n    if (!fileExcludes || !searchExcludes) {\n        return fileExcludes || searchExcludes || undefined;\n    }\n    let allExcludes = Object.create(null);\n    allExcludes = mixin(allExcludes, deepClone(fileExcludes));\n    allExcludes = mixin(allExcludes, deepClone(searchExcludes), true);\n    return allExcludes;\n}\nfunction pathIncludedInQuery(queryProps, fsPath) {\n    if (queryProps.excludePattern && match(queryProps.excludePattern, fsPath)) {\n        return false;\n    }\n    if (queryProps.includePattern || queryProps.usingSearchPaths) {\n        if (queryProps.includePattern && match(queryProps.includePattern, fsPath)) {\n            return true;\n        }\n        if (queryProps.usingSearchPaths) {\n            return !!queryProps.folderQueries && ( queryProps.folderQueries.some(fq => {\n                const searchPath = fq.folder.fsPath;\n                if (isEqualOrParent(fsPath, searchPath)) {\n                    const relPath = relative(searchPath, fsPath);\n                    return !fq.includePattern || !!match(fq.includePattern, relPath);\n                }\n                else {\n                    return false;\n                }\n            }));\n        }\n        return false;\n    }\n    return true;\n}\nvar SearchErrorCode;\n( (function(SearchErrorCode) {\n    SearchErrorCode[SearchErrorCode[\"unknownEncoding\"] = 1] = \"unknownEncoding\";\n    SearchErrorCode[SearchErrorCode[\"regexParseError\"] = 2] = \"regexParseError\";\n    SearchErrorCode[SearchErrorCode[\"globParseError\"] = 3] = \"globParseError\";\n    SearchErrorCode[SearchErrorCode[\"invalidLiteral\"] = 4] = \"invalidLiteral\";\n    SearchErrorCode[SearchErrorCode[\"rgProcessError\"] = 5] = \"rgProcessError\";\n    SearchErrorCode[SearchErrorCode[\"other\"] = 6] = \"other\";\n    SearchErrorCode[SearchErrorCode[\"canceled\"] = 7] = \"canceled\";\n})(SearchErrorCode || (SearchErrorCode = {})));\nclass SearchError extends Error {\n    constructor(message, code) {\n        super(message);\n        this.code = code;\n    }\n}\nfunction deserializeSearchError(error) {\n    const errorMsg = error.message;\n    if (isCancellationError(error)) {\n        return ( new SearchError(errorMsg, SearchErrorCode.canceled));\n    }\n    try {\n        const details = JSON.parse(errorMsg);\n        return ( new SearchError(details.message, details.code));\n    }\n    catch (e) {\n        return ( new SearchError(errorMsg, SearchErrorCode.other));\n    }\n}\nfunction resolvePatternsForProvider(globalPattern, folderPattern) {\n    const merged = {\n        ...(globalPattern || {}),\n        ...(folderPattern || {})\n    };\n    return ( Object.keys(merged))\n        .filter(key => {\n        const value = merged[key];\n        return typeof value === 'boolean' && value;\n    });\n}\nclass QueryGlobTester {\n    constructor(config, folderQuery) {\n        this._parsedIncludeExpression = null;\n        this._excludeExpression = folderQuery.excludePattern?.map(excludePattern => {\n            return {\n                ...(config.excludePattern || {}),\n                ...(excludePattern.pattern || {})\n            };\n        }) ?? [];\n        if (this._excludeExpression.length === 0) {\n            this._excludeExpression = [config.excludePattern || {}];\n        }\n        this._parsedExcludeExpression = ( this._excludeExpression.map(e => parse(e)));\n        let includeExpression = config.includePattern;\n        if (folderQuery.includePattern) {\n            if (includeExpression) {\n                includeExpression = {\n                    ...includeExpression,\n                    ...folderQuery.includePattern\n                };\n            }\n            else {\n                includeExpression = folderQuery.includePattern;\n            }\n        }\n        if (includeExpression) {\n            this._parsedIncludeExpression = parse(includeExpression);\n        }\n    }\n    _evalParsedExcludeExpression(testPath, basename, hasSibling) {\n        let result = null;\n        for (const folderExclude of this._parsedExcludeExpression) {\n            const evaluation = folderExclude(testPath, basename, hasSibling);\n            if (typeof evaluation === 'string') {\n                result = evaluation;\n                break;\n            }\n        }\n        return result;\n    }\n    matchesExcludesSync(testPath, basename, hasSibling) {\n        if (this._parsedExcludeExpression && this._evalParsedExcludeExpression(testPath, basename, hasSibling)) {\n            return true;\n        }\n        return false;\n    }\n    includedInQuerySync(testPath, basename, hasSibling) {\n        if (this._parsedExcludeExpression && this._evalParsedExcludeExpression(testPath, basename, hasSibling)) {\n            return false;\n        }\n        if (this._parsedIncludeExpression && !this._parsedIncludeExpression(testPath, basename, hasSibling)) {\n            return false;\n        }\n        return true;\n    }\n    includedInQuery(testPath, basename, hasSibling) {\n        const isIncluded = () => {\n            return this._parsedIncludeExpression ?\n                !!(this._parsedIncludeExpression(testPath, basename, hasSibling)) :\n                true;\n        };\n        return Promise.all(( this._parsedExcludeExpression.map(e => {\n            const excluded = e(testPath, basename, hasSibling);\n            if (isThenable(excluded)) {\n                return excluded.then(excluded => {\n                    if (excluded) {\n                        return false;\n                    }\n                    return isIncluded();\n                });\n            }\n            return isIncluded();\n        }))).then(e => ( e.some(e => !!e)));\n    }\n    hasSiblingExcludeClauses() {\n        return this._excludeExpression.reduce((prev, curr) => hasSiblingClauses(curr) || prev, false);\n    }\n}\nfunction hasSiblingClauses(pattern) {\n    for (const key in pattern) {\n        if (typeof pattern[key] !== 'boolean') {\n            return true;\n        }\n    }\n    return false;\n}\nfunction hasSiblingPromiseFn(siblingsFn) {\n    if (!siblingsFn) {\n        return undefined;\n    }\n    let siblings;\n    return (name) => {\n        if (!siblings) {\n            siblings = (siblingsFn() || Promise.resolve([]))\n                .then(list => list ? listToMap(list) : {});\n        }\n        return siblings.then(map => !!map[name]);\n    };\n}\nfunction hasSiblingFn(siblingsFn) {\n    if (!siblingsFn) {\n        return undefined;\n    }\n    let siblings;\n    return (name) => {\n        if (!siblings) {\n            const list = siblingsFn();\n            siblings = list ? listToMap(list) : {};\n        }\n        return !!siblings[name];\n    };\n}\nfunction listToMap(list) {\n    const map = {};\n    for (const key of list) {\n        map[key] = true;\n    }\n    return map;\n}\nfunction excludeToGlobPattern(excludesForFolder) {\n    return excludesForFolder.flatMap(exclude => ( exclude.patterns.map(pattern => {\n        return exclude.baseUri ?\n            {\n                baseUri: exclude.baseUri,\n                pattern: pattern\n            } : pattern;\n    })));\n}\nconst DEFAULT_TEXT_SEARCH_PREVIEW_OPTIONS = {\n    matchLines: 100,\n    charsPerLine: 10000\n};\nexport { DEFAULT_MAX_SEARCH_RESULTS, DEFAULT_TEXT_SEARCH_PREVIEW_OPTIONS, FileMatch, OneLineRange, QueryGlobTester, SEARCH_EXCLUDE_CONFIG, SEARCH_RESULT_LANGUAGE_ID, SearchError, SearchErrorCode, SearchRange, TextSearchMatch, VIEWLET_ID, VIEW_ID, deserializeSearchError, excludeToGlobPattern, getExcludes, hasSiblingFn, hasSiblingPromiseFn, isFileMatch, isProgressMessage, pathIncludedInQuery, resolvePatternsForProvider, resultIsMatch };\n","import { createDecorator } from '../../../../platform/instantiation/common/instantiation.js';\nconst ISearchService = ( createDecorator('searchService'));\nexport { ISearchService };\n","import { coalesce, asArray } from '../../../../base/common/arrays.js';\nimport { DEFAULT_TEXT_SEARCH_PREVIEW_OPTIONS } from './search.js';\nimport { TextSearchMatchNew, TextSearchContextNew } from './searchExtTypes.js';\nfunction isTextSearchMatch(object) {\n    return 'uri' in object && 'ranges' in object && 'preview' in object;\n}\nfunction newToOldFileProviderOptions(options) {\n    return ( options.folderOptions.map(folderOption => ({\n        folder: folderOption.folder,\n        excludes: ( folderOption.excludes.map(e => typeof (e) === 'string' ? e : e.pattern)),\n        includes: folderOption.includes,\n        useGlobalIgnoreFiles: folderOption.useIgnoreFiles.global,\n        useIgnoreFiles: folderOption.useIgnoreFiles.local,\n        useParentIgnoreFiles: folderOption.useIgnoreFiles.parent,\n        followSymlinks: folderOption.followSymlinks,\n        maxResults: options.maxResults,\n        session: options.session\n    })));\n}\nclass OldFileSearchProviderConverter {\n    constructor(provider) {\n        this.provider = provider;\n    }\n    provideFileSearchResults(pattern, options, token) {\n        const getResult = async () => {\n            const newOpts = newToOldFileProviderOptions(options);\n            return Promise.all(( newOpts.map(o => this.provider.provideFileSearchResults({ pattern }, o, token))));\n        };\n        return getResult().then(e => coalesce(e).flat());\n    }\n}\nfunction newToOldTextProviderOptions(options) {\n    return ( options.folderOptions.map(folderOption => ({\n        folder: folderOption.folder,\n        excludes: ( folderOption.excludes.map(e => typeof (e) === 'string' ? e : e.pattern)),\n        includes: folderOption.includes,\n        useGlobalIgnoreFiles: folderOption.useIgnoreFiles.global,\n        useIgnoreFiles: folderOption.useIgnoreFiles.local,\n        useParentIgnoreFiles: folderOption.useIgnoreFiles.parent,\n        followSymlinks: folderOption.followSymlinks,\n        maxResults: options.maxResults,\n        previewOptions: newToOldPreviewOptions(options.previewOptions),\n        maxFileSize: options.maxFileSize,\n        encoding: folderOption.encoding,\n        afterContext: options.surroundingContext,\n        beforeContext: options.surroundingContext\n    })));\n}\nfunction newToOldPreviewOptions(options) {\n    return {\n        matchLines: options?.matchLines ?? DEFAULT_TEXT_SEARCH_PREVIEW_OPTIONS.matchLines,\n        charsPerLine: options?.charsPerLine ?? DEFAULT_TEXT_SEARCH_PREVIEW_OPTIONS.charsPerLine\n    };\n}\nfunction oldToNewTextSearchResult(result) {\n    if (isTextSearchMatch(result)) {\n        const ranges = ( asArray(result.ranges).map((r, i) => {\n            const previewArr = asArray(result.preview.matches);\n            const matchingPreviewRange = previewArr[i];\n            return { sourceRange: r, previewRange: matchingPreviewRange };\n        }));\n        return ( new TextSearchMatchNew(result.uri, ranges, result.preview.text));\n    }\n    else {\n        return ( new TextSearchContextNew(result.uri, result.text, result.lineNumber));\n    }\n}\nclass OldTextSearchProviderConverter {\n    constructor(provider) {\n        this.provider = provider;\n    }\n    provideTextSearchResults(query, options, progress, token) {\n        const progressShim = (oldResult) => {\n            if (!validateProviderResult(oldResult)) {\n                return;\n            }\n            progress.report(oldToNewTextSearchResult(oldResult));\n        };\n        const getResult = async () => {\n            return coalesce(await Promise.all(( newToOldTextProviderOptions(options).map(\n                o => this.provider.provideTextSearchResults(query, o, { report: (e) => progressShim(e) }, token)\n            ))))\n                .reduce((prev, cur) => ({ limitHit: prev.limitHit || cur.limitHit }), { limitHit: false });\n        };\n        const oldResult = getResult();\n        return oldResult.then((e) => {\n            return {\n                limitHit: e.limitHit,\n                message: coalesce(asArray(e.message))\n            };\n        });\n    }\n}\nclass OldAITextSearchProviderConverter {\n    constructor(provider) {\n        this.provider = provider;\n        this.name = this.provider.name;\n    }\n    provideAITextSearchResults(query, options, progress, token) {\n        const progressShim = (oldResult) => {\n            if (!validateProviderResult(oldResult)) {\n                return;\n            }\n            progress.report(oldToNewTextSearchResult(oldResult));\n        };\n        const getResult = async () => {\n            return coalesce(await Promise.all(( newToOldTextProviderOptions(options).map(\n                o => this.provider.provideAITextSearchResults(query, o, { report: (e) => progressShim(e) }, token)\n            ))))\n                .reduce((prev, cur) => ({ limitHit: prev.limitHit || cur.limitHit }), { limitHit: false });\n        };\n        const oldResult = getResult();\n        return oldResult.then((e) => {\n            return {\n                limitHit: e.limitHit,\n                message: coalesce(asArray(e.message))\n            };\n        });\n    }\n}\nfunction validateProviderResult(result) {\n    if (extensionResultIsMatch(result)) {\n        if (Array.isArray(result.ranges)) {\n            if (!Array.isArray(result.preview.matches)) {\n                console.warn('INVALID - A text search provider match\\'s`ranges` and`matches` properties must have the same type.');\n                return false;\n            }\n            if (result.preview.matches.length !== result.ranges.length) {\n                console.warn('INVALID - A text search provider match\\'s`ranges` and`matches` properties must have the same length.');\n                return false;\n            }\n        }\n        else {\n            if (Array.isArray(result.preview.matches)) {\n                console.warn('INVALID - A text search provider match\\'s`ranges` and`matches` properties must have the same length.');\n                return false;\n            }\n        }\n    }\n    return true;\n}\nfunction extensionResultIsMatch(data) {\n    return !!data.preview;\n}\nexport { OldAITextSearchProviderConverter, OldFileSearchProviderConverter, OldTextSearchProviderConverter, extensionResultIsMatch, newToOldPreviewOptions, oldToNewTextSearchResult };\n","class TextSearchMatchNew {\n    constructor(uri, ranges, previewText) {\n        this.uri = uri;\n        this.ranges = ranges;\n        this.previewText = previewText;\n    }\n}\nclass TextSearchContextNew {\n    constructor(uri, text, lineNumber) {\n        this.uri = uri;\n        this.text = text;\n        this.lineNumber = lineNumber;\n    }\n}\nvar ExcludeSettingOptions;\n( (function(ExcludeSettingOptions) {\n    ExcludeSettingOptions[ExcludeSettingOptions[\"None\"] = 1] = \"None\";\n    ExcludeSettingOptions[ExcludeSettingOptions[\"FilesExclude\"] = 2] = \"FilesExclude\";\n    ExcludeSettingOptions[ExcludeSettingOptions[\"SearchAndFilesExclude\"] = 3] = \"SearchAndFilesExclude\";\n})(ExcludeSettingOptions || (ExcludeSettingOptions = {})));\nvar TextSearchCompleteMessageType;\n( (function(TextSearchCompleteMessageType) {\n    TextSearchCompleteMessageType[TextSearchCompleteMessageType[\"Information\"] = 1] = \"Information\";\n    TextSearchCompleteMessageType[TextSearchCompleteMessageType[\"Warning\"] = 2] = \"Warning\";\n})(TextSearchCompleteMessageType || (TextSearchCompleteMessageType = {})));\nexport { ExcludeSettingOptions, TextSearchCompleteMessageType, TextSearchContextNew, TextSearchMatchNew };\n","import { isThenable } from '../../../../base/common/async.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { toErrorMessage } from '../../../../base/common/errorMessage.js';\nimport { Schemas } from '../../../../base/common/network.js';\nimport { basename } from '../../../../base/common/path.js';\nimport { isEqual, relativePath, dirname } from '../../../../base/common/resources.js';\nimport { TernarySearchTree } from '../../../../base/common/ternarySearchTree.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { resolvePatternsForProvider, excludeToGlobPattern, QueryGlobTester, DEFAULT_MAX_SEARCH_RESULTS, DEFAULT_TEXT_SEARCH_PREVIEW_OPTIONS, hasSiblingPromiseFn } from './search.js';\nimport { TextSearchMatchNew } from './searchExtTypes.js';\nclass TextSearchManager {\n    constructor(queryProviderPair, fileUtils, processType) {\n        this.queryProviderPair = queryProviderPair;\n        this.fileUtils = fileUtils;\n        this.processType = processType;\n        this.collector = null;\n        this.isLimitHit = false;\n        this.resultCount = 0;\n    }\n    get query() {\n        return this.queryProviderPair.query;\n    }\n    search(onProgress, token) {\n        const folderQueries = this.query.folderQueries || [];\n        const tokenSource = ( new CancellationTokenSource(token));\n        return ( new Promise((resolve, reject) => {\n            this.collector = ( new TextSearchResultsCollector(onProgress));\n            let isCanceled = false;\n            const onResult = (result, folderIdx) => {\n                if (isCanceled) {\n                    return;\n                }\n                if (!this.isLimitHit) {\n                    const resultSize = this.resultSize(result);\n                    if (result instanceof TextSearchMatchNew && typeof this.query.maxResults === 'number' && this.resultCount + resultSize > this.query.maxResults) {\n                        this.isLimitHit = true;\n                        isCanceled = true;\n                        tokenSource.cancel();\n                        result = this.trimResultToSize(result, this.query.maxResults - this.resultCount);\n                    }\n                    const newResultSize = this.resultSize(result);\n                    this.resultCount += newResultSize;\n                    const a = result instanceof TextSearchMatchNew;\n                    if (newResultSize > 0 || !a) {\n                        this.collector.add(result, folderIdx);\n                    }\n                }\n            };\n            this.doSearch(folderQueries, onResult, tokenSource.token).then(result => {\n                tokenSource.dispose();\n                this.collector.flush();\n                resolve({\n                    limitHit: this.isLimitHit || result?.limitHit,\n                    messages: this.getMessagesFromResults(result),\n                    stats: {\n                        type: this.processType\n                    }\n                });\n            }, (err) => {\n                tokenSource.dispose();\n                const errMsg = toErrorMessage(err);\n                reject(( new Error(errMsg)));\n            });\n        }));\n    }\n    getMessagesFromResults(result) {\n        if (!result?.message) {\n            return [];\n        }\n        if (Array.isArray(result.message)) {\n            return result.message;\n        }\n        return [result.message];\n    }\n    resultSize(result) {\n        if (result instanceof TextSearchMatchNew) {\n            return Array.isArray(result.ranges) ?\n                result.ranges.length :\n                1;\n        }\n        else {\n            return 0;\n        }\n    }\n    trimResultToSize(result, size) {\n        return ( new TextSearchMatchNew(result.uri, result.ranges.slice(0, size), result.previewText));\n    }\n    async doSearch(folderQueries, onResult, token) {\n        const folderMappings = TernarySearchTree.forUris(() => true);\n        folderQueries.forEach((fq, i) => {\n            const queryTester = ( new QueryGlobTester(this.query, fq));\n            folderMappings.set(fq.folder, { queryTester, folder: fq.folder, folderIdx: i });\n        });\n        const testingPs = [];\n        const progress = {\n            report: (result) => {\n                if (result.uri === undefined) {\n                    throw Error('Text search result URI is undefined. Please check provider implementation.');\n                }\n                const folderQuery = folderMappings.findSubstr(result.uri);\n                const hasSibling = folderQuery.folder.scheme === Schemas.file ?\n                    hasSiblingPromiseFn(() => {\n                        return this.fileUtils.readdir(dirname(result.uri));\n                    }) :\n                    undefined;\n                const relativePath$1 = relativePath(folderQuery.folder, result.uri);\n                if (relativePath$1) {\n                    const included = folderQuery.queryTester.includedInQuery(relativePath$1, basename(relativePath$1), hasSibling);\n                    if (isThenable(included)) {\n                        testingPs.push(included.then(isIncluded => {\n                            if (isIncluded) {\n                                onResult(result, folderQuery.folderIdx);\n                            }\n                        }));\n                    }\n                    else if (included) {\n                        onResult(result, folderQuery.folderIdx);\n                    }\n                }\n            }\n        };\n        const folderOptions = ( folderQueries.map(fq => this.getSearchOptionsForFolder(fq)));\n        const searchOptions = {\n            folderOptions,\n            maxFileSize: this.query.maxFileSize,\n            maxResults: this.query.maxResults ?? DEFAULT_MAX_SEARCH_RESULTS,\n            previewOptions: this.query.previewOptions ?? DEFAULT_TEXT_SEARCH_PREVIEW_OPTIONS,\n            surroundingContext: this.query.surroundingContext ?? 0,\n        };\n        if ('usePCRE2' in this.query) {\n            searchOptions.usePCRE2 = this.query.usePCRE2;\n        }\n        let result;\n        if (this.queryProviderPair.query.type === 3 ) {\n            result = await this.queryProviderPair.provider.provideAITextSearchResults(this.queryProviderPair.query.contentPattern, searchOptions, progress, token);\n        }\n        else {\n            result = await this.queryProviderPair.provider.provideTextSearchResults(patternInfoToQuery(this.queryProviderPair.query.contentPattern), searchOptions, progress, token);\n        }\n        if (testingPs.length) {\n            await Promise.all(testingPs);\n        }\n        return result;\n    }\n    getSearchOptionsForFolder(fq) {\n        const includes = resolvePatternsForProvider(this.query.includePattern, fq.includePattern);\n        let excludePattern = fq.excludePattern?.map(e => ({\n            folder: e.folder,\n            patterns: resolvePatternsForProvider(this.query.excludePattern, e.pattern)\n        }));\n        if (!excludePattern || excludePattern.length === 0) {\n            excludePattern = [{\n                    folder: undefined,\n                    patterns: resolvePatternsForProvider(this.query.excludePattern, undefined)\n                }];\n        }\n        const excludes = excludeToGlobPattern(excludePattern);\n        const options = {\n            folder: ( URI.from(fq.folder)),\n            excludes,\n            includes,\n            useIgnoreFiles: {\n                local: !fq.disregardIgnoreFiles,\n                parent: !fq.disregardParentIgnoreFiles,\n                global: !fq.disregardGlobalIgnoreFiles\n            },\n            followSymlinks: !fq.ignoreSymlinks,\n            encoding: (fq.fileEncoding && this.fileUtils.toCanonicalName(fq.fileEncoding)) ?? '',\n        };\n        return options;\n    }\n}\nfunction patternInfoToQuery(patternInfo) {\n    return {\n        isCaseSensitive: patternInfo.isCaseSensitive || false,\n        isRegExp: patternInfo.isRegExp || false,\n        isWordMatch: patternInfo.isWordMatch || false,\n        isMultiline: patternInfo.isMultiline || false,\n        pattern: patternInfo.pattern\n    };\n}\nclass TextSearchResultsCollector {\n    constructor(_onResult) {\n        this._onResult = _onResult;\n        this._currentFolderIdx = -1;\n        this._currentFileMatch = null;\n        this._batchedCollector = ( new BatchedCollector(512, items => this.sendItems(items)));\n    }\n    add(data, folderIdx) {\n        if (this._currentFileMatch && (this._currentFolderIdx !== folderIdx || !isEqual(this._currentUri, data.uri))) {\n            this.pushToCollector();\n            this._currentFileMatch = null;\n        }\n        if (!this._currentFileMatch) {\n            this._currentFolderIdx = folderIdx;\n            this._currentFileMatch = {\n                resource: data.uri,\n                results: []\n            };\n        }\n        this._currentFileMatch.results.push(extensionResultToFrontendResult(data));\n    }\n    pushToCollector() {\n        const size = this._currentFileMatch && this._currentFileMatch.results ?\n            this._currentFileMatch.results.length :\n            0;\n        this._batchedCollector.addItem(this._currentFileMatch, size);\n    }\n    flush() {\n        this.pushToCollector();\n        this._batchedCollector.flush();\n    }\n    sendItems(items) {\n        this._onResult(items);\n    }\n}\nfunction extensionResultToFrontendResult(data) {\n    if (data instanceof TextSearchMatchNew) {\n        return {\n            previewText: data.previewText,\n            rangeLocations: ( data.ranges.map(r => ({\n                preview: {\n                    startLineNumber: r.previewRange.start.line,\n                    startColumn: r.previewRange.start.character,\n                    endLineNumber: r.previewRange.end.line,\n                    endColumn: r.previewRange.end.character\n                },\n                source: {\n                    startLineNumber: r.sourceRange.start.line,\n                    startColumn: r.sourceRange.start.character,\n                    endLineNumber: r.sourceRange.end.line,\n                    endColumn: r.sourceRange.end.character\n                },\n            }))),\n        };\n    }\n    else {\n        return {\n            text: data.text,\n            lineNumber: data.lineNumber\n        };\n    }\n}\nclass BatchedCollector {\n    static { this.TIMEOUT = 4000; }\n    static { this.START_BATCH_AFTER_COUNT = 50; }\n    constructor(maxBatchSize, cb) {\n        this.maxBatchSize = maxBatchSize;\n        this.cb = cb;\n        this.totalNumberCompleted = 0;\n        this.batch = [];\n        this.batchSize = 0;\n    }\n    addItem(item, size) {\n        if (!item) {\n            return;\n        }\n        this.addItemToBatch(item, size);\n    }\n    addItems(items, size) {\n        if (!items) {\n            return;\n        }\n        this.addItemsToBatch(items, size);\n    }\n    addItemToBatch(item, size) {\n        this.batch.push(item);\n        this.batchSize += size;\n        this.onUpdate();\n    }\n    addItemsToBatch(item, size) {\n        this.batch = this.batch.concat(item);\n        this.batchSize += size;\n        this.onUpdate();\n    }\n    onUpdate() {\n        if (this.totalNumberCompleted < BatchedCollector.START_BATCH_AFTER_COUNT) {\n            this.flush();\n        }\n        else if (this.batchSize >= this.maxBatchSize) {\n            this.flush();\n        }\n        else if (!this.timeoutHandle) {\n            this.timeoutHandle = setTimeout(() => {\n                this.flush();\n            }, BatchedCollector.TIMEOUT);\n        }\n    }\n    flush() {\n        if (this.batchSize) {\n            this.totalNumberCompleted += this.batchSize;\n            this.cb(this.batch);\n            this.batch = [];\n            this.batchSize = 0;\n            if (this.timeoutHandle) {\n                clearTimeout(this.timeoutHandle);\n                this.timeoutHandle = 0;\n            }\n        }\n    }\n}\nexport { BatchedCollector, TextSearchManager, TextSearchResultsCollector };\n","import '../vscode/src/vs/workbench/api/worker/extensionHostWorker.esm.js';\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"vendors-node_modules_vscode_workers_extensionHost_worker_js\": 0\n};\n\n// no install chunk\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no external install chunk\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);","","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [\"vendors-node_modules_vscode_vscode_src_vs_base_common_assert_js-node_modules_vscode_vscode_sr-39c9f0\",\"vendors-node_modules_vscode_vscode_src_vs_base_common_buffer_js-node_modules_vscode_vscode_sr-2c9cae\",\"vendors-node_modules_vscode_vscode_src_vs_base_common_hash_js-node_modules_vscode_vscode_src_-ae4189\"], () => (__webpack_require__(\"./node_modules/vscode/workers/extensionHost.worker.js\")))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n",""],"names":[],"sourceRoot":""}