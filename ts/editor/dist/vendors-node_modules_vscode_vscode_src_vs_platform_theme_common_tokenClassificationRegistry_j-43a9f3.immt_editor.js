(self["webpackChunkimmt_editor"] = self["webpackChunkimmt_editor"] || []).push([["vendors-node_modules_vscode_vscode_src_vs_platform_theme_common_tokenClassificationRegistry_j-43a9f3"],{

/***/ "./node_modules/vscode/vscode/src/vs/platform/theme/common/tokenClassificationRegistry.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/vscode/vscode/src/vs/platform/theme/common/tokenClassificationRegistry.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SemanticTokenRule: () => (/* binding */ SemanticTokenRule),
/* harmony export */   TokenStyle: () => (/* binding */ TokenStyle),
/* harmony export */   getTokenClassificationRegistry: () => (/* binding */ getTokenClassificationRegistry),
/* harmony export */   parseClassifierString: () => (/* binding */ parseClassifierString),
/* harmony export */   tokenStylingSchemaId: () => (/* binding */ tokenStylingSchemaId),
/* harmony export */   typeAndModifierIdPattern: () => (/* binding */ typeAndModifierIdPattern)
/* harmony export */ });
/* harmony import */ var _base_common_async_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/async.js */ "./node_modules/vscode/vscode/src/vs/base/common/async.js");
/* harmony import */ var _base_common_color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../base/common/color.js */ "./node_modules/vscode/vscode/src/vs/base/common/color.js");
/* harmony import */ var _base_common_event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../base/common/event.js */ "./node_modules/vscode/vscode/src/vs/base/common/event.js");
/* harmony import */ var _nls_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../nls.js */ "./node_modules/vscode/vscode/src/vs/nls.js");
/* harmony import */ var _jsonschemas_common_jsonContributionRegistry_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../jsonschemas/common/jsonContributionRegistry.js */ "./node_modules/vscode/vscode/src/vs/platform/jsonschemas/common/jsonContributionRegistry.js");
/* harmony import */ var _registry_common_platform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../registry/common/platform.js */ "./node_modules/vscode/vscode/src/vs/platform/registry/common/platform.js");






const TOKEN_TYPE_WILDCARD = '*';
const TOKEN_CLASSIFIER_LANGUAGE_SEPARATOR = ':';
const CLASSIFIER_MODIFIER_SEPARATOR = '.';
const idPattern = '\\w+[-_\\w+]*';
const typeAndModifierIdPattern = `^${idPattern}$`;
const selectorPattern = `^(${idPattern}|\\*)(\\${CLASSIFIER_MODIFIER_SEPARATOR}${idPattern})*(${TOKEN_CLASSIFIER_LANGUAGE_SEPARATOR}${idPattern})?$`;
const fontStylePattern = '^(\\s*(italic|bold|underline|strikethrough))*\\s*$';
class TokenStyle {
    constructor(foreground, bold, underline, strikethrough, italic) {
        this.foreground = foreground;
        this.bold = bold;
        this.underline = underline;
        this.strikethrough = strikethrough;
        this.italic = italic;
    }
}
( ((function(TokenStyle) {
    function toJSONObject(style) {
        return {
            _foreground: style.foreground === undefined ? null : _base_common_color_js__WEBPACK_IMPORTED_MODULE_1__.Color.Format.CSS.formatHexA(style.foreground, true),
            _bold: style.bold === undefined ? null : style.bold,
            _underline: style.underline === undefined ? null : style.underline,
            _italic: style.italic === undefined ? null : style.italic,
            _strikethrough: style.strikethrough === undefined ? null : style.strikethrough,
        };
    }
    TokenStyle.toJSONObject = toJSONObject;
    function fromJSONObject(obj) {
        if (obj) {
            const boolOrUndef = (b) => (typeof b === 'boolean') ? b : undefined;
            const colorOrUndef = (s) => (typeof s === 'string') ? ( (_base_common_color_js__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(s))) : undefined;
            return (
                 (new TokenStyle(
                    colorOrUndef(obj._foreground),
                    boolOrUndef(obj._bold),
                    boolOrUndef(obj._underline),
                    boolOrUndef(obj._strikethrough),
                    boolOrUndef(obj._italic)
                ))
            );
        }
        return undefined;
    }
    TokenStyle.fromJSONObject = fromJSONObject;
    function equals(s1, s2) {
        if (s1 === s2) {
            return true;
        }
        return s1 !== undefined && s2 !== undefined
            && (s1.foreground instanceof _base_common_color_js__WEBPACK_IMPORTED_MODULE_1__.Color ? s1.foreground.equals(s2.foreground) : s2.foreground === undefined)
            && s1.bold === s2.bold
            && s1.underline === s2.underline
            && s1.strikethrough === s2.strikethrough
            && s1.italic === s2.italic;
    }
    TokenStyle.equals = equals;
    function is(s) {
        return s instanceof TokenStyle;
    }
    TokenStyle.is = is;
    function fromData(data) {
        return (
             (new TokenStyle(
                data.foreground,
                data.bold,
                data.underline,
                data.strikethrough,
                data.italic
            ))
        );
    }
    TokenStyle.fromData = fromData;
    function fromSettings(foreground, fontStyle, bold, underline, strikethrough, italic) {
        let foregroundColor = undefined;
        if (foreground !== undefined) {
            foregroundColor = ( (_base_common_color_js__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(foreground)));
        }
        if (fontStyle !== undefined) {
            bold = italic = underline = strikethrough = false;
            const expression = /italic|bold|underline|strikethrough/g;
            let match;
            while ((match = expression.exec(fontStyle))) {
                switch (match[0]) {
                    case 'bold':
                        bold = true;
                        break;
                    case 'italic':
                        italic = true;
                        break;
                    case 'underline':
                        underline = true;
                        break;
                    case 'strikethrough':
                        strikethrough = true;
                        break;
                }
            }
        }
        return (
             (new TokenStyle(foregroundColor, bold, underline, strikethrough, italic))
        );
    }
    TokenStyle.fromSettings = fromSettings;
})(TokenStyle || (TokenStyle = {}))));
var SemanticTokenRule;
( ((function(SemanticTokenRule) {
    function fromJSONObject(registry, o) {
        if (o && typeof o._selector === 'string' && o._style) {
            const style = TokenStyle.fromJSONObject(o._style);
            if (style) {
                try {
                    return { selector: registry.parseTokenSelector(o._selector), style };
                }
                catch (_ignore) {
                }
            }
        }
        return undefined;
    }
    SemanticTokenRule.fromJSONObject = fromJSONObject;
    function toJSONObject(rule) {
        return {
            _selector: rule.selector.id,
            _style: TokenStyle.toJSONObject(rule.style)
        };
    }
    SemanticTokenRule.toJSONObject = toJSONObject;
    function equals(r1, r2) {
        if (r1 === r2) {
            return true;
        }
        return r1 !== undefined && r2 !== undefined
            && r1.selector && r2.selector && r1.selector.id === r2.selector.id
            && TokenStyle.equals(r1.style, r2.style);
    }
    SemanticTokenRule.equals = equals;
    function is(r) {
        return r && r.selector && typeof r.selector.id === 'string' && TokenStyle.is(r.style);
    }
    SemanticTokenRule.is = is;
})(SemanticTokenRule || (SemanticTokenRule = {}))));
const Extensions = {
    TokenClassificationContribution: 'base.contributions.tokenClassification'
};
class TokenClassificationRegistry {
    constructor() {
        this._onDidChangeSchema = ( (new _base_common_event_js__WEBPACK_IMPORTED_MODULE_2__.Emitter()));
        this.onDidChangeSchema = this._onDidChangeSchema.event;
        this.currentTypeNumber = 0;
        this.currentModifierBit = 1;
        this.tokenStylingDefaultRules = [];
        this.tokenStylingSchema = {
            type: 'object',
            properties: {},
            patternProperties: {
                [selectorPattern]: getStylingSchemeEntry()
            },
            additionalProperties: false,
            definitions: {
                style: {
                    type: 'object',
                    description: ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(7072, 'Colors and styles for the token.')),
                    properties: {
                        foreground: {
                            type: 'string',
                            description: ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(7073, 'Foreground color for the token.')),
                            format: 'color-hex',
                            default: '#ff0000'
                        },
                        background: {
                            type: 'string',
                            deprecationMessage: ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(7074, 'Token background colors are currently not supported.'))
                        },
                        fontStyle: {
                            type: 'string',
                            description: ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(
                                7075,
                                'Sets the all font styles of the rule: \'italic\', \'bold\', \'underline\' or \'strikethrough\' or a combination. All styles that are not listed are unset. The empty string unsets all styles.'
                            )),
                            pattern: fontStylePattern,
                            patternErrorMessage: ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(
                                7076,
                                'Font style must be \'italic\', \'bold\', \'underline\' or \'strikethrough\' or a combination. The empty string unsets all styles.'
                            )),
                            defaultSnippets: [
                                { label: ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(7077, 'None (clear inherited style)')), bodyText: '""' },
                                { body: 'italic' },
                                { body: 'bold' },
                                { body: 'underline' },
                                { body: 'strikethrough' },
                                { body: 'italic bold' },
                                { body: 'italic underline' },
                                { body: 'italic strikethrough' },
                                { body: 'bold underline' },
                                { body: 'bold strikethrough' },
                                { body: 'underline strikethrough' },
                                { body: 'italic bold underline' },
                                { body: 'italic bold strikethrough' },
                                { body: 'italic underline strikethrough' },
                                { body: 'bold underline strikethrough' },
                                { body: 'italic bold underline strikethrough' }
                            ]
                        },
                        bold: {
                            type: 'boolean',
                            description: ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(
                                7078,
                                'Sets or unsets the font style to bold. Note, the presence of \'fontStyle\' overrides this setting.'
                            )),
                        },
                        italic: {
                            type: 'boolean',
                            description: ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(
                                7079,
                                'Sets or unsets the font style to italic. Note, the presence of \'fontStyle\' overrides this setting.'
                            )),
                        },
                        underline: {
                            type: 'boolean',
                            description: ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(
                                7080,
                                'Sets or unsets the font style to underline. Note, the presence of \'fontStyle\' overrides this setting.'
                            )),
                        },
                        strikethrough: {
                            type: 'boolean',
                            description: ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(
                                7081,
                                'Sets or unsets the font style to strikethrough. Note, the presence of \'fontStyle\' overrides this setting.'
                            )),
                        }
                    },
                    defaultSnippets: [{ body: { foreground: '${1:#FF0000}', fontStyle: '${2:bold}' } }]
                }
            }
        };
        this.tokenTypeById = Object.create(null);
        this.tokenModifierById = Object.create(null);
        this.typeHierarchy = Object.create(null);
    }
    registerTokenType(id, description, superType, deprecationMessage) {
        if (!id.match(typeAndModifierIdPattern)) {
            throw ( (new Error('Invalid token type id.')));
        }
        if (superType && !superType.match(typeAndModifierIdPattern)) {
            throw ( (new Error('Invalid token super type id.')));
        }
        const num = this.currentTypeNumber++;
        const tokenStyleContribution = { num, id, superType, description, deprecationMessage };
        this.tokenTypeById[id] = tokenStyleContribution;
        const stylingSchemeEntry = getStylingSchemeEntry(description, deprecationMessage);
        this.tokenStylingSchema.properties[id] = stylingSchemeEntry;
        this.typeHierarchy = Object.create(null);
    }
    registerTokenModifier(id, description, deprecationMessage) {
        if (!id.match(typeAndModifierIdPattern)) {
            throw ( (new Error('Invalid token modifier id.')));
        }
        const num = this.currentModifierBit;
        this.currentModifierBit = this.currentModifierBit * 2;
        const tokenStyleContribution = { num, id, description, deprecationMessage };
        this.tokenModifierById[id] = tokenStyleContribution;
        this.tokenStylingSchema.properties[`*.${id}`] = getStylingSchemeEntry(description, deprecationMessage);
    }
    parseTokenSelector(selectorString, language) {
        const selector = parseClassifierString(selectorString, language);
        if (!selector.type) {
            return {
                match: () => -1,
                id: '$invalid'
            };
        }
        return {
            match: (type, modifiers, language) => {
                let score = 0;
                if (selector.language !== undefined) {
                    if (selector.language !== language) {
                        return -1;
                    }
                    score += 10;
                }
                if (selector.type !== TOKEN_TYPE_WILDCARD) {
                    const hierarchy = this.getTypeHierarchy(type);
                    const level = hierarchy.indexOf(selector.type);
                    if (level === -1) {
                        return -1;
                    }
                    score += (100 - level);
                }
                for (const selectorModifier of selector.modifiers) {
                    if (modifiers.indexOf(selectorModifier) === -1) {
                        return -1;
                    }
                }
                return score + selector.modifiers.length * 100;
            },
            id: `${[selector.type, ...selector.modifiers.sort()].join('.')}${selector.language !== undefined ? ':' + selector.language : ''}`
        };
    }
    registerTokenStyleDefault(selector, defaults) {
        this.tokenStylingDefaultRules.push({ selector, defaults });
    }
    deregisterTokenStyleDefault(selector) {
        const selectorString = selector.id;
        this.tokenStylingDefaultRules = this.tokenStylingDefaultRules.filter(r => r.selector.id !== selectorString);
    }
    deregisterTokenType(id) {
        delete this.tokenTypeById[id];
        delete this.tokenStylingSchema.properties[id];
        this.typeHierarchy = Object.create(null);
    }
    deregisterTokenModifier(id) {
        delete this.tokenModifierById[id];
        delete this.tokenStylingSchema.properties[`*.${id}`];
    }
    getTokenTypes() {
        return (
             (( (Object.keys(this.tokenTypeById))).map(id => this.tokenTypeById[id]))
        );
    }
    getTokenModifiers() {
        return (
             (( (Object.keys(this.tokenModifierById))).map(id => this.tokenModifierById[id]))
        );
    }
    getTokenStylingSchema() {
        return this.tokenStylingSchema;
    }
    getTokenStylingDefaultRules() {
        return this.tokenStylingDefaultRules;
    }
    getTypeHierarchy(typeId) {
        let hierarchy = this.typeHierarchy[typeId];
        if (!hierarchy) {
            this.typeHierarchy[typeId] = hierarchy = [typeId];
            let type = this.tokenTypeById[typeId];
            while (type && type.superType) {
                hierarchy.push(type.superType);
                type = this.tokenTypeById[type.superType];
            }
        }
        return hierarchy;
    }
    toString() {
        const sorter = (a, b) => {
            const cat1 = a.indexOf('.') === -1 ? 0 : 1;
            const cat2 = b.indexOf('.') === -1 ? 0 : 1;
            if (cat1 !== cat2) {
                return cat1 - cat2;
            }
            return a.localeCompare(b);
        };
        return ( (( (Object.keys(this.tokenTypeById))).sort(sorter).map(k => `- \`${k}\`: ${this.tokenTypeById[k].description}`))).join('\n');
    }
}
const CHAR_LANGUAGE = TOKEN_CLASSIFIER_LANGUAGE_SEPARATOR.charCodeAt(0);
const CHAR_MODIFIER = CLASSIFIER_MODIFIER_SEPARATOR.charCodeAt(0);
function parseClassifierString(s, defaultLanguage) {
    let k = s.length;
    let language = defaultLanguage;
    const modifiers = [];
    for (let i = k - 1; i >= 0; i--) {
        const ch = s.charCodeAt(i);
        if (ch === CHAR_LANGUAGE || ch === CHAR_MODIFIER) {
            const segment = s.substring(i + 1, k);
            k = i;
            if (ch === CHAR_LANGUAGE) {
                language = segment;
            }
            else {
                modifiers.push(segment);
            }
        }
    }
    const type = s.substring(0, k);
    return { type, modifiers, language };
}
const tokenClassificationRegistry = createDefaultTokenClassificationRegistry();
_registry_common_platform_js__WEBPACK_IMPORTED_MODULE_5__.Registry.add(Extensions.TokenClassificationContribution, tokenClassificationRegistry);
function createDefaultTokenClassificationRegistry() {
    const registry = ( (new TokenClassificationRegistry()));
    function registerTokenType(id, description, scopesToProbe = [], superType, deprecationMessage) {
        registry.registerTokenType(id, description, superType, deprecationMessage);
        if (scopesToProbe) {
            registerTokenStyleDefault(id, scopesToProbe);
        }
        return id;
    }
    function registerTokenStyleDefault(selectorString, scopesToProbe) {
        try {
            const selector = registry.parseTokenSelector(selectorString);
            registry.registerTokenStyleDefault(selector, { scopesToProbe });
        }
        catch (e) {
            console.log(e);
        }
    }
    registerTokenType('comment', ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(7082, "Style for comments.")), [['comment']]);
    registerTokenType('string', ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(7083, "Style for strings.")), [['string']]);
    registerTokenType('keyword', ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(7084, "Style for keywords.")), [['keyword.control']]);
    registerTokenType('number', ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(7085, "Style for numbers.")), [['constant.numeric']]);
    registerTokenType('regexp', ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(7086, "Style for expressions.")), [['constant.regexp']]);
    registerTokenType('operator', ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(7087, "Style for operators.")), [['keyword.operator']]);
    registerTokenType('namespace', ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(7088, "Style for namespaces.")), [['entity.name.namespace']]);
    registerTokenType('type', ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(7089, "Style for types.")), [['entity.name.type'], ['support.type']]);
    registerTokenType('struct', ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(7090, "Style for structs.")), [['entity.name.type.struct']]);
    registerTokenType('class', ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(7091, "Style for classes.")), [['entity.name.type.class'], ['support.class']]);
    registerTokenType('interface', ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(7092, "Style for interfaces.")), [['entity.name.type.interface']]);
    registerTokenType('enum', ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(7093, "Style for enums.")), [['entity.name.type.enum']]);
    registerTokenType('typeParameter', ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(7094, "Style for type parameters.")), [['entity.name.type.parameter']]);
    registerTokenType('function', ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(7095, "Style for functions")), [['entity.name.function'], ['support.function']]);
    registerTokenType('member', ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(7096, "Style for member functions")), [], 'method', 'Deprecated use `method` instead');
    registerTokenType('method', ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(7097, "Style for method (member functions)")), [['entity.name.function.member'], ['support.function']]);
    registerTokenType('macro', ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(7098, "Style for macros.")), [['entity.name.function.preprocessor']]);
    registerTokenType('variable', ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(7099, "Style for variables.")), [['variable.other.readwrite'], ['entity.name.variable']]);
    registerTokenType('parameter', ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(7100, "Style for parameters.")), [['variable.parameter']]);
    registerTokenType('property', ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(7101, "Style for properties.")), [['variable.other.property']]);
    registerTokenType('enumMember', ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(7102, "Style for enum members.")), [['variable.other.enummember']]);
    registerTokenType('event', ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(7103, "Style for events.")), [['variable.other.event']]);
    registerTokenType('decorator', ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(7104, "Style for decorators & annotations.")), [['entity.name.decorator'], ['entity.name.function']]);
    registerTokenType('label', ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(7105, "Style for labels. ")), undefined);
    registry.registerTokenModifier('declaration', ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(7106, "Style for all symbol declarations.")), undefined);
    registry.registerTokenModifier('documentation', ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(7107, "Style to use for references in documentation.")), undefined);
    registry.registerTokenModifier('static', ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(7108, "Style to use for symbols that are static.")), undefined);
    registry.registerTokenModifier('abstract', ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(7109, "Style to use for symbols that are abstract.")), undefined);
    registry.registerTokenModifier('deprecated', ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(7110, "Style to use for symbols that are deprecated.")), undefined);
    registry.registerTokenModifier('modification', ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(7111, "Style to use for write accesses.")), undefined);
    registry.registerTokenModifier('async', ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(7112, "Style to use for symbols that are async.")), undefined);
    registry.registerTokenModifier('readonly', ( (0,_nls_js__WEBPACK_IMPORTED_MODULE_3__.localize)(7113, "Style to use for symbols that are read-only.")), undefined);
    registerTokenStyleDefault('variable.readonly', [['variable.other.constant']]);
    registerTokenStyleDefault('property.readonly', [['variable.other.constant.property']]);
    registerTokenStyleDefault('type.defaultLibrary', [['support.type']]);
    registerTokenStyleDefault('class.defaultLibrary', [['support.class']]);
    registerTokenStyleDefault('interface.defaultLibrary', [['support.class']]);
    registerTokenStyleDefault('variable.defaultLibrary', [['support.variable'], ['support.other.variable']]);
    registerTokenStyleDefault('variable.defaultLibrary.readonly', [['support.constant']]);
    registerTokenStyleDefault('property.defaultLibrary', [['support.variable.property']]);
    registerTokenStyleDefault('property.defaultLibrary.readonly', [['support.constant.property']]);
    registerTokenStyleDefault('function.defaultLibrary', [['support.function']]);
    registerTokenStyleDefault('member.defaultLibrary', [['support.function']]);
    return registry;
}
function getTokenClassificationRegistry() {
    return tokenClassificationRegistry;
}
function getStylingSchemeEntry(description, deprecationMessage) {
    return {
        description,
        deprecationMessage,
        defaultSnippets: [{ body: '${1:#ff0000}' }],
        anyOf: [
            {
                type: 'string',
                format: 'color-hex'
            },
            {
                $ref: '#/definitions/style'
            }
        ]
    };
}
const tokenStylingSchemaId = 'vscode://schemas/token-styling';
const schemaRegistry = ( _registry_common_platform_js__WEBPACK_IMPORTED_MODULE_5__.Registry.as(_jsonschemas_common_jsonContributionRegistry_js__WEBPACK_IMPORTED_MODULE_4__.Extensions.JSONContribution));
schemaRegistry.registerSchema(tokenStylingSchemaId, tokenClassificationRegistry.getTokenStylingSchema());
const delayer = ( (new _base_common_async_js__WEBPACK_IMPORTED_MODULE_0__.RunOnceScheduler(() => schemaRegistry.notifySchemaChanged(tokenStylingSchemaId), 200)));
tokenClassificationRegistry.onDidChangeSchema(() => {
    if (!delayer.isScheduled()) {
        delayer.schedule();
    }
});



/***/ }),

/***/ "./node_modules/vscode/vscode/src/vs/workbench/services/textMate/common/TMHelper.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/vscode/vscode/src/vs/workbench/services/textMate/common/TMHelper.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ThemeRule: () => (/* binding */ ThemeRule),
/* harmony export */   findMatchingThemeRule: () => (/* binding */ findMatchingThemeRule)
/* harmony export */ });
function findMatchingThemeRule(theme, scopes, onlyColorRules = true) {
    for (let i = scopes.length - 1; i >= 0; i--) {
        const parentScopes = scopes.slice(0, i);
        const scope = scopes[i];
        const r = findMatchingThemeRule2(theme, scope, parentScopes, onlyColorRules);
        if (r) {
            return r;
        }
    }
    return null;
}
function findMatchingThemeRule2(theme, scope, parentScopes, onlyColorRules) {
    let result = null;
    for (let i = theme.tokenColors.length - 1; i >= 0; i--) {
        const rule = theme.tokenColors[i];
        if (onlyColorRules && !rule.settings.foreground) {
            continue;
        }
        let selectors;
        if (typeof rule.scope === 'string') {
            selectors = ( rule.scope.split(/,/).map(scope => scope.trim()));
        }
        else if (Array.isArray(rule.scope)) {
            selectors = rule.scope;
        }
        else {
            continue;
        }
        for (let j = 0, lenJ = selectors.length; j < lenJ; j++) {
            const rawSelector = selectors[j];
            const themeRule = ( new ThemeRule(rawSelector, rule.settings));
            if (themeRule.matches(scope, parentScopes)) {
                if (themeRule.isMoreSpecific(result)) {
                    result = themeRule;
                }
            }
        }
    }
    return result;
}
class ThemeRule {
    constructor(rawSelector, settings) {
        this.rawSelector = rawSelector;
        this.settings = settings;
        const rawSelectorPieces = this.rawSelector.split(/ /);
        this.scope = rawSelectorPieces[rawSelectorPieces.length - 1];
        this.parentScopes = rawSelectorPieces.slice(0, rawSelectorPieces.length - 1);
    }
    matches(scope, parentScopes) {
        return ThemeRule._matches(this.scope, this.parentScopes, scope, parentScopes);
    }
    static _cmp(a, b) {
        if (a === null && b === null) {
            return 0;
        }
        if (a === null) {
            return -1;
        }
        if (b === null) {
            return 1;
        }
        if (a.scope.length !== b.scope.length) {
            return a.scope.length - b.scope.length;
        }
        const aParentScopesLen = a.parentScopes.length;
        const bParentScopesLen = b.parentScopes.length;
        if (aParentScopesLen !== bParentScopesLen) {
            return aParentScopesLen - bParentScopesLen;
        }
        for (let i = 0; i < aParentScopesLen; i++) {
            const aLen = a.parentScopes[i].length;
            const bLen = b.parentScopes[i].length;
            if (aLen !== bLen) {
                return aLen - bLen;
            }
        }
        return 0;
    }
    isMoreSpecific(other) {
        return (ThemeRule._cmp(this, other) > 0);
    }
    static _matchesOne(selectorScope, scope) {
        const selectorPrefix = selectorScope + '.';
        if (selectorScope === scope || scope.substring(0, selectorPrefix.length) === selectorPrefix) {
            return true;
        }
        return false;
    }
    static _matches(selectorScope, selectorParentScopes, scope, parentScopes) {
        if (!this._matchesOne(selectorScope, scope)) {
            return false;
        }
        let selectorParentIndex = selectorParentScopes.length - 1;
        let parentIndex = parentScopes.length - 1;
        while (selectorParentIndex >= 0 && parentIndex >= 0) {
            if (this._matchesOne(selectorParentScopes[selectorParentIndex], parentScopes[parentIndex])) {
                selectorParentIndex--;
            }
            parentIndex--;
        }
        if (selectorParentIndex === -1) {
            return true;
        }
        return false;
    }
}



/***/ }),

/***/ "./node_modules/vscode/vscode/src/vs/workbench/services/themes/common/workbenchThemeService.service.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/vscode/vscode/src/vs/workbench/services/themes/common/workbenchThemeService.service.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IWorkbenchThemeService: () => (/* binding */ IWorkbenchThemeService)
/* harmony export */ });
/* harmony import */ var _platform_instantiation_common_instantiation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../platform/instantiation/common/instantiation.js */ "./node_modules/vscode/vscode/src/vs/platform/instantiation/common/instantiation.js");
/* harmony import */ var _platform_theme_common_themeService_service_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../platform/theme/common/themeService.service.js */ "./node_modules/vscode/vscode/src/vs/platform/theme/common/themeService.service.js");


const IWorkbenchThemeService = (0,_platform_instantiation_common_instantiation_js__WEBPACK_IMPORTED_MODULE_0__.refineServiceDecorator)(_platform_theme_common_themeService_service_js__WEBPACK_IMPORTED_MODULE_1__.IThemeService);



/***/ })

}])
//# sourceMappingURL=vendors-node_modules_vscode_vscode_src_vs_platform_theme_common_tokenClassificationRegistry_j-43a9f3.immt_editor.js.map