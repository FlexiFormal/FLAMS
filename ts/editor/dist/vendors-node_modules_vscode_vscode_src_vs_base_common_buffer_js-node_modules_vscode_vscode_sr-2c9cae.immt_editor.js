(self["webpackChunkimmt_editor"] = self["webpackChunkimmt_editor"] || []).push([["vendors-node_modules_vscode_vscode_src_vs_base_common_buffer_js-node_modules_vscode_vscode_sr-2c9cae"],{

/***/ "./node_modules/vscode/vscode/src/vs/base/common/buffer.js":
/*!*****************************************************************!*\
  !*** ./node_modules/vscode/vscode/src/vs/base/common/buffer.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VSBuffer: () => (/* binding */ VSBuffer),
/* harmony export */   binaryIndexOf: () => (/* binding */ binaryIndexOf),
/* harmony export */   bufferToReadable: () => (/* binding */ bufferToReadable),
/* harmony export */   bufferToStream: () => (/* binding */ bufferToStream),
/* harmony export */   bufferedStreamToBuffer: () => (/* binding */ bufferedStreamToBuffer),
/* harmony export */   decodeBase64: () => (/* binding */ decodeBase64),
/* harmony export */   encodeBase64: () => (/* binding */ encodeBase64),
/* harmony export */   newWriteableBufferStream: () => (/* binding */ newWriteableBufferStream),
/* harmony export */   prefixedBufferReadable: () => (/* binding */ prefixedBufferReadable),
/* harmony export */   prefixedBufferStream: () => (/* binding */ prefixedBufferStream),
/* harmony export */   readUInt16LE: () => (/* binding */ readUInt16LE),
/* harmony export */   readUInt32BE: () => (/* binding */ readUInt32BE),
/* harmony export */   readUInt32LE: () => (/* binding */ readUInt32LE),
/* harmony export */   readUInt8: () => (/* binding */ readUInt8),
/* harmony export */   readableToBuffer: () => (/* binding */ readableToBuffer),
/* harmony export */   streamToBuffer: () => (/* binding */ streamToBuffer),
/* harmony export */   writeUInt16LE: () => (/* binding */ writeUInt16LE),
/* harmony export */   writeUInt32BE: () => (/* binding */ writeUInt32BE),
/* harmony export */   writeUInt32LE: () => (/* binding */ writeUInt32LE),
/* harmony export */   writeUInt8: () => (/* binding */ writeUInt8)
/* harmony export */ });
/* harmony import */ var _lazy_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lazy.js */ "./node_modules/vscode/vscode/src/vs/base/common/lazy.js");
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stream.js */ "./node_modules/vscode/vscode/src/vs/base/common/stream.js");


const hasBuffer = (typeof Buffer !== 'undefined');
const indexOfTable = ( new _lazy_js__WEBPACK_IMPORTED_MODULE_0__.Lazy(() => ( new Uint8Array(256))));
let textEncoder;
let textDecoder;
class VSBuffer {
    static alloc(byteLength) {
        if (hasBuffer) {
            return ( new VSBuffer(Buffer.allocUnsafe(byteLength)));
        }
        else {
            return ( new VSBuffer(( new Uint8Array(byteLength))));
        }
    }
    static wrap(actual) {
        if (hasBuffer && !(Buffer.isBuffer(actual))) {
            actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);
        }
        return ( new VSBuffer(actual));
    }
    static fromString(source, options) {
        const dontUseNodeBuffer = options?.dontUseNodeBuffer || false;
        if (!dontUseNodeBuffer && hasBuffer) {
            return ( new VSBuffer(Buffer.from(source)));
        }
        else {
            if (!textEncoder) {
                textEncoder = ( new TextEncoder());
            }
            return ( new VSBuffer(textEncoder.encode(source)));
        }
    }
    static fromByteArray(source) {
        const result = VSBuffer.alloc(source.length);
        for (let i = 0, len = source.length; i < len; i++) {
            result.buffer[i] = source[i];
        }
        return result;
    }
    static concat(buffers, totalLength) {
        if (typeof totalLength === 'undefined') {
            totalLength = 0;
            for (let i = 0, len = buffers.length; i < len; i++) {
                totalLength += buffers[i].byteLength;
            }
        }
        const ret = VSBuffer.alloc(totalLength);
        let offset = 0;
        for (let i = 0, len = buffers.length; i < len; i++) {
            const element = buffers[i];
            ret.set(element, offset);
            offset += element.byteLength;
        }
        return ret;
    }
    constructor(buffer) {
        this.buffer = buffer;
        this.byteLength = this.buffer.byteLength;
    }
    clone() {
        const result = VSBuffer.alloc(this.byteLength);
        result.set(this);
        return result;
    }
    toString() {
        if (hasBuffer) {
            return ( this.buffer.toString());
        }
        else {
            if (!textDecoder) {
                textDecoder = ( new TextDecoder());
            }
            return textDecoder.decode(this.buffer);
        }
    }
    slice(start, end) {
        return ( new VSBuffer(this.buffer.subarray(start, end)));
    }
    set(array, offset) {
        if (array instanceof VSBuffer) {
            this.buffer.set(array.buffer, offset);
        }
        else if (array instanceof Uint8Array) {
            this.buffer.set(array, offset);
        }
        else if (array instanceof ArrayBuffer) {
            this.buffer.set(( new Uint8Array(array)), offset);
        }
        else if (ArrayBuffer.isView(array)) {
            this.buffer.set(( new Uint8Array(array.buffer, array.byteOffset, array.byteLength)), offset);
        }
        else {
            throw ( new Error(`Unknown argument 'array'`));
        }
    }
    readUInt32BE(offset) {
        return readUInt32BE(this.buffer, offset);
    }
    writeUInt32BE(value, offset) {
        writeUInt32BE(this.buffer, value, offset);
    }
    readUInt32LE(offset) {
        return readUInt32LE(this.buffer, offset);
    }
    writeUInt32LE(value, offset) {
        writeUInt32LE(this.buffer, value, offset);
    }
    readUInt8(offset) {
        return readUInt8(this.buffer, offset);
    }
    writeUInt8(value, offset) {
        writeUInt8(this.buffer, value, offset);
    }
    indexOf(subarray, offset = 0) {
        return binaryIndexOf(this.buffer, subarray instanceof VSBuffer ? subarray.buffer : subarray, offset);
    }
}
function binaryIndexOf(haystack, needle, offset = 0) {
    const needleLen = needle.byteLength;
    const haystackLen = haystack.byteLength;
    if (needleLen === 0) {
        return 0;
    }
    if (needleLen === 1) {
        return haystack.indexOf(needle[0]);
    }
    if (needleLen > haystackLen - offset) {
        return -1;
    }
    const table = indexOfTable.value;
    table.fill(needle.length);
    for (let i = 0; i < needle.length; i++) {
        table[needle[i]] = needle.length - i - 1;
    }
    let i = offset + needle.length - 1;
    let j = i;
    let result = -1;
    while (i < haystackLen) {
        if (haystack[i] === needle[j]) {
            if (j === 0) {
                result = i;
                break;
            }
            i--;
            j--;
        }
        else {
            i += Math.max(needle.length - j, table[haystack[i]]);
            j = needle.length - 1;
        }
    }
    return result;
}
function readUInt16LE(source, offset) {
    return (((source[offset + 0] << 0) >>> 0) |
        ((source[offset + 1] << 8) >>> 0));
}
function writeUInt16LE(destination, value, offset) {
    destination[offset + 0] = (value & 0b11111111);
    value = value >>> 8;
    destination[offset + 1] = (value & 0b11111111);
}
function readUInt32BE(source, offset) {
    return (source[offset] * 2 ** 24
        + source[offset + 1] * 2 ** 16
        + source[offset + 2] * 2 ** 8
        + source[offset + 3]);
}
function writeUInt32BE(destination, value, offset) {
    destination[offset + 3] = value;
    value = value >>> 8;
    destination[offset + 2] = value;
    value = value >>> 8;
    destination[offset + 1] = value;
    value = value >>> 8;
    destination[offset] = value;
}
function readUInt32LE(source, offset) {
    return (((source[offset + 0] << 0) >>> 0) |
        ((source[offset + 1] << 8) >>> 0) |
        ((source[offset + 2] << 16) >>> 0) |
        ((source[offset + 3] << 24) >>> 0));
}
function writeUInt32LE(destination, value, offset) {
    destination[offset + 0] = (value & 0b11111111);
    value = value >>> 8;
    destination[offset + 1] = (value & 0b11111111);
    value = value >>> 8;
    destination[offset + 2] = (value & 0b11111111);
    value = value >>> 8;
    destination[offset + 3] = (value & 0b11111111);
}
function readUInt8(source, offset) {
    return source[offset];
}
function writeUInt8(destination, value, offset) {
    destination[offset] = value;
}
function readableToBuffer(readable) {
    return (0,_stream_js__WEBPACK_IMPORTED_MODULE_1__.consumeReadable)(readable, chunks => VSBuffer.concat(chunks));
}
function bufferToReadable(buffer) {
    return (0,_stream_js__WEBPACK_IMPORTED_MODULE_1__.toReadable)(buffer);
}
function streamToBuffer(stream) {
    return (0,_stream_js__WEBPACK_IMPORTED_MODULE_1__.consumeStream)(stream, chunks => VSBuffer.concat(chunks));
}
async function bufferedStreamToBuffer(bufferedStream) {
    if (bufferedStream.ended) {
        return VSBuffer.concat(bufferedStream.buffer);
    }
    return VSBuffer.concat([
        ...bufferedStream.buffer,
        await streamToBuffer(bufferedStream.stream)
    ]);
}
function bufferToStream(buffer) {
    return (0,_stream_js__WEBPACK_IMPORTED_MODULE_1__.toStream)(buffer, chunks => VSBuffer.concat(chunks));
}
function newWriteableBufferStream(options) {
    return (0,_stream_js__WEBPACK_IMPORTED_MODULE_1__.newWriteableStream)(chunks => VSBuffer.concat(chunks), options);
}
function prefixedBufferReadable(prefix, readable) {
    return (0,_stream_js__WEBPACK_IMPORTED_MODULE_1__.prefixedReadable)(prefix, readable, chunks => VSBuffer.concat(chunks));
}
function prefixedBufferStream(prefix, stream) {
    return (0,_stream_js__WEBPACK_IMPORTED_MODULE_1__.prefixedStream)(prefix, stream, chunks => VSBuffer.concat(chunks));
}
function decodeBase64(encoded) {
    let building = 0;
    let remainder = 0;
    let bufi = 0;
    const buffer = ( new Uint8Array(Math.floor(encoded.length / 4 * 3)));
    const append = (value) => {
        switch (remainder) {
            case 3:
                buffer[bufi++] = building | value;
                remainder = 0;
                break;
            case 2:
                buffer[bufi++] = building | (value >>> 2);
                building = value << 6;
                remainder = 3;
                break;
            case 1:
                buffer[bufi++] = building | (value >>> 4);
                building = value << 4;
                remainder = 2;
                break;
            default:
                building = value << 2;
                remainder = 1;
        }
    };
    for (let i = 0; i < encoded.length; i++) {
        const code = encoded.charCodeAt(i);
        if (code >= 65 && code <= 90) {
            append(code - 65);
        }
        else if (code >= 97 && code <= 122) {
            append(code - 97 + 26);
        }
        else if (code >= 48 && code <= 57) {
            append(code - 48 + 52);
        }
        else if (code === 43 || code === 45) {
            append(62);
        }
        else if (code === 47 || code === 95) {
            append(63);
        }
        else if (code === 61) {
            break;
        }
        else {
            throw ( new SyntaxError(`Unexpected base64 character ${encoded[i]}`));
        }
    }
    const unpadded = bufi;
    while (remainder > 0) {
        append(0);
    }
    return VSBuffer.wrap(buffer).slice(0, unpadded);
}
const base64Alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
const base64UrlSafeAlphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';
function encodeBase64({ buffer }, padded = true, urlSafe = false) {
    const dictionary = urlSafe ? base64UrlSafeAlphabet : base64Alphabet;
    let output = '';
    const remainder = buffer.byteLength % 3;
    let i = 0;
    for (; i < buffer.byteLength - remainder; i += 3) {
        const a = buffer[i + 0];
        const b = buffer[i + 1];
        const c = buffer[i + 2];
        output += dictionary[a >>> 2];
        output += dictionary[(a << 4 | b >>> 4) & 0b111111];
        output += dictionary[(b << 2 | c >>> 6) & 0b111111];
        output += dictionary[c & 0b111111];
    }
    if (remainder === 1) {
        const a = buffer[i + 0];
        output += dictionary[a >>> 2];
        output += dictionary[(a << 4) & 0b111111];
        if (padded) {
            output += '==';
        }
    }
    else if (remainder === 2) {
        const a = buffer[i + 0];
        const b = buffer[i + 1];
        output += dictionary[a >>> 2];
        output += dictionary[(a << 4 | b >>> 4) & 0b111111];
        output += dictionary[(b << 2) & 0b111111];
        if (padded) {
            output += '=';
        }
    }
    return output;
}



/***/ }),

/***/ "./node_modules/vscode/vscode/src/vs/base/common/equals.js":
/*!*****************************************************************!*\
  !*** ./node_modules/vscode/vscode/src/vs/base/common/equals.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   equalsIfDefined: () => (/* binding */ equalsIfDefined),
/* harmony export */   getStructuralKey: () => (/* binding */ getStructuralKey),
/* harmony export */   itemEquals: () => (/* binding */ itemEquals),
/* harmony export */   itemsEquals: () => (/* binding */ itemsEquals),
/* harmony export */   strictEquals: () => (/* binding */ strictEquals),
/* harmony export */   structuralEquals: () => (/* binding */ structuralEquals)
/* harmony export */ });
/* harmony import */ var _arrays_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrays.js */ "./node_modules/vscode/vscode/src/vs/base/common/arrays.js");

const strictEquals = (a, b) => a === b;
function itemsEquals(itemEquals = strictEquals) {
    return (a, b) => (0,_arrays_js__WEBPACK_IMPORTED_MODULE_0__.equals)(a, b, itemEquals);
}
function itemEquals() {
    return (a, b) => a.equals(b);
}
function equalsIfDefined(equalsOrV1, v2, equals) {
    if (equals !== undefined) {
        const v1 = equalsOrV1;
        if (v1 === undefined || v1 === null || v2 === undefined || v2 === null) {
            return v2 === v1;
        }
        return equals(v1, v2);
    }
    else {
        const equals = equalsOrV1;
        return (v1, v2) => {
            if (v1 === undefined || v1 === null || v2 === undefined || v2 === null) {
                return v2 === v1;
            }
            return equals(v1, v2);
        };
    }
}
function structuralEquals(a, b) {
    if (a === b) {
        return true;
    }
    if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length) {
            return false;
        }
        for (let i = 0; i < a.length; i++) {
            if (!structuralEquals(a[i], b[i])) {
                return false;
            }
        }
        return true;
    }
    if (a && typeof a === 'object' && b && typeof b === 'object') {
        if (Object.getPrototypeOf(a) === Object.prototype && Object.getPrototypeOf(b) === Object.prototype) {
            const aObj = a;
            const bObj = b;
            const keysA = ( Object.keys(aObj));
            const keysB = ( Object.keys(bObj));
            const keysBSet = ( new Set(keysB));
            if (keysA.length !== keysB.length) {
                return false;
            }
            for (const key of keysA) {
                if (!( keysBSet.has(key))) {
                    return false;
                }
                if (!structuralEquals(aObj[key], bObj[key])) {
                    return false;
                }
            }
            return true;
        }
    }
    return false;
}
function getStructuralKey(t) {
    return JSON.stringify(toNormalizedJsonStructure(t));
}
let objectId = 0;
const objIds = ( new WeakMap());
function toNormalizedJsonStructure(t) {
    if (Array.isArray(t)) {
        return ( t.map(toNormalizedJsonStructure));
    }
    if (t && typeof t === 'object') {
        if (Object.getPrototypeOf(t) === Object.prototype) {
            const tObj = t;
            const res = Object.create(null);
            for (const key of ( Object.keys(tObj)).sort()) {
                res[key] = toNormalizedJsonStructure(tObj[key]);
            }
            return res;
        }
        else {
            let objId = objIds.get(t);
            if (objId === undefined) {
                objId = objectId++;
                objIds.set(t, objId);
            }
            return objId + '----2b76a038c20c4bcc';
        }
    }
    return t;
}



/***/ }),

/***/ "./node_modules/vscode/vscode/src/vs/base/common/observableInternal/autorun.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/vscode/vscode/src/vs/base/common/observableInternal/autorun.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AutorunObserver: () => (/* binding */ AutorunObserver),
/* harmony export */   autorun: () => (/* binding */ autorun),
/* harmony export */   autorunHandleChanges: () => (/* binding */ autorunHandleChanges),
/* harmony export */   autorunOpts: () => (/* binding */ autorunOpts),
/* harmony export */   autorunWithStore: () => (/* binding */ autorunWithStore),
/* harmony export */   autorunWithStoreHandleChanges: () => (/* binding */ autorunWithStoreHandleChanges)
/* harmony export */ });
/* harmony import */ var _debugName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./debugName.js */ "./node_modules/vscode/vscode/src/vs/base/common/observableInternal/debugName.js");
/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../assert.js */ "./node_modules/vscode/vscode/src/vs/base/common/assert.js");
/* harmony import */ var _arrays_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../arrays.js */ "./node_modules/vscode/vscode/src/vs/base/common/arrays.js");
/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../errors.js */ "./node_modules/vscode/vscode/src/vs/base/common/errors.js");
/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../event.js */ "./node_modules/vscode/vscode/src/vs/base/common/event.js");
/* harmony import */ var _lifecycle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../lifecycle.js */ "./node_modules/vscode/vscode/src/vs/base/common/lifecycle.js");
/* harmony import */ var _logging_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./logging.js */ "./node_modules/vscode/vscode/src/vs/base/common/observableInternal/logging.js");







function autorun(fn) {
    return ( new AutorunObserver(( new _debugName_js__WEBPACK_IMPORTED_MODULE_0__.DebugNameData(undefined, undefined, fn)), fn, undefined, undefined));
}
function autorunOpts(options, fn) {
    return ( new AutorunObserver(( new _debugName_js__WEBPACK_IMPORTED_MODULE_0__.DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? fn)), fn, undefined, undefined));
}
function autorunHandleChanges(options, fn) {
    return ( new AutorunObserver(( new _debugName_js__WEBPACK_IMPORTED_MODULE_0__.DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? fn)), fn, options.createEmptyChangeSummary, options.handleChange));
}
function autorunWithStoreHandleChanges(options, fn) {
    const store = ( new _lifecycle_js__WEBPACK_IMPORTED_MODULE_5__.DisposableStore());
    const disposable = autorunHandleChanges({
        owner: options.owner,
        debugName: options.debugName,
        debugReferenceFn: options.debugReferenceFn ?? fn,
        createEmptyChangeSummary: options.createEmptyChangeSummary,
        handleChange: options.handleChange,
    }, (reader, changeSummary) => {
        store.clear();
        fn(reader, changeSummary, store);
    });
    return (0,_lifecycle_js__WEBPACK_IMPORTED_MODULE_5__.toDisposable)(() => {
        disposable.dispose();
        store.dispose();
    });
}
function autorunWithStore(fn) {
    const store = ( new _lifecycle_js__WEBPACK_IMPORTED_MODULE_5__.DisposableStore());
    const disposable = autorunOpts({
        owner: undefined,
        debugName: undefined,
        debugReferenceFn: fn,
    }, reader => {
        store.clear();
        fn(reader, store);
    });
    return (0,_lifecycle_js__WEBPACK_IMPORTED_MODULE_5__.toDisposable)(() => {
        disposable.dispose();
        store.dispose();
    });
}
class AutorunObserver {
    get debugName() {
        return this._debugNameData.getDebugName(this) ?? '(anonymous)';
    }
    constructor(_debugNameData, _runFn, createChangeSummary, _handleChange) {
        this._debugNameData = _debugNameData;
        this._runFn = _runFn;
        this.createChangeSummary = createChangeSummary;
        this._handleChange = _handleChange;
        this.state = 2 ;
        this.updateCount = 0;
        this.disposed = false;
        this.dependencies = ( new Set());
        this.dependenciesToBeRemoved = ( new Set());
        this.changeSummary = this.createChangeSummary?.();
        this._runIfNeeded();
        (0,_lifecycle_js__WEBPACK_IMPORTED_MODULE_5__.trackDisposable)(this);
    }
    dispose() {
        this.disposed = true;
        for (const o of this.dependencies) {
            o.removeObserver(this);
        }
        this.dependencies.clear();
        (0,_lifecycle_js__WEBPACK_IMPORTED_MODULE_5__.markAsDisposed)(this);
    }
    _runIfNeeded() {
        if (this.state === 3 ) {
            return;
        }
        const emptySet = this.dependenciesToBeRemoved;
        this.dependenciesToBeRemoved = this.dependencies;
        this.dependencies = emptySet;
        this.state = 3 ;
        const isDisposed = this.disposed;
        try {
            if (!isDisposed) {
                (0,_logging_js__WEBPACK_IMPORTED_MODULE_6__.getLogger)()?.handleAutorunTriggered(this);
                const changeSummary = this.changeSummary;
                try {
                    this.changeSummary = this.createChangeSummary?.();
                    this._runFn(this, changeSummary);
                }
                catch (e) {
                    (0,_errors_js__WEBPACK_IMPORTED_MODULE_3__.onBugIndicatingError)(e);
                }
            }
        }
        finally {
            for (const o of this.dependenciesToBeRemoved) {
                o.removeObserver(this);
            }
            this.dependenciesToBeRemoved.clear();
        }
    }
    toString() {
        return `Autorun<${this.debugName}>`;
    }
    beginUpdate() {
        if (this.state === 3 ) {
            this.state = 1 ;
        }
        this.updateCount++;
    }
    endUpdate() {
        try {
            if (this.updateCount === 1) {
                do {
                    if (this.state === 1 ) {
                        this.state = 3 ;
                        for (const d of this.dependencies) {
                            d.reportChanges();
                            if (this.state === 2 ) {
                                break;
                            }
                        }
                    }
                    this._runIfNeeded();
                } while (this.state !== 3 );
            }
        }
        finally {
            this.updateCount--;
        }
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.assertFn)(() => this.updateCount >= 0);
    }
    handlePossibleChange(observable) {
        if (this.state === 3  && ( this.dependencies.has(observable)) && !( this.dependenciesToBeRemoved.has(observable))) {
            this.state = 1 ;
        }
    }
    handleChange(observable, change) {
        if (( this.dependencies.has(observable)) && !( this.dependenciesToBeRemoved.has(observable))) {
            try {
                const shouldReact = this._handleChange ? this._handleChange({
                    changedObservable: observable,
                    change,
                    didChange: (o) => o === observable,
                }, this.changeSummary) : true;
                if (shouldReact) {
                    this.state = 2 ;
                }
            }
            catch (e) {
                (0,_errors_js__WEBPACK_IMPORTED_MODULE_3__.onBugIndicatingError)(e);
            }
        }
    }
    readObservable(observable) {
        if (this.disposed) {
            return observable.get();
        }
        observable.addObserver(this);
        const value = observable.get();
        this.dependencies.add(observable);
        this.dependenciesToBeRemoved.delete(observable);
        return value;
    }
}
( (function(autorun) {
    autorun.Observer = AutorunObserver;
})(autorun || (autorun = {})));



/***/ }),

/***/ "./node_modules/vscode/vscode/src/vs/base/common/observableInternal/base.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/vscode/vscode/src/vs/base/common/observableInternal/base.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseObservable: () => (/* binding */ BaseObservable),
/* harmony export */   ConvenientObservable: () => (/* binding */ ConvenientObservable),
/* harmony export */   DisposableObservableValue: () => (/* binding */ DisposableObservableValue),
/* harmony export */   ObservableValue: () => (/* binding */ ObservableValue),
/* harmony export */   TransactionImpl: () => (/* binding */ TransactionImpl),
/* harmony export */   _setDerivedOpts: () => (/* binding */ _setDerivedOpts),
/* harmony export */   _setKeepObserved: () => (/* binding */ _setKeepObserved),
/* harmony export */   _setRecomputeInitiallyAndOnChange: () => (/* binding */ _setRecomputeInitiallyAndOnChange),
/* harmony export */   asyncTransaction: () => (/* binding */ asyncTransaction),
/* harmony export */   disposableObservableValue: () => (/* binding */ disposableObservableValue),
/* harmony export */   globalTransaction: () => (/* binding */ globalTransaction),
/* harmony export */   observableValue: () => (/* binding */ observableValue),
/* harmony export */   subtransaction: () => (/* binding */ subtransaction),
/* harmony export */   transaction: () => (/* binding */ transaction)
/* harmony export */ });
/* harmony import */ var _debugName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./debugName.js */ "./node_modules/vscode/vscode/src/vs/base/common/observableInternal/debugName.js");
/* harmony import */ var _equals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../equals.js */ "./node_modules/vscode/vscode/src/vs/base/common/equals.js");
/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../event.js */ "./node_modules/vscode/vscode/src/vs/base/common/event.js");
/* harmony import */ var _lifecycle_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lifecycle.js */ "./node_modules/vscode/vscode/src/vs/base/common/lifecycle.js");
/* harmony import */ var _logging_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./logging.js */ "./node_modules/vscode/vscode/src/vs/base/common/observableInternal/logging.js");





let _recomputeInitiallyAndOnChange;
function _setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange) {
    _recomputeInitiallyAndOnChange = recomputeInitiallyAndOnChange;
}
let _keepObserved;
function _setKeepObserved(keepObserved) {
    _keepObserved = keepObserved;
}
let _derived;
function _setDerivedOpts(derived) {
    _derived = derived;
}
class ConvenientObservable {
    get TChange() { return null; }
    reportChanges() {
        this.get();
    }
    read(reader) {
        if (reader) {
            return reader.readObservable(this);
        }
        else {
            return this.get();
        }
    }
    map(fnOrOwner, fnOrUndefined) {
        const owner = fnOrUndefined === undefined ? undefined : fnOrOwner;
        const fn = fnOrUndefined === undefined ? fnOrOwner : fnOrUndefined;
        return _derived({
            owner,
            debugName: () => {
                const name = (0,_debugName_js__WEBPACK_IMPORTED_MODULE_0__.getFunctionName)(fn);
                if (name !== undefined) {
                    return name;
                }
                const regexp = /^\s*\(?\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\s*\)?\s*=>\s*\1(?:\??)\.([a-zA-Z_$][a-zA-Z_$0-9]*)\s*$/;
                const match = regexp.exec(( fn.toString()));
                if (match) {
                    return `${this.debugName}.${match[2]}`;
                }
                if (!owner) {
                    return `${this.debugName} (mapped)`;
                }
                return undefined;
            },
            debugReferenceFn: fn,
        }, (reader) => fn(this.read(reader), reader));
    }
    flatten() {
        return _derived({
            owner: undefined,
            debugName: () => `${this.debugName} (flattened)`,
        }, (reader) => this.read(reader).read(reader));
    }
    recomputeInitiallyAndOnChange(store, handleValue) {
        store.add(_recomputeInitiallyAndOnChange(this, handleValue));
        return this;
    }
    keepObserved(store) {
        store.add(_keepObserved(this));
        return this;
    }
    get debugValue() {
        return this.get();
    }
}
class BaseObservable extends ConvenientObservable {
    constructor() {
        super(...arguments);
        this.observers = ( new Set());
    }
    addObserver(observer) {
        const len = this.observers.size;
        this.observers.add(observer);
        if (len === 0) {
            this.onFirstObserverAdded();
        }
    }
    removeObserver(observer) {
        const deleted = this.observers.delete(observer);
        if (deleted && this.observers.size === 0) {
            this.onLastObserverRemoved();
        }
    }
    onFirstObserverAdded() { }
    onLastObserverRemoved() { }
}
function transaction(fn, getDebugName) {
    const tx = ( new TransactionImpl(fn, getDebugName));
    try {
        fn(tx);
    }
    finally {
        tx.finish();
    }
}
let _globalTransaction = undefined;
function globalTransaction(fn) {
    if (_globalTransaction) {
        fn(_globalTransaction);
    }
    else {
        const tx = ( new TransactionImpl(fn, undefined));
        _globalTransaction = tx;
        try {
            fn(tx);
        }
        finally {
            tx.finish();
            _globalTransaction = undefined;
        }
    }
}
async function asyncTransaction(fn, getDebugName) {
    const tx = ( new TransactionImpl(fn, getDebugName));
    try {
        await fn(tx);
    }
    finally {
        tx.finish();
    }
}
function subtransaction(tx, fn, getDebugName) {
    if (!tx) {
        transaction(fn, getDebugName);
    }
    else {
        fn(tx);
    }
}
class TransactionImpl {
    constructor(_fn, _getDebugName) {
        this._fn = _fn;
        this._getDebugName = _getDebugName;
        this.updatingObservers = [];
    }
    getDebugName() {
        if (this._getDebugName) {
            return this._getDebugName();
        }
        return (0,_debugName_js__WEBPACK_IMPORTED_MODULE_0__.getFunctionName)(this._fn);
    }
    updateObserver(observer, observable) {
        this.updatingObservers.push({ observer, observable });
        observer.beginUpdate(observable);
    }
    finish() {
        const updatingObservers = this.updatingObservers;
        for (let i = 0; i < updatingObservers.length; i++) {
            const { observer, observable } = updatingObservers[i];
            observer.endUpdate(observable);
        }
        this.updatingObservers = null;
    }
}
function observableValue(nameOrOwner, initialValue) {
    let debugNameData;
    if (typeof nameOrOwner === 'string') {
        debugNameData = ( new _debugName_js__WEBPACK_IMPORTED_MODULE_0__.DebugNameData(undefined, nameOrOwner, undefined));
    }
    else {
        debugNameData = ( new _debugName_js__WEBPACK_IMPORTED_MODULE_0__.DebugNameData(nameOrOwner, undefined, undefined));
    }
    return ( new ObservableValue(debugNameData, initialValue, _equals_js__WEBPACK_IMPORTED_MODULE_1__.strictEquals));
}
class ObservableValue extends BaseObservable {
    get debugName() {
        return this._debugNameData.getDebugName(this) ?? 'ObservableValue';
    }
    constructor(_debugNameData, initialValue, _equalityComparator) {
        super();
        this._debugNameData = _debugNameData;
        this._equalityComparator = _equalityComparator;
        this._value = initialValue;
    }
    get() {
        return this._value;
    }
    set(value, tx, change) {
        if (change === undefined && this._equalityComparator(this._value, value)) {
            return;
        }
        let _tx;
        if (!tx) {
            tx = _tx = ( new TransactionImpl(() => { }, () => `Setting ${this.debugName}`));
        }
        try {
            const oldValue = this._value;
            this._setValue(value);
            (0,_logging_js__WEBPACK_IMPORTED_MODULE_4__.getLogger)()?.handleObservableChanged(this, { oldValue, newValue: value, change, didChange: true, hadValue: true });
            for (const observer of this.observers) {
                tx.updateObserver(observer, this);
                observer.handleChange(this, change);
            }
        }
        finally {
            if (_tx) {
                _tx.finish();
            }
        }
    }
    toString() {
        return `${this.debugName}: ${this._value}`;
    }
    _setValue(newValue) {
        this._value = newValue;
    }
}
function disposableObservableValue(nameOrOwner, initialValue) {
    let debugNameData;
    if (typeof nameOrOwner === 'string') {
        debugNameData = ( new _debugName_js__WEBPACK_IMPORTED_MODULE_0__.DebugNameData(undefined, nameOrOwner, undefined));
    }
    else {
        debugNameData = ( new _debugName_js__WEBPACK_IMPORTED_MODULE_0__.DebugNameData(nameOrOwner, undefined, undefined));
    }
    return ( new DisposableObservableValue(debugNameData, initialValue, _equals_js__WEBPACK_IMPORTED_MODULE_1__.strictEquals));
}
class DisposableObservableValue extends ObservableValue {
    _setValue(newValue) {
        if (this._value === newValue) {
            return;
        }
        if (this._value) {
            this._value.dispose();
        }
        this._value = newValue;
    }
    dispose() {
        this._value?.dispose();
    }
}



/***/ }),

/***/ "./node_modules/vscode/vscode/src/vs/base/common/observableInternal/debugName.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/vscode/vscode/src/vs/base/common/observableInternal/debugName.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DebugNameData: () => (/* binding */ DebugNameData),
/* harmony export */   getDebugName: () => (/* binding */ getDebugName),
/* harmony export */   getFunctionName: () => (/* binding */ getFunctionName)
/* harmony export */ });
class DebugNameData {
    constructor(owner, debugNameSource, referenceFn) {
        this.owner = owner;
        this.debugNameSource = debugNameSource;
        this.referenceFn = referenceFn;
    }
    getDebugName(target) {
        return getDebugName(target, this);
    }
}
const countPerName = ( new Map());
const cachedDebugName = ( new WeakMap());
function getDebugName(target, data) {
    const cached = cachedDebugName.get(target);
    if (cached) {
        return cached;
    }
    const dbgName = computeDebugName(target, data);
    if (dbgName) {
        let count = countPerName.get(dbgName) ?? 0;
        count++;
        countPerName.set(dbgName, count);
        const result = count === 1 ? dbgName : `${dbgName}#${count}`;
        cachedDebugName.set(target, result);
        return result;
    }
    return undefined;
}
function computeDebugName(self, data) {
    const cached = cachedDebugName.get(self);
    if (cached) {
        return cached;
    }
    const ownerStr = data.owner ? formatOwner(data.owner) + `.` : '';
    let result;
    const debugNameSource = data.debugNameSource;
    if (debugNameSource !== undefined) {
        if (typeof debugNameSource === 'function') {
            result = debugNameSource();
            if (result !== undefined) {
                return ownerStr + result;
            }
        }
        else {
            return ownerStr + debugNameSource;
        }
    }
    const referenceFn = data.referenceFn;
    if (referenceFn !== undefined) {
        result = getFunctionName(referenceFn);
        if (result !== undefined) {
            return ownerStr + result;
        }
    }
    if (data.owner !== undefined) {
        const key = findKey(data.owner, self);
        if (key !== undefined) {
            return ownerStr + key;
        }
    }
    return undefined;
}
function findKey(obj, value) {
    for (const key in obj) {
        if (obj[key] === value) {
            return key;
        }
    }
    return undefined;
}
const countPerClassName = ( new Map());
const ownerId = ( new WeakMap());
function formatOwner(owner) {
    const id = ownerId.get(owner);
    if (id) {
        return id;
    }
    const className = getClassName(owner);
    let count = countPerClassName.get(className) ?? 0;
    count++;
    countPerClassName.set(className, count);
    const result = count === 1 ? className : `${className}#${count}`;
    ownerId.set(owner, result);
    return result;
}
function getClassName(obj) {
    const ctor = obj.constructor;
    if (ctor) {
        return ctor.name;
    }
    return 'Object';
}
function getFunctionName(fn) {
    const fnSrc = ( fn.toString());
    const regexp = /\/\*\*\s*@description\s*([^*]*)\*\//;
    const match = regexp.exec(fnSrc);
    const result = match ? match[1] : undefined;
    return result?.trim();
}



/***/ }),

/***/ "./node_modules/vscode/vscode/src/vs/base/common/observableInternal/derived.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/vscode/vscode/src/vs/base/common/observableInternal/derived.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Derived: () => (/* binding */ Derived),
/* harmony export */   DerivedWithSetter: () => (/* binding */ DerivedWithSetter),
/* harmony export */   derived: () => (/* binding */ derived),
/* harmony export */   derivedDisposable: () => (/* binding */ derivedDisposable),
/* harmony export */   derivedHandleChanges: () => (/* binding */ derivedHandleChanges),
/* harmony export */   derivedOpts: () => (/* binding */ derivedOpts),
/* harmony export */   derivedWithSetter: () => (/* binding */ derivedWithSetter),
/* harmony export */   derivedWithStore: () => (/* binding */ derivedWithStore)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/vscode/vscode/src/vs/base/common/observableInternal/base.js");
/* harmony import */ var _debugName_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./debugName.js */ "./node_modules/vscode/vscode/src/vs/base/common/observableInternal/debugName.js");
/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../assert.js */ "./node_modules/vscode/vscode/src/vs/base/common/assert.js");
/* harmony import */ var _equals_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../equals.js */ "./node_modules/vscode/vscode/src/vs/base/common/equals.js");
/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../errors.js */ "./node_modules/vscode/vscode/src/vs/base/common/errors.js");
/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../event.js */ "./node_modules/vscode/vscode/src/vs/base/common/event.js");
/* harmony import */ var _lifecycle_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../lifecycle.js */ "./node_modules/vscode/vscode/src/vs/base/common/lifecycle.js");
/* harmony import */ var _logging_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./logging.js */ "./node_modules/vscode/vscode/src/vs/base/common/observableInternal/logging.js");








function derived(computeFnOrOwner, computeFn) {
    if (computeFn !== undefined) {
        return ( new Derived(( new _debugName_js__WEBPACK_IMPORTED_MODULE_1__.DebugNameData(computeFnOrOwner, undefined, computeFn)), computeFn, undefined, undefined, undefined, _equals_js__WEBPACK_IMPORTED_MODULE_3__.strictEquals));
    }
    return ( new Derived(( new _debugName_js__WEBPACK_IMPORTED_MODULE_1__.DebugNameData(undefined, undefined, computeFnOrOwner)), computeFnOrOwner, undefined, undefined, undefined, _equals_js__WEBPACK_IMPORTED_MODULE_3__.strictEquals));
}
function derivedWithSetter(owner, computeFn, setter) {
    return ( new DerivedWithSetter(( new _debugName_js__WEBPACK_IMPORTED_MODULE_1__.DebugNameData(owner, undefined, computeFn)), computeFn, undefined, undefined, undefined, _equals_js__WEBPACK_IMPORTED_MODULE_3__.strictEquals, setter));
}
function derivedOpts(options, computeFn) {
    return ( new Derived(( new _debugName_js__WEBPACK_IMPORTED_MODULE_1__.DebugNameData(options.owner, options.debugName, options.debugReferenceFn)), computeFn, undefined, undefined, options.onLastObserverRemoved, options.equalsFn ?? _equals_js__WEBPACK_IMPORTED_MODULE_3__.strictEquals));
}
(0,_base_js__WEBPACK_IMPORTED_MODULE_0__._setDerivedOpts)(derivedOpts);
function derivedHandleChanges(options, computeFn) {
    return ( new Derived(( new _debugName_js__WEBPACK_IMPORTED_MODULE_1__.DebugNameData(options.owner, options.debugName, undefined)), computeFn, options.createEmptyChangeSummary, options.handleChange, undefined, options.equalityComparer ?? _equals_js__WEBPACK_IMPORTED_MODULE_3__.strictEquals));
}
function derivedWithStore(computeFnOrOwner, computeFnOrUndefined) {
    let computeFn;
    let owner;
    if (computeFnOrUndefined === undefined) {
        computeFn = computeFnOrOwner;
        owner = undefined;
    }
    else {
        owner = computeFnOrOwner;
        computeFn = computeFnOrUndefined;
    }
    const store = ( new _lifecycle_js__WEBPACK_IMPORTED_MODULE_6__.DisposableStore());
    return ( new Derived(( new _debugName_js__WEBPACK_IMPORTED_MODULE_1__.DebugNameData(owner, undefined, computeFn)), r => {
        store.clear();
        return computeFn(r, store);
    }, undefined, undefined, () => store.dispose(), _equals_js__WEBPACK_IMPORTED_MODULE_3__.strictEquals));
}
function derivedDisposable(computeFnOrOwner, computeFnOrUndefined) {
    let computeFn;
    let owner;
    if (computeFnOrUndefined === undefined) {
        computeFn = computeFnOrOwner;
        owner = undefined;
    }
    else {
        owner = computeFnOrOwner;
        computeFn = computeFnOrUndefined;
    }
    let store = undefined;
    return ( new Derived(( new _debugName_js__WEBPACK_IMPORTED_MODULE_1__.DebugNameData(owner, undefined, computeFn)), r => {
        if (!store) {
            store = ( new _lifecycle_js__WEBPACK_IMPORTED_MODULE_6__.DisposableStore());
        }
        else {
            store.clear();
        }
        const result = computeFn(r);
        if (result) {
            store.add(result);
        }
        return result;
    }, undefined, undefined, () => {
        if (store) {
            store.dispose();
            store = undefined;
        }
    }, _equals_js__WEBPACK_IMPORTED_MODULE_3__.strictEquals));
}
class Derived extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseObservable {
    get debugName() {
        return this._debugNameData.getDebugName(this) ?? '(anonymous)';
    }
    constructor(_debugNameData, _computeFn, createChangeSummary, _handleChange, _handleLastObserverRemoved = undefined, _equalityComparator) {
        super();
        this._debugNameData = _debugNameData;
        this._computeFn = _computeFn;
        this.createChangeSummary = createChangeSummary;
        this._handleChange = _handleChange;
        this._handleLastObserverRemoved = _handleLastObserverRemoved;
        this._equalityComparator = _equalityComparator;
        this.state = 0 ;
        this.value = undefined;
        this.updateCount = 0;
        this.dependencies = ( new Set());
        this.dependenciesToBeRemoved = ( new Set());
        this.changeSummary = undefined;
        this.changeSummary = this.createChangeSummary?.();
    }
    onLastObserverRemoved() {
        this.state = 0 ;
        this.value = undefined;
        for (const d of this.dependencies) {
            d.removeObserver(this);
        }
        this.dependencies.clear();
        this._handleLastObserverRemoved?.();
    }
    get() {
        if (this.observers.size === 0) {
            const result = this._computeFn(this, this.createChangeSummary?.());
            this.onLastObserverRemoved();
            return result;
        }
        else {
            do {
                if (this.state === 1 ) {
                    for (const d of this.dependencies) {
                        d.reportChanges();
                        if (this.state === 2 ) {
                            break;
                        }
                    }
                }
                if (this.state === 1 ) {
                    this.state = 3 ;
                }
                this._recomputeIfNeeded();
            } while (this.state !== 3 );
            return this.value;
        }
    }
    _recomputeIfNeeded() {
        if (this.state === 3 ) {
            return;
        }
        const emptySet = this.dependenciesToBeRemoved;
        this.dependenciesToBeRemoved = this.dependencies;
        this.dependencies = emptySet;
        const hadValue = this.state !== 0 ;
        const oldValue = this.value;
        this.state = 3 ;
        let didChange = false;
        try {
            const changeSummary = this.changeSummary;
            this.changeSummary = this.createChangeSummary?.();
            try {
                this.value = this._computeFn(this, changeSummary);
            }
            finally {
                for (const o of this.dependenciesToBeRemoved) {
                    o.removeObserver(this);
                }
                this.dependenciesToBeRemoved.clear();
            }
            didChange = hadValue && !(this._equalityComparator(oldValue, this.value));
            (0,_logging_js__WEBPACK_IMPORTED_MODULE_7__.getLogger)()?.handleDerivedRecomputed(this, {
                oldValue,
                newValue: this.value,
                change: undefined,
                didChange,
                hadValue,
            });
        }
        catch (e) {
            (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.onBugIndicatingError)(e);
        }
        if (didChange) {
            for (const r of this.observers) {
                r.handleChange(this, undefined);
            }
        }
    }
    toString() {
        return `LazyDerived<${this.debugName}>`;
    }
    beginUpdate(_observable) {
        this.updateCount++;
        const propagateBeginUpdate = this.updateCount === 1;
        if (this.state === 3 ) {
            this.state = 1 ;
            if (!propagateBeginUpdate) {
                for (const r of this.observers) {
                    r.handlePossibleChange(this);
                }
            }
        }
        if (propagateBeginUpdate) {
            for (const r of this.observers) {
                r.beginUpdate(this);
            }
        }
    }
    endUpdate(_observable) {
        this.updateCount--;
        if (this.updateCount === 0) {
            const observers = [...this.observers];
            for (const r of observers) {
                r.endUpdate(this);
            }
        }
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.assertFn)(() => this.updateCount >= 0);
    }
    handlePossibleChange(observable) {
        if (this.state === 3  && ( this.dependencies.has(observable)) && !( this.dependenciesToBeRemoved.has(observable))) {
            this.state = 1 ;
            for (const r of this.observers) {
                r.handlePossibleChange(this);
            }
        }
    }
    handleChange(observable, change) {
        if (( this.dependencies.has(observable)) && !( this.dependenciesToBeRemoved.has(observable))) {
            let shouldReact = false;
            try {
                shouldReact = this._handleChange ? this._handleChange({
                    changedObservable: observable,
                    change,
                    didChange: (o) => o === observable,
                }, this.changeSummary) : true;
            }
            catch (e) {
                (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.onBugIndicatingError)(e);
            }
            const wasUpToDate = this.state === 3 ;
            if (shouldReact && (this.state === 1  || wasUpToDate)) {
                this.state = 2 ;
                if (wasUpToDate) {
                    for (const r of this.observers) {
                        r.handlePossibleChange(this);
                    }
                }
            }
        }
    }
    readObservable(observable) {
        observable.addObserver(this);
        const value = observable.get();
        this.dependencies.add(observable);
        this.dependenciesToBeRemoved.delete(observable);
        return value;
    }
    addObserver(observer) {
        const shouldCallBeginUpdate = !( this.observers.has(observer)) && this.updateCount > 0;
        super.addObserver(observer);
        if (shouldCallBeginUpdate) {
            observer.beginUpdate(this);
        }
    }
    removeObserver(observer) {
        const shouldCallEndUpdate = ( this.observers.has(observer)) && this.updateCount > 0;
        super.removeObserver(observer);
        if (shouldCallEndUpdate) {
            observer.endUpdate(this);
        }
    }
}
class DerivedWithSetter extends Derived {
    constructor(debugNameData, computeFn, createChangeSummary, handleChange, handleLastObserverRemoved = undefined, equalityComparator, set) {
        super(debugNameData, computeFn, createChangeSummary, handleChange, handleLastObserverRemoved, equalityComparator);
        this.set = set;
    }
}



/***/ }),

/***/ "./node_modules/vscode/vscode/src/vs/base/common/observableInternal/logging.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/vscode/vscode/src/vs/base/common/observableInternal/logging.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getLogger: () => (/* binding */ getLogger)
/* harmony export */ });
let globalObservableLogger;
function getLogger() {
    return globalObservableLogger;
}



/***/ }),

/***/ "./node_modules/vscode/vscode/src/vs/base/common/observableInternal/utils.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/vscode/vscode/src/vs/base/common/observableInternal/utils.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FromEventObservable: () => (/* binding */ FromEventObservable),
/* harmony export */   KeepAliveObserver: () => (/* binding */ KeepAliveObserver),
/* harmony export */   ValueWithChangeEventFromObservable: () => (/* binding */ ValueWithChangeEventFromObservable),
/* harmony export */   constObservable: () => (/* binding */ constObservable),
/* harmony export */   derivedConstOnceDefined: () => (/* binding */ derivedConstOnceDefined),
/* harmony export */   derivedObservableWithCache: () => (/* binding */ derivedObservableWithCache),
/* harmony export */   derivedObservableWithWritableCache: () => (/* binding */ derivedObservableWithWritableCache),
/* harmony export */   keepObserved: () => (/* binding */ keepObserved),
/* harmony export */   latestChangedValue: () => (/* binding */ latestChangedValue),
/* harmony export */   mapObservableArrayCached: () => (/* binding */ mapObservableArrayCached),
/* harmony export */   observableFromEvent: () => (/* binding */ observableFromEvent),
/* harmony export */   observableFromEventOpts: () => (/* binding */ observableFromEventOpts),
/* harmony export */   observableFromPromise: () => (/* binding */ observableFromPromise),
/* harmony export */   observableFromValueWithChangeEvent: () => (/* binding */ observableFromValueWithChangeEvent),
/* harmony export */   observableSignal: () => (/* binding */ observableSignal),
/* harmony export */   observableSignalFromEvent: () => (/* binding */ observableSignalFromEvent),
/* harmony export */   recomputeInitiallyAndOnChange: () => (/* binding */ recomputeInitiallyAndOnChange),
/* harmony export */   runOnChange: () => (/* binding */ runOnChange),
/* harmony export */   runOnChangeWithStore: () => (/* binding */ runOnChangeWithStore),
/* harmony export */   wasEventTriggeredRecently: () => (/* binding */ wasEventTriggeredRecently)
/* harmony export */ });
/* harmony import */ var _autorun_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./autorun.js */ "./node_modules/vscode/vscode/src/vs/base/common/observableInternal/autorun.js");
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ "./node_modules/vscode/vscode/src/vs/base/common/observableInternal/base.js");
/* harmony import */ var _debugName_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./debugName.js */ "./node_modules/vscode/vscode/src/vs/base/common/observableInternal/debugName.js");
/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../errors.js */ "./node_modules/vscode/vscode/src/vs/base/common/errors.js");
/* harmony import */ var _equals_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../equals.js */ "./node_modules/vscode/vscode/src/vs/base/common/equals.js");
/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../event.js */ "./node_modules/vscode/vscode/src/vs/base/common/event.js");
/* harmony import */ var _lifecycle_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../lifecycle.js */ "./node_modules/vscode/vscode/src/vs/base/common/lifecycle.js");
/* harmony import */ var _derived_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./derived.js */ "./node_modules/vscode/vscode/src/vs/base/common/observableInternal/derived.js");








function constObservable(value) {
    return ( new ConstObservable(value));
}
class ConstObservable extends _base_js__WEBPACK_IMPORTED_MODULE_1__.ConvenientObservable {
    constructor(value) {
        super();
        this.value = value;
    }
    get debugName() {
        return ( this.toString());
    }
    get() {
        return this.value;
    }
    addObserver(observer) {
    }
    removeObserver(observer) {
    }
    toString() {
        return `Const: ${this.value}`;
    }
}
function observableFromPromise(promise) {
    const observable = (0,_base_js__WEBPACK_IMPORTED_MODULE_1__.observableValue)('promiseValue', {});
    promise.then((value) => {
        observable.set({ value }, undefined);
    });
    return observable;
}
function observableFromEvent(...args) {
    let owner;
    let event;
    let getValue;
    if (args.length === 3) {
        [owner, event, getValue] = args;
    }
    else {
        [event, getValue] = args;
    }
    return ( new FromEventObservable(( new _debugName_js__WEBPACK_IMPORTED_MODULE_2__.DebugNameData(owner, undefined, getValue)), event, getValue, () => FromEventObservable.globalTransaction, _equals_js__WEBPACK_IMPORTED_MODULE_4__.strictEquals));
}
function observableFromEventOpts(options, event, getValue) {
    return ( new FromEventObservable(( new _debugName_js__WEBPACK_IMPORTED_MODULE_2__.DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? getValue)), event, getValue, () => FromEventObservable.globalTransaction, options.equalsFn ?? _equals_js__WEBPACK_IMPORTED_MODULE_4__.strictEquals));
}
class FromEventObservable extends _base_js__WEBPACK_IMPORTED_MODULE_1__.BaseObservable {
    constructor(_debugNameData, event, _getValue, _getTransaction, _equalityComparator) {
        super();
        this._debugNameData = _debugNameData;
        this.event = event;
        this._getValue = _getValue;
        this._getTransaction = _getTransaction;
        this._equalityComparator = _equalityComparator;
        this.hasValue = false;
        this.handleEvent = (args) => {
            const newValue = this._getValue(args);
            const oldValue = this.value;
            const didChange = !this.hasValue || !(this._equalityComparator(oldValue, newValue));
            if (didChange) {
                this.value = newValue;
                if (this.hasValue) {
                    (0,_base_js__WEBPACK_IMPORTED_MODULE_1__.subtransaction)(this._getTransaction(), (tx) => {
                        for (const o of this.observers) {
                            tx.updateObserver(o, this);
                            o.handleChange(this, undefined);
                        }
                    }, () => {
                        const name = this.getDebugName();
                        return 'Event fired' + (name ? `: ${name}` : '');
                    });
                }
                this.hasValue = true;
            }
        };
    }
    getDebugName() {
        return this._debugNameData.getDebugName(this);
    }
    get debugName() {
        const name = this.getDebugName();
        return 'From Event' + (name ? `: ${name}` : '');
    }
    onFirstObserverAdded() {
        this.subscription = this.event(this.handleEvent);
    }
    onLastObserverRemoved() {
        this.subscription.dispose();
        this.subscription = undefined;
        this.hasValue = false;
        this.value = undefined;
    }
    get() {
        if (this.subscription) {
            if (!this.hasValue) {
                this.handleEvent(undefined);
            }
            return this.value;
        }
        else {
            const value = this._getValue(undefined);
            return value;
        }
    }
}
( (function(observableFromEvent) {
    observableFromEvent.Observer = FromEventObservable;
    function batchEventsGlobally(tx, fn) {
        let didSet = false;
        if (FromEventObservable.globalTransaction === undefined) {
            FromEventObservable.globalTransaction = tx;
            didSet = true;
        }
        try {
            fn();
        }
        finally {
            if (didSet) {
                FromEventObservable.globalTransaction = undefined;
            }
        }
    }
    observableFromEvent.batchEventsGlobally = batchEventsGlobally;
})(observableFromEvent || (observableFromEvent = {})));
function observableSignalFromEvent(debugName, event) {
    return ( new FromEventObservableSignal(debugName, event));
}
class FromEventObservableSignal extends _base_js__WEBPACK_IMPORTED_MODULE_1__.BaseObservable {
    constructor(debugName, event) {
        super();
        this.debugName = debugName;
        this.event = event;
        this.handleEvent = () => {
            (0,_base_js__WEBPACK_IMPORTED_MODULE_1__.transaction)((tx) => {
                for (const o of this.observers) {
                    tx.updateObserver(o, this);
                    o.handleChange(this, undefined);
                }
            }, () => this.debugName);
        };
    }
    onFirstObserverAdded() {
        this.subscription = this.event(this.handleEvent);
    }
    onLastObserverRemoved() {
        this.subscription.dispose();
        this.subscription = undefined;
    }
    get() {
    }
}
function observableSignal(debugNameOrOwner) {
    if (typeof debugNameOrOwner === 'string') {
        return ( new ObservableSignal(debugNameOrOwner));
    }
    else {
        return ( new ObservableSignal(undefined, debugNameOrOwner));
    }
}
class ObservableSignal extends _base_js__WEBPACK_IMPORTED_MODULE_1__.BaseObservable {
    get debugName() {
        return ( new _debugName_js__WEBPACK_IMPORTED_MODULE_2__.DebugNameData(this._owner, this._debugName, undefined)).getDebugName(this) ?? 'Observable Signal';
    }
    toString() {
        return this.debugName;
    }
    constructor(_debugName, _owner) {
        super();
        this._debugName = _debugName;
        this._owner = _owner;
    }
    trigger(tx, change) {
        if (!tx) {
            (0,_base_js__WEBPACK_IMPORTED_MODULE_1__.transaction)(tx => {
                this.trigger(tx, change);
            }, () => `Trigger signal ${this.debugName}`);
            return;
        }
        for (const o of this.observers) {
            tx.updateObserver(o, this);
            o.handleChange(this, change);
        }
    }
    get() {
    }
}
function wasEventTriggeredRecently(event, timeoutMs, disposableStore) {
    const observable = (0,_base_js__WEBPACK_IMPORTED_MODULE_1__.observableValue)('triggeredRecently', false);
    let timeout = undefined;
    disposableStore.add(event(() => {
        observable.set(true, undefined);
        if (timeout) {
            clearTimeout(timeout);
        }
        timeout = setTimeout(() => {
            observable.set(false, undefined);
        }, timeoutMs);
    }));
    return observable;
}
function keepObserved(observable) {
    const o = ( new KeepAliveObserver(false, undefined));
    observable.addObserver(o);
    return (0,_lifecycle_js__WEBPACK_IMPORTED_MODULE_6__.toDisposable)(() => {
        observable.removeObserver(o);
    });
}
(0,_base_js__WEBPACK_IMPORTED_MODULE_1__._setKeepObserved)(keepObserved);
function recomputeInitiallyAndOnChange(observable, handleValue) {
    const o = ( new KeepAliveObserver(true, handleValue));
    observable.addObserver(o);
    if (handleValue) {
        handleValue(observable.get());
    }
    else {
        observable.reportChanges();
    }
    return (0,_lifecycle_js__WEBPACK_IMPORTED_MODULE_6__.toDisposable)(() => {
        observable.removeObserver(o);
    });
}
(0,_base_js__WEBPACK_IMPORTED_MODULE_1__._setRecomputeInitiallyAndOnChange)(recomputeInitiallyAndOnChange);
class KeepAliveObserver {
    constructor(_forceRecompute, _handleValue) {
        this._forceRecompute = _forceRecompute;
        this._handleValue = _handleValue;
        this._counter = 0;
    }
    beginUpdate(observable) {
        this._counter++;
    }
    endUpdate(observable) {
        this._counter--;
        if (this._counter === 0 && this._forceRecompute) {
            if (this._handleValue) {
                this._handleValue(observable.get());
            }
            else {
                observable.reportChanges();
            }
        }
    }
    handlePossibleChange(observable) {
    }
    handleChange(observable, change) {
    }
}
function derivedObservableWithCache(owner, computeFn) {
    let lastValue = undefined;
    const observable = (0,_derived_js__WEBPACK_IMPORTED_MODULE_7__.derivedOpts)({ owner, debugReferenceFn: computeFn }, reader => {
        lastValue = computeFn(reader, lastValue);
        return lastValue;
    });
    return observable;
}
function derivedObservableWithWritableCache(owner, computeFn) {
    let lastValue = undefined;
    const onChange = observableSignal('derivedObservableWithWritableCache');
    const observable = (0,_derived_js__WEBPACK_IMPORTED_MODULE_7__.derived)(owner, reader => {
        onChange.read(reader);
        lastValue = computeFn(reader, lastValue);
        return lastValue;
    });
    return Object.assign(observable, {
        clearCache: (tx) => {
            lastValue = undefined;
            onChange.trigger(tx);
        },
        setCache: (newValue, tx) => {
            lastValue = newValue;
            onChange.trigger(tx);
        }
    });
}
function mapObservableArrayCached(owner, items, map, keySelector) {
    let m = ( new ArrayMap(map, keySelector));
    const self = (0,_derived_js__WEBPACK_IMPORTED_MODULE_7__.derivedOpts)({
        debugReferenceFn: map,
        owner,
        onLastObserverRemoved: () => {
            m.dispose();
            m = ( new ArrayMap(map));
        }
    }, (reader) => {
        m.setItems(items.read(reader));
        return m.getItems();
    });
    return self;
}
class ArrayMap {
    constructor(_map, _keySelector) {
        this._map = _map;
        this._keySelector = _keySelector;
        this._cache = ( new Map());
        this._items = [];
    }
    dispose() {
        this._cache.forEach(entry => entry.store.dispose());
        this._cache.clear();
    }
    setItems(items) {
        const newItems = [];
        const itemsToRemove = ( new Set(( this._cache.keys())));
        for (const item of items) {
            const key = this._keySelector ? this._keySelector(item) : item;
            let entry = this._cache.get(key);
            if (!entry) {
                const store = ( new _lifecycle_js__WEBPACK_IMPORTED_MODULE_6__.DisposableStore());
                const out = this._map(item, store);
                entry = { out, store };
                this._cache.set(key, entry);
            }
            else {
                itemsToRemove.delete(key);
            }
            newItems.push(entry.out);
        }
        for (const item of itemsToRemove) {
            const entry = this._cache.get(item);
            entry.store.dispose();
            this._cache.delete(item);
        }
        this._items = newItems;
    }
    getItems() {
        return this._items;
    }
}
class ValueWithChangeEventFromObservable {
    constructor(observable) {
        this.observable = observable;
    }
    get onDidChange() {
        return _event_js__WEBPACK_IMPORTED_MODULE_5__.Event.fromObservableLight(this.observable);
    }
    get value() {
        return this.observable.get();
    }
}
function observableFromValueWithChangeEvent(owner, value) {
    if (value instanceof ValueWithChangeEventFromObservable) {
        return value.observable;
    }
    return observableFromEvent(owner, value.onDidChange, () => value.value);
}
function latestChangedValue(owner, observables) {
    if (observables.length === 0) {
        throw ( new _errors_js__WEBPACK_IMPORTED_MODULE_3__.BugIndicatingError());
    }
    let hasLastChangedValue = false;
    let lastChangedValue = undefined;
    const result = observableFromEvent(owner, cb => {
        const store = ( new _lifecycle_js__WEBPACK_IMPORTED_MODULE_6__.DisposableStore());
        for (const o of observables) {
            store.add((0,_autorun_js__WEBPACK_IMPORTED_MODULE_0__.autorunOpts)({ debugName: () => (0,_debugName_js__WEBPACK_IMPORTED_MODULE_2__.getDebugName)(result, ( new _debugName_js__WEBPACK_IMPORTED_MODULE_2__.DebugNameData(owner, undefined, undefined))) + '.updateLastChangedValue' }, reader => {
                hasLastChangedValue = true;
                lastChangedValue = o.read(reader);
                cb();
            }));
        }
        store.add({
            dispose() {
                hasLastChangedValue = false;
                lastChangedValue = undefined;
            },
        });
        return store;
    }, () => {
        if (hasLastChangedValue) {
            return lastChangedValue;
        }
        else {
            return observables[observables.length - 1].get();
        }
    });
    return result;
}
function derivedConstOnceDefined(owner, fn) {
    return derivedObservableWithCache(owner, (reader, lastValue) => lastValue ?? fn(reader));
}
function runOnChange(observable, cb) {
    let _previousValue;
    return (0,_autorun_js__WEBPACK_IMPORTED_MODULE_0__.autorunWithStoreHandleChanges)({
        createEmptyChangeSummary: () => ({ deltas: [], didChange: false }),
        handleChange: (context, changeSummary) => {
            if (context.didChange(observable)) {
                const e = context.change;
                if (e !== undefined) {
                    changeSummary.deltas.push(e);
                }
                changeSummary.didChange = true;
            }
            return true;
        },
    }, (reader, changeSummary) => {
        const value = observable.read(reader);
        const previousValue = _previousValue;
        if (changeSummary.didChange) {
            _previousValue = value;
            cb(value, previousValue, changeSummary.deltas);
        }
    });
}
function runOnChangeWithStore(observable, cb) {
    const store = ( new _lifecycle_js__WEBPACK_IMPORTED_MODULE_6__.DisposableStore());
    const disposable = runOnChange(observable, (value, previousValue, deltas) => {
        store.clear();
        cb(value, previousValue, deltas, store);
    });
    return {
        dispose() {
            disposable.dispose();
            store.dispose();
        }
    };
}



/***/ }),

/***/ "./node_modules/vscode/vscode/src/vs/base/common/stream.js":
/*!*****************************************************************!*\
  !*** ./node_modules/vscode/vscode/src/vs/base/common/stream.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   consumeReadable: () => (/* binding */ consumeReadable),
/* harmony export */   consumeStream: () => (/* binding */ consumeStream),
/* harmony export */   emptyStream: () => (/* binding */ emptyStream),
/* harmony export */   isReadableBufferedStream: () => (/* binding */ isReadableBufferedStream),
/* harmony export */   isReadableStream: () => (/* binding */ isReadableStream),
/* harmony export */   listenStream: () => (/* binding */ listenStream),
/* harmony export */   newWriteableStream: () => (/* binding */ newWriteableStream),
/* harmony export */   peekReadable: () => (/* binding */ peekReadable),
/* harmony export */   peekStream: () => (/* binding */ peekStream),
/* harmony export */   prefixedReadable: () => (/* binding */ prefixedReadable),
/* harmony export */   prefixedStream: () => (/* binding */ prefixedStream),
/* harmony export */   toReadable: () => (/* binding */ toReadable),
/* harmony export */   toStream: () => (/* binding */ toStream),
/* harmony export */   transform: () => (/* binding */ transform)
/* harmony export */ });
/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ "./node_modules/vscode/vscode/src/vs/base/common/errors.js");
/* harmony import */ var _lifecycle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lifecycle.js */ "./node_modules/vscode/vscode/src/vs/base/common/lifecycle.js");


function isReadableStream(obj) {
    const candidate = obj;
    if (!candidate) {
        return false;
    }
    return [candidate.on, candidate.pause, candidate.resume, candidate.destroy].every(fn => typeof fn === 'function');
}
function isReadableBufferedStream(obj) {
    const candidate = obj;
    if (!candidate) {
        return false;
    }
    return isReadableStream(candidate.stream) && Array.isArray(candidate.buffer) && typeof candidate.ended === 'boolean';
}
function newWriteableStream(reducer, options) {
    return ( new WriteableStreamImpl(reducer, options));
}
class WriteableStreamImpl {
    constructor(reducer, options) {
        this.reducer = reducer;
        this.options = options;
        this.state = {
            flowing: false,
            ended: false,
            destroyed: false
        };
        this.buffer = {
            data: [],
            error: []
        };
        this.listeners = {
            data: [],
            error: [],
            end: []
        };
        this.pendingWritePromises = [];
    }
    pause() {
        if (this.state.destroyed) {
            return;
        }
        this.state.flowing = false;
    }
    resume() {
        if (this.state.destroyed) {
            return;
        }
        if (!this.state.flowing) {
            this.state.flowing = true;
            this.flowData();
            this.flowErrors();
            this.flowEnd();
        }
    }
    write(data) {
        if (this.state.destroyed) {
            return;
        }
        if (this.state.flowing) {
            this.emitData(data);
        }
        else {
            this.buffer.data.push(data);
            if (typeof this.options?.highWaterMark === 'number' && this.buffer.data.length > this.options.highWaterMark) {
                return ( new Promise(resolve => this.pendingWritePromises.push(resolve)));
            }
        }
    }
    error(error) {
        if (this.state.destroyed) {
            return;
        }
        if (this.state.flowing) {
            this.emitError(error);
        }
        else {
            this.buffer.error.push(error);
        }
    }
    end(result) {
        if (this.state.destroyed) {
            return;
        }
        if (typeof result !== 'undefined') {
            this.write(result);
        }
        if (this.state.flowing) {
            this.emitEnd();
            this.destroy();
        }
        else {
            this.state.ended = true;
        }
    }
    emitData(data) {
        this.listeners.data.slice(0).forEach(listener => listener(data));
    }
    emitError(error) {
        if (this.listeners.error.length === 0) {
            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.onUnexpectedError)(error);
        }
        else {
            this.listeners.error.slice(0).forEach(listener => listener(error));
        }
    }
    emitEnd() {
        this.listeners.end.slice(0).forEach(listener => listener());
    }
    on(event, callback) {
        if (this.state.destroyed) {
            return;
        }
        switch (event) {
            case 'data':
                this.listeners.data.push(callback);
                this.resume();
                break;
            case 'end':
                this.listeners.end.push(callback);
                if (this.state.flowing && this.flowEnd()) {
                    this.destroy();
                }
                break;
            case 'error':
                this.listeners.error.push(callback);
                if (this.state.flowing) {
                    this.flowErrors();
                }
                break;
        }
    }
    removeListener(event, callback) {
        if (this.state.destroyed) {
            return;
        }
        let listeners = undefined;
        switch (event) {
            case 'data':
                listeners = this.listeners.data;
                break;
            case 'end':
                listeners = this.listeners.end;
                break;
            case 'error':
                listeners = this.listeners.error;
                break;
        }
        if (listeners) {
            const index = listeners.indexOf(callback);
            if (index >= 0) {
                listeners.splice(index, 1);
            }
        }
    }
    flowData() {
        if (this.buffer.data.length > 0) {
            const fullDataBuffer = this.reducer(this.buffer.data);
            this.emitData(fullDataBuffer);
            this.buffer.data.length = 0;
            const pendingWritePromises = [...this.pendingWritePromises];
            this.pendingWritePromises.length = 0;
            pendingWritePromises.forEach(pendingWritePromise => pendingWritePromise());
        }
    }
    flowErrors() {
        if (this.listeners.error.length > 0) {
            for (const error of this.buffer.error) {
                this.emitError(error);
            }
            this.buffer.error.length = 0;
        }
    }
    flowEnd() {
        if (this.state.ended) {
            this.emitEnd();
            return this.listeners.end.length > 0;
        }
        return false;
    }
    destroy() {
        if (!this.state.destroyed) {
            this.state.destroyed = true;
            this.state.ended = true;
            this.buffer.data.length = 0;
            this.buffer.error.length = 0;
            this.listeners.data.length = 0;
            this.listeners.error.length = 0;
            this.listeners.end.length = 0;
            this.pendingWritePromises.length = 0;
        }
    }
}
function consumeReadable(readable, reducer) {
    const chunks = [];
    let chunk;
    while ((chunk = readable.read()) !== null) {
        chunks.push(chunk);
    }
    return reducer(chunks);
}
function peekReadable(readable, reducer, maxChunks) {
    const chunks = [];
    let chunk = undefined;
    while ((chunk = readable.read()) !== null && chunks.length < maxChunks) {
        chunks.push(chunk);
    }
    if (chunk === null && chunks.length > 0) {
        return reducer(chunks);
    }
    return {
        read: () => {
            if (chunks.length > 0) {
                return chunks.shift();
            }
            if (typeof chunk !== 'undefined') {
                const lastReadChunk = chunk;
                chunk = undefined;
                return lastReadChunk;
            }
            return readable.read();
        }
    };
}
function consumeStream(stream, reducer) {
    return ( new Promise((resolve, reject) => {
        const chunks = [];
        listenStream(stream, {
            onData: chunk => {
                if (reducer) {
                    chunks.push(chunk);
                }
            },
            onError: error => {
                if (reducer) {
                    reject(error);
                }
                else {
                    resolve(undefined);
                }
            },
            onEnd: () => {
                if (reducer) {
                    resolve(reducer(chunks));
                }
                else {
                    resolve(undefined);
                }
            }
        });
    }));
}
function listenStream(stream, listener, token) {
    stream.on('error', error => {
        if (!token?.isCancellationRequested) {
            listener.onError(error);
        }
    });
    stream.on('end', () => {
        if (!token?.isCancellationRequested) {
            listener.onEnd();
        }
    });
    stream.on('data', data => {
        if (!token?.isCancellationRequested) {
            listener.onData(data);
        }
    });
}
function peekStream(stream, maxChunks) {
    return ( new Promise((resolve, reject) => {
        const streamListeners = ( new _lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.DisposableStore());
        const buffer = [];
        const dataListener = (chunk) => {
            buffer.push(chunk);
            if (buffer.length > maxChunks) {
                streamListeners.dispose();
                stream.pause();
                return resolve({ stream, buffer, ended: false });
            }
        };
        const errorListener = (error) => {
            streamListeners.dispose();
            return reject(error);
        };
        const endListener = () => {
            streamListeners.dispose();
            return resolve({ stream, buffer, ended: true });
        };
        streamListeners.add((0,_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.toDisposable)(() => stream.removeListener('error', errorListener)));
        stream.on('error', errorListener);
        streamListeners.add((0,_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.toDisposable)(() => stream.removeListener('end', endListener)));
        stream.on('end', endListener);
        streamListeners.add((0,_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.toDisposable)(() => stream.removeListener('data', dataListener)));
        stream.on('data', dataListener);
    }));
}
function toStream(t, reducer) {
    const stream = newWriteableStream(reducer);
    stream.end(t);
    return stream;
}
function emptyStream() {
    const stream = newWriteableStream(() => { throw ( new Error('not supported')); });
    stream.end();
    return stream;
}
function toReadable(t) {
    let consumed = false;
    return {
        read: () => {
            if (consumed) {
                return null;
            }
            consumed = true;
            return t;
        }
    };
}
function transform(stream, transformer, reducer) {
    const target = newWriteableStream(reducer);
    listenStream(stream, {
        onData: data => target.write(transformer.data(data)),
        onError: error => target.error(transformer.error ? transformer.error(error) : error),
        onEnd: () => target.end()
    });
    return target;
}
function prefixedReadable(prefix, readable, reducer) {
    let prefixHandled = false;
    return {
        read: () => {
            const chunk = readable.read();
            if (!prefixHandled) {
                prefixHandled = true;
                if (chunk !== null) {
                    return reducer([prefix, chunk]);
                }
                return prefix;
            }
            return chunk;
        }
    };
}
function prefixedStream(prefix, stream, reducer) {
    let prefixHandled = false;
    const target = newWriteableStream(reducer);
    listenStream(stream, {
        onData: data => {
            if (!prefixHandled) {
                prefixHandled = true;
                return target.write(reducer([prefix, data]));
            }
            return target.write(data);
        },
        onError: error => target.error(error),
        onEnd: () => {
            if (!prefixHandled) {
                prefixHandled = true;
                target.write(prefix);
            }
            target.end();
        }
    });
    return target;
}



/***/ }),

/***/ "./node_modules/vscode/vscode/src/vs/editor/common/core/eolCounter.js":
/*!****************************************************************************!*\
  !*** ./node_modules/vscode/vscode/src/vs/editor/common/core/eolCounter.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   countEOL: () => (/* binding */ countEOL)
/* harmony export */ });
function countEOL(text) {
    let eolCount = 0;
    let firstLineLength = 0;
    let lastLineStart = 0;
    let eol = 0 ;
    for (let i = 0, len = text.length; i < len; i++) {
        const chr = text.charCodeAt(i);
        if (chr === 13 ) {
            if (eolCount === 0) {
                firstLineLength = i;
            }
            eolCount++;
            if (i + 1 < len && text.charCodeAt(i + 1) === 10 ) {
                eol |= 2 ;
                i++;
            }
            else {
                eol |= 3 ;
            }
            lastLineStart = i + 1;
        }
        else if (chr === 10 ) {
            eol |= 1 ;
            if (eolCount === 0) {
                firstLineLength = i;
            }
            eolCount++;
            lastLineStart = i + 1;
        }
    }
    if (eolCount === 0) {
        firstLineLength = text.length;
    }
    return [eolCount, firstLineLength, text.length - lastLineStart, eol];
}



/***/ })

}])
//# sourceMappingURL=vendors-node_modules_vscode_vscode_src_vs_base_common_buffer_js-node_modules_vscode_vscode_sr-2c9cae.immt_editor.js.map