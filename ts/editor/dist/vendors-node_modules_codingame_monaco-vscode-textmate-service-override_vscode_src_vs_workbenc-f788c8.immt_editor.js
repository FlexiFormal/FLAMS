(self["webpackChunkimmt_editor"] = self["webpackChunkimmt_editor"] || []).push([["vendors-node_modules_codingame_monaco-vscode-textmate-service-override_vscode_src_vs_workbenc-f788c8"],{

/***/ "./node_modules/@codingame/monaco-vscode-textmate-service-override/vscode/src/vs/workbench/services/textMate/browser/backgroundTokenization/worker/textMateWorkerHost.js":
/*!*******************************************************************************************************************************************************************************!*\
  !*** ./node_modules/@codingame/monaco-vscode-textmate-service-override/vscode/src/vs/workbench/services/textMate/browser/backgroundTokenization/worker/textMateWorkerHost.js ***!
  \*******************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextMateWorkerHost: () => (/* binding */ TextMateWorkerHost)
/* harmony export */ });
class TextMateWorkerHost {
    static { this.CHANNEL_NAME = 'textMateWorkerHost'; }
    static getChannel(workerServer) {
        return workerServer.getChannel(TextMateWorkerHost.CHANNEL_NAME);
    }
    static setChannel(workerClient, obj) {
        workerClient.setChannel(TextMateWorkerHost.CHANNEL_NAME, obj);
    }
}




/***/ }),

/***/ "./node_modules/@codingame/monaco-vscode-textmate-service-override/vscode/src/vs/workbench/services/textMate/browser/tokenizationSupport/textMateTokenizationSupport.js":
/*!******************************************************************************************************************************************************************************!*\
  !*** ./node_modules/@codingame/monaco-vscode-textmate-service-override/vscode/src/vs/workbench/services/textMate/browser/tokenizationSupport/textMateTokenizationSupport.js ***!
  \******************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextMateTokenizationSupport: () => (/* binding */ TextMateTokenizationSupport)
/* harmony export */ });
/* harmony import */ var vscode_vscode_vs_base_common_event__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode/vscode/vs/base/common/event */ "./node_modules/vscode/vscode/src/vs/base/common/event.js");
/* harmony import */ var vscode_vscode_vs_base_common_lifecycle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vscode/vscode/vs/base/common/lifecycle */ "./node_modules/vscode/vscode/src/vs/base/common/lifecycle.js");
/* harmony import */ var vscode_vscode_vs_base_common_stopwatch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vscode/vscode/vs/base/common/stopwatch */ "./node_modules/vscode/vscode/src/vs/base/common/stopwatch.js");
/* harmony import */ var vscode_vscode_vs_editor_common_encodedTokenAttributes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vscode/vscode/vs/editor/common/encodedTokenAttributes */ "./node_modules/vscode/vscode/src/vs/editor/common/encodedTokenAttributes.js");
/* harmony import */ var vscode_vscode_vs_editor_common_languages__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vscode/vscode/vs/editor/common/languages */ "./node_modules/vscode/vscode/src/vs/editor/common/languages.js");






class TextMateTokenizationSupport extends vscode_vscode_vs_base_common_lifecycle__WEBPACK_IMPORTED_MODULE_1__.Disposable {
    constructor(_grammar, _initialState, _containsEmbeddedLanguages, _createBackgroundTokenizer, _backgroundTokenizerShouldOnlyVerifyTokens, _reportTokenizationTime, _reportSlowTokenization) {
        super();
        this._grammar = _grammar;
        this._initialState = _initialState;
        this._containsEmbeddedLanguages = _containsEmbeddedLanguages;
        this._createBackgroundTokenizer = _createBackgroundTokenizer;
        this._backgroundTokenizerShouldOnlyVerifyTokens = _backgroundTokenizerShouldOnlyVerifyTokens;
        this._reportTokenizationTime = _reportTokenizationTime;
        this._reportSlowTokenization = _reportSlowTokenization;
        this._seenLanguages = [];
        this._onDidEncounterLanguage = this._register(( new vscode_vscode_vs_base_common_event__WEBPACK_IMPORTED_MODULE_0__.Emitter()));
        this.onDidEncounterLanguage = this._onDidEncounterLanguage.event;
    }
    get backgroundTokenizerShouldOnlyVerifyTokens() {
        return this._backgroundTokenizerShouldOnlyVerifyTokens();
    }
    getInitialState() {
        return this._initialState;
    }
    tokenize(line, hasEOL, state) {
        throw ( new Error('Not supported!'));
    }
    createBackgroundTokenizer(textModel, store) {
        if (this._createBackgroundTokenizer) {
            return this._createBackgroundTokenizer(textModel, store);
        }
        return undefined;
    }
    tokenizeEncoded(line, hasEOL, state) {
        const isRandomSample = Math.random() * 10_000 < 1;
        const shouldMeasure = this._reportSlowTokenization || isRandomSample;
        const sw = shouldMeasure ? ( new vscode_vscode_vs_base_common_stopwatch__WEBPACK_IMPORTED_MODULE_2__.StopWatch(true)) : undefined;
        const textMateResult = this._grammar.tokenizeLine2(line, state, 500);
        if (shouldMeasure) {
            const timeMS = sw.elapsed();
            if (isRandomSample || timeMS > 32) {
                this._reportTokenizationTime(timeMS, line.length, isRandomSample);
            }
        }
        if (textMateResult.stoppedEarly) {
            console.warn(`Time limit reached when tokenizing line: ${line.substring(0, 100)}`);
            return ( new vscode_vscode_vs_editor_common_languages__WEBPACK_IMPORTED_MODULE_4__.EncodedTokenizationResult(textMateResult.tokens, state));
        }
        if (this._containsEmbeddedLanguages) {
            const seenLanguages = this._seenLanguages;
            const tokens = textMateResult.tokens;
            for (let i = 0, len = (tokens.length >>> 1); i < len; i++) {
                const metadata = tokens[(i << 1) + 1];
                const languageId = vscode_vscode_vs_editor_common_encodedTokenAttributes__WEBPACK_IMPORTED_MODULE_3__.TokenMetadata.getLanguageId(metadata);
                if (!seenLanguages[languageId]) {
                    seenLanguages[languageId] = true;
                    this._onDidEncounterLanguage.fire(languageId);
                }
            }
        }
        let endState;
        if (state.equals(textMateResult.ruleStack)) {
            endState = state;
        }
        else {
            endState = textMateResult.ruleStack;
        }
        return ( new vscode_vscode_vs_editor_common_languages__WEBPACK_IMPORTED_MODULE_4__.EncodedTokenizationResult(textMateResult.tokens, endState));
    }
}




/***/ }),

/***/ "./node_modules/@codingame/monaco-vscode-textmate-service-override/vscode/src/vs/workbench/services/textMate/browser/tokenizationSupport/tokenizationSupportWithLineLimit.js":
/*!***********************************************************************************************************************************************************************************!*\
  !*** ./node_modules/@codingame/monaco-vscode-textmate-service-override/vscode/src/vs/workbench/services/textMate/browser/tokenizationSupport/tokenizationSupportWithLineLimit.js ***!
  \***********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TokenizationSupportWithLineLimit: () => (/* binding */ TokenizationSupportWithLineLimit)
/* harmony export */ });
/* harmony import */ var vscode_vscode_vs_editor_common_languages_nullTokenize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode/vscode/vs/editor/common/languages/nullTokenize */ "./node_modules/vscode/vscode/src/vs/editor/common/languages/nullTokenize.js");
/* harmony import */ var vscode_vscode_vs_base_common_lifecycle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vscode/vscode/vs/base/common/lifecycle */ "./node_modules/vscode/vscode/src/vs/base/common/lifecycle.js");
/* harmony import */ var vscode_vscode_vs_base_common_arrays__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vscode/vscode/vs/base/common/arrays */ "./node_modules/vscode/vscode/src/vs/base/common/arrays.js");
/* harmony import */ var vscode_vscode_vs_base_common_event__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vscode/vscode/vs/base/common/event */ "./node_modules/vscode/vscode/src/vs/base/common/event.js");
/* harmony import */ var vscode_vscode_vs_base_common_observableInternal_autorun__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vscode/vscode/vs/base/common/observableInternal/autorun */ "./node_modules/vscode/vscode/src/vs/base/common/observableInternal/autorun.js");
/* harmony import */ var vscode_vscode_vs_base_common_observableInternal_derived__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vscode/vscode/vs/base/common/observableInternal/derived */ "./node_modules/vscode/vscode/src/vs/base/common/observableInternal/derived.js");
/* harmony import */ var vscode_vscode_vs_base_common_cancellation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! vscode/vscode/vs/base/common/cancellation */ "./node_modules/vscode/vscode/src/vs/base/common/cancellation.js");
/* harmony import */ var vscode_vscode_vs_base_common_observableInternal_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! vscode/vscode/vs/base/common/observableInternal/utils */ "./node_modules/vscode/vscode/src/vs/base/common/observableInternal/utils.js");









class TokenizationSupportWithLineLimit extends vscode_vscode_vs_base_common_lifecycle__WEBPACK_IMPORTED_MODULE_1__.Disposable {
    get backgroundTokenizerShouldOnlyVerifyTokens() {
        return this._actual.backgroundTokenizerShouldOnlyVerifyTokens;
    }
    constructor(_encodedLanguageId, _actual, disposable, _maxTokenizationLineLength) {
        super();
        this._encodedLanguageId = _encodedLanguageId;
        this._actual = _actual;
        this._maxTokenizationLineLength = _maxTokenizationLineLength;
        this._register((0,vscode_vscode_vs_base_common_observableInternal_utils__WEBPACK_IMPORTED_MODULE_7__.keepObserved)(this._maxTokenizationLineLength));
        this._register(disposable);
    }
    getInitialState() {
        return this._actual.getInitialState();
    }
    tokenize(line, hasEOL, state) {
        throw ( new Error('Not supported!'));
    }
    tokenizeEncoded(line, hasEOL, state) {
        if (line.length >= this._maxTokenizationLineLength.get()) {
            return (0,vscode_vscode_vs_editor_common_languages_nullTokenize__WEBPACK_IMPORTED_MODULE_0__.nullTokenizeEncoded)(this._encodedLanguageId, state);
        }
        return this._actual.tokenizeEncoded(line, hasEOL, state);
    }
    createBackgroundTokenizer(textModel, store) {
        if (this._actual.createBackgroundTokenizer) {
            return this._actual.createBackgroundTokenizer(textModel, store);
        }
        else {
            return undefined;
        }
    }
}




/***/ }),

/***/ "./node_modules/@codingame/monaco-vscode-textmate-service-override/vscode/src/vs/workbench/services/textMate/common/TMGrammarFactory.js":
/*!**********************************************************************************************************************************************!*\
  !*** ./node_modules/@codingame/monaco-vscode-textmate-service-override/vscode/src/vs/workbench/services/textMate/common/TMGrammarFactory.js ***!
  \**********************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TMGrammarFactory: () => (/* binding */ TMGrammarFactory),
/* harmony export */   missingTMGrammarErrorMessage: () => (/* binding */ missingTMGrammarErrorMessage)
/* harmony export */ });
/* harmony import */ var vscode_vscode_vs_base_common_lifecycle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode/vscode/vs/base/common/lifecycle */ "./node_modules/vscode/vscode/src/vs/base/common/lifecycle.js");
/* harmony import */ var _TMScopeRegistry_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TMScopeRegistry.js */ "./node_modules/@codingame/monaco-vscode-textmate-service-override/vscode/src/vs/workbench/services/textMate/common/TMScopeRegistry.js");



const missingTMGrammarErrorMessage = 'No TM Grammar registered for this language.';
class TMGrammarFactory extends vscode_vscode_vs_base_common_lifecycle__WEBPACK_IMPORTED_MODULE_0__.Disposable {
    constructor(host, grammarDefinitions, vscodeTextmate, onigLib) {
        super();
        this._host = host;
        this._initialState = vscodeTextmate.INITIAL;
        this._scopeRegistry = ( new _TMScopeRegistry_js__WEBPACK_IMPORTED_MODULE_1__.TMScopeRegistry());
        this._injections = {};
        this._injectedEmbeddedLanguages = {};
        this._languageToScope = ( new Map());
        this._grammarRegistry = this._register(new vscodeTextmate.Registry({
            onigLib: onigLib,
            loadGrammar: async (scopeName) => {
                const grammarDefinition = this._scopeRegistry.getGrammarDefinition(scopeName);
                if (!grammarDefinition) {
                    this._host.logTrace(`No grammar found for scope ${scopeName}`);
                    return null;
                }
                const location = grammarDefinition.location;
                try {
                    const content = await this._host.readFile(location);
                    return vscodeTextmate.parseRawGrammar(content, location.path);
                }
                catch (e) {
                    this._host.logError(`Unable to load and parse grammar for scope ${scopeName} from ${location}`, e);
                    return null;
                }
            },
            getInjections: (scopeName) => {
                const scopeParts = scopeName.split('.');
                let injections = [];
                for (let i = 1; i <= scopeParts.length; i++) {
                    const subScopeName = scopeParts.slice(0, i).join('.');
                    injections = [...injections, ...(this._injections[subScopeName] || [])];
                }
                return injections;
            }
        }));
        for (const validGrammar of grammarDefinitions) {
            this._scopeRegistry.register(validGrammar);
            if (validGrammar.injectTo) {
                for (const injectScope of validGrammar.injectTo) {
                    let injections = this._injections[injectScope];
                    if (!injections) {
                        this._injections[injectScope] = injections = [];
                    }
                    injections.push(validGrammar.scopeName);
                }
                if (validGrammar.embeddedLanguages) {
                    for (const injectScope of validGrammar.injectTo) {
                        let injectedEmbeddedLanguages = this._injectedEmbeddedLanguages[injectScope];
                        if (!injectedEmbeddedLanguages) {
                            this._injectedEmbeddedLanguages[injectScope] = injectedEmbeddedLanguages = [];
                        }
                        injectedEmbeddedLanguages.push(validGrammar.embeddedLanguages);
                    }
                }
            }
            if (validGrammar.language) {
                this._languageToScope.set(validGrammar.language, validGrammar.scopeName);
            }
        }
    }
    has(languageId) {
        return ( this._languageToScope.has(languageId));
    }
    setTheme(theme, colorMap) {
        this._grammarRegistry.setTheme(theme, colorMap);
    }
    getColorMap() {
        return this._grammarRegistry.getColorMap();
    }
    async createGrammar(languageId, encodedLanguageId) {
        const scopeName = this._languageToScope.get(languageId);
        if (typeof scopeName !== 'string') {
            throw ( new Error(missingTMGrammarErrorMessage));
        }
        const grammarDefinition = this._scopeRegistry.getGrammarDefinition(scopeName);
        if (!grammarDefinition) {
            throw ( new Error(missingTMGrammarErrorMessage));
        }
        const embeddedLanguages = grammarDefinition.embeddedLanguages;
        if (this._injectedEmbeddedLanguages[scopeName]) {
            const injectedEmbeddedLanguages = this._injectedEmbeddedLanguages[scopeName];
            for (const injected of injectedEmbeddedLanguages) {
                for (const scope of ( Object.keys(injected))) {
                    embeddedLanguages[scope] = injected[scope];
                }
            }
        }
        const containsEmbeddedLanguages = (( Object.keys(embeddedLanguages)).length > 0);
        let grammar;
        try {
            grammar = await this._grammarRegistry.loadGrammarWithConfiguration(scopeName, encodedLanguageId, {
                embeddedLanguages,
                tokenTypes: grammarDefinition.tokenTypes,
                balancedBracketSelectors: grammarDefinition.balancedBracketSelectors,
                unbalancedBracketSelectors: grammarDefinition.unbalancedBracketSelectors,
            });
        }
        catch (err) {
            if (err.message && err.message.startsWith('No grammar provided for')) {
                throw ( new Error(missingTMGrammarErrorMessage));
            }
            throw err;
        }
        return {
            languageId: languageId,
            grammar: grammar,
            initialState: this._initialState,
            containsEmbeddedLanguages: containsEmbeddedLanguages,
            sourceExtensionId: grammarDefinition.sourceExtensionId,
        };
    }
}




/***/ }),

/***/ "./node_modules/@codingame/monaco-vscode-textmate-service-override/vscode/src/vs/workbench/services/textMate/common/TMScopeRegistry.js":
/*!*********************************************************************************************************************************************!*\
  !*** ./node_modules/@codingame/monaco-vscode-textmate-service-override/vscode/src/vs/workbench/services/textMate/common/TMScopeRegistry.js ***!
  \*********************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TMScopeRegistry: () => (/* binding */ TMScopeRegistry)
/* harmony export */ });
class TMScopeRegistry {
    constructor() {
        this._scopeNameToLanguageRegistration = Object.create(null);
    }
    reset() {
        this._scopeNameToLanguageRegistration = Object.create(null);
    }
    register(def) {
        this._scopeNameToLanguageRegistration[def.scopeName] = def;
    }
    getGrammarDefinition(scopeName) {
        return this._scopeNameToLanguageRegistration[scopeName] || null;
    }
}




/***/ })

}])
//# sourceMappingURL=vendors-node_modules_codingame_monaco-vscode-textmate-service-override_vscode_src_vs_workbenc-f788c8.immt_editor.js.map