{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import * as FLAMS from \"./types\";\nexport * from \"./types\";\n\nexport class FLAMSServer {\n  _url: string;\n  constructor(url: string) {\n    this._url = url;\n  }\n\n  get url(): string {\n    return this._url;\n  }\n\n  /**\n   * All institutions and `archive.json`-registered documents\n   */\n  async index(): Promise<\n    [FLAMS.Institution[], FLAMS.ArchiveIndex[]] | undefined\n  > {\n    return await this.rawPostRequest(\"api/index\", {});\n  }\n\n  /**\n   * Full-text search for documents, assuming the given filter\n   */\n  async searchDocs(\n    query: string,\n    filter: FLAMS.QueryFilter,\n    numResults: number,\n  ): Promise<[number, FLAMS.SearchResult][] | undefined> {\n    return await this.rawPostRequest(\"api/search\", {\n      query: query,\n      opts: filter,\n      num_results: numResults,\n    });\n  }\n\n  /**\n   * Full-text search for (definitions of) symbols\n   */\n  async searchSymbols(\n    query: string,\n    numResults: number,\n  ): Promise<[FLAMS.SymbolURI, [number, FLAMS.SearchResult][]][] | undefined> {\n    return await this.rawPostRequest(\"api/search_symbols\", {\n      query: query,\n      num_results: numResults,\n    });\n  }\n\n  /**\n   * List all archives/groups in the given group (or at top-level, if undefined)\n   */\n  async backendGroupEntries(\n    in_entry?: string,\n  ): Promise<[FLAMS.ArchiveGroup[], FLAMS.Archive[]] | undefined> {\n    return await this.rawPostRequest(\"api/backend/group_entries\", {\n      in: in_entry,\n    });\n  }\n\n  /**\n   * List all directories/files in the given archive at path (or at top-level, if undefined)\n   */\n  async backendArchiveEntries(\n    archive: string,\n    in_path?: string,\n  ): Promise<[FLAMS.Directory[], FLAMS.File[]] | undefined> {\n    return await this.rawPostRequest(\"api/backend/archive_entries\", {\n      archive: archive,\n      path: in_path,\n    });\n  }\n\n  /**\n   * SPARQL query\n   */\n  async query(sparql: String): Promise<any> {\n    return await this.rawPostRequest(\"api/backend/query\", { query: sparql });\n  }\n\n  /**\n   * Get all dependencies of the given archive (excluding meta-inf archives)\n   */\n  async archiveDependencies(\n    archives: FLAMS.ArchiveId[],\n  ): Promise<FLAMS.ArchiveId[] | undefined> {\n    return await this.rawPostRequest(\"api/backend/archive_dependencies\", {\n      archives: archives,\n    });\n  }\n\n  /**\n   * Return the TOC of the given document\n   */\n  async contentToc(\n    uri: FLAMS.DocumentURIParams,\n  ): Promise<[FLAMS.CSS[], FLAMS.TOCElem[]] | undefined> {\n    return await this.rawGetRequest(\"content/toc\", uri);\n  }\n\n  /**\n   * Get all learning objects for the given symbol; if problems === true, this includes Problems and Subproblems;\n   * otherwise, only definitions and examples.\n   */\n  async learningObjects(\n    uri: FLAMS.SymbolURIParams,\n    problems?: boolean,\n  ): Promise<[[string, FLAMS.LOKind]] | undefined> {\n    const exc = problems ? problems : false;\n    const sym =\n      \"uri\" in uri\n        ? { uri: uri.uri, problems: exc }\n        : { a: uri.a, p: uri.p, m: uri.m, s: uri.s, problems: exc };\n    return await this.rawGetRequest(\"content/los\", sym);\n  }\n\n  /**\n   * Get the quiz in the given document.\n   */\n  async quiz(uri: FLAMS.DocumentURIParams): Promise<FLAMS.Quiz | undefined> {\n    return await this.rawGetRequest(\"content/quiz\", uri);\n  }\n\n  /**\n   * Return slides for the given document / section\n   */\n  async slides(\n    uri: FLAMS.URIParams,\n  ): Promise<[FLAMS.CSS[], FLAMS.SlideElement[]] | undefined> {\n    return await this.rawGetRequest(\"content/slides\", uri);\n  }\n\n  /**\n   * Batch grade an arrray of <solution,response[]> pairs.\n   * Each of the responses will be graded against the corresponding solution, and the resulting\n   * feedback returned at the same position. If *any* of the responses is malformed,\n   * the whole batch will fail.\n   * A SolutionData[] can be obtained from Solutions.to_solutions(). A ProblemFeedbackJson\n   * can be turned into a \"proper\" ProblemFeedback using ProblemFeedback.from_json().\n   */\n  async batchGrade(\n    ...submissions: [FLAMS.SolutionData[],(FLAMS.ProblemResponse | undefined)[]][]\n  ): Promise<(FLAMS.ProblemFeedbackJson[])[] | undefined> {\n    return await this.rawPostRequest(\"content/grade\", {submissions: submissions});\n  }\n\n  /**\n   * Get the solution for the problem with the given URI. As string, so it can be\n   * deserialized by the ts binding for the WASM datastructure\n   */\n  async solution(\n    uri: FLAMS.DocumentElementURIParams,\n  ): Promise<string | undefined> {\n    let r = await this.getRequestI(\"content/solution\", uri);\n    if (r) {\n      return await r.text();\n    }\n  }\n\n\n  async omdoc(\n    uri: FLAMS.URIParams,\n  ): Promise<[FLAMS.CSS[],FLAMS.OMDoc] | undefined> {\n    return await this.rawGetRequest(\"content/omdoc\", {uri:uri});\n  }\n\n  async contentDocument(\n    uri: FLAMS.DocumentURIParams,\n  ): Promise<[FLAMS.DocumentURI, FLAMS.CSS[], string] | undefined> {\n    return await this.rawGetRequest(\"content/document\", uri);\n  }\n\n  async contentFragment(\n    uri: FLAMS.URIParams,\n  ): Promise<[FLAMS.CSS[], string] | undefined> {\n    return await this.rawGetRequest(\"content/fragment\", uri);\n  }\n\n  async rawGetRequest<TRequest extends Record<string, unknown>, TResponse>(\n    endpoint: string,\n    request: TRequest,\n  ): Promise<TResponse | undefined> {\n    const response = await this.getRequestI(endpoint, request);\n    if (response) {\n      const j = await response.json();\n      console.log(\"Response\", endpoint, \":\", j);\n      return j as TResponse;\n    }\n  }\n\n  private async getRequestI<TRequest extends Record<string, unknown>>(\n    endpoint: string,\n    request: TRequest,\n  ): Promise<Response | undefined> {\n    const encodeParam = (v: unknown): string => {\n      return encodeURIComponent(JSON.stringify(v));\n    };\n    const buildQueryString = (obj: unknown, prefix = \"\"): string[] => {\n      const params: string[] = [];\n      if (obj === null || obj === undefined) {\n        return params;\n      }\n      if (Array.isArray(obj)) {\n        if (prefix) {\n          params.push(`${prefix}=${encodeParam(obj)}`);\n        }\n      } else if (typeof obj === \"string\") {\n        params.push(`${prefix}=${encodeURIComponent(obj)}`);\n      } else if (typeof obj === \"object\" && !(obj instanceof Date)) {\n        if (prefix) {\n          params.push(`${prefix}=${encodeParam(obj)}`);\n        } else {\n          for (const [key, value] of Object.entries(obj)) {\n            const newPrefix = prefix ? `${prefix}[${key}]` : key;\n            params.push(...buildQueryString(value, newPrefix));\n          }\n        }\n      } else {\n        const value = obj instanceof Date ? obj.toISOString() : obj;\n        params.push(`${prefix}=${encodeParam(value)}`);\n      }\n      return params;\n    };\n\n    const queryString = buildQueryString(request).join(\"&\");\n    const url = `${this._url}/${endpoint}${queryString ? \"?\" + queryString : \"\"}`;\n    console.log(\"Calling\", url);\n    const response = await fetch(url, {\n      method: \"GET\",\n      headers: {\n        Accept: \"application/json\",\n      },\n    });\n    if (response.ok) {\n      return response;\n    }\n  }\n\n  async rawPostRequest<TRequest extends Record<string, unknown>, TResponse>(\n    endpoint: string,\n    request: TRequest,\n  ): Promise<TResponse | undefined> {\n    const response = await this.postRequestI(endpoint, request);\n    if (response) {\n      const j = await response.json();\n      console.log(`Response ${this._url}/${endpoint} with body:`, j);\n      return j as TResponse;\n    }\n  }\n\n  private async postRequestI<TRequest extends Record<string, unknown>>(\n    endpoint: string,\n    request: TRequest,\n  ): Promise<Response | undefined> {\n    const formData = new URLSearchParams();\n    const appendToForm = (obj: unknown, prefix = \"\"): void => {\n      if (Array.isArray(obj)) {\n        obj.forEach((v, i) => appendToForm(v, `${prefix}[${i}]`));\n      } else if (obj instanceof Date) {\n        formData.append(prefix, obj.toISOString());\n      } else if (obj && typeof obj === \"object\" && !(obj instanceof File)) {\n        for (const [key, value] of Object.entries(obj)) {\n          const newPrefix = prefix ? `${prefix}[${key}]` : key;\n          appendToForm(value, newPrefix);\n        }\n      } else if (obj !== undefined && obj !== null) {\n        formData.append(prefix, String(obj));\n      }\n    };\n    appendToForm(request);\n    console.log(`Calling ${this._url}/${endpoint} with body`, formData);\n    const response = await fetch(`${this._url}/${endpoint}`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/x-www-form-urlencoded\",\n      },\n      body: formData.toString(),\n    });\n\n    if (response.ok) {\n      return response;\n    }\n  }\n}\n\n//type IsEqual<T1,T2> = (T1 | T2) extends (T1 & T2) ? true : never;\n"],"mappings":"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","names":[]}